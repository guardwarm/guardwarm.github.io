<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="多线程简介并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。   并发指的是在一段时间内宏观上有多个程序同时运行">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="java进阶2">
<meta property="og:url" content="http://yoursite.com/2020/02/28/heima57/java进阶2/index.html">
<meta property="og:site_name" content="guard warm">
<meta property="og:description" content="多线程简介并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。   并发指的是在一段时间内宏观上有多个程序同时运行">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092208-821105.bmp">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223102015-961264.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223102122-138221.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200310174129-276086.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200310174232-57512.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223134605-158865.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223134726-964888.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223112807-10084.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200306191508-325266.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223140342-704108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223140811-489439.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223142500-184550.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223142621-546872.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092728-871297.bmp">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092754-441985.bmp">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223093024-815496.jpeg">
<meta property="og:image" content="http://yoursite.com/.com//C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307084853961.png">
<meta property="og:image" content="http://yoursite.com/.com//C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307084830555.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223093057-276464.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200307091858-105649.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200307091951-911827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224203557-914120.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204335-94131.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204412-835347.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204356-130658.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204346-894574.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205653-273589.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205700-592149.bmp">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205704-832626.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205711-27191.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205717-958331.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205618-423948.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224213409-67743.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205607-277291.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205629-919189.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205728-178275.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205637-218119.png">
<meta property="og:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205643-71748.png">
<meta property="og:updated_time" content="2020-03-10T09:42:39.264Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java进阶2">
<meta name="twitter:description" content="多线程简介并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。   并发指的是在一段时间内宏观上有多个程序同时运行">
<meta name="twitter:image" content="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092208-821105.bmp">

<link rel="canonical" href="http://yoursite.com/2020/02/28/heima57/java进阶2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java进阶2 | guard warm</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">

  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">guard warm</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">编程学习之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/guardwarm" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/28/heima57/java进阶2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="这些年编程路上踩得坑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="guard warm">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java进阶2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-28 10:17:23" itemprop="dateCreated datePublished" datetime="2020-02-28T10:17:23Z">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-10 09:42:39" itemprop="dateModified" datetime="2020-03-10T09:42:39Z">2020-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/heima57/" itemprop="url" rel="index"><span itemprop="name">heima57</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/02/28/heima57/java进阶2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/02/28/heima57/java进阶2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092208-821105.bmp" alt></p>
<p>并发指的是在一段时间内宏观上有多个程序同时运行</p>
<a id="more"></a>

<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。</p>
<p>同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，</p>
<p>当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为<strong>线程调度</strong>。</p>
</blockquote>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
<p>我们可以打开任务管理器查看当前任务的进程：</p>
<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，<strong>Java使用</strong>的为抢占式调度。</p>
<ul>
<li><p>设置线程的优先级</p>
</li>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时</p>
</li>
</ul>
</li>
</ul>
<p>刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。</p>
<pre><code>其实，多线程程序并不能提高程序的运行速度，但能够**提高程序运行效率，让CPU的使用率更高。**</code></pre><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h3><p>构造方法：</p>
<p><code>public Thread()</code> :分配一个新的线程对象。<br><code>public Thread(String name)</code><br><code>public Thread(Runnable target)</code><br><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。</p>
<p>常用方法：</p>
<p><code>public String getName()</code> :获取当前线程名称。<br><code>public void start()</code> :导致此线程开始执行; Java虚拟机调用此线程的run方法。<br><code>public void run()</code> :此线程要执行的任务在此处定义代码。<br><code>public static void sleep(long millis)</code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）<br><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</p>
<p><code>public void join()</code>:等待调用join方法的线程结束后才能执行</p>
<h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"小强"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建自定义线程对象</span></span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"新的线程！"</span>);</span><br><span class="line">		<span class="comment">//开启新线程</span></span><br><span class="line">		mt.start();</span><br><span class="line">		<span class="comment">//在主方法中执行for循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"旺财"</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223102015-961264.png" alt="image-20200223102014703"></p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223102122-138221.png" alt="image-20200223102121409"></p>
<h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象  线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">"小强"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"旺财 "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过实现Runnable接口，使得该类有了多线程类的特征。</p>
</li>
<li><p>Thread类实际上也是实现了Runnable接口的类。</p>
</li>
<li><p>所有的多线程代码都是通过运行Thread的start()方法来运行的。因此不管怎么创建的，最终还是通过Thread的对象的API来控制线程的</p>
</li>
</ul>
<h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p><strong>实现Runnable接口的优势</strong></p>
<ol>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
</ol>
<h4 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h4><p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程</p>
<p>每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>匿名内部类方式实现线程的创建 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      Runnable r = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">                  System.out.println(<span class="string">"张宇:"</span>+i);</span><br><span class="line">              &#125;</span><br><span class="line">      	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="keyword">new</span> Thread(r).start();</span><br></pre></td></tr></table></figure>

<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200310174129-276086.png" alt="image-20200310174127374"></p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200310174232-57512.png" alt="image-20200310174232322"></p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>线程安全问题都是由全局变量及静态变量引起的。</p>
<ul>
<li><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</p>
</li>
<li><p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223134605-158865.png" alt="image-20200223134454077"></p>
<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>Java中提供了同步机制(synchronized)来解决线程安全问题</p>
<p>生成一个唯一的锁对象，抢到锁对象的线程可以执行同步方法，其余线程被阻塞，直到锁对象被释放</p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223134726-964888.png" alt="image-20200223134725166"></p>
<h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><p>可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作 </span></span><br><span class="line">        <span class="comment">//窗口 永远开启 </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                    <span class="comment">//出票操作</span></span><br><span class="line">                    <span class="comment">//使用sleep模拟一下出票时间 </span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取当前线程对象的名字 </span></span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于非static方法,同步锁就是this。 </li>
<li>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作 </span></span><br><span class="line">        <span class="comment">//窗口 永远开启 </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 锁对象 是 谁调用这个方法 就是谁 </span></span><br><span class="line"><span class="comment">     *   隐含 锁对象 就是  this</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖   </span></span><br><span class="line">            <span class="comment">//出票操作</span></span><br><span class="line">            <span class="comment">//使用sleep模拟一下出票时间 </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取当前线程对象的名字 </span></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h5><p>提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> :加同步锁。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> :释放同步锁。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作 </span></span><br><span class="line">        <span class="comment">//窗口 永远开启 </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作 </span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间 </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字 </span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="常见状态"><a href="#常见状态" class="headerlink" title="常见状态"></a>常见状态</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223112807-10084.png" alt="image-20200223112806050"></p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200306191508-325266.png" alt="image-20200306191508654"></p>
<h4 id="Timed-Waiting（计时等待）"><a href="#Timed-Waiting（计时等待）" class="headerlink" title="Timed Waiting（计时等待）"></a>Timed Waiting（计时等待）</h4><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。</p>
<p>在写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句</p>
<p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)</p>
<p>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"‐‐‐‐‐‐‐"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.print(<span class="string">"线程睡眠1秒！\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>tips：</strong></p>
<ol>
<li><p>进入 TIMED_WAITING 状态的一种常见情形是调用 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</p>
</li>
<li><p>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠</p>
</li>
<li><p>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</p>
<p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就立刻执行。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223140342-704108.png" alt="image-20200223140341287"></p>
<h4 id="BLOCKED（锁阻塞）"><a href="#BLOCKED（锁阻塞）" class="headerlink" title="BLOCKED（锁阻塞）"></a>BLOCKED（锁阻塞）</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223140811-489439.png" alt></p>
<h4 id="Waiting（无限等待）"><a href="#Waiting（无限等待）" class="headerlink" title="Waiting（无限等待）"></a>Waiting（无限等待）</h4><p>等待唤醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 演示waiting</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println( Thread.currentThread().getName() +<span class="string">"=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象"</span>);</span><br><span class="line">                            obj.wait();  <span class="comment">//无限等待</span></span><br><span class="line">                            <span class="comment">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span></span><br><span class="line"> </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName + <span class="string">"=== 从waiting状态醒来，获取到锁对象，继续执行了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"等待线程"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;   <span class="comment">//每隔3秒 唤醒一次</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName)</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName<span class="string">"‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象"</span>);</span><br><span class="line">                        obj.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;,<span class="string">"唤醒线程"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用<strong>此对象</strong>的Object.notify()方</p>
<p>法 或 Object.notifyAll()方法</p>
<p>其实waiting状态并不是一个线程的操作，它体现的是<strong>多个线程间的通信</strong>，可以理解为多个线程之间的协作关系，</p>
<p><strong>多个线程会争取锁，同时相互之间又存在协作关系</strong></p>
<p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了</p>
<p>Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那</p>
<p>么就会将无限等待的A线程唤醒。如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223142500-184550.png" alt="image-20200223142459327"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223142621-546872.png" alt="image-20200223142620323" style="zoom:200%;">

<h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同</p>
<p>多个thread类传入同一个runnable接口，且该runnable接口中有唯一锁对象，通过该对象来实现线程间通信</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092728-871297.bmp" alt></p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 即我们需要</p>
<p>通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<h4 id="等待唤醒机制-1"><a href="#等待唤醒机制-1" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，但这并不是故事的全部，线程间也会有协作机制。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态， 等待其他线程执行完他们的指定代码过后 再将其唤醒;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait/notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li><p>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态</p>
<p>即是 WAITING。它还要等别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知</strong>”在这个对象上等待的线程从wait set 中释放出</p>
<p>来，重新进入到调度队列（ready queue）中</p>
</li>
<li><p>notify：则选取锁通知对象的 wait set 中的一个线程释放</p>
</li>
<li><p>notifyAll：则释放锁通知对象的 wait set 上的全部线程。</p>
</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁，成功后才能在当初调用 <strong>wait 方法之后的地方恢复执行</strong>。</p>
<p><strong>总结：</strong></p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li><p>wait方法与notify方法必须要由<strong>同一个锁对象调用</strong>。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait</p>
<p>方法后的线程。</p>
</li>
<li><p>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</p>
</li>
<li><p>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</p>
</li>
</ol>
<h4 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h4><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">包子铺线程生产包子，吃货线程消费包子。</span></span><br><span class="line"><span class="comment">当包子没有时，吃货线程等待，</span></span><br><span class="line"><span class="comment">包子铺线程生产包子，并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。</span></span><br><span class="line"><span class="comment">接下来，吃货线程能否进一步执行则取决于锁的获取情况。</span></span><br><span class="line"><span class="comment">如果吃货获取到锁，那么就执行吃包子动作，</span></span><br><span class="line"><span class="comment">包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。</span></span><br><span class="line"><span class="comment">包子铺线程能否进一步执行则取决于锁的获取情况。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>代码演示：</strong></p>
<p>包子资源类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="keyword">boolean</span>  flag = <span class="keyword">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>吃货线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"吃货正在吃"</span>+bz.pier+bz.xianer+<span class="string">"包子"</span>);</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包子铺线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">"包子铺开始做包子"</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">"冰皮"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"五仁"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">"薄皮"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"牛肉大葱"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">"包子造好了："</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">"吃货来吃吧"</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line"></span><br><span class="line">        ChiHuo ch = <span class="keyword">new</span> ChiHuo(<span class="string">"吃货"</span>,bz);</span><br><span class="line">        BaoZiPu bzp = <span class="keyword">new</span> BaoZiPu(<span class="string">"包子铺"</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池思想概述"><a href="#线程池思想概述" class="headerlink" title="线程池思想概述"></a>线程池思想概述</h3><p>在Java中可以通过线程池来使得线程可以复用</p>
<h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092754-441985.bmp" alt></p>
<p>合理利用线程池的好处：</p>
<ol>
<li><p>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p>
</li>
<li><p>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p>
</li>
<li><p>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而导致</p>
<p>服务器瘫痪(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)</p>
</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个</p>
<p>执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此</p>
<p>在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors</p>
<p>工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><p><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是</p>
<p>池中的线程个数可以指定最大数量)</p>
</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
<p>Runnable实现类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要一个教练"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"教练来了： "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"教我游泳,交完后，教练回到了游泳池"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public File(String pathname)</code> </li>
<li><code>public File(String parent, String child)</code> </li>
<li><code>public File(File parent, String child)</code></li>
</ul>
<p>tips：</p>
<blockquote>
<ol>
<li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
</ol>
</blockquote>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ul>
<li><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。</p>
</li>
<li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p>
</li>
<li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p>
</li>
<li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p>
</li>
</ul>
<blockquote>
<p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p>
</blockquote>
<h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><ul>
<li><code>public boolean exists()</code> </li>
<li><code>public boolean isDirectory()</code> </li>
<li><code>public boolean isFile()</code> </li>
</ul>
<h4 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h4><ul>
<li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li>
<li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li>
<li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li>
<li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li>
</ul>
<blockquote>
<p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p>
</blockquote>
<h3 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h3><ul>
<li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
</ul>
<ul>
<li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>​    调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p>
</li>
<li><p><strong>递归的分类:</strong></p>
<ul>
<li>直接递归称为方法自身调用自己。</li>
<li>间接递归为A方法调用B方法，B方法调用C方法，C方法调用A方法。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li>
<li>构造方法禁止递归</li>
</ul>
</li>
<li><p><strong>核心：找到f(n)和f(n-1)的关系</strong></p>
</li>
</ul>
<h3 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h3><ul>
<li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br><span class="line">	f(n) = n*f(n-1)</span><br><span class="line">	出口：n=1时，返回1</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h3><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们要使用递归实现。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 创建File对象</span></span><br><span class="line">        File dir  = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">printDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">      	  判断:</span></span><br><span class="line"><span class="comment">      	  当是文件时,打印绝对路径.</span></span><br><span class="line"><span class="comment">      	  当是目录时,继续调用打印目录的方法,形成递归调用.</span></span><br><span class="line"><span class="comment">      	*/</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    		<span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">"文件名:"</span>+ file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">"目录:"</span>+file.getAbsolutePath());</span><br><span class="line">              	<span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li>
<li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建File对象</span></span><br><span class="line">        File dir  = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">      	<span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      	</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              	<span class="comment">// 是文件，判断文件名并输出文件绝对路径</span></span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">".java"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是目录，继续遍历,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件过滤器优化"><a href="#文件过滤器优化" class="headerlink" title="文件过滤器优化"></a>文件过滤器优化</h3><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接</p>
<p>口中只有一个方法。</p>
<p><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p>
<p><strong>分析</strong>：</p>
<ol>
<li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li>
<li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol>
<li>要么是.java文件。</li>
<li>要么是目录，用于继续遍历。</li>
</ol>
</li>
<li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li>
</ol>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir2</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">".java"</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      	<span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda优化"><a href="#Lambda优化" class="headerlink" title="Lambda优化"></a>Lambda优化</h3><p><strong>分析：</strong><code>FileFilter</code>是函数式接口，因此可以用lambda表达式简写。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir3</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      	<span class="keyword">return</span> f.getName().endsWith(<span class="string">".java"</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">	<span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">      	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	printDir3(file);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><h3 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h3><p>把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> </p>
<p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作</p>
<h3 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p>根据数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li>
</ul>
<h3 id="IO的流向说明图解"><a href="#IO的流向说明图解" class="headerlink" title="IO的流向说明图解"></a>IO的流向说明图解</h3><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223093024-815496.jpeg" alt></p>
<h3 id="顶级父类们"><a href="#顶级父类们" class="headerlink" title="顶级父类们"></a>顶级父类们</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流<br><strong>InputStream</strong></td>
<td align="center">字节输出流<br><strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流<br><strong>Reader</strong></td>
<td align="center">字符输出流<br><strong>Writer</strong></td>
</tr>
</tbody></table>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="一切皆为字节"><a href="#一切皆为字节" class="headerlink" title="一切皆为字节"></a>一切皆为字节</h3><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，所以字节流可以传输任意文件数据。</p>
<p>在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的<strong>始终为二进制数据</strong>。</p>
<h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地</p>
<ul>
<li><code>public void close()</code> </li>
<li><code>public void flush()</code> </li>
<li><code>public void write(byte[] b)</code></li>
<li><code>public void write(byte[] b, int off, int len)</code> </li>
<li><code>public abstract void write(int b)</code> </li>
</ul>
<blockquote>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<p><img src="/.com//C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307084853961.png" alt="image-20200307084853961"></p>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p><code>OutputStream</code>有很多子类</p>
<p><code>java.io.FileOutputStream</code>类是文件输出流，用于将数据写出到文件。</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件</p>
<p>如果有这个文件，会清空这个文件的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);      </span><br><span class="line"><span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><ol>
<li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line"> FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line"><span class="comment">// 写出数据</span></span><br><span class="line">fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"> fos.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line"> FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line"><span class="comment">// 字符串转换为字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="string">"黑马程序员"</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出字节数组数据</span></span><br><span class="line">fos.write(b);</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"> fos.close();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">      FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line">    	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">    	<span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">      fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">      fos.close();</span><br></pre></td></tr></table></figure>

<h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><ul>
<li><code>public FileOutputStream(File file, boolean append)</code></li>
<li><code>public FileOutputStream(String name, boolean append)</code></li>
</ul>
<p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">      FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>，<span class="keyword">true</span>);     </span><br><span class="line">    	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">    	<span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">      fos.write(b);</span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">      fos.close();</span><br></pre></td></tr></table></figure>

<h4 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h4><p>Windows系统里，换行符号是<code>\r\n</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line"> FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);  </span><br><span class="line"><span class="comment">// 定义字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">   	<span class="comment">// 写出一个字节</span></span><br><span class="line">     fos.write(words[i]);</span><br><span class="line">   	<span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">     fos.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"> fos.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul>
<li>回车符：回到一行的开头（return）。</li>
<li>换行符：下一行（newline）。</li>
</ul>
</li>
<li>系统中的换行：<ul>
<li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li>
<li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li>
<li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li>
</ul>
<blockquote>
<p>小贴士：</p>
<p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p>
</blockquote>
<p><img src="/.com//C:%5CUsers%5Casus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307084830555.png" alt="image-20200307084830555"></p>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p>
<h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileInputStream(File file)</code></li>
<li><code>FileInputStream(String name)</code></li>
</ul>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">  FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">  <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">  FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h4><ol>
<li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">     	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line">    	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">      <span class="keyword">int</span> b ；</span><br><span class="line">      <span class="comment">// 循环读取</span></span><br><span class="line">      <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">          System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">      fis.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然读取了一个字节，但是会自动提升为int类型</li>
<li>流操作完毕后，必须释放系统资源，调用close方法，千万记得</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    	<span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">     	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">    	<span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">      <span class="keyword">int</span> len ；</span><br><span class="line">      <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="comment">// 循环读取</span></span><br><span class="line">      <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">         	<span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">          System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">      fis.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p>
</blockquote>
<h3 id="练习：图片复制"><a href="#练习：图片复制" class="headerlink" title="练习：图片复制"></a>练习：图片复制</h3><h4 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223093057-276464.jpeg" alt></p>
<h4 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h4><p>复制图片文件，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建流对象</span></span><br><span class="line"><span class="comment">// 1.1 指定数据源</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.jpg"</span>);</span><br><span class="line"><span class="comment">// 1.2 指定目的地</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test_copy.jpg"</span>);</span><br><span class="line"><span class="comment">// 2.读写数据</span></span><br><span class="line"><span class="comment">// 2.1 定义数组</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 2.2 定义长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">// 2.3 循环读取</span></span><br><span class="line"><span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.4 写出数据</span></span><br><span class="line">    fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.关闭资源</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>流的关闭原则：<strong>先开后关，后开先关。</strong></p>
</blockquote>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字</p>
<p>符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<p>字符流会用到文件缓冲区，所以写入时多了个flush方法</p>
<h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中</p>
<ul>
<li><code>public void close()</code> </li>
<li><code>public int read()</code></li>
<li><code>public int read(char[] cbuf)</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200307091858-105649.png" alt="image-20200307091856611"></p>
<h4 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h4><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<blockquote>
<p>小贴士：</p>
<ol>
<li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p>
<p>idea中UTF-8</p>
</li>
<li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p>
</li>
</ol>
</blockquote>
<h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileReader(File file)</code></li>
<li><code>FileReader(String fileName)</code></li>
</ul>
<h4 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h4><ol>
<li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">     	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line">    	<span class="comment">// 定义变量，保存数据</span></span><br><span class="line">      <span class="keyword">int</span> b ；</span><br><span class="line">      <span class="comment">// 循环读取</span></span><br><span class="line">      <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">          System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">      fr.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p>
</blockquote>
<ol start="2">
<li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">  	FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line"> 	<span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">   <span class="keyword">int</span> len ；</span><br><span class="line">   <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">   <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">   <span class="comment">// 循环读取</span></span><br><span class="line">   <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">       System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len));</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">   fr.close();</span><br></pre></td></tr></table></figure>

<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf)</code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len)</code></li>
<li><code>void write(String str)</code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush()</code></li>
<li><code>void close()</code> </li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200307091951-911827.png" alt="image-20200307091950288"></p>
<h4 id="FileWriter类"><a href="#FileWriter类" class="headerlink" title="FileWriter类"></a>FileWriter类</h4><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>FileWriter(File file)</code></li>
<li><code>FileWriter(String fileName)</code></li>
</ul>
<h4 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h4><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line"> FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line"><span class="comment">// 写出数据</span></span><br><span class="line">fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">fw.write(<span class="string">'b'</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">fw.write(<span class="string">'C'</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。   </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment"> 如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> fw.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<ol>
<li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li>
<li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li>
</ol>
</blockquote>
<h4 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们</p>
<p>既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p>
<ul>
<li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
<blockquote>
<p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p>
</blockquote>
<h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><ol>
<li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">      FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line">    	<span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">    	<span class="keyword">char</span>[] chars = <span class="string">"黑马程序员"</span>.toCharArray();      </span><br><span class="line">    	<span class="comment">// 写出字符数组</span></span><br><span class="line">    	fw.write(chars); <span class="comment">// 黑马程序员 </span></span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。</span></span><br><span class="line">      fw.write(b,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 程序      </span></span><br><span class="line">    	<span class="comment">// 关闭资源</span></span><br><span class="line">      fos.close();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便</p>
</li>
<li><p><strong>续写和换行</strong>：操作类似于FileOutputStream。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>，<span class="keyword">true</span>);     </span><br><span class="line">  	<span class="comment">// 写出字符串</span></span><br><span class="line">    fw.write(<span class="string">"黑马"</span>);</span><br><span class="line">  	<span class="comment">// 写出换行</span></span><br><span class="line">  	fw.write(<span class="string">"\r\n"</span>);</span><br><span class="line">  	<span class="comment">// 写出字符串</span></span><br><span class="line">fw.write(<span class="string">"程序员"</span>);</span><br><span class="line">  	<span class="comment">// 关闭资源</span></span><br><span class="line">    fw.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p>
<p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p>
</blockquote>
<h2 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h2><h4 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h4><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      	<span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK7的处理"><a href="#JDK7的处理" class="headerlink" title="JDK7的处理"></a>JDK7的处理</h4><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时自动关闭。</p>
<p>所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">';'</span>隔开) &#123;</span><br><span class="line">	<span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      	<span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> ( FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>); ) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK9的改进"><a href="#JDK9的改进" class="headerlink" title="JDK9的改进"></a>JDK9的改进</h4><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭</p>
<p>改进前格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">"resource1"</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">"resource2"</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (Resource r1 = resource1;</span><br><span class="line">     Resource r2 = resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">"resource1"</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">"resource2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后，代码使用演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">final</span>  FileReader fr  = <span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>);</span><br><span class="line"><span class="comment">// 引入到try中</span></span><br><span class="line"><span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">  	<span class="comment">// 读取数据</span></span><br><span class="line">  	<span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="comment">// 写出数据</span></span><br><span class="line">    	fw.write(b);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一</p>
<p>个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public Properties()</code> :创建一个空的属性列表。</li>
</ul>
<h4 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h4><ul>
<li><code>public Object setProperty(String key, String value)</code> </li>
<li><code>public String getProperty(String key)</code></li>
<li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建属性集对象</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 添加键值对元素</span></span><br><span class="line">properties.setProperty(<span class="string">"location"</span>, <span class="string">"D:\\a.txt"</span>);</span><br><span class="line"><span class="comment">// 通过键,获取属性值</span></span><br><span class="line">System.out.println(properties.getProperty(<span class="string">"location"</span>));</span><br><span class="line"><span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line"><span class="comment">// 打印键值对</span></span><br><span class="line"><span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">  	System.out.println(key+<span class="string">" -- "</span>+properties.getProperty(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><h5 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用</span></span><br><span class="line"><span class="comment">        void load(InputStream inStream)</span></span><br><span class="line"><span class="comment">        void load(Reader reader)</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            InputStream inStream:字节输入流,不能读取含有中文的键值对</span></span><br><span class="line"><span class="comment">            Reader reader:字符输入流,能读取含有中文的键值对</span></span><br><span class="line"><span class="comment">        使用步骤:</span></span><br><span class="line"><span class="comment">            1.创建Properties集合对象</span></span><br><span class="line"><span class="comment">            2.使用Properties集合对象中的方法load读取保存键值对的文件</span></span><br><span class="line"><span class="comment">            3.遍历Properties集合</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)</span></span><br><span class="line"><span class="comment">            2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取</span></span><br><span class="line"><span class="comment">            3.存储键值对的文件中,键与值默认都是字符串,不用再加引号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          	System.out.println(key+<span class="string">" -- "</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p>
</blockquote>
<h5 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line"><span class="comment">        void store(OutputStream out, String comments)</span></span><br><span class="line"><span class="comment">        void store(Writer writer, String comments)</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            OutputStream out:字节输出流,不能写入中文</span></span><br><span class="line"><span class="comment">            Writer writer:字符输出流,可以写中文</span></span><br><span class="line"><span class="comment">            String comments:注释,用来解释说明保存的文件是做什么用的</span></span><br><span class="line"><span class="comment">                    不能使用中文,会产生乱码,默认是Unicode编码</span></span><br><span class="line"><span class="comment">                    一般使用""空字符串</span></span><br><span class="line"><span class="comment">        使用步骤:</span></span><br><span class="line"><span class="comment">            1.创建Properties集合对象,添加数据</span></span><br><span class="line"><span class="comment">            2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地</span></span><br><span class="line"><span class="comment">            3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line"><span class="comment">            4.释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">//1.创建Properties集合对象,添加数据</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">"赵丽颖"</span>,<span class="string">"168"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"165"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"160"</span>);</span><br><span class="line">    <span class="comment">//2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"09_IOAndProperties\\prop.txt"</span>);</span><br><span class="line">    <span class="comment">//3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line">    prop.store(fw,<span class="string">"save data"</span>);</span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    fw.close();</span><br></pre></td></tr></table></figure>

<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理：在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数</p>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public BufferedInputStream(InputStream in)</code> </li>
<li><code>public BufferedOutputStream(OutputStream out)</code></li>
</ul>
<h4 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h4><p>如何更快呢？使用数组的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">		<span class="comment">// 创建流对象</span></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"jdk9.exe"</span>));</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.exe"</span>));</span><br><span class="line">)&#123;</span><br><span class="line">    <span class="comment">// 读写数据</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public BufferedReader(Reader in)</code></li>
<li><code>public BufferedWriter(Writer out)</code></li>
</ul>
<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li>
</ul>
<p><code>readLine</code>方法演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    	 <span class="comment">// 创建流对象</span></span><br><span class="line">      BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line"><span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">      String line  = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">      <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">          System.out.print(line);</span><br><span class="line">          System.out.println(<span class="string">"------"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">      br.close();</span><br></pre></td></tr></table></figure>

<p><code>newLine</code>方法演示，代码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    	<span class="comment">// 创建流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>));</span><br><span class="line">    	<span class="comment">// 写出数据</span></span><br><span class="line">      bw.write(<span class="string">"黑马"</span>);</span><br><span class="line">    	<span class="comment">// 写出换行</span></span><br><span class="line">      bw.newLine();</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">      bw.close();</span><br></pre></td></tr></table></figure>

<h3 id="练习-文本排序"><a href="#练习-文本排序" class="headerlink" title="练习:文本排序"></a>练习:文本排序</h3><p>请将文本信息恢复顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure>

<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ol>
<li>逐行读取文本信息。</li>
<li>解析文本信息到集合中。</li>
<li>遍历集合，按顺序，写出文本信息。</li>
</ol>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h3><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后</p>
<p>的结果</p>
<blockquote>
<p>编码:字符按一定规则转换为对应字节</p>
<p>解码:字节按之前编码规则，逆向来获得字符，选错编码规则就会造成乱码</p>
</blockquote>
<ul>
<li><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则</li>
</ul>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><ul>
<li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
</ul>
<p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码<img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224203557-914120.jpeg" alt></p>
<p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p>
<ul>
<li><p><strong>ASCII字符集</strong> ：</p>
<p>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。</p>
</li>
<li><p><strong>ISO-8859-1字符集</strong>：</p>
<ul>
<li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li>
<li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li>
</ul>
</li>
<li><p><strong>GBxxx字符集</strong>：</p>
<p>GB就是国标的意思，是为了显示中文而设计的一套字符集。</p>
<ul>
<li><p><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个</p>
<p>汉字，这样大约可以组合了包含7000多个简体汉字，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个</p>
<p>字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</p>
</li>
<li><p><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，</p>
<p>完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</p>
</li>
<li><p><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持</p>
<p>中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</p>
</li>
</ul>
</li>
<li><p><strong>Unicode字符集</strong> ：</p>
<ul>
<li><p>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</p>
</li>
<li><p>它最多使用4个字节的数字来表达每个字母、符号，或者文字，有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</p>
</li>
<li><p>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采</p>
<p>用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码，它使用一至四个字节为每个字</p>
<p>符编码，编码规则：</p>
<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。 </li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="编码引出的问题"><a href="#编码引出的问题" class="headerlink" title="编码引出的问题"></a>编码引出的问题</h3><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，</p>
<p>当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"E:\\File_GBK.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure>

<h3 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h3><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其</p>
<p>解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h4 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>InputStreamReader(InputStream in)</code></li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code></li>
</ul>
<h4 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    	<span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">      String FileName = <span class="string">"E:\\file_gbk.txt"</span>;</span><br><span class="line">    	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">      InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">    	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">      InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">"GBK"</span>);</span><br><span class="line"><span class="comment">// 定义变量,保存字符</span></span><br><span class="line">      <span class="keyword">int</span> read;</span><br><span class="line">    	<span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">      <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">      &#125;</span><br><span class="line">      isr.close();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">      <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">      &#125;</span><br><span class="line">      isr2.close();</span><br></pre></td></tr></table></figure>

<h3 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h3><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字</p>
<p>节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<h4 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>OutputStreamWriter(OutputStream in)</code></li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code></li>
</ul>
<h4 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    	<span class="comment">// 定义文件路径</span></span><br><span class="line">      String FileName = <span class="string">"E:\\out.txt"</span>;</span><br><span class="line">    	<span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">      OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">    	osw.write(<span class="string">"你好"</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">      osw.close();</span><br><span class="line">    	</span><br><span class="line"><span class="comment">// 定义文件路径</span></span><br><span class="line">String FileName2 = <span class="string">"E:\\out2.txt"</span>;</span><br><span class="line">   	<span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">      OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">"GBK"</span>);</span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">    	osw2.write(<span class="string">"你好"</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">      osw2.close();</span><br></pre></td></tr></table></figure>

<h4 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h4><p><strong>转换流是字节与字符间的桥梁！</strong><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204335-94131.jpeg" alt></p>
<h3 id="练习：转换文件编码"><a href="#练习：转换文件编码" class="headerlink" title="练习：转换文件编码"></a>练习：转换文件编码</h3><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p>
<h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><ol>
<li>指定GBK编码的转换流，读取文本文件。</li>
<li>使用UTF-8编码的转换流，写出文本文件。</li>
</ol>
<h4 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    	<span class="comment">// 1.定义文件路径</span></span><br><span class="line">   	String srcFile = <span class="string">"file_gbk.txt"</span>;</span><br><span class="line">      String destFile = <span class="string">"file_utf8.txt"</span>;</span><br><span class="line"><span class="comment">// 2.创建流对象</span></span><br><span class="line">  	<span class="comment">// 2.1 转换输入流,指定GBK编码</span></span><br><span class="line">      InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(srcFile) , <span class="string">"GBK"</span>);</span><br><span class="line">  	<span class="comment">// 2.2 转换输出流,默认utf8编码</span></span><br><span class="line">      OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(destFile));</span><br><span class="line"><span class="comment">// 3.读写数据</span></span><br><span class="line">  	<span class="comment">// 3.1 定义数组</span></span><br><span class="line">      <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">  	<span class="comment">// 3.2 定义长度</span></span><br><span class="line">      <span class="keyword">int</span> len;</span><br><span class="line">  	<span class="comment">// 3.3 循环读取</span></span><br><span class="line">      <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 循环写出</span></span><br><span class="line">        	osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">      &#125;</span><br><span class="line">  	<span class="comment">// 4.释放资源</span></span><br><span class="line">      osw.close();</span><br><span class="line">      isr.close();</span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中</code></p>
<p><code>存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信</p>
<p>息，都可以用来在内存中创建对象<img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204412-835347.jpeg" alt></p>
<h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<h4 id="构造方法-10"><a href="#构造方法-10" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
<h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><p>一个对象要想序列化，必须满足两个条件:</p>
<ul>
<li><p>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列</p>
<p>化或反序列化，会抛出<code>NotSerializableException</code> 。</p>
</li>
<li><p>该类的所有属性必须是可序列化的。如果有属性不需要序列化，则必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</p>
</li>
<li><p>static修饰的成员是属于类的，不序列化</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">"Address  check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.写出对象方法</p>
<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">e.age = <span class="number">20</span>; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> 		<span class="comment">// 创建序列化流对象</span></span><br><span class="line">     ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line">   	<span class="comment">// 写出对象</span></span><br><span class="line">   	out.writeObject(e);</span><br><span class="line">   	<span class="comment">// 释放资源</span></span><br><span class="line">   	out.close();</span><br><span class="line">   	fileOut.close();</span><br><span class="line">   	System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">   &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">       i.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<h4 id="构造方法-11"><a href="#构造方法-11" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</li>
</ul>
<h4 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h4><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p>
<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Employee e = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;		</span><br><span class="line">     <span class="comment">// 创建反序列化流</span></span><br><span class="line">     FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">     ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">     <span class="comment">// 读取一个对象</span></span><br><span class="line">     e = (Employee) in.readObject();</span><br><span class="line">     <span class="comment">// 释放资源</span></span><br><span class="line">     in.close();</span><br><span class="line">     fileIn.close();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">     <span class="comment">// 捕获其他异常</span></span><br><span class="line">     i.printStackTrace();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">	<span class="comment">// 捕获类找不到异常</span></span><br><span class="line">     System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">     c.printStackTrace();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">System.out.println(<span class="string">"Name: "</span> + e.name);	<span class="comment">// zhangsan</span></span><br><span class="line">System.out.println(<span class="string">"Address: "</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">System.out.println(<span class="string">"age: "</span> + e.age); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<h4 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h4><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失</strong></p>
<p><strong>败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>该类包含未知数据类型 </li>
<li>该类没有可访问的无参构造方法 </li>
</ul>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和</p>
<p>对应类是否版本匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;	<span class="comment">// 原本是jvm来管理，这样自己手动管理</span></span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="练习：序列化集合"><a href="#练习：序列化集合" class="headerlink" title="练习：序列化集合"></a>练习：序列化集合</h3><ol>
<li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li>
<li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li>
</ol>
<h4 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h4><ol>
<li>把若干学生对象 ，保存到集合中。</li>
<li>把集合作为一个整体序列化。</li>
<li>反序列化读取时，只需要读取一次，转换为集合类型。</li>
<li>遍历集合，可以打印所有的学生信息</li>
</ol>
<h4 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 创建 学生对象</span></span><br><span class="line">	Student student = <span class="keyword">new</span> Student(<span class="string">"老王"</span>, <span class="string">"laow"</span>);</span><br><span class="line">	Student student2 = <span class="keyword">new</span> Student(<span class="string">"老张"</span>, <span class="string">"laoz"</span>);</span><br><span class="line">	Student student3 = <span class="keyword">new</span> Student(<span class="string">"老李"</span>, <span class="string">"laol"</span>);</span><br><span class="line"></span><br><span class="line">	ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	arrayList.add(student);</span><br><span class="line">	arrayList.add(student2);</span><br><span class="line">	arrayList.add(student3);</span><br><span class="line">	<span class="comment">// 序列化操作</span></span><br><span class="line">	serializ(arrayList);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 反序列化  </span></span><br><span class="line">	ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"list.txt"</span>));</span><br><span class="line">	<span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">	ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line">	</span><br><span class="line">     	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">         	Student s = list.get(i);</span><br><span class="line">       	System.out.println(s.getName()+<span class="string">"--"</span>+ s.getPwd());</span><br><span class="line">     	&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 创建 序列化流 </span></span><br><span class="line">	ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"list.txt"</span>));</span><br><span class="line">	<span class="comment">// 写出对象</span></span><br><span class="line">	oos.writeObject(arrayList);</span><br><span class="line">	<span class="comment">// 释放资源</span></span><br><span class="line">	oos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类</p>
<p>能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h3 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h3><h4 id="构造方法-12"><a href="#构造方法-12" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</li>
</ul>
<h4 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h4><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过我们可以改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">      System.out.println(<span class="number">97</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">      PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">      System.setOut(ps);</span><br><span class="line">    	<span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">      System.out.println(<span class="number">97</span>);</span><br></pre></td></tr></table></figure>

<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h3><ul>
<li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204356-130658.jpeg" alt></p>
<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构</p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204346-894574.jpeg" alt></p>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。</p>
<p><strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><ul>
<li><p><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守</p>
<p>一定的规则。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步</p>
<p>骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</p>
</li>
</ul>
<ul>
<li><p><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最</p>
<p>广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理</p>
<p>数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205653-273589.jpeg" alt></p>
<p>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</p>
<p>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</p>
<p>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</p>
<p>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p>
<h3 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h3><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接</p>
<p>口，来专注于网络程序开发，而不用考虑通信的细节。</p>
<p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不</p>
<p>建立逻辑连接</p>
<p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP</p>
<p>协议</p>
<p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使</p>
<p>用UDP协议</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205700-592149.bmp" alt="UDP通信图解"></p>
<p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p>
<p>数据报(Datagram):网络传输的基本单位 </p>
<ul>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和</p>
<p>接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。(服务器确认客户有发送能力)</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。(客户确认服务器有发送和接收能力)</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。(服务器确认客户有接收能力)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205704-832626.jpeg" alt></p>
<p>   由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p>
<h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul>
<li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述</li>
</ul>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul>
<li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，IP地址用来给一个网络中的计算机设备做唯一的编号</li>
</ul>
<p><strong>IP地址分类</strong></p>
<ul>
<li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示</p>
<p>成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><strong>常用命令</strong></p>
<ul>
<li>查看本机IP地址，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>检查网络是否连通，在控制台输入：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping <span class="number">220.181</span>.57.216</span><br></pre></td></tr></table></figure>

<p><strong>特殊的IP地址</strong></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>网络的通信，本质上是两个进程（应用程序）的通信</p>
<p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p>
<ul>
<li><p><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和</p>
<p>应用，普通的应用程序需要使用1024以上的端口号</p>
</li>
</ul>
<p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p>
<h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p><strong>两端通信时步骤：</strong></p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h3><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<h4 id="构造方法-13"><a href="#构造方法-13" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li><p><code>public InputStream getInputStream()</code> </p>
</li>
<li><p>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</p>
<ul>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public OutputStream getOutputStream()</code> </p>
</li>
<li><p>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</p>
<ul>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><p><code>public void close()</code> </p>
</li>
<li><p>一旦一个socket被关闭，它不可再使用。</p>
<ul>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p>
<ul>
<li><strong>任何先前写出的数据将被发送，随后终止输出流，不然服务器端收不到结束标志，会一直等待</strong></li>
</ul>
</li>
</ul>
<h3 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h3><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<h4 id="构造方法-14"><a href="#构造方法-14" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，将其绑定到一个指定的端口号</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个Socket对象，用于和客户端通信。该方法一直阻塞直到建立连接</li>
</ul>
<h3 id="简单的TCP网络程序"><a href="#简单的TCP网络程序" class="headerlink" title="简单的TCP网络程序"></a>简单的TCP网络程序</h3><h4 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h4><ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205711-27191.jpeg" alt></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 OutputStream out = server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		OutputStream os = client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());<span class="comment">// 没有主动关闭，两边应该会一直等待吧</span></span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	InputStream in = client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="综合案例-1"><a href="#综合案例-1" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="文件上传案例"><a href="#文件上传案例" class="headerlink" title="文件上传案例"></a>文件上传案例</h3><h4 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h4><ol>
<li>【客户端】输入流，从硬盘读取文件数据到程序中。</li>
<li>【客户端】输出流，写出文件数据到服务端。</li>
<li>【服务端】输入流，读取文件数据到服务端程序。</li>
<li>【服务端】输出流，写出文件数据到服务器硬盘中。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205717-958331.jpeg" alt>    </p>
<h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      	ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  		<span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      	<span class="comment">// 3. 创建流对象</span></span><br><span class="line">      	<span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>));</span><br><span class="line">		<span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">"文件上传完毕 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h4><ol>
<li><p><strong>文件名称写死的问题</strong></p>
<p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>循环接收的问题</strong></p>
<p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>效率问题</strong></p>
<p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      	......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      	......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      	<span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/* </span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h4><p>前四步与基本文件上传一致.</p>
<ol start="5">
<li>【服务端】获取输出流，回写数据。</li>
<li>【客户端】获取输入流，解析回写数据。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205618-423948.jpeg" alt></p>
<h5 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟B-S服务器-扩展知识点"><a href="#模拟B-S服务器-扩展知识点" class="headerlink" title="模拟B\S服务器(扩展知识点)"></a>模拟B\S服务器(扩展知识点)</h3><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p>
<h4 id="案例分析-3"><a href="#案例分析-3" class="headerlink" title="案例分析"></a>案例分析</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224213409-67743.png" alt="image-20200224213408136"></p>
<ol>
<li><p>准备页面数据，web文件夹。</p>
<p>复制到我们Module中，比如复制到day08中</p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205607-277291.png" alt></p>
</li>
<li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    	Socket socket = server.accept();</span><br><span class="line">    	InputStream in = socket.getInputStream();</span><br><span class="line">   	    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	<span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    	System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    	socket.close();</span><br><span class="line">    	server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205629-919189.jpeg" alt></p>
</li>
<li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205728-178275.jpeg" alt></p>
</li>
</ol>
<p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure>

<h4 id="案例实现-3"><a href="#案例实现-3" class="headerlink" title="案例实现"></a>案例实现</h4><p>服务端实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端  启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">"HTTP/200 OK\r\n"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();	</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h4><ul>
<li><strong>火狐</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205637-218119.png" alt></p>
<blockquote>
<p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p>
</blockquote>
<p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p>
<p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">"HTTP/200 OK\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问效果：</strong></p>
<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205643-71748.png" alt></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持技术分享，如有帮助，请多支持！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/pay/to/wechat.png" alt="Author 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/19/框架/Spring/" rel="prev" title="Spring">
      <i class="fa fa-chevron-left"></i> Spring
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/05/工具/设计模式/" rel="next" title="设计模式">
      设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发与并行"><span class="nav-number">1.1.1.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与进程"><span class="nav-number">1.1.2.</span> <span class="nav-text">线程与进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建"><span class="nav-number">1.2.</span> <span class="nav-text">创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建线程类"><span class="nav-number">1.2.1.</span> <span class="nav-text">创建线程类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#法一"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">法一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#法二"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">法二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二者区别"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">二者区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩充"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">扩充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优化"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程优先级"><span class="nav-number">1.2.2.</span> <span class="nav-text">线程优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全"><span class="nav-number">1.3.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程同步"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#同步代码块"><span class="nav-number">1.3.0.2.1.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#同步方法"><span class="nav-number">1.3.0.2.2.</span> <span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁机制"><span class="nav-number">1.3.0.2.3.</span> <span class="nav-text">锁机制</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态"><span class="nav-number">1.4.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见状态"><span class="nav-number">1.4.1.</span> <span class="nav-text">常见状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念-1"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Timed-Waiting（计时等待）"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Timed Waiting（计时等待）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BLOCKED（锁阻塞）"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">BLOCKED（锁阻塞）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Waiting（无限等待）"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">Waiting（无限等待）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待唤醒机制"><span class="nav-number">1.4.2.</span> <span class="nav-text">等待唤醒机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程间通信"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">线程间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#等待唤醒机制-1"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">等待唤醒机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生产者与消费者问题"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">生产者与消费者问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池"><span class="nav-number">1.5.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池思想概述"><span class="nav-number">1.5.1.</span> <span class="nav-text">线程池思想概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念-2"><span class="nav-number">1.5.2.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用"><span class="nav-number">1.5.3.</span> <span class="nav-text">使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件"><span class="nav-number">2.</span> <span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#File类"><span class="nav-number">2.1.</span> <span class="nav-text">File类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">2.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">2.1.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法"><span class="nav-number">2.1.3.</span> <span class="nav-text">常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取功能的方法"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">获取功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断功能的方法"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">判断功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建删除功能的方法"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">创建删除功能的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录的遍历"><span class="nav-number">2.1.4.</span> <span class="nav-text">目录的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归"><span class="nav-number">2.2.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归求阶乘"><span class="nav-number">2.2.2.</span> <span class="nav-text">递归求阶乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归打印多级目录"><span class="nav-number">2.2.3.</span> <span class="nav-text">递归打印多级目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综合案例"><span class="nav-number">2.3.</span> <span class="nav-text">综合案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件搜索"><span class="nav-number">2.3.1.</span> <span class="nav-text">文件搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件过滤器优化"><span class="nav-number">2.3.2.</span> <span class="nav-text">文件过滤器优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda优化"><span class="nav-number">2.3.3.</span> <span class="nav-text">Lambda优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO概述"><span class="nav-number">2.4.</span> <span class="nav-text">IO概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是IO"><span class="nav-number">2.4.1.</span> <span class="nav-text">什么是IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO的分类"><span class="nav-number">2.4.2.</span> <span class="nav-text">IO的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO的流向说明图解"><span class="nav-number">2.4.3.</span> <span class="nav-text">IO的流向说明图解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顶级父类们"><span class="nav-number">2.4.4.</span> <span class="nav-text">顶级父类们</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字节流"><span class="nav-number">2.5.</span> <span class="nav-text">字节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一切皆为字节"><span class="nav-number">2.5.1.</span> <span class="nav-text">一切皆为字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节输出流"><span class="nav-number">2.5.2.</span> <span class="nav-text">字节输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileOutputStream"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">FileOutputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-1"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写出字节数据"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">写出字节数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据追加续写"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">数据追加续写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写出换行"><span class="nav-number">2.5.2.5.</span> <span class="nav-text">写出换行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节输入流"><span class="nav-number">2.5.3.</span> <span class="nav-text">字节输入流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileInputStream"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">FileInputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-2"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取字节数据"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">读取字节数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：图片复制"><span class="nav-number">2.5.4.</span> <span class="nav-text">练习：图片复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复制原理图解"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">复制原理图解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例实现"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">案例实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符流"><span class="nav-number">2.6.</span> <span class="nav-text">字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符输入流"><span class="nav-number">2.6.1.</span> <span class="nav-text">字符输入流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileReader类"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">FileReader类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-3"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取字符数据"><span class="nav-number">2.6.1.3.</span> <span class="nav-text">读取字符数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符输出流"><span class="nav-number">2.6.2.</span> <span class="nav-text">字符输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileWriter类"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">FileWriter类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-4"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本写出数据"><span class="nav-number">2.6.2.3.</span> <span class="nav-text">基本写出数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关闭和刷新"><span class="nav-number">2.6.2.4.</span> <span class="nav-text">关闭和刷新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#写出其他数据"><span class="nav-number">2.6.2.5.</span> <span class="nav-text">写出其他数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO异常的处理"><span class="nav-number">2.7.</span> <span class="nav-text">IO异常的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK7前处理"><span class="nav-number">2.7.0.1.</span> <span class="nav-text">JDK7前处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK7的处理"><span class="nav-number">2.7.0.2.</span> <span class="nav-text">JDK7的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK9的改进"><span class="nav-number">2.7.0.3.</span> <span class="nav-text">JDK9的改进</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性集"><span class="nav-number">2.8.</span> <span class="nav-text">属性集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-2"><span class="nav-number">2.8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Properties类"><span class="nav-number">2.8.2.</span> <span class="nav-text">Properties类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-5"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的存储方法"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">基本的存储方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与流相关的方法"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">与流相关的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#读取"><span class="nav-number">2.8.2.3.1.</span> <span class="nav-text">读取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#写入"><span class="nav-number">2.8.2.3.2.</span> <span class="nav-text">写入</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲流"><span class="nav-number">2.9.</span> <span class="nav-text">缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-3"><span class="nav-number">2.9.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节缓冲流"><span class="nav-number">2.9.2.</span> <span class="nav-text">字节缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-6"><span class="nav-number">2.9.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#效率测试"><span class="nav-number">2.9.2.2.</span> <span class="nav-text">效率测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符缓冲流"><span class="nav-number">2.9.3.</span> <span class="nav-text">字符缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-7"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特有方法"><span class="nav-number">2.9.3.2.</span> <span class="nav-text">特有方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习-文本排序"><span class="nav-number">2.9.4.</span> <span class="nav-text">练习:文本排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例分析"><span class="nav-number">2.9.4.1.</span> <span class="nav-text">案例分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转换流"><span class="nav-number">2.10.</span> <span class="nav-text">转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符编码和字符集"><span class="nav-number">2.10.1.</span> <span class="nav-text">字符编码和字符集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符编码"><span class="nav-number">2.10.1.1.</span> <span class="nav-text">字符编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符集"><span class="nav-number">2.10.1.2.</span> <span class="nav-text">字符集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码引出的问题"><span class="nav-number">2.10.2.</span> <span class="nav-text">编码引出的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputStreamReader类"><span class="nav-number">2.10.3.</span> <span class="nav-text">InputStreamReader类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-8"><span class="nav-number">2.10.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定编码读取"><span class="nav-number">2.10.3.2.</span> <span class="nav-text">指定编码读取</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutputStreamWriter类"><span class="nav-number">2.10.4.</span> <span class="nav-text">OutputStreamWriter类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-9"><span class="nav-number">2.10.4.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指定编码写出"><span class="nav-number">2.10.4.2.</span> <span class="nav-text">指定编码写出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转换流理解图解"><span class="nav-number">2.10.4.3.</span> <span class="nav-text">转换流理解图解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：转换文件编码"><span class="nav-number">2.10.5.</span> <span class="nav-text">练习：转换文件编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例分析-1"><span class="nav-number">2.10.5.1.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例实现-1"><span class="nav-number">2.10.5.2.</span> <span class="nav-text">案例实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化"><span class="nav-number">2.11.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-4"><span class="nav-number">2.11.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectOutputStream类"><span class="nav-number">2.11.2.</span> <span class="nav-text">ObjectOutputStream类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-10"><span class="nav-number">2.11.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化操作"><span class="nav-number">2.11.2.2.</span> <span class="nav-text">序列化操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectInputStream类"><span class="nav-number">2.11.3.</span> <span class="nav-text">ObjectInputStream类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-11"><span class="nav-number">2.11.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反序列化操作1"><span class="nav-number">2.11.3.2.</span> <span class="nav-text">反序列化操作1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反序列化操作2"><span class="nav-number">2.11.3.3.</span> <span class="nav-text">反序列化操作2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#练习：序列化集合"><span class="nav-number">2.11.4.</span> <span class="nav-text">练习：序列化集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例分析-2"><span class="nav-number">2.11.4.1.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例实现-2"><span class="nav-number">2.11.4.2.</span> <span class="nav-text">案例实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打印流"><span class="nav-number">2.12.</span> <span class="nav-text">打印流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-5"><span class="nav-number">2.12.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PrintStream类"><span class="nav-number">2.12.2.</span> <span class="nav-text">PrintStream类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-12"><span class="nav-number">2.12.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改变打印流向"><span class="nav-number">2.12.2.2.</span> <span class="nav-text">改变打印流向</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-number">3.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#入门"><span class="nav-number">3.1.</span> <span class="nav-text">入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件结构"><span class="nav-number">3.1.1.</span> <span class="nav-text">软件结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络通信协议"><span class="nav-number">3.1.2.</span> <span class="nav-text">网络通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协议分类"><span class="nav-number">3.1.3.</span> <span class="nav-text">协议分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络编程三要素"><span class="nav-number">3.1.4.</span> <span class="nav-text">网络编程三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#协议"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP地址"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#端口号"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">端口号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP通信程序"><span class="nav-number">3.2.</span> <span class="nav-text">TCP通信程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-6"><span class="nav-number">3.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket类"><span class="nav-number">3.2.2.</span> <span class="nav-text">Socket类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-13"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员方法"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">成员方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServerSocket类"><span class="nav-number">3.2.3.</span> <span class="nav-text">ServerSocket类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法-14"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员方法-1"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">成员方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单的TCP网络程序"><span class="nav-number">3.2.4.</span> <span class="nav-text">简单的TCP网络程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP通信分析图解"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">TCP通信分析图解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综合案例-1"><span class="nav-number">3.3.</span> <span class="nav-text">综合案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件上传案例"><span class="nav-number">3.3.1.</span> <span class="nav-text">文件上传案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件上传分析图解"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">文件上传分析图解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基本实现"><span class="nav-number">3.3.1.1.1.</span> <span class="nav-text">基本实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件上传优化分析"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">文件上传优化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优化实现"><span class="nav-number">3.3.1.2.1.</span> <span class="nav-text">优化实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信息回写分析图解"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">信息回写分析图解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#回写实现"><span class="nav-number">3.3.1.3.1.</span> <span class="nav-text">回写实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模拟B-S服务器-扩展知识点"><span class="nav-number">3.3.2.</span> <span class="nav-text">模拟B\S服务器(扩展知识点)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例分析-3"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例实现-3"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">案例实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问效果"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">访问效果</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">这些年编程路上踩得坑</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/guardwarm" title="GitHub → https://github.com/guardwarm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xunzhaoshouhu@gmail.com" title="E-Mail → mailto:xunzhaoshouhu@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">guardwarm</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://https-guardwarm-github-io-1.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/02/28/heima57/java进阶2/";
    this.page.identifier = "2020/02/28/heima57/java进阶2/";
    this.page.title = "java进阶2";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://https-guardwarm-github-io-1.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
