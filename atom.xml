<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guard warm</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-18T09:19:50.986Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>grandwarm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring</title>
    <link href="http://yoursite.com/2020/02/18/Spring/"/>
    <id>http://yoursite.com/2020/02/18/Spring/</id>
    <published>2020-02-18T09:19:50.000Z</published>
    <updated>2020-02-18T09:19:50.986Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="http://yoursite.com/2020/02/18/Mybatis/"/>
    <id>http://yoursite.com/2020/02/18/Mybatis/</id>
    <published>2020-02-18T09:19:32.000Z</published>
    <updated>2020-02-18T09:19:32.987Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java Web</title>
    <link href="http://yoursite.com/2020/02/18/java-Web/"/>
    <id>http://yoursite.com/2020/02/18/java-Web/</id>
    <published>2020-02-18T09:19:13.000Z</published>
    <updated>2020-02-18T09:19:13.231Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java进阶</title>
    <link href="http://yoursite.com/2020/02/18/java%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2020/02/18/java进阶/</id>
    <published>2020-02-18T09:19:03.000Z</published>
    <updated>2020-02-25T06:38:11.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p><code>java.lang.Object</code>类是Java语言中的根类，那么默认则继承自Object类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> /*<span class="keyword">extends</span> <span class="title">Object</span>*/ </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><h4 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul><li><code>public String toString()</code>：返回该对象的字符串表示。</li></ul><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值的hash值。</p><p>而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><h4 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h4><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> + <span class="string">"name='"</span> + name + <span class="string">'\''</span> + <span class="string">", age="</span> + age + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略构造器与Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的<code>Generate...</code>可自动生成<img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200218173521.bmp" alt></p><blockquote><p> 在我们直接使用输出语句输出对象名的时候,其实默认通过该对象调用了其toString()方法。</p></blockquote><h3 id="1-3-equals方法"><a href="#1-3-equals方法" class="headerlink" title="1.3 equals方法"></a>1.3 equals方法</h3><h4 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul><li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li></ul><p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p><h4 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h4><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的<strong>对象地址</strong>比较，只要不是同一个对象，结果必然为false。</p><h4 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h4><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 转换为当前类型</span></span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用<code>Code</code>菜单中的<code>Generate…</code>选项，并选择<code>equals() and hashCode()</code>进行自动代码生成。如下图所示：</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218193746-836469.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218194219-798604.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218194212-381100.png" alt></p><blockquote><p>tips：Object类当中的hashCode等其他方法，今后学习。</p></blockquote><h2 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h2><p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是<strong>null-save（空指针安全的）或null-tolerant（容忍空指针的）</strong>，用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p><p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p><ul><li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li></ul><p>我们可以查看一下源码，学习一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h2><p><code>java.util.Date</code>类 表示特定的瞬间，精确到毫秒。</p><ul><li><code>public Date()</code>：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Date</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date()); <span class="comment">// Tue Jan 16 14:37:35 CST 2018</span></span><br><span class="line">        <span class="comment">// 创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date(<span class="number">0L</span>)); <span class="comment">// Thu Jan 01 08:00:00 CST 1970</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li></ul><h2 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h2><p><code>java.text.DateFormat</code> 是日期/时间格式化子类的抽象类，我们通过这个类可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>由于DateFormat为<strong>抽象类</strong>，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li></ul><p>参数pattern是一个字符串，代表日期时间的自定义格式。</p><h3 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h3><p>常用的格式规则为：</p><table><thead><tr><th>标识字母</th><th align="left">含义</th></tr></thead><tbody><tr><td>y</td><td align="left">年</td></tr><tr><td>M</td><td align="left">月</td></tr><tr><td>d</td><td align="left">日</td></tr><tr><td>H</td><td align="left">时</td></tr><tr><td>m</td><td align="left">分</td></tr><tr><td>s</td><td align="left">秒</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02SimpleDateFormat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对应的日期格式如：2018-01-16 15:06:38</span></span><br><span class="line">        DateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为<strong>静态成员变量</strong>，方便获取。日历类就是方便获取各个时间属性的。</p><h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象</p><ul><li><code>public static Calendar getInstance()</code>：使用默认时区和语言环境获得一个日历</li></ul><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>根据Calendar类的API文档，常用方法有：</p><ul><li><code>public int get(int field)</code>：返回给定日历字段的值。</li><li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。</li><li><code>public abstract void add(int field, int amount)</code>：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li><li><code>public Date getTime()</code>：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的<strong>Date对象</strong>。</li></ul><p>Calendar类中提供很多成员常量，代表给定的日历字段：</p><table><thead><tr><th>字段值</th><th>含义</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td></tr><tr><td>MONTH</td><td>月（从0开始，可以+1使用）</td></tr><tr><td>DAY_OF_MONTH</td><td>月中的天（几号）</td></tr><tr><td>HOUR</td><td>时（12小时制）</td></tr><tr><td>HOUR_OF_DAY</td><td>时（24小时制）</td></tr><tr><td>MINUTE</td><td>分</td></tr><tr><td>SECOND</td><td>秒</td></tr><tr><td>DAY_OF_WEEK</td><td>周中的天（周几，周日为1，可以-1使用）</td></tr></tbody></table><h4 id="get-set方法"><a href="#get-set方法" class="headerlink" title="get/set方法"></a>get/set方法</h4><p>get方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Calendar对象</span></span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置年 </span></span><br><span class="line">        <span class="keyword">int</span> year = cal.get(Calendar.YEAR);</span><br><span class="line">        <span class="comment">// 设置月默认是0-11</span></span><br><span class="line">        <span class="keyword">int</span> month = cal.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置日</span></span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(Calendar.YEAR, <span class="number">2020</span>);</span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>); <span class="comment">// 2020年1月17日</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><p>add方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>); <span class="comment">// 2018年1月17日</span></span><br><span class="line">        <span class="comment">// 使用add方法</span></span><br><span class="line">        cal.add(Calendar.DAY_OF_MONTH, <span class="number">2</span>); <span class="comment">// 加2天</span></span><br><span class="line">        cal.add(Calendar.YEAR, -<span class="number">3</span>); <span class="comment">// 减3年</span></span><br><span class="line">        System.out.print(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + dayOfMonth + <span class="string">"日"</span>); <span class="comment">// 2015年1月18日; </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getTime方法"><a href="#getTime方法" class="headerlink" title="getTime方法"></a>getTime方法</h4><p>Calendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09CalendarMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        Date date = cal.getTime();</span><br><span class="line">        System.out.println(date); <span class="comment">// Tue Jan 16 16:03:09 CST 2018</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小贴士：</p><ul><li><p>​     西方星期的开始为周日，中国为周一。</p></li><li><p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p></li><li><p>​     日期是有大小关系的，时间靠后，时间越大。</p></li></ul><h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p><ul><li><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</li><li><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</li></ul><h2 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h2><h3 id="字符串拼接问题"><a href="#字符串拼接问题" class="headerlink" title="字符串拼接问题"></a>字符串拼接问题</h3><p>由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"Hello"</span>;</span><br><span class="line">        s += <span class="string">"World"</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。</p><p>根据这句话分析我们的代码，其实总共产生了三个字符串，即<code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>和<code>&quot;HelloWorld&quot;</code>。引用变量s首先指向<code>Hello</code>对象，最终指向拼接出来的新字符串对象，即<code>HelloWord</code> 。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218200020-984183.bmp" alt></p><p>由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用<code>java.lang.StringBuilder</code>类。</p><h3 id="StringBuilder概述"><a href="#StringBuilder概述" class="headerlink" title="StringBuilder概述"></a>StringBuilder概述</h3><p>查阅<code>java.lang.StringBuilder</code>的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218200030-728766.png" alt="06-StringBuilder的原理"></p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>根据StringBuilder的API文档，常用构造方法有2个：</p><ul><li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li><li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        System.out.println(sb1); <span class="comment">// (空白)</span></span><br><span class="line">        <span class="comment">// 使用带参构造</span></span><br><span class="line">        StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"itcast"</span>);</span><br><span class="line">        System.out.println(sb2); <span class="comment">// itcast</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><p>StringBuilder常用的方法有2个：</p><ul><li><code>public StringBuilder append(...)</code>：添加<strong>任意类型数据</strong>的字符串形式，并返回当前对象自身。</li><li><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</li></ul><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td><strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td><strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><p><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</p></li><li><p><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</p></li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure><h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><p>由于我们经常要做基本类型与包装类之间的转换，从<strong>Java 5</strong>（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span></span><br><span class="line"><span class="comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><h3 id="基本类型与字符串转换"><a href="#基本类型与字符串转换" class="headerlink" title="基本类型与字符串转换"></a>基本类型与字符串转换</h3><h4 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h4><p>基本类型转换String总共有三种方式</p><ol><li>基本类型直接与””相连接即可；如：34+””</li><li>包装类中的toString方法</li><li>String中的静态方法valueOf</li></ol><h4 id="String转换成对应的基本类型"><a href="#String转换成对应的基本类型" class="headerlink" title="String转换成对应的基本类型"></a>String转换成对应的基本类型</h4><p>除了Character类之外，其他所有包装类都具有<strong>parseXxx</strong>静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li><li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18WrapperParse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = Integer.parseInt(<span class="string">"100"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p></blockquote><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>集合是java中提供的<strong>一种容器</strong>，可以用来存储多个数据。</p><p>集合和数组区别</p><ul><li>数组的长度是固定的。集合的长度是可变的。</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的<strong>都是对象</strong>。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ul><p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li></ul><p>从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218202415-500527.png" alt></p><p>集合本身是一个工具，它存放在java.util包中。在<code>Collection</code>接口定义着单列集合框架中最最共性的内容。</p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>在程序开发中，经常需要遍历集合中的所有元素</p><p><code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p><p>想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：</p><ul><li><code>public Iterator iterator()</code>: 获取集合对应的迭代器，用来遍历集合中的元素的。</li></ul><p><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</p><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用多态方式 创建对象</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素到集合</span></span><br><span class="line">        coll.add(<span class="string">"串串星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"吐槽星人"</span>);</span><br><span class="line">        coll.add(<span class="string">"汪星人"</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//使用迭代器 遍历   每个集合对象都有自己的迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//  泛型指的是 迭代出 元素的数据类型</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:：如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。</p></blockquote><h3 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h3><p>Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218202559-680162.bmp" alt></p><p>在调用Iterator的next方法之前，<strong>迭代器的索引位于第一个元素之前，不指向任何元素</strong>，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p><h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以<strong>在遍历的过程中，不能对集合中的元素进行增删操作</strong>。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  <span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p><blockquote><p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p></blockquote><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。</p><ul><li>允许出现重复的元素，</li><li>所有的元素是以一种线性方式进行存储的，</li><li>在程序中可以通过索引来访问集合中的指定元素</li><li>元素有序，即元素的存入顺序和取出顺序一致。</li></ul><h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><p>List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法</p><ul><li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li><li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li><li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li><li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li></ul><p>List集合特有的方法都是跟索引相关，我们在基础班都学习过，那么我们再来复习一遍吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建List集合对象</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 往 尾部添加 指定元素</span></span><br><span class="line">    list.add(<span class="string">"图图"</span>);</span><br><span class="line">    list.add(<span class="string">"小美"</span>);</span><br><span class="line">    list.add(<span class="string">"不高兴"</span>);</span><br><span class="line">    <span class="comment">// String remove(int index) 删除指定位置元素  返回被删除元素</span></span><br><span class="line">    <span class="comment">// 删除索引位置为2的元素 </span></span><br><span class="line">    System.out.println(<span class="string">"删除索引位置为2的元素"</span>);</span><br><span class="line">    System.out.println(list.remove(<span class="number">2</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(list);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// String set(int index,String s)</span></span><br><span class="line">    <span class="comment">// 在指定位置 进行 元素替代（改） </span></span><br><span class="line">    <span class="comment">// 修改指定位置元素</span></span><br><span class="line">    list.set(<span class="number">0</span>, <span class="string">"三毛"</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// String get(int index)  获取指定位置元素</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 跟size() 方法一起用  来 遍历的 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还可以使用增强for</span></span><br><span class="line">    <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><h4 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h4><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快</p><p>由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p><h4 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h4><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p><blockquote><p>LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下</p></blockquote><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218213149-89626.png" alt></p><p>实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可：</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。（了解即可）</p><p>方法演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        link.addFirst(<span class="string">"abc1"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc2"</span>);</span><br><span class="line">        link.addFirst(<span class="string">"abc3"</span>);</span><br><span class="line">        System.out.println(link);</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        System.out.println(link.getFirst());</span><br><span class="line">        System.out.println(link.getLast());</span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        System.out.println(link.removeFirst());</span><br><span class="line">        System.out.println(link.removeLast());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!link.isEmpty()) &#123; <span class="comment">//判断集合是否为空</span></span><br><span class="line">            System.out.println(link.pop()); <span class="comment">//弹出集合中的栈顶元素</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>线程安全，是List最初的实现类，底层是数组，在JDK1.2之后增加由于访问速度慢渐渐被遗弃</p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><code>java.util.Set</code>接口继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。</p><p>与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p><p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p><blockquote><p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p></blockquote><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是不可重复的，并且是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。</p><p>保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>我们先来使用一下Set集合存储，看下现象，再进行原理的讲解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 Set集合</span></span><br><span class="line">        HashSet&lt;String&gt;  set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="keyword">new</span> String(<span class="string">"cba"</span>));</span><br><span class="line">        set.add(<span class="string">"abc"</span>);</span><br><span class="line">        set.add(<span class="string">"bac"</span>); </span><br><span class="line">        set.add(<span class="string">"cba"</span>);  </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String name : set) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，说明集合中不能存储重复元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cba</span><br><span class="line">abc</span><br><span class="line">bac</span><br></pre></td></tr></table></figure><blockquote><p>tips:根据结果我们发现字符串”cba”只存储了一个，也就是说重复的元素set集合不存储。</p></blockquote><h4 id="存储数据的结构（哈希表）"><a href="#存储数据的结构（哈希表）" class="headerlink" title="存储数据的结构（哈希表）"></a>存储数据的结构（哈希表）</h4><p>什么是哈希表呢？</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。</p><p>而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下图所示。<img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218213940-459878.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218214030-717218.png" alt></p><p>保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须<strong>复写hashCode和equals</strong>方法建立属于当前对象的比较方式。</p><h4 id="存储自定义类型元素"><a href="#存储自定义类型元素" class="headerlink" title="存储自定义类型元素"></a>存储自定义类型元素</h4><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构，但他是有序的</p><p>演示代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">"bbb"</span>);</span><br><span class="line">set.add(<span class="string">"aaa"</span>);</span><br><span class="line">set.add(<span class="string">"abc"</span>);</span><br><span class="line">set.add(<span class="string">"bbc"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">  bbb</span><br><span class="line">  aaa</span><br><span class="line">  abc</span><br><span class="line">  bbc</span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h3 id="常用功能-1"><a href="#常用功能-1" class="headerlink" title="常用功能"></a>常用功能</h3><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)</code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//原来写法</span></span><br><span class="line">        <span class="comment">//list.add(12);</span></span><br><span class="line">        <span class="comment">//list.add(14);</span></span><br><span class="line">        <span class="comment">//list.add(15);</span></span><br><span class="line">        <span class="comment">//list.add(1000);</span></span><br><span class="line">        <span class="comment">//采用工具类 完成 往集合中添加元素  </span></span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>，<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">//排序方法 </span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[<span class="number">5</span>, <span class="number">222</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">222</span>]</span><br></pre></td></tr></table></figure><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><h5 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h5><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p><p>不过这次存储的是字符串类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[aba, cba, nba, sba]</span><br></pre></td></tr></table></figure><p>我们使用的是默认的规则完成字符串的排序，那么默认规则是怎么定义出来的呢？</p><p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p><p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能，在String类型上如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符降序排列，那么这样就要修改String的源代码</p><h5 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h5><p>public static <t> void sort(List<t> list，Comparator&lt;? super T&gt; )`涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</t></t></p><ul><li><p><code>public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote></li></ul><p>操作如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"cba"</span>);</span><br><span class="line">        list.add(<span class="string">"aba"</span>);</span><br><span class="line">        list.add(<span class="string">"sba"</span>);</span><br><span class="line">        list.add(<span class="string">"nba"</span>);</span><br><span class="line">        <span class="comment">//排序方法  按照第一个单词的降序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.charAt(<span class="number">0</span>) - o1.charAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[sba, nba, cba, aba]</span><br></pre></td></tr></table></figure><h5 id="简述Comparable和Comparator两个接口的区别"><a href="#简述Comparable和Comparator两个接口的区别" class="headerlink" title="简述Comparable和Comparator两个接口的区别"></a>简述Comparable和Comparator两个接口的区别</h5><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p><h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做<strong>映射</strong>。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p><p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218224257-218245.bmp" alt></p><ul><li><code>Collection</code>中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。</li><li><code>Map</code>中的集合，元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li><li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul><h3 id="常用子类"><a href="#常用子类" class="headerlink" title="常用子类"></a>常用子类</h3><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li><strong>HashMap&lt;K,V&gt;</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>LinkedHashMap&lt;K,V&gt;</strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><h3 id="Map接口中的常用方法"><a href="#Map接口中的常用方法" class="headerlink" title="Map接口中的常用方法"></a>Map接口中的常用方法</h3><p>Map接口中定义了很多方法，常用的如下：</p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)</code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><blockquote><p>tips:</p><ul><li><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p></li><li><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></li></ul></blockquote><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="遍历键找值方式"><a href="#遍历键找值方式" class="headerlink" title="遍历键找值方式"></a>遍历键找值方式</h4><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>分析步骤：</p><ol><li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li><li>遍历键的Set集合，得到每一个键。</li><li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">        map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">        map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          <span class="comment">//key  就是键</span></span><br><span class="line">            <span class="comment">//获取对应值</span></span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key+<span class="string">"的CP是："</span>+value);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h4><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>在Map集合中也提供了获取所有Entry对象的方法：</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><h4 id="遍历键值对方式"><a href="#遍历键值对方式" class="headerlink" title="遍历键值对方式"></a>遍历键值对方式</h4><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Map集合对象 </span></span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合 </span></span><br><span class="line">        map.put(<span class="string">"胡歌"</span>, <span class="string">"霍建华"</span>);</span><br><span class="line">        map.put(<span class="string">"郭德纲"</span>, <span class="string">"于谦"</span>);</span><br><span class="line">        map.put(<span class="string">"薛之谦"</span>, <span class="string">"大张伟"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 所有的 entry对象  entrySet</span></span><br><span class="line">        Set&lt;Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历得到每一个entry对象</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">           <span class="comment">// 解析 </span></span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();  </span><br><span class="line">            System.out.println(key+<span class="string">"的CP是:"</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历图解：</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218224351-656126.bmp" alt></p><blockquote><p>tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p></blockquote><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构，可以保证有序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"邓超"</span>, <span class="string">"孙俪"</span>);</span><br><span class="line">        map.put(<span class="string">"李晨"</span>, <span class="string">"范冰冰"</span>);</span><br><span class="line">        map.put(<span class="string">"刘德华"</span>, <span class="string">"朱丽倩"</span>);</span><br><span class="line">        Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entrySet) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"  "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邓超  孙俪</span><br><span class="line">李晨  范冰冰</span><br><span class="line">刘德华  朱丽倩</span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><strong>需求：</strong></p><p>计算一个字符串中每个字符出现次数。</p><p><strong>分析：</strong></p><ol><li>获取一个字符串对象</li><li>创建一个Map集合，键代表字符，值代表次数。</li><li>遍历字符串得到每个字符。</li><li>判断Map中是否有该键。</li><li>如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。     </li><li>打印最终结果</li></ol><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//友情提示</span></span><br><span class="line">        System.out.println(<span class="string">"请录入一个字符串:"</span>);</span><br><span class="line">        String line = <span class="keyword">new</span> Scanner(System.in).nextLine();</span><br><span class="line">        <span class="comment">// 定义 每个字符出现次数的方法</span></span><br><span class="line">        findChar(line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findChar</span><span class="params">(String line)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1:创建一个集合 存储  字符 以及其出现的次数</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="comment">//2:遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; line.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = line.charAt(i);</span><br><span class="line">            <span class="comment">//判断 该字符 是否在键集中</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;<span class="comment">//说明这个字符没有出现过</span></span><br><span class="line">                <span class="comment">//那就是第一次</span></span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先获取之前的次数</span></span><br><span class="line">                Integer count = map.get(c);</span><br><span class="line">                <span class="comment">//count++;</span></span><br><span class="line">                <span class="comment">//再次存入  更新</span></span><br><span class="line">                map.put(c, ++count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合综合案例"><a href="#集合综合案例" class="headerlink" title="集合综合案例"></a>集合综合案例</h2><h3 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h3><p>用collection来实现简单的斗地主</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1: 准备牌操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//1.1 创建牌盒 将来存储牌面的 </span></span><br><span class="line">        ArrayList&lt;String&gt; pokerBox = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//1.2 创建花色集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.3 创建数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.4 分别给花色 以及 数字集合添加元素</span></span><br><span class="line">        colors.add(<span class="string">"♥"</span>);</span><br><span class="line">        colors.add(<span class="string">"♦"</span>);</span><br><span class="line">        colors.add(<span class="string">"♠"</span>);</span><br><span class="line">        colors.add(<span class="string">"♣"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            numbers.add(i+<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numbers.add(<span class="string">"J"</span>);</span><br><span class="line">        numbers.add(<span class="string">"Q"</span>);</span><br><span class="line">        numbers.add(<span class="string">"K"</span>);</span><br><span class="line">        numbers.add(<span class="string">"A"</span>);</span><br><span class="line">        <span class="comment">//1.5 创造牌  拼接牌操作</span></span><br><span class="line">        <span class="comment">// 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中</span></span><br><span class="line">        <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">            <span class="comment">//color每一个花色 </span></span><br><span class="line">            <span class="comment">//遍历数字集合</span></span><br><span class="line">            <span class="keyword">for</span>(String number : numbers)&#123;</span><br><span class="line">                <span class="comment">//结合</span></span><br><span class="line">                String card = color+number;</span><br><span class="line">                <span class="comment">//存储到牌盒中</span></span><br><span class="line">                pokerBox.add(card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.6大王小王</span></span><br><span class="line">        pokerBox.add(<span class="string">"小☺"</span>);</span><br><span class="line">        pokerBox.add(<span class="string">"大☠"</span>);  </span><br><span class="line">        <span class="comment">// System.out.println(pokerBox);</span></span><br><span class="line">        <span class="comment">//洗牌 是不是就是将  牌盒中 牌的索引打乱 </span></span><br><span class="line">        <span class="comment">// Collections类  工具类  都是 静态方法</span></span><br><span class="line">        <span class="comment">// shuffer方法   </span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * static void shuffle(List&lt;?&gt; list) </span></span><br><span class="line"><span class="comment">         *     使用默认随机源对指定列表进行置换。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//2:洗牌</span></span><br><span class="line">        Collections.shuffle(pokerBox);</span><br><span class="line">        <span class="comment">//3 发牌</span></span><br><span class="line">        <span class="comment">//3.1 创建 三个 玩家集合  创建一个底牌集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 牌盒  必须知道索引   </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pokerBox.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取 牌面</span></span><br><span class="line">            String card = pokerBox.get(i);</span><br><span class="line">            <span class="comment">//留出三张底牌 存到 底牌集合中</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">51</span>)&#123;<span class="comment">//存到底牌集合中</span></span><br><span class="line">                dipai.add(card);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//玩家1   %3  ==0</span></span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                  player1.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">1</span>)&#123;<span class="comment">//玩家2</span></span><br><span class="line">                  player2.add(card);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//玩家3</span></span><br><span class="line">                  player3.add(card);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看看</span></span><br><span class="line">        System.out.println(<span class="string">"令狐冲："</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">"田伯光："</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">"绿竹翁："</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">"底牌："</span>+dipai);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200218224430-981816.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Poker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1组装54张扑克牌</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.1 创建Map集合存储</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; pokerMap = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">        <span class="comment">// 1.2 创建 花色集合 与 数字集合</span></span><br><span class="line">        ArrayList&lt;String&gt; colors = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; numbers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.3 存储 花色 与数字</span></span><br><span class="line">        Collections.addAll(colors, <span class="string">"♦"</span>, <span class="string">"♣"</span>, <span class="string">"♥"</span>, <span class="string">"♠"</span>);</span><br><span class="line">        Collections.addAll(numbers, <span class="string">"2"</span>, <span class="string">"A"</span>, <span class="string">"K"</span>, <span class="string">"Q"</span>, <span class="string">"J"</span>, <span class="string">"10"</span>, <span class="string">"9"</span>, <span class="string">"8"</span>, <span class="string">"7"</span>, <span class="string">"6"</span>, <span class="string">"5"</span>, <span class="string">"4"</span>, <span class="string">"3"</span>);</span><br><span class="line">        <span class="comment">// 设置 存储编号变量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        pokerMap.put(count++, <span class="string">"大王"</span>);</span><br><span class="line">        pokerMap.put(count++, <span class="string">"小王"</span>);</span><br><span class="line">        <span class="comment">// 1.4 创建牌 存储到map集合中</span></span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String color : colors) &#123;</span><br><span class="line">                String card = color + number;</span><br><span class="line">                pokerMap.put(count++, card);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2 将54张牌顺序打乱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 取出编号 集合</span></span><br><span class="line">        Set&lt;Integer&gt; numberSet = pokerMap.keySet();</span><br><span class="line">        <span class="comment">// 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中</span></span><br><span class="line">        ArrayList&lt;Integer&gt; numberList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        numberList.addAll(numberSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打乱顺序</span></span><br><span class="line">        Collections.shuffle(numberList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌</span></span><br><span class="line">        <span class="comment">// 3.1 发牌的编号</span></span><br><span class="line">        <span class="comment">// 创建三个玩家编号集合 和一个 底牌编号集合</span></span><br><span class="line">        ArrayList&lt;Integer&gt; noP1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; noP3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dipaiNo = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2发牌的编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取该编号</span></span><br><span class="line">            Integer no = numberList.get(i);</span><br><span class="line">            <span class="comment">// 发牌</span></span><br><span class="line">            <span class="comment">// 留出底牌</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dipaiNo.add(no);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    noP1.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    noP2.add(no);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    noP3.add(no);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 查看三人各自手中的牌（按照牌的大小排序）、底牌</span></span><br><span class="line">        <span class="comment">// 4.1 对手中编号进行排序</span></span><br><span class="line">        Collections.sort(noP1);</span><br><span class="line">        Collections.sort(noP2);</span><br><span class="line">        Collections.sort(noP3);</span><br><span class="line">        Collections.sort(dipaiNo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.2 进行牌面的转换</span></span><br><span class="line">        <span class="comment">// 创建三个玩家牌面集合 以及底牌牌面集合</span></span><br><span class="line">        ArrayList&lt;String&gt; player1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; player3 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; dipai = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.3转换</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP1) &#123;</span><br><span class="line">            <span class="comment">// 4.4 根据编号找到 牌面 pokerMap</span></span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            <span class="comment">// 添加到对应的 牌面集合中</span></span><br><span class="line">            player1.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP2) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            player2.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : noP3) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            player3.add(card);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Integer i : dipaiNo) &#123;</span><br><span class="line">            String card = pokerMap.get(i);</span><br><span class="line">            dipai.add(card);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.5 查看</span></span><br><span class="line">        System.out.println(<span class="string">"令狐冲："</span>+player1);</span><br><span class="line">        System.out.println(<span class="string">"石破天："</span>+player2);</span><br><span class="line">        System.out.println(<span class="string">"鸠摩智："</span>+player3);</span><br><span class="line">        System.out.println(<span class="string">"底牌："</span>+dipai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h3><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">"abc"</span>);</span><br><span class="line">coll.add(<span class="string">"itcast"</span>);</span><br><span class="line">coll.add(<span class="number">5</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"><span class="comment">//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型</span></span><br><span class="line">String str = (String) it.next();</span><br><span class="line">System.out.println(str.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在运行时发生了问题<strong>java.lang.ClassCastException</strong>。                                                                                                                                                   Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象</p><ul><li><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</li></ul><blockquote><p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p></blockquote><h3 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h3><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>通过我们如下代码体验一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"itcast"</span>);</span><br><span class="line">        <span class="comment">// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错</span></span><br><span class="line">        <span class="comment">// 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            <span class="comment">//当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素直接就是String类型</span></span><br><span class="line">            System.out.println(str.length());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。</p></blockquote><h3 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h3><h4 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h4><h5 id="定义格式："><a href="#定义格式：" class="headerlink" title="定义格式："></a>定义格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，API中的ArrayList集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123; &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型： 即什么时候确定泛型。</p><h5 id="在创建对象的时候确定泛型"><a href="#在创建对象的时候确定泛型" class="headerlink" title="在创建对象的时候确定泛型"></a>在创建对象的时候确定泛型</h5><p> 例如，<code>ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><p>此时，变量E的值就是String类型,那么我们的类型就可以理解为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(String e)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;  &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h4><h5 id="定义格式：-1"><a href="#定义格式：-1" class="headerlink" title="定义格式："></a>定义格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericMethod</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;MVP&gt; <span class="function">MVP <span class="title">show2</span><span class="params">(MVP mvp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用方法时，确定泛型的类型"><a href="#调用方法时，确定泛型的类型" class="headerlink" title="调用方法时，确定泛型的类型"></a>调用方法时，确定泛型的类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        MyGenericMethod mm = <span class="keyword">new</span> MyGenericMethod();</span><br><span class="line">        <span class="comment">// 演示看方法提示</span></span><br><span class="line">        mm.show(<span class="string">"aaa"</span>);</span><br><span class="line">        mm.show(<span class="number">123</span>);</span><br><span class="line">        mm.show(<span class="number">12.45</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h4><h5 id="定义格式：-2"><a href="#定义格式：-2" class="headerlink" title="定义格式："></a>定义格式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface接口名&lt;代表泛型的变量&gt; &#123;  &#125;</span><br></pre></td></tr></table></figure><p>例如，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> E <span class="title">getE</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用格式："><a href="#使用格式：" class="headerlink" title="使用格式："></a>使用格式：</h5><h6 id="定义类时确定泛型的类型"><a href="#定义类时确定泛型的类型" class="headerlink" title="定义类时确定泛型的类型"></a>定义类时确定泛型的类型</h6><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp1</span> <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，泛型E的值就是String类型。</p><h6 id="始终不确定泛型的类型，直到创建对象时，确定泛型的类型"><a href="#始终不确定泛型的类型，直到创建对象时，确定泛型的类型" class="headerlink" title="始终不确定泛型的类型，直到创建对象时，确定泛型的类型"></a>始终不确定泛型的类型，直到创建对象时，确定泛型的类型</h6><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">MyGenericInterface</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyImp2&lt;String&gt;  my = <span class="keyword">new</span> MyImp2&lt;String&gt;();  </span><br><span class="line">        my.add(<span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>当使用泛型类或者接口做参数接收数据时，泛型类型不确定，可以通过通配符&lt;?&gt;表示。</p><p>但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p><h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>此时只能接受数据,不能往该集合中存储数据。</p><p>举个例子大家理解使用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br></pre></td></tr></table></figure><blockquote><p>tips:泛型不存在继承关系 Collection<object> list = new ArrayList<string>();这种是错误的。</string></object></p></blockquote><h4 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h4><p>JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p><p><strong>泛型的上限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型的下限</strong>：</p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><p>比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    Collection&lt;Number&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">    Collection&lt;Object&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    </span><br><span class="line">    getElement(list1);</span><br><span class="line">    getElement(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement(list3);</span><br><span class="line">    getElement(list4);<span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">    getElement2(list1);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list2);<span class="comment">//报错</span></span><br><span class="line">    getElement2(list3);</span><br><span class="line">    getElement2(list4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getElement2</span><span class="params">(Collection&lt;? <span class="keyword">super</span> Number&gt; coll)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>其实这个书写完全等价与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p><strong>JDK1.5</strong>以后。出现了简化操作。<strong>…</strong> 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeArgs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">431</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(arr);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="comment">//  6  7  2 12 2121</span></span><br><span class="line">        <span class="comment">// 求 这几个元素和 6  7  2 12 2121</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = getSum(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">2121</span>);</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 完成数组  所有元素的求和 原始写法</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      public static int getSum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment">        int sum = 0;</span></span><br><span class="line"><span class="comment">        for(int a : arr)&#123;</span></span><br><span class="line"><span class="comment">            sum += a;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        return sum;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//可变参数写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>... arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tips: 上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</p><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><h2 id="JDK9对集合添加的优化"><a href="#JDK9对集合添加的优化" class="headerlink" title="JDK9对集合添加的优化"></a>JDK9对集合添加的优化</h2><p>通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用，使得代码重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"abc"</span>);</span><br><span class="line">        list.add(<span class="string">"def"</span>);</span><br><span class="line">        list.add(<span class="string">"ghi"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Set&lt;String&gt; str1=Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);  </span><br><span class="line">        <span class="comment">//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合  </span></span><br><span class="line">        System.out.println(str1);  </span><br><span class="line">        Map&lt;String,Integer&gt; str2=Map.of(<span class="string">"a"</span>,<span class="number">1</span>,<span class="string">"b"</span>,<span class="number">2</span>);  </span><br><span class="line">        System.out.println(str2);  </span><br><span class="line">        List&lt;String&gt; str3=List.of(<span class="string">"a"</span>,<span class="string">"b"</span>);  </span><br><span class="line">        System.out.println(str3);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意以下两点：</p><blockquote><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等待；</p><p>2:<strong>返回的集合是不可变的</strong>；</p></blockquote><h2 id="Debug追踪"><a href="#Debug追踪" class="headerlink" title="Debug追踪"></a>Debug追踪</h2><table><thead><tr><th>按键</th><th>效果</th></tr></thead><tbody><tr><td>F7</td><td>进入方法</td></tr><tr><td>shift+F8</td><td>跳出方法</td></tr><tr><td>F8</td><td>逐行执行</td></tr><tr><td>F9</td><td>跳到下一断点</td></tr><tr><td>Ctrl+F2</td><td>停止调试</td></tr></tbody></table><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是<strong>中断处理</strong>。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h3 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h3><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092432-251086.png" alt></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p>提示给用户的时候,就提示错误原因。</p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092440-286569.bmp" alt></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p>​    <img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092148-834172.png" alt></p><h3 id="产生过程解析"><a href="#产生过程解析" class="headerlink" title="产生过程解析"></a>产生过程解析</h3><p> 工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> num = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">"num="</span> + num);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序执行过程图解：</p><p> <img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092154-791954.png" alt></p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p><h4 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a>抛出异常throw</h4><p>在编写程序时，我们必须要考虑程序出现问题的情况。使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，<strong>并结束当前方法的执行</strong>。</p></li></ol><p><strong>使用格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br></pre></td></tr></table></figure><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> element = getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123; </span><br><span class="line">       <span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"哥们，角标越界了~~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h4><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。</p><p><strong>声明异常格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;</span><br></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        read(<span class="string">"a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">"b.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h4><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><h4 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h4><p><strong>finally</strong>：无论异常是否发生，在finally代码块中存放的代码都是一定会被执行的，常用于资源的释放</p><p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p></blockquote><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092200-369005.bmp" alt></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理</li><li>多个异常一次捕获，多次处理。(<strong>推荐)</strong></li><li>多个异常一次捕获一次处理。</li></ol><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">try</span>&#123;</span><br><span class="line">&gt;      编写可能会出现异常的代码</span><br><span class="line">&gt; &#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">&gt;      处理异常的代码</span><br><span class="line">&gt;      <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&gt; &#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">&gt;      处理异常的代码</span><br><span class="line">&gt;      <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote></li><li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p></li><li><p>如果finally有return语句,永远返回finally中的结果,<strong>避免该情况.</strong> </p></li><li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p></li><li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p></li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p><strong>为什么需要自定义异常类:</strong></p><p>在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题等等。</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义异常类.</p><p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li><li>命名：XxxException</li></ol><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><p>要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>首先定义一个登陆异常类RegisterException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">"bill"</span>,<span class="string">"hill"</span>,<span class="string">"jill"</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">"nill"</span>);</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(RegisterException e)&#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RegisterException(<span class="string">"亲"</span>+name+<span class="string">"已经被注册了！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>说到Stream便容易想到I/O Stream，而实际上，谁规定“流”就一定是“IO流”呢？</p><p>在Java 8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream概念，用于解决<strong>已有集合类库</strong>既有的弊端</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>几乎所有的集合（如 Collection 接口或 Map 接口等）都支持直接或间接的遍历操作。而当我们需要对集合中的元素进行</p><p>操作的时候，除了必需的添加、删除、获取外，最典型的就是集合遍历</p><h4 id="循环遍历的弊端"><a href="#循环遍历的弊端" class="headerlink" title="循环遍历的弊端"></a>循环遍历的弊端</h4><p>Java 8的Lambda让我们可以更加专注于做什么（What），而不是怎么做（How），这点此前已经结合内部类进行了对比</p><p>说明</p><blockquote><p>for循环的语法就是“怎么做”</p><p>for循环的循环体才是“做什么”</p></blockquote><p>为什么使用循环？因为要进行遍历。但循环是遍历的唯一方式吗？遍历是指每一个元素逐一进行处理，而并不是从第一个</p><p>到最后一个顺次处理的循环。前者是目的，后者是方式。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ol><li>将集合A根据条件一过滤为子集B；</li><li>然后再根据条件二过滤为子集C。</li></ol><h5 id="java8以前"><a href="#java8以前" class="headerlink" title="java8以前"></a>java8以前</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02NormalFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">        list.add(<span class="string">"赵敏"</span>);</span><br><span class="line">        list.add(<span class="string">"张强"</span>);</span><br><span class="line">        list.add(<span class="string">"张三丰"</span>);</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; zhangList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">                zhangList.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; shortList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : zhangList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                shortList.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (String name : shortList) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03StreamFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        list.add(<span class="string">"周芷若"</span>);</span><br><span class="line">        list.add(<span class="string">"赵敏"</span>);</span><br><span class="line">        list.add(<span class="string">"张强"</span>);</span><br><span class="line">        list.add(<span class="string">"张三丰"</span>);</span><br><span class="line"> </span><br><span class="line">        list.stream()</span><br><span class="line">            .filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>))</span><br><span class="line">            .filter(s ‐&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流式思想概述"><a href="#流式思想概述" class="headerlink" title="流式思想概述"></a>流式思想概述</h3><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200225101339-260224.png" alt></p><p>这里的 filter 、 map 、 skip 都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 count执行的时</p><p>候，整个模型才会按照指定策略执行操作。<strong>而这得益于Lambda的延迟执行特性</strong>。</p><p><strong>备注</strong>：</p><ul><li><p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地</p><p>址值）</p></li></ul><p>Stream（流）是一个来自数据源的元素队列</p><p>元素是特定类型的对象，形成一个队列。</p><p>Java中的Stream并不会存储元素，而是按需计算数据源流的来源。可以是集合，数组等和以前的Collection操作不同， </p><p>Stream操作还有两个基础的特征：</p><ul><li><p>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（ﬂuent style）。</p><p>这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p></li><li><p>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 </p><p>Stream提供了内部迭代的方式，流可以直接调用遍历方法。当使用一个流的时候通常包括三个基本步骤：</p><p><strong>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果</strong></p></li></ul><h3 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h3><p><code>java.util.stream.Stream&lt;T&gt;</code> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口）</p><p>获取一个流非常简单，有以下几种常用的方式：</p><p>所有的 Collection 集合都可以通过 stream 默认方法获取流；</p><p>Stream 接口的静态方法 of 可以获取数组对应的流。</p><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04GetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"> </span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line"> </span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据Map获取流"><a href="#根据Map获取流" class="headerlink" title="根据Map获取流"></a>根据Map获取流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的单一特征，</span></span><br><span class="line"><span class="comment">// 所以获取对应的流需要分key、value或entry等情况</span></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05GetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="根据数组获取流"><a href="#根据数组获取流" class="headerlink" title="根据数组获取流"></a>根据数组获取流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果使用的不是集合或映射而是数组，由于数组对象不可能添加默认方法，</span></span><br><span class="line"><span class="comment">// 所以 Stream 接口中提供了静态方法of</span></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06GetStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = &#123; <span class="string">"张无忌"</span>, <span class="string">"张翠山"</span>, <span class="string">"张三丰"</span>, <span class="string">"张一元"</span> &#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  of 方法的参数其实是一个可变参数，所以支持数组。</span></span><br></pre></td></tr></table></figure><h3 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h3><p>延迟方法：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用</p><p>终结方法：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持链式调用，本小节包括 count 和 forEach 方法</p><h4 id="逐一处理：forEach"><a href="#逐一处理：forEach" class="headerlink" title="逐一处理：forEach"></a>逐一处理：forEach</h4><p>虽然方法名字叫 forEach ，但是与for循环中的“for-each”不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p>该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。</p><p>基本使用： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12StreamForEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">        stream.forEach(name‐&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤：ﬁlter"><a href="#过滤：ﬁlter" class="headerlink" title="过滤：ﬁlter"></a>过滤：ﬁlter</h4><p>可以通过 filter 方法将一个流转换成另一个子集流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><p>该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件</p><p>基本使用 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07StreamFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这里通过Lambda表达式来指定了筛选的条件：必须姓张</span></span><br></pre></td></tr></table></figure><h4 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h4><p>如果需要将流中的元素映射到另一个流中，可以使用 map 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br></pre></td></tr></table></figure><p>该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><p>将一种T类型转换成为R类型，而这种转换的动作，就称为“映射”。<br>基本使用 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08StreamMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">"10"</span>, <span class="string">"12"</span>, <span class="string">"18"</span>);</span><br><span class="line">        Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中， map 方法的参数通过方法引用，将字符串类型转换成为了int类型（并自动装箱为 Integer 类对象）</p><h4 id="统计个数：count"><a href="#统计个数：count" class="headerlink" title="统计个数：count"></a>统计个数：count</h4><p>正如旧集合 Collection 当中的 size 方法一样，流提供 count 方法来数一数其中的元素个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>该方法返回一个long值代表元素个数</p><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09StreamCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>));</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="取用前几个：limit"><a href="#取用前几个：limit" class="headerlink" title="取用前几个：limit"></a>取用前几个：limit</h4><p>limit 方法可以对流进行截取，只取用前n个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure><p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作</p><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10StreamLimit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳过前几个：skip"><a href="#跳过前几个：skip" class="headerlink" title="跳过前几个：skip"></a>跳过前几个：skip</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n);</span><br></pre></td></tr></table></figure><p>如果希望跳过前几个元素，可以使用 skip 方法获取一个截取之后的新流：</p><p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流</p><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11StreamSkip</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; original = Stream.of(<span class="string">"张无忌"</span>, <span class="string">"张三丰"</span>, <span class="string">"周芷若"</span>);</span><br><span class="line">        Stream&lt;String&gt; result = original.skip(<span class="number">2</span>);</span><br><span class="line">        System.out.println(result.count()); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合：concat"><a href="#组合：concat" class="headerlink" title="组合：concat"></a>组合：concat</h4><p>如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span><br></pre></td></tr></table></figure><p>备注：这是一个静态方法，与 java.lang.String 当中的 concat 方法是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12StreamConcat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; streamA = Stream.of(<span class="string">"张无忌"</span>);</span><br><span class="line">        Stream&lt;String&gt; streamB = Stream.of(<span class="string">"张翠山"</span>);</span><br><span class="line">        Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习：集合元素处理"><a href="#练习：集合元素处理" class="headerlink" title="练习：集合元素处理"></a>练习：集合元素处理</h3><p>现在有两个 ArrayList 集合存储队伍当中的多个成员姓名，要求使用传统的for循环（或增强for循环）依次进行以<br>下若干操作步骤：</p><ol><li>第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。</li><li>第一个队伍筛选之后只要前3个人；存储到一个新集合中。</li><li>第二个队伍只要姓张的成员姓名；存储到一个新集合中。</li><li>第二个队伍筛选之后不要前2个人；存储到一个新集合中。</li><li>将两个队伍合并为一个队伍；存储到一个新集合中。</li><li>根据姓名创建 Person 对象；存储到一个新集合中。</li><li>打印整个队伍的Person对象信息。</li></ol><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArrayListNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//第一支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        one.add(<span class="string">"迪丽热巴"</span>);</span><br><span class="line">        one.add(<span class="string">"宋远桥"</span>);</span><br><span class="line">        one.add(<span class="string">"苏星河"</span>);</span><br><span class="line">        one.add(<span class="string">"石破天"</span>);</span><br><span class="line">        one.add(<span class="string">"石中玉"</span>);</span><br><span class="line">        one.add(<span class="string">"老子"</span>);</span><br><span class="line">        one.add(<span class="string">"庄子"</span>);</span><br><span class="line">        one.add(<span class="string">"洪七公"</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//第二支队伍</span></span><br><span class="line">        ArrayList&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        two.add(<span class="string">"古力娜扎"</span>);</span><br><span class="line">        two.add(<span class="string">"张无忌"</span>);</span><br><span class="line">        two.add(<span class="string">"赵丽颖"</span>);</span><br><span class="line">        two.add(<span class="string">"张三丰"</span>);</span><br><span class="line">        two.add(<span class="string">"尼古拉斯赵四"</span>);</span><br><span class="line">        two.add(<span class="string">"张天爱"</span>);</span><br><span class="line">        two.add(<span class="string">"张二狗"</span>);</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;name='"</span> + name + <span class="string">"'&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用传统的for循环"><a href="#使用传统的for循环" class="headerlink" title="使用传统的for循环"></a>使用传统的for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoArrayListNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">        List&lt;String&gt; oneA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : one) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">3</span>) &#123;</span><br><span class="line">                oneA.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">        List&lt;String&gt; oneB = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            oneB.add(oneA.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">        List&lt;String&gt; twoA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name.startsWith(<span class="string">"张"</span>)) &#123;</span><br><span class="line">                twoA.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">        List&lt;String&gt; twoB = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; twoA.size(); i++) &#123;</span><br><span class="line">            twoB.add(twoA.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">        List&lt;String&gt; totalNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        totalNames.addAll(oneB);</span><br><span class="line">        totalNames.addAll(twoB);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">        List&lt;Person&gt; totalPersonList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String name : totalNames) &#123;</span><br><span class="line">            totalPersonList.add(<span class="keyword">new</span> Person(name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        <span class="keyword">for</span> (Person person : totalPersonList) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Stream方式"><a href="#使用Stream方式" class="headerlink" title="使用Stream方式"></a>使用Stream方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoStreamNames</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; two = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 第一个队伍只要名字为3个字的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 第二个队伍只要姓张的成员姓名；</span></span><br><span class="line">        <span class="comment">// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">        Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>)).skip(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将两个队伍合并为一个队伍；</span></span><br><span class="line">        <span class="comment">// 根据姓名创建Person对象；</span></span><br><span class="line">        <span class="comment">// 打印整个队伍的Person对象信息。</span></span><br><span class="line">        Stream.concat(streamOne, streamTwo).map(Person::<span class="keyword">new</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑</p><p>一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p><p>冗余的Lambda场景 </p><p>来看一个简单的函数式接口以应用Lambda表达式：</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092208-821105.bmp" alt></p><p>并发指的是在一段时间内宏观上有多个程序同时运行</p><p>这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行</p><blockquote><p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为<strong>线程调度</strong>。</p></blockquote><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p><p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p></li></ul><p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p><p><strong>进程</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092245-29038.png" alt></p><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，<strong>Java使用</strong>的为抢占式调度。</p><ul><li>设置线程的优先级</li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092254-158881.bmp" alt="设置线程优先级"></p><ul><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够<strong>提高程序运行效率，让CPU的使用率更高。</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092314-698813.bmp" alt="抢占式调度"></p></li></ul></li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h3><p>构造方法：</p><p><code>public Thread()</code> :分配一个新的线程对象。<br><code>public Thread(String name)</code> :分配一个指定名字的新的线程对象。<br><code>public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。<br><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。</p><p>常用方法：</p><p><code>public String getName()</code> :获取当前线程名称。<br><code>public void start()</code> :导致此线程开始执行; Java虚拟机调用此线程的run方法。<br><code>public void run()</code> :此线程要执行的任务在此处定义代码。<br><code>public static void sleep(long millis)</code>:使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。<br><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li><p>定义Thread类的子类，并重写该类的run()方法</p><p>该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</p></li><li><p>创建Thread子类的实例，即创建了线程对象</p></li><li><p>调用线程对象的start()方法来启动该线程</p></li></ol><p>代码如下：</p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建自定义线程对象</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"新的线程！"</span>);</span><br><span class="line"><span class="comment">//开启新线程</span></span><br><span class="line">mt.start();</span><br><span class="line"><span class="comment">//在主方法中执行for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"旺财"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"小强"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223102015-961264.png" alt="image-20200223102014703"></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223102122-138221.png" alt="image-20200223102121409"></p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><ol><li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li><li>调用线程对象的start()方法来启动线程。<br>代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建自定义类对象  线程任务对象</span></span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr, <span class="string">"小强"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"旺财 "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口，使得该类有了多线程类的特征。</p><p>run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。</p><p>Thread类实际上也是实现了Runnable接口的类。<br>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现<br>Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><p><strong>实现Runnable接口的优势</strong></p><ol><li>适合多个相同的程序代码的线程去共享同一个资源。</li><li>可以避免java中的单继承的局限性。</li><li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li><li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li></ol><h4 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h4><p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用<br>java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>匿名内部类方式实现线程的创建<br>使用线程的内匿名内部类方式，可以方便的实现每个线程执行不同的线程任务操作。</p><pre><code>public class NoNameInnerClassThread {    public static void main(String[] args) {                Runnable r = new Runnable(){            public void run(){                for (int i = 0; i &lt; 20; i++) {                    System.out.println(&quot;张宇:&quot;+i);                }            }        };    new Thread(r).start();    }}</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p>线程安全问题都是由全局变量及静态变量引起的。</p><ul><li><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；</p></li><li><p>若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223134605-158865.png" alt="image-20200223134454077"></p><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><p>Java中提供了同步机制(synchronized)来解决线程安全问题</p><p>生成一个唯一的锁对象，抢到锁对象的线程可以执行同步方法，其余线程被阻塞，直到锁对象被释放</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223134726-964888.png" alt="image-20200223134725166"></p><h5 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h5><p>可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作 </span></span><br><span class="line">        <span class="comment">//窗口 永远开启 </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                    <span class="comment">//出票操作</span></span><br><span class="line">                    <span class="comment">//使用sleep模拟一下出票时间 </span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//获取当前线程对象的名字 </span></span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> 对于非static方法,同步锁就是this。 </li><li>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作 </span></span><br><span class="line">        <span class="comment">//窗口 永远开启 </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 锁对象 是 谁调用这个方法 就是谁 </span></span><br><span class="line"><span class="comment">     *   隐含 锁对象 就是  this</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖   </span></span><br><span class="line">            <span class="comment">//出票操作</span></span><br><span class="line">            <span class="comment">//使用sleep模拟一下出票时间 </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取当前线程对象的名字 </span></span><br><span class="line">            String name = Thread.currentThread().getName();</span><br><span class="line">            System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h5><p>提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> :加同步锁。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> :释放同步锁。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 执行卖票操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个窗口卖票的操作 </span></span><br><span class="line">        <span class="comment">//窗口 永远开启 </span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line">                <span class="comment">//出票操作 </span></span><br><span class="line">                <span class="comment">//使用sleep模拟一下出票时间 </span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取当前线程对象的名字 </span></span><br><span class="line">                String name = Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h3 id="常见状态"><a href="#常见状态" class="headerlink" title="常见状态"></a>常见状态</h3><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223112807-10084.png" alt="image-20200223112806050"></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223135201-628017.png" alt="image-20200223135200714"></p><h4 id="Timed-Waiting（计时等待）"><a href="#Timed-Waiting（计时等待）" class="headerlink" title="Timed Waiting（计时等待）"></a>Timed Waiting（计时等待）</h4><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。</p><p>在写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。</p><p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待)</p><p>实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i) % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"‐‐‐‐‐‐‐"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.print(<span class="string">"线程睡眠1秒！\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips：</strong></p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协<br>作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程<br>中会睡眠</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。<br>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就<br>开始立刻执行。</li></ol><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223140342-704108.png" alt="image-20200223140341287"></p><h4 id="BLOCKED（锁阻塞）"><a href="#BLOCKED（锁阻塞）" class="headerlink" title="BLOCKED（锁阻塞）"></a>BLOCKED（锁阻塞）</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223140811-489439.png" alt></p><h4 id="Waiting（无限等待）"><a href="#Waiting（无限等待）" class="headerlink" title="Waiting（无限等待）"></a>Waiting（无限等待）</h4><p>等待唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitingTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 演示waiting</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println( Thread.currentThread().getName() +<span class="string">"=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象"</span>);</span><br><span class="line">                            obj.wait();  <span class="comment">//无限等待</span></span><br><span class="line">                            <span class="comment">//obj.wait(5000); //计时等待, 5秒 时间到，自动醒来</span></span><br><span class="line"> </span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName + <span class="string">"=== 从waiting状态醒来，获取到锁对象，继续执行了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"等待线程"</span>).start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//                while (true)&#123;   //每隔3秒 唤醒一次</span></span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                        System.out.println( Thread.currentThread().getName<span class="string">"‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象"</span>);</span><br><span class="line">                        obj.notify();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;,<span class="string">"唤醒线程"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用<strong>此对象</strong>的Object.notify()方法 或 </p><p>Object.notifyAll()方法。</p><p>其实waiting状态并不是一个线程的操作，它体现的是<strong>多个线程间的通信</strong>，可以理解为多个线程之间的协作关系，</p><p><strong>多个线程会争取锁，同时相互之间又存在协作关系</strong></p><p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等</p><p>待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤</p><p>醒。如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到</p><p>Blocked（锁阻塞状态）。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223142500-184550.png" alt="image-20200223142459327"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223142621-546872.png" alt="image-20200223142620323"></p><h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同</p><p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092728-871297.bmp" alt></p><p><strong>如何保证线程间通信有效利用资源：</strong></p><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 即我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><h4 id="等待唤醒机制-1"><a href="#等待唤醒机制-1" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（<strong>wait()</strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（<strong>notify()</strong>）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 <strong>wait 方法之后的地方恢复执行</strong>。</p><p><strong>总结：</strong></p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由<strong>同一个锁对象调用</strong>。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h4 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h4><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p><p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">包子铺线程生产包子，吃货线程消费包子。</span></span><br><span class="line"><span class="comment">当包子没有时（包子状态为false），吃货线程等待，</span></span><br><span class="line"><span class="comment">包子铺线程生产包子（即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。</span></span><br><span class="line"><span class="comment">接下来，吃货线程能否进一步执行则取决于锁的获取情况。</span></span><br><span class="line"><span class="comment">如果吃货获取到锁，那么就执行吃包子动作，</span></span><br><span class="line"><span class="comment">包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。</span></span><br><span class="line"><span class="comment">包子铺线程能否进一步执行则取决于锁的获取情况。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>代码演示：</strong></p><p>包子资源类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZi</span> </span>&#123;</span><br><span class="line">     String  pier ;</span><br><span class="line">     String  xianer ;</span><br><span class="line">     <span class="keyword">boolean</span>  flag = <span class="keyword">false</span> ;<span class="comment">//包子资源 是否存在  包子资源状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吃货线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChiHuo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChiHuo</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>)&#123;<span class="comment">//没包子</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"吃货正在吃"</span>+bz.pier+bz.xianer+<span class="string">"包子"</span>);</span><br><span class="line">                bz.flag = <span class="keyword">false</span>;</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包子铺线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaoZiPu</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaoZi bz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaoZiPu</span><span class="params">(String name,BaoZi bz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//造包子</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (bz)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bz.flag == <span class="keyword">true</span>)&#123;<span class="comment">//包子资源  存在</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        bz.wait();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有包子  造包子</span></span><br><span class="line">                System.out.println(<span class="string">"包子铺开始做包子"</span>);</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 冰皮  五仁</span></span><br><span class="line">                    bz.pier = <span class="string">"冰皮"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"五仁"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 薄皮  牛肉大葱</span></span><br><span class="line">                    bz.pier = <span class="string">"薄皮"</span>;</span><br><span class="line">                    bz.xianer = <span class="string">"牛肉大葱"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                bz.flag=<span class="keyword">true</span>;</span><br><span class="line">                System.out.println(<span class="string">"包子造好了："</span>+bz.pier+bz.xianer);</span><br><span class="line">                System.out.println(<span class="string">"吃货来吃吧"</span>);</span><br><span class="line">                <span class="comment">//唤醒等待线程 （吃货）</span></span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//等待唤醒案例</span></span><br><span class="line">        BaoZi bz = <span class="keyword">new</span> BaoZi();</span><br><span class="line"></span><br><span class="line">        ChiHuo ch = <span class="keyword">new</span> ChiHuo(<span class="string">"吃货"</span>,bz);</span><br><span class="line">        BaoZiPu bzp = <span class="keyword">new</span> BaoZiPu(<span class="string">"包子铺"</span>,bz);</span><br><span class="line"></span><br><span class="line">        ch.start();</span><br><span class="line">        bzp.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">包子铺开始做包子</span></span><br><span class="line"><span class="comment">包子造好了：冰皮五仁</span></span><br><span class="line"><span class="comment">吃货来吃吧</span></span><br><span class="line"><span class="comment">吃货正在吃冰皮五仁包子</span></span><br><span class="line"><span class="comment">包子铺开始做包子</span></span><br><span class="line"><span class="comment">包子造好了：薄皮牛肉大葱</span></span><br><span class="line"><span class="comment">吃货来吃吧</span></span><br><span class="line"><span class="comment">吃货正在吃薄皮牛肉大葱包子</span></span><br><span class="line"><span class="comment">包子铺开始做包子</span></span><br><span class="line"><span class="comment">包子造好了：冰皮五仁</span></span><br><span class="line"><span class="comment">吃货来吃吧</span></span><br><span class="line"><span class="comment">吃货正在吃冰皮五仁包子</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池思想概述"><a href="#线程池思想概述" class="headerlink" title="线程池思想概述"></a>线程池思想概述</h3><p>在Java中可以通过线程池来使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务</p><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li></ul><p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092754-441985.bmp" alt></p><p>合理利用线程池能够带来三个好处：</p><ol><li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不做)。</li></ol><p>Runnable实现类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要一个教练"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"教练来了： "</span> + Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"教我游泳,交完后，教练回到了游泳池"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池对象</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//包含2个线程对象</span></span><br><span class="line">        <span class="comment">// 创建Runnable实例对象</span></span><br><span class="line">        MyRunnable r = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自己创建线程对象的方式</span></span><br><span class="line">        <span class="comment">// Thread t = new Thread(r);</span></span><br><span class="line">        <span class="comment">// t.start(); ---&gt; 调用MyRunnable中的run()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从线程池中获取线程对象,然后调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 再获取个线程对象，调用MyRunnable中的run()</span></span><br><span class="line">        service.submit(r);</span><br><span class="line">        service.submit(r);</span><br><span class="line">        <span class="comment">// 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。</span></span><br><span class="line">        <span class="comment">// 将使用完的线程又归还到了线程池中</span></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="comment">//service.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223092839-309487.png" alt></p><p>面向对象过分强调“必须通过对象的形式来做事情”</p><p>函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p><p>面向对象的思想:</p><p>​    做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p><p>函数式编程思想:</p><p>​    只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><h4 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h4><p><strong>传统写法</strong></p><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 匿名内部类</span></span><br><span class="line">Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">// 覆盖重写抽象方法</span></span><br><span class="line">System.out.println(<span class="string">"多线程任务执行！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Thread(task).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p><ul><li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li><li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li><li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li><li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li><li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li></ul><h4 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h4><p><strong>做什么，而不是怎么做</strong></p><p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？</p><h4 id="Lambda的更优写法"><a href="#Lambda的更优写法" class="headerlink" title="Lambda的更优写法"></a>Lambda的更优写法</h4><p>Lambda：<strong>凡可推导的，都可省略</strong></p><p>借助Java 8的全新语法，上述<code>Runnable</code>接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02LambdaRunnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"多线程任务执行！"</span>)).start(); <span class="comment">// 启动线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担</p><h3 id="回顾匿名内部类"><a href="#回顾匿名内部类" class="headerlink" title="回顾匿名内部类"></a>回顾匿名内部类</h3><h4 id="匿名内部类的好处与弊端"><a href="#匿名内部类的好处与弊端" class="headerlink" title="匿名内部类的好处与弊端"></a>匿名内部类的好处与弊端</h4><p>一方面，匿名内部类可以帮我们<strong>省去实现类的定义</strong>；另一方面，匿名内部类的语法——<strong>确实太复杂了！</strong></p><h4 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h4><p>仔细分析该代码中的语义，<code>Runnable</code>接口只有一个<code>run</code>方法的定义：</p><ul><li><code>public abstract void run();</code></li></ul><p>即制定了一种做事情的方案（其实就是一个函数）：</p><ul><li><strong>无参数</strong>：不需要任何条件即可执行该方案。</li><li><strong>无返回值</strong>：该方案不产生任何结果。</li><li><strong>代码块</strong>（方法体）：该方案的具体执行步骤。</li></ul><h3 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h3><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p><ul><li>一些参数</li><li>一个箭头</li><li>一段代码</li></ul><p>Lambda表达式的<strong>标准格式</strong>为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure><p>格式说明：</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><h3 id="有参数和返回值"><a href="#有参数和返回值" class="headerlink" title="有参数和返回值"></a>有参数和返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">需求:</span><br><span class="line">    使用数组存储多个Person对象</span><br><span class="line">    对数组中的Person对象使用Arrays的sort方法通过年龄进行升序排序</span><br></pre></td></tr></table></figure><p>下面举例演示<code>java.util.Comparator&lt;T&gt;</code>接口的使用场景代码，其中的抽象方法定义为：</p><ul><li><code>public abstract int compare(T o1, T o2);</code></li></ul><p>当需要对一个对象数组进行排序时，<code>Arrays.sort</code>方法需要一个<code>Comparator</code>接口实例来指定排序的规则。假设有一个<code>Person</code>类，含有<code>String name</code>和<code>int age</code>两个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造器、toString方法与Getter Setter </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda写法"><a href="#Lambda写法" class="headerlink" title="Lambda写法"></a>Lambda写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07ComparatorLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] array = &#123;</span><br><span class="line">          <span class="keyword">new</span> Person(<span class="string">"古力娜扎"</span>, <span class="number">19</span>),</span><br><span class="line">          <span class="keyword">new</span> Person(<span class="string">"迪丽热巴"</span>, <span class="number">18</span>),</span><br><span class="line">          <span class="keyword">new</span> Person(<span class="string">"马尔扎哈"</span>, <span class="number">20</span>) &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, (Person a, Person b) -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> a.getAge() - b.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person person : array) &#123;</span><br><span class="line">            System.out.println(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="省略格式"><a href="#省略格式" class="headerlink" title="省略格式"></a>省略格式</h3><h4 id="可推导即可省略"><a href="#可推导即可省略" class="headerlink" title="可推导即可省略"></a>可推导即可省略</h4><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。例如上例还可以使用Lambda的省略写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  invokeCalc(<span class="number">120</span>, <span class="number">130</span>, (a, b) -&gt; a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h4><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><blockquote><p>备注：掌握这些省略规则后，请对应地回顾本章开头的多线程案例。</p></blockquote><h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。</p><p>而Lambda表达式是延迟执行的，真正需要时才会执行，可提升性能</p><h3 id="作为参数和返回值"><a href="#作为参数和返回值" class="headerlink" title="作为参数和返回值"></a>作为参数和返回值</h3><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。</p><p>如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式接口作为方法参数。<br>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就<br>可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        startThread(() ‐&gt; System.out.println(<span class="string">"线程任务执行！"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为返回值类似做参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06Comparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">newComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a, b) ‐&gt; b.length() ‐ a.length();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = &#123; <span class="string">"abc"</span>, <span class="string">"ab"</span>, <span class="string">"abcd"</span> &#125;;</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        Arrays.sort(array, newComparator());</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>函数式接口在Java中是指：有且仅有一个抽象方法的接口。</p><p>函数式接口，即适用于函数式编程场景的接口。</p><p>而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅</p><p>有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><p><strong>备注</strong>：</p><blockquote><p>“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实</p><p>底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部</p><p>类的“语法糖”，但是二者在原理上是不同的。</p></blockquote><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>只要确保接口中有且仅有一个抽象方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    [<span class="keyword">public</span> <span class="keyword">abstract</span>] 返回值类型 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h3><p>用于检验该类是否满足函数式接口要求</p><h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><h4 id="Supplier接口"><a href="#Supplier接口" class="headerlink" title="Supplier接口"></a>Supplier接口</h4><p>java.util.function.Supplier<t> 接口仅包含一个无参的方法： <code>T get()</code> 。用来获取一个泛型参数指定类型的对<br>象数据。由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象<br>数据。</t></p><p>Supplier 接口是一个<strong>供给型</strong>的接口，其实，说白了就是一个<strong>容器</strong>，可以用来存储数据，然后可以供其他方法使用的这么一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Supplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//① 使用Supplier接口实现方法,只有一个get方法，无参数，返回一个值</span></span><br><span class="line">    Supplier&lt;Integer&gt; supplier = <span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//返回一个随机值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"********************"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//② 使用lambda表达式，</span></span><br><span class="line">    supplier = () -&gt; <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">    System.out.println(supplier.get());</span><br><span class="line">    System.out.println(<span class="string">"********************"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//③ 使用方法引用</span></span><br><span class="line">    Supplier&lt;Double&gt; supplier2 = Math::random;</span><br><span class="line">    System.out.println(supplier2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h4><p>java.util.function.Consumer<t> 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据，<br>其数据类型由泛型决定</t></p><p>从字面意思上我们就可以看得出啦，<code>consumer接口</code>就是一个消费型的接口，通过传入参数，然后输出值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//① 使用consumer接口实现方法</span></span><br><span class="line">    Consumer&lt;String&gt; consumer = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ddd"</span>, <span class="string">"ccc"</span>, <span class="string">"fff"</span>);</span><br><span class="line">    stream.forEach(consumer);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"********************"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//② 使用lambda表达式，forEach方法需要的就是一个Consumer接口</span></span><br><span class="line">    stream = Stream.of(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ddd"</span>, <span class="string">"ccc"</span>, <span class="string">"fff"</span>);</span><br><span class="line">    Consumer&lt;String&gt; consumer1 = (s) -&gt; System.out.println(s);<span class="comment">//lambda表达式返回的就是一个Consumer接口</span></span><br><span class="line">    stream.forEach(consumer1);</span><br><span class="line">    <span class="comment">//更直接的方式</span></span><br><span class="line">    <span class="comment">//stream.forEach((s) -&gt; System.out.println(s));</span></span><br><span class="line">    System.out.println(<span class="string">"********************"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//③ 使用方法引用，方法引用也是一个consumer</span></span><br><span class="line">    stream = Stream.of(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ddd"</span>, <span class="string">"ccc"</span>, <span class="string">"fff"</span>);</span><br><span class="line">    Consumer consumer2 = System.out::println;</span><br><span class="line">    stream.forEach(consumer);</span><br><span class="line">    <span class="comment">//更直接的方式</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="andThen"><a href="#andThen" class="headerlink" title="andThen"></a>andThen</h5><p>是默认方法，一次消耗多个数据时使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 举例</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10ConsumerAndThen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumeString</span><span class="params">(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two)</span> </span>&#123;</span><br><span class="line">        one.andThen(two).accept(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        consumeString(</span><br><span class="line">            s ‐&gt; System.out.println(s.toUpperCase()),</span><br><span class="line">            s ‐&gt; System.out.println(s.toLowerCase()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Predicate-接口"><a href="#Predicate-接口" class="headerlink" title="Predicate 接口"></a>Predicate 接口</h4><p>Predicate 接口是一个谓词型接口，其实，这个就是一个类似于 bool 类型的判断的接口</p><p>对某种类型的数据进行判断，从而得到一个boolean值结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void test_Predicate() &#123;</span><br><span class="line">    //① 使用Predicate接口实现方法,只有一个test方法，传入一个参数，返回一个bool值</span><br><span class="line">    Predicate&lt;Integer&gt; predicate = new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean test(Integer integer) &#123;</span><br><span class="line">            if(integer &gt; 5)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(predicate.test(6));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;********************&quot;);</span><br><span class="line"></span><br><span class="line">    //② 使用lambda表达式，</span><br><span class="line">    predicate = (t) -&gt; t &gt; 5;</span><br><span class="line">    System.out.println(predicate.test(1));</span><br><span class="line">    System.out.println(&quot;********************&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="and"><a href="#and" class="headerlink" title="and"></a>and</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 练习</span></span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16PredicateAnd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Predicate&lt;String&gt; one, Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isValid = one.and(two).test(<span class="string">"Helloworld"</span>);</span><br><span class="line">        System.out.println(<span class="string">"字符串符合要求吗："</span> + isValid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(s ‐&gt; s.contains(<span class="string">"H"</span>), s ‐&gt; s.contains(<span class="string">"W"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="or"><a href="#or" class="headerlink" title="or"></a>or</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t) ‐&gt; !test(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤出数组中性别为女且名字长度为4的人</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPredicate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = &#123; <span class="string">"迪丽热巴,女"</span>, <span class="string">"古力娜扎,女"</span>, <span class="string">"马尔扎哈,男"</span>, <span class="string">"赵丽颖,女"</span> &#125;;</span><br><span class="line">        List&lt;String&gt; list = filter(array,</span><br><span class="line">                                   s ‐&gt; <span class="string">"女"</span>.equals(s.split(<span class="string">","</span>)[<span class="number">1</span>]),</span><br><span class="line">                                   s ‐&gt; s.split(<span class="string">","</span>)[<span class="number">0</span>].length() == <span class="number">4</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(String[] array, Predicate&lt;String&gt; one, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       Predicate&lt;String&gt; two)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String info : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (one.and(two).test(info)) &#123;</span><br><span class="line">                list.add(info);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h4><p>接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li><code>public File(String pathname)</code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child)</code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li></ul><p>tips：</p><blockquote><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h3 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ul><li><p><code>public String getAbsolutePath()</code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileGet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:/aaa/bbb.java"</span>);     </span><br><span class="line">        System.out.println(<span class="string">"文件绝对路径:"</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"文件构造路径:"</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">"文件名称:"</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">"文件长度:"</span>+f.length()+<span class="string">"字节"</span>);</span><br><span class="line"></span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:/aaa"</span>);     </span><br><span class="line">        System.out.println(<span class="string">"目录绝对路径:"</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">"目录构造路径:"</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">"目录名称:"</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">"目录长度:"</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileIs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:\\aaa\\bbb.java"</span>);</span><br><span class="line">        File f2 = <span class="keyword">new</span> File(<span class="string">"d:\\aaa"</span>);</span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa\\bbb.java 是否存在:"</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 是否存在:"</span>+f2.exists());</span><br><span class="line">      <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 文件?:"</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">"d:\\aaa 目录?:"</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="keyword">true</span></span><br><span class="line">d:\aaa 文件?:<span class="keyword">false</span></span><br><span class="line">d:\aaa 目录?:<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h4 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h4><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCreateDelete</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"aaa.txt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 目录的创建</span></span><br><span class="line">      File f2= <span class="keyword">new</span> File(<span class="string">"newDir"</span>);</span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">"是否创建:"</span>+f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">"是否存在:"</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">      File f3= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> File(<span class="string">"newDira\\newDirb"</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 文件的删除</span></span><br><span class="line">       System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h3 id="目录的遍历"><a href="#目录的遍历" class="headerlink" title="目录的遍历"></a>目录的遍历</h3><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li></ul><ul><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"d:\\java_code"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>​    调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法禁止递归</li></ul></li><li><p><strong>找到f(n)和f(n-1)的关系</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01DiGui</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// a();</span></span><br><span class="line">b(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3.构造方法,禁止递归</span></span><br><span class="line"><span class="comment"> * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo01DiGui</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Demo01DiGui();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</span></span><br><span class="line"><span class="comment"> * 4993</span></span><br><span class="line"><span class="comment"> * Exception in thread "main" java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line"><span class="comment">//添加一个递归结束的条件,i==5000的时候结束</span></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5000</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//结束方法</span></span><br><span class="line">&#125;</span><br><span class="line">b(++i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread "main"</span></span><br><span class="line"><span class="comment"> * java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"a方法"</span>);</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归求阶乘"><a href="#递归求阶乘" class="headerlink" title="递归求阶乘"></a>递归求阶乘</h3><ul><li><strong>阶乘</strong>：所有小于及等于该数的正整数的积。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n的阶乘：n! = n * (n-<span class="number">1</span>) *...* <span class="number">3</span> * <span class="number">2</span> * <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推理得出：n! = n * (n-1)!</span><br></pre></td></tr></table></figure><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">//计算n的阶乘，使用递归完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">      <span class="comment">// 调用求阶乘的方法</span></span><br><span class="line">        <span class="keyword">int</span> value = getValue(n);</span><br><span class="line">      <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"阶乘为:"</span>+ value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过递归算法实现.</span></span><br><span class="line"><span class="comment">    参数列表:int </span></span><br><span class="line"><span class="comment">    返回值类型: int </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 1的阶乘为1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        n不为1时,方法返回 n! = n*(n-1)!</span></span><br><span class="line"><span class="comment">          递归调用getValue方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">return</span> n * getValue(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归打印多级目录"><a href="#递归打印多级目录" class="headerlink" title="递归打印多级目录"></a>递归打印多级目录</h3><p><strong>分析</strong>：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建File对象</span></span><br><span class="line">        File dir  = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">      <span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">printDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      <span class="comment">// 循环打印</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        判断:</span></span><br><span class="line"><span class="comment">        当是文件时,打印绝对路径.</span></span><br><span class="line"><span class="comment">        当是目录时,继续调用打印目录的方法,形成递归调用.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    <span class="comment">// 判断</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              <span class="comment">// 是文件,输出文件绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">"文件名:"</span>+ file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 是目录,输出目录绝对路径</span></span><br><span class="line">                System.out.println(<span class="string">"目录:"</span>+file.getAbsolutePath());</span><br><span class="line">              <span class="comment">// 继续遍历,调用printDir,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>搜索<code>D:\aaa</code> 目录中的<code>.java</code> 文件。</p><p><strong>分析</strong>：</p><ol><li>目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。</li><li>遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。</li></ol><p><strong>代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建File对象</span></span><br><span class="line">        File dir  = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">      <span class="comment">// 调用打印目录方法</span></span><br><span class="line">        printDir(dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取子文件和目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">              <span class="comment">// 是文件，判断文件名并输出文件绝对路径</span></span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">".java"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是目录，继续遍历,形成递归</span></span><br><span class="line">                printDir(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件过滤器优化"><a href="#文件过滤器优化" class="headerlink" title="文件过滤器优化"></a>文件过滤器优化</h3><p><code>java.io.FileFilter</code>是一个接口，是File的过滤器。 该接口的对象可以传递给File类的<code>listFiles(FileFilter)</code> 作为参数， 接口中只有一个方法。</p><p><code>boolean accept(File pathname)</code> ：测试pathname是否应该包含在当前File目录中，符合则返回true。</p><p><strong>分析</strong>：</p><ol><li>接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。</li><li><code>accept</code>方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：<ol><li>要么是.java文件。</li><li>要么是目录，用于继续遍历。</li></ol></li><li>通过过滤器的作用，<code>listFiles(FileFilter)</code>返回的数组元素中，子文件对象都是符合条件的，可以直接打印。</li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File dir = <span class="keyword">new</span> File(<span class="string">"D:\\aaa"</span>);</span><br><span class="line">        printDir2(dir);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir2</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 匿名内部类方式,创建过滤器子类对象</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().endsWith(<span class="string">".java"</span>)||pathname.isDirectory();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 循环打印</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                printDir2(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda优化"><a href="#Lambda优化" class="headerlink" title="Lambda优化"></a>Lambda优化</h3><p><strong>分析：</strong><code>FileFilter</code>是只有一个方法的接口，因此可以用lambda表达式简写。</p><p>lambda格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDir3</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// lambda的改写</span></span><br><span class="line">    File[] files = dir.listFiles(f -&gt;&#123; </span><br><span class="line">      <span class="keyword">return</span> f.getName().endsWith(<span class="string">".java"</span>) || f.isDirectory(); </span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 循环打印</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"文件名:"</span> + file.getAbsolutePath());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printDir3(file);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO概述"><a href="#IO概述" class="headerlink" title="IO概述"></a>IO概述</h2><h3 id="什么是IO"><a href="#什么是IO" class="headerlink" title="什么是IO"></a>什么是IO</h3><p>把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为<code>输入input</code> 和<code>输出output</code> ，即流向内存是输入流，流出内存的输出流。</p><p>Java中I/O操作主要是指使用<code>java.io</code>包下的内容，进行输入、输出操作。<strong>输入</strong>也叫做<strong>读取</strong>数据，<strong>输出</strong>也叫做作<strong>写出</strong>数据。</p><h3 id="IO的分类"><a href="#IO的分类" class="headerlink" title="IO的分类"></a>IO的分类</h3><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。</p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。</li><li><strong>字符流</strong> ：以字符为单位，读写数据的流。</li></ul><h3 id="IO的流向说明图解"><a href="#IO的流向说明图解" class="headerlink" title="IO的流向说明图解"></a>IO的流向说明图解</h3><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223093024-815496.jpeg" alt></p><h3 id="顶级父类们"><a href="#顶级父类们" class="headerlink" title="顶级父类们"></a>顶级父类们</h3><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流<br><strong>InputStream</strong></td><td align="center">字节输出流<br><strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流<br><strong>Reader</strong></td><td align="center">字符输出流<br><strong>Writer</strong></td></tr></tbody></table><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="一切皆为字节"><a href="#一切皆为字节" class="headerlink" title="一切皆为字节"></a>一切皆为字节</h3><p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。</p><h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><p><code>java.io.OutputStream</code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="FileOutputStream类"><a href="#FileOutputStream类" class="headerlink" title="FileOutputStream类"></a>FileOutputStream类</h3><p><code>OutputStream</code>有很多子类，我们从最简单的一个子类开始。</p><p><code>java.io.FileOutputStream</code>类是文件输出流，用于将数据写出到文件。</p><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileOutputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写出字节数据"><a href="#写出字节数据" class="headerlink" title="写出字节数据"></a>写出字节数据</h4><ol><li><strong>写出字节</strong>：<code>write(int b)</code> 方法，每次可以写出一个字节数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">      fos.write(<span class="number">97</span>); <span class="comment">// 写出第1个字节</span></span><br><span class="line">      fos.write(<span class="number">98</span>); <span class="comment">// 写出第2个字节</span></span><br><span class="line">      fos.write(<span class="number">99</span>); <span class="comment">// 写出第3个字节</span></span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>写出字节数组</strong>：<code>write(byte[] b)</code>，每次可以写出数组中的数据，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">"黑马程序员"</span>.getBytes();</span><br><span class="line">      <span class="comment">// 写出字节数组数据</span></span><br><span class="line">      fos.write(b);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马程序员</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>写出指定长度字节数组</strong>：<code>write(byte[] b, int off, int len)</code> ,每次写出从off索引开始，len个字节，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">cd</span><br></pre></td></tr></table></figure><h4 id="数据追加续写"><a href="#数据追加续写" class="headerlink" title="数据追加续写"></a>数据追加续写</h4><p>经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？</p><ul><li><code>public FileOutputStream(File file, boolean append)</code>： 创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>public FileOutputStream(String name, boolean append)</code>： 创建文件输出流以指定的名称写入文件。  </li></ul><p>这两个构造方法，参数中都需要传入一个boolean类型的值，<code>true</code> 表示追加数据，<code>false</code> 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>，<span class="keyword">true</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="string">"abcde"</span>.getBytes();</span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">文件操作前：cd</span><br><span class="line">文件操作后：cdabcde</span><br></pre></td></tr></table></figure><h4 id="写出换行"><a href="#写出换行" class="headerlink" title="写出换行"></a>写出换行</h4><p>Windows系统里，换行符号是<code>\r\n</code> 。把</p><p>以指定是否追加续写了，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FOSWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"fos.txt"</span>);  </span><br><span class="line">      <span class="comment">// 定义字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] words = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">      <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 写出一个字节</span></span><br><span class="line">            fos.write(words[i]);</span><br><span class="line">          <span class="comment">// 写出一个换行, 换行符号转成数组写出</span></span><br><span class="line">            fos.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><blockquote><ul><li>回车符<code>\r</code>和换行符<code>\n</code> ：<ul><li>回车符：回到一行的开头（return）。</li><li>换行符：下一行（newline）。</li></ul></li><li>系统中的换行：<ul><li>Windows系统里，每行结尾是 <code>回车+换行</code> ，即<code>\r\n</code>；</li><li>Unix系统里，每行结尾只有 <code>换行</code> ，即<code>\n</code>；</li><li>Mac系统里，每行结尾是 <code>回车</code> ，即<code>\r</code>。从 Mac OS X开始与Linux统一。</li></ul></li></ul></blockquote><h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</li></ul><blockquote><p>小贴士：</p><p>close方法，当完成流的操作时，必须调用此方法，释放系统资源。</p></blockquote><h3 id="FileInputStream类"><a href="#FileInputStream类" class="headerlink" title="FileInputStream类"></a>FileInputStream类</h3><p><code>java.io.FileInputStream</code>类是文件输入流，从文件中读取字节。</p><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出<code>FileNotFoundException</code> 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileInputStreamConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileInputStream fos = <span class="keyword">new</span> FileInputStream(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取字节数据"><a href="#读取字节数据" class="headerlink" title="读取字节数据"></a>读取字节数据</h4><ol><li><strong>读取字节</strong>：<code>read</code>方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，代码使用演示：</li></ol><p>循环改进读取方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然读取了一个字节，但是会自动提升为int类型。</li><li>流操作完毕后，必须释放系统资源，调用close方法，千万记得。</li></ol></blockquote><ol start="2"><li><strong>使用字节数组读取</strong>：<code>read(byte[] b)</code>，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回<code>-1</code></li></ol><p>但由于最后一次读取时，只读取一个字节<code>e</code>，数组中，上次读取的数据没有被完全替换，所以要通过<code>len</code> ，获取有效的字节，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">       FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">      <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器   </span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> (( len= fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(b，<span class="number">0</span>，len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line">e</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。</p></blockquote><h3 id="字节流练习：图片复制"><a href="#字节流练习：图片复制" class="headerlink" title="字节流练习：图片复制"></a>字节流练习：图片复制</h3><h4 id="复制原理图解"><a href="#复制原理图解" class="headerlink" title="复制原理图解"></a>复制原理图解</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200223093057-276464.jpeg" alt></p><h4 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h4><p>复制图片文件，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\test.jpg"</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test_copy.jpg"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>流的关闭原则：<strong>先开后关，后开先关。</strong></p></blockquote><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h3 id="FileReader类"><a href="#FileReader类" class="headerlink" title="FileReader类"></a>FileReader类</h3><p><code>java.io.FileReader</code>类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><blockquote><p>小贴士：</p><ol><li><p>字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。</p><p>idea中UTF-8</p></li><li><p>字节缓冲区：一个字节数组，用来临时存储字节数据。</p></li></ol></blockquote><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderConstructor</span> <span class="title">throws</span> <span class="title">IOException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读取字符数据"><a href="#读取字符数据" class="headerlink" title="读取字符数据"></a>读取字符数据</h4><ol><li><strong>读取字符</strong>：<code>read</code>方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回<code>-1</code>，循环读取，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="keyword">int</span> b ；</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑</span><br><span class="line">马</span><br><span class="line">程</span><br><span class="line">序</span><br><span class="line">员</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：虽然读取了一个字符，但是会自动提升为int类型。</p></blockquote><ol start="2"><li><strong>使用字符数组读取</strong>：<code>read(char[] cbuf)</code>，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回<code>-1</code> ，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FRRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">         <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf));</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员序</span><br></pre></td></tr></table></figure><p>获取有效的字符改进，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FISRead</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">       FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"read.txt"</span>);</span><br><span class="line">      <span class="comment">// 定义变量，保存有效字符个数</span></span><br><span class="line">        <span class="keyword">int</span> len ；</span><br><span class="line">        <span class="comment">// 定义字符数组，作为装字符数据的容器</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure><h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf)</code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str)</code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush()</code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，内部会先刷新缓冲区。 </li></ul><h3 id="3-4-FileWriter类"><a href="#3-4-FileWriter类" class="headerlink" title="3.4 FileWriter类"></a>3.4 FileWriter类</h3><p><code>java.io.FileWriter</code>类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</p><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul><p>当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。</p><ul><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterConstructor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 使用File对象创建流对象</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"a.txt"</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"b.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本写出数据"><a href="#基本写出数据" class="headerlink" title="基本写出数据"></a>基本写出数据</h4><p><strong>写出字符</strong>：<code>write(int b)</code> 方法，每次可以写出一个字符数据，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">      fw.write(<span class="number">97</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">      fw.write(<span class="string">'b'</span>); <span class="comment">// 写出第2个字符</span></span><br><span class="line">      fw.write(<span class="string">'C'</span>); <span class="comment">// 写出第3个字符</span></span><br><span class="line">      fw.write(<span class="number">30000</span>); <span class="comment">// 写出第4个字符，中文编码表中30000对应一个汉字。</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        【注意】关闭资源时,与FileOutputStream不同。</span></span><br><span class="line"><span class="comment">       如果不关闭,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// fw.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">abC田</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。</li><li>未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。</li></ol></blockquote><h4 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h4><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush</code> 方法了。</p><ul><li><code>flush</code> ：刷新缓冲区，流对象可以继续使用。</li><li><code>close</code>:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">        <span class="comment">// 写出数据，通过flush</span></span><br><span class="line">        fw.write(<span class="string">'刷'</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.flush();</span><br><span class="line">        fw.write(<span class="string">'新'</span>); <span class="comment">// 继续写出第2个字符，写出成功</span></span><br><span class="line">        fw.flush();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 写出数据，通过close</span></span><br><span class="line">        fw.write(<span class="string">'关'</span>); <span class="comment">// 写出第1个字符</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fw.write(<span class="string">'闭'</span>); <span class="comment">// 继续写出第2个字符,【报错】java.io.IOException: Stream closed</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。</p></blockquote><h4 id="写出其他数据"><a href="#写出其他数据" class="headerlink" title="写出其他数据"></a>写出其他数据</h4><ol><li><strong>写出字符数组</strong> ：<code>write(char[] cbuf)</code> 和 <code>write(char[] cbuf, int off, int len)</code> ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line">      <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">      <span class="keyword">char</span>[] chars = <span class="string">"黑马程序员"</span>.toCharArray();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 写出字符数组</span></span><br><span class="line">      fw.write(chars); <span class="comment">// 黑马程序员</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。</span></span><br><span class="line">        fw.write(b,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 程序</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>写出字符串</strong>：<code>write(String str)</code> 和 <code>write(String str, int off, int len)</code> ，每次可以写出字符串中的数据，更为方便，代码使用演示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);     </span><br><span class="line">      <span class="comment">// 字符串</span></span><br><span class="line">      String msg = <span class="string">"黑马程序员"</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 写出字符数组</span></span><br><span class="line">      fw.write(msg); <span class="comment">//黑马程序员</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">// 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。</span></span><br><span class="line">        fw.write(msg,<span class="number">2</span>,<span class="number">2</span>);<span class="comment">// 程序</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>续写和换行</strong>：操作类似于FileOutputStream。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FWWrite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象，可以续写数据</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>，<span class="keyword">true</span>);     </span><br><span class="line">      <span class="comment">// 写出字符串</span></span><br><span class="line">        fw.write(<span class="string">"黑马"</span>);</span><br><span class="line">      <span class="comment">// 写出换行</span></span><br><span class="line">      fw.write(<span class="string">"\r\n"</span>);</span><br><span class="line">      <span class="comment">// 写出字符串</span></span><br><span class="line">  fw.write(<span class="string">"程序员"</span>);</span><br><span class="line">      <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">黑马</span><br><span class="line">程序员</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</p><p>当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流</p></blockquote><h2 id="IO异常的处理"><a href="#IO异常的处理" class="headerlink" title="IO异常的处理"></a>IO异常的处理</h2><h4 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h4><p>之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用<code>try...catch...finally</code> 代码块，处理异常部分，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 声明变量</span></span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建流对象</span></span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK7的处理-扩展知识点了解内容"><a href="#JDK7的处理-扩展知识点了解内容" class="headerlink" title="JDK7的处理(扩展知识点了解内容)"></a>JDK7的处理(扩展知识点了解内容)</h4><p>还可以使用JDK7优化后的<code>try-with-resource</code> 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (创建流对象语句，如果多个,使用<span class="string">';'</span>隔开) &#123;</span><br><span class="line"><span class="comment">// 读写数据</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleException2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> ( FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>); ) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); <span class="comment">//黑马程序员</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK9的改进-扩展知识点了解内容"><a href="#JDK9的改进-扩展知识点了解内容" class="headerlink" title="JDK9的改进(扩展知识点了解内容)"></a>JDK9的改进(扩展知识点了解内容)</h4><p>JDK9中<code>try-with-resource</code> 的改进，对于<strong>引入对象</strong>的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。</p><p>改进前格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">"resource1"</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">"resource2"</span>);</span><br><span class="line"><span class="comment">// 引入方式：创建新的变量保存</span></span><br><span class="line"><span class="keyword">try</span> (Resource r1 = resource1;</span><br><span class="line">     Resource r2 = resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被final修饰的对象</span></span><br><span class="line"><span class="keyword">final</span> Resource resource1 = <span class="keyword">new</span> Resource(<span class="string">"resource1"</span>);</span><br><span class="line"><span class="comment">// 普通对象</span></span><br><span class="line">Resource resource2 = <span class="keyword">new</span> Resource(<span class="string">"resource2"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入方式：直接引入</span></span><br><span class="line"><span class="keyword">try</span> (resource1; resource2) &#123;</span><br><span class="line">     <span class="comment">// 使用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进后，代码使用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">final</span>  FileReader fr  = <span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>);</span><br><span class="line">       <span class="comment">// 引入到try中</span></span><br><span class="line">        <span class="keyword">try</span> (fr; fw) &#123;</span><br><span class="line">          <span class="comment">// 定义变量</span></span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">          <span class="comment">// 读取数据</span></span><br><span class="line">          <span class="keyword">while</span> ((b = fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 写出数据</span></span><br><span class="line">            fw.write(b);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性集"><a href="#属性集" class="headerlink" title="属性集"></a>属性集</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Properties</code> 继承于<code>Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><h4 id="构造方法-7"><a href="#构造方法-7" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public Properties()</code> :创建一个空的属性列表。</li></ul><h4 id="基本的存储方法"><a href="#基本的存储方法" class="headerlink" title="基本的存储方法"></a>基本的存储方法</h4><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key)</code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames()</code> ：所有键的名称的集合。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 添加键值对元素</span></span><br><span class="line">        properties.setProperty(<span class="string">"filename"</span>, <span class="string">"a.txt"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"length"</span>, <span class="string">"209385038"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"location"</span>, <span class="string">"D:\\a.txt"</span>);</span><br><span class="line">        <span class="comment">// 打印属性集对象</span></span><br><span class="line">        System.out.println(properties);</span><br><span class="line">        <span class="comment">// 通过键,获取属性值</span></span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">"filename"</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">"length"</span>));</span><br><span class="line">        System.out.println(properties.getProperty(<span class="string">"location"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历属性集,获取所有键的集合</span></span><br><span class="line">        Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">        <span class="comment">// 打印键值对</span></span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          System.out.println(key+<span class="string">" -- "</span>+properties.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">&#123;filename=a.txt, length=<span class="number">209385038</span>, location=D:\a.txt&#125;</span><br><span class="line">a.txt</span><br><span class="line"><span class="number">209385038</span></span><br><span class="line">D:\a.txt</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure><h4 id="与流相关的方法"><a href="#与流相关的方法" class="headerlink" title="与流相关的方法"></a>与流相关的方法</h4><p>加载代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用</span></span><br><span class="line"><span class="comment">        void load(InputStream inStream)</span></span><br><span class="line"><span class="comment">        void load(Reader reader)</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            InputStream inStream:字节输入流,不能读取含有中文的键值对</span></span><br><span class="line"><span class="comment">            Reader reader:字符输入流,能读取含有中文的键值对</span></span><br><span class="line"><span class="comment">        使用步骤:</span></span><br><span class="line"><span class="comment">            1.创建Properties集合对象</span></span><br><span class="line"><span class="comment">            2.使用Properties集合对象中的方法load读取保存键值对的文件</span></span><br><span class="line"><span class="comment">            3.遍历Properties集合</span></span><br><span class="line"><span class="comment">        注意:</span></span><br><span class="line"><span class="comment">            1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号)</span></span><br><span class="line"><span class="comment">            2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取</span></span><br><span class="line"><span class="comment">            3.存储键值对的文件中,键与值默认都是字符串,不用再加引号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建属性集对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">// 加载文本中信息到属性集</span></span><br><span class="line">        pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>));</span><br><span class="line">        <span class="comment">// 遍历集合并打印</span></span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : strings ) &#123;</span><br><span class="line">          System.out.println(key+<span class="string">" -- "</span>+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- <span class="number">209385038</span></span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</p></blockquote><p>写入代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line"><span class="comment">        void store(OutputStream out, String comments)</span></span><br><span class="line"><span class="comment">        void store(Writer writer, String comments)</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            OutputStream out:字节输出流,不能写入中文</span></span><br><span class="line"><span class="comment">            Writer writer:字符输出流,可以写中文</span></span><br><span class="line"><span class="comment">            String comments:注释,用来解释说明保存的文件是做什么用的</span></span><br><span class="line"><span class="comment">                    不能使用中文,会产生乱码,默认是Unicode编码</span></span><br><span class="line"><span class="comment">                    一般使用""空字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        使用步骤:</span></span><br><span class="line"><span class="comment">            1.创建Properties集合对象,添加数据</span></span><br><span class="line"><span class="comment">            2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地</span></span><br><span class="line"><span class="comment">            3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line"><span class="comment">            4.释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建Properties集合对象,添加数据</span></span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    prop.setProperty(<span class="string">"赵丽颖"</span>,<span class="string">"168"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"迪丽热巴"</span>,<span class="string">"165"</span>);</span><br><span class="line">    prop.setProperty(<span class="string">"古力娜扎"</span>,<span class="string">"160"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地</span></span><br><span class="line">    FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"09_IOAndProperties\\prop.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储</span></span><br><span class="line">    prop.store(fw,<span class="string">"save data"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    fw.close();</span><br><span class="line"></span><br><span class="line">    prop.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"09_IOAndProperties\\prop2.txt"</span>),<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><h4 id="构造方法-8"><a href="#构造方法-8" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"bis.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"bos.txt"</span>));</span><br></pre></td></tr></table></figure><h4 id="效率测试"><a href="#效率测试" class="headerlink" title="效率测试"></a>效率测试</h4><p>如何更快呢？使用数组的方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">      <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 创建流对象</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"jdk9.exe"</span>));</span><br><span class="line"> BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.exe"</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">          <span class="comment">// 读写数据</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>*<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"缓冲流使用数组复制时间:"</span>+(end - start)+<span class="string">" 毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">缓冲流使用数组复制时间:<span class="number">666</span> 毫秒</span><br></pre></td></tr></table></figure><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><h4 id="构造方法-9"><a href="#构造方法-9" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"br.txt"</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"bw.txt"</span>));</span><br></pre></td></tr></table></figure><h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p><ul><li>BufferedReader：<code>public String readLine()</code>: 读一行文字。 </li><li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。 </li></ul><p><code>readLine</code>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line"><span class="comment">// 定义字符串,保存读取的一行文字</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 循环读取,读取到最后返回null</span></span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(line);</span><br><span class="line">            System.out.println(<span class="string">"------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newLine</code>方法演示，代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> <span class="title">throws</span> <span class="title">IOException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">      <span class="comment">// 创建流对象</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>));</span><br><span class="line">      <span class="comment">// 写出数据</span></span><br><span class="line">        bw.write(<span class="string">"黑马"</span>);</span><br><span class="line">      <span class="comment">// 写出换行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">"程序"</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.write(<span class="string">"员"</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出效果:</span><br><span class="line">黑马</span><br><span class="line">程序</span><br><span class="line">员</span><br></pre></td></tr></table></figure><h3 id="练习-文本排序"><a href="#练习-文本排序" class="headerlink" title="练习:文本排序"></a>练习:文本排序</h3><p>请将文本信息恢复顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。</span><br><span class="line">8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。</span><br><span class="line">4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。</span><br><span class="line">2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。</span><br><span class="line">1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。</span><br><span class="line">9.今当远离，临表涕零，不知所言。</span><br><span class="line">6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。</span><br><span class="line">7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</span><br><span class="line">5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。</span><br></pre></td></tr></table></figure><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ol><li>逐行读取文本信息。</li><li>解析文本信息到集合中。</li><li>遍历集合，按顺序，写出文本信息。</li></ol><h4 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建map集合,保存文本数据,键为序号,值为文字</span></span><br><span class="line">        HashMap&lt;String, String&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"in.txt"</span>));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"out.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String line  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析文本</span></span><br><span class="line">            String[] split = line.split(<span class="string">"\\."</span>);</span><br><span class="line">            <span class="comment">// 保存到集合</span></span><br><span class="line">            lineMap.put(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历map集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lineMap.size(); i++) &#123;</span><br><span class="line">            String key = String.valueOf(i);</span><br><span class="line">            <span class="comment">// 获取map中文本</span></span><br><span class="line">            String value = lineMap.get(key);</span><br><span class="line">          <span class="comment">// 写出拼接文本</span></span><br><span class="line">            bw.write(key+<span class="string">"."</span>+value);</span><br><span class="line">          <span class="comment">// 写出换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h3><h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。</p><p>按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。</p><p>反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。</p><p>编码:字符(能看懂的)–字节(看不懂的)</p><p>解码:字节(看不懂的)–&gt;字符(能看懂的)</p><ul><li><p><strong>字符编码<code>Character Encoding</code></strong> : 就是一套自然语言的字符与二进制数之间的对应规则。</p><p>编码表:生活中文字和计算机中二进制的对应规则</p></li></ul><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><ul><li><strong>字符集 <code>Charset</code></strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li></ul><p>计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。<img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224203557-914120.jpeg" alt></p><p>可见，当指定了<strong>编码</strong>，它所对应的<strong>字符集</strong>自然就指定了，所以<strong>编码</strong>才是我们最终要关心的。</p><ul><li><strong>ASCII字符集</strong> ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</li><li>基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li></ul></li><li><strong>ISO-8859-1字符集</strong>：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。</li><li>ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li><strong>GBxxx字符集</strong>：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li><strong>GB2312</strong>：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。</li><li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li><li><strong>GB18030</strong>：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。</li></ul></li><li><strong>Unicode字符集</strong> ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。</li><li>UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：<ol><li>128个US-ASCII字符，只需一个字节编码。</li><li>拉丁文等字符，需要二个字节编码。 </li><li>大部分常用字（含中文），使用三个字节编码。</li><li>其他极少使用的Unicode辅助字符，使用四字节编码。</li></ol></li></ul></li></ul><h3 id="编码引出的问题"><a href="#编码引出的问题" class="headerlink" title="编码引出的问题"></a>编码引出的问题</h3><p>在IDEA中，使用<code>FileReader</code> 读取项目中的文本文件。由于IDEA的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"E:\\File_GBK.txt"</span>);</span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);</span><br><span class="line">        &#125;</span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">���</span><br></pre></td></tr></table></figure><p>那么如何读取GBK编码的文件呢？ </p><h3 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h3><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h4 id="构造方法-10"><a href="#构造方法-10" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>));</span><br><span class="line">InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"in.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><h4 id="指定编码读取"><a href="#指定编码读取" class="headerlink" title="指定编码读取"></a>指定编码读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">        String FileName = <span class="string">"E:\\file_gbk.txt"</span>;</span><br><span class="line">      <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName));</span><br><span class="line">      <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr2 = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(FileName) , <span class="string">"GBK"</span>);</span><br><span class="line"><span class="comment">// 定义变量,保存字符</span></span><br><span class="line">        <span class="keyword">int</span> read;</span><br><span class="line">      <span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">        <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h3><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><h4 id="构造方法-11"><a href="#构造方法-11" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><p>构造举例，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter isr = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>));</span><br><span class="line">OutputStreamWriter isr2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"out.txt"</span>) , <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure><h4 id="指定编码写出"><a href="#指定编码写出" class="headerlink" title="指定编码写出"></a>指定编码写出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 定义文件路径</span></span><br><span class="line">        String FileName = <span class="string">"E:\\out.txt"</span>;</span><br><span class="line">      <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName));</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      osw.write(<span class="string">"你好"</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">        osw.close();</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 定义文件路径</span></span><br><span class="line">String FileName2 = <span class="string">"E:\\out2.txt"</span>;</span><br><span class="line">     <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">        OutputStreamWriter osw2 = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(FileName2),<span class="string">"GBK"</span>);</span><br><span class="line">        <span class="comment">// 写出数据</span></span><br><span class="line">      osw2.write(<span class="string">"你好"</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">        osw2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换流理解图解"><a href="#转换流理解图解" class="headerlink" title="转换流理解图解"></a>转换流理解图解</h4><p><strong>转换流是字节与字符间的桥梁！</strong><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204335-94131.jpeg" alt></p><h3 id="练习：转换文件编码"><a href="#练习：转换文件编码" class="headerlink" title="练习：转换文件编码"></a>练习：转换文件编码</h3><p>将GBK编码的文本文件，转换为UTF-8编码的文本文件。</p><h4 id="案例分析-1"><a href="#案例分析-1" class="headerlink" title="案例分析"></a>案例分析</h4><ol><li>指定GBK编码的转换流，读取文本文件。</li><li>使用UTF-8编码的转换流，写出文本文件。</li></ol><h4 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </span><br><span class="line">    <span class="comment">// 1.定义文件路径</span></span><br><span class="line">     String srcFile = <span class="string">"file_gbk.txt"</span>;</span><br><span class="line">        String destFile = <span class="string">"file_utf8.txt"</span>;</span><br><span class="line"><span class="comment">// 2.创建流对象</span></span><br><span class="line">    <span class="comment">// 2.1 转换输入流,指定GBK编码</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(srcFile) , <span class="string">"GBK"</span>);</span><br><span class="line">    <span class="comment">// 2.2 转换输出流,默认utf8编码</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(destFile));</span><br><span class="line"><span class="comment">// 3.读写数据</span></span><br><span class="line">    <span class="comment">// 3.1 定义数组</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 3.2 定义长度</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 3.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环写出</span></span><br><span class="line">          osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 4.释放资源</span></span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： <img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204412-835347.jpeg" alt></p><h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p><code>java.io.ObjectOutputStream</code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><h4 id="构造方法-12"><a href="#构造方法-12" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public ObjectOutputStream(OutputStream out)</code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fileOut = <span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(fileOut);</span><br></pre></td></tr></table></figure><h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><ol><li>一个对象要想序列化，必须满足两个条件:</li></ol><ul><li>该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li><li>static修饰的成员是属于类的，不序列化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Address  check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.写出对象方法</p><ul><li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeDemo</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">    Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">    e.name = <span class="string">"zhangsan"</span>;</span><br><span class="line">    e.address = <span class="string">"beiqinglu"</span>;</span><br><span class="line">    e.age = <span class="number">20</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建序列化流对象</span></span><br><span class="line">          ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"employee.txt"</span>));</span><br><span class="line">        <span class="comment">// 写出对象</span></span><br><span class="line">        out.writeObject(e);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        out.close();</span><br><span class="line">        fileOut.close();</span><br><span class="line">        System.out.println(<span class="string">"Serialized data is saved"</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Serialized data is saved</span><br></pre></td></tr></table></figure><h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><h4 id="构造方法-13"><a href="#构造方法-13" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public ObjectInputStream(InputStream in)</code>： 创建一个指定InputStream的ObjectInputStream。</li></ul><h4 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h4><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用<code>ObjectInputStream</code>读取对象的方法：</p><ul><li><code>public final Object readObject ()</code> : 读取一个对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeserializeDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span>   </span>&#123;</span><br><span class="line">        Employee e = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 创建反序列化流</span></span><br><span class="line">             FileInputStream fileIn = <span class="keyword">new</span> FileInputStream(<span class="string">"employee.txt"</span>);</span><br><span class="line">             ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(fileIn);</span><br><span class="line">             <span class="comment">// 读取一个对象</span></span><br><span class="line">             e = (Employee) in.readObject();</span><br><span class="line">             <span class="comment">// 释放资源</span></span><br><span class="line">             in.close();</span><br><span class="line">             fileIn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">             <span class="comment">// 捕获其他异常</span></span><br><span class="line">             i.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException c)  &#123;</span><br><span class="line">        <span class="comment">// 捕获类找不到异常</span></span><br><span class="line">             System.out.println(<span class="string">"Employee class not found"</span>);</span><br><span class="line">             c.printStackTrace();</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">        System.out.println(<span class="string">"Name: "</span> + e.name);<span class="comment">// zhangsan</span></span><br><span class="line">        System.out.println(<span class="string">"Address: "</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">        System.out.println(<span class="string">"age: "</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><h4 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a><strong>反序列化操作2</strong></h4><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong>发生这个异常的原因如下：</p><ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法 </li></ul><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加入序列版本号</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;<span class="comment">// 原本是jvm来管理，这样自己手动管理</span></span><br><span class="line">     <span class="keyword">public</span> String name;</span><br><span class="line">     <span class="keyword">public</span> String address;</span><br><span class="line">     <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> eid; </span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addressCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Address  check : "</span> + name + <span class="string">" -- "</span> + address);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习：序列化集合"><a href="#练习：序列化集合" class="headerlink" title="练习：序列化集合"></a>练习：序列化集合</h3><ol><li>将存有多个自定义对象的集合序列化操作，保存到<code>list.txt</code>文件中。</li><li>反序列化<code>list.txt</code> ，并遍历集合，打印对象信息。</li></ol><h4 id="案例分析-2"><a href="#案例分析-2" class="headerlink" title="案例分析"></a>案例分析</h4><ol><li>把若干学生对象 ，保存到集合中。</li><li>把集合作为一个整体序列化。</li><li>反序列化读取时，只需要读取一次，转换为集合类型。</li><li>遍历集合，可以打印所有的学生信息</li></ol><h4 id="案例实现-3"><a href="#案例实现-3" class="headerlink" title="案例实现"></a>案例实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建 学生对象</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student(<span class="string">"老王"</span>, <span class="string">"laow"</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="string">"老张"</span>, <span class="string">"laoz"</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="string">"老李"</span>, <span class="string">"laol"</span>);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Student&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList.add(student);</span><br><span class="line">arrayList.add(student2);</span><br><span class="line">arrayList.add(student3);</span><br><span class="line"><span class="comment">// 序列化操作</span></span><br><span class="line"><span class="comment">// serializ(arrayList);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化  </span></span><br><span class="line">ObjectInputStream ois  = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"list.txt"</span>));</span><br><span class="line"><span class="comment">// 读取对象,强转为ArrayList类型</span></span><br><span class="line">ArrayList&lt;Student&gt; list  = (ArrayList&lt;Student&gt;)ois.readObject();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++ )&#123;</span><br><span class="line">          Student s = list.get(i);</span><br><span class="line">        System.out.println(s.getName()+<span class="string">"--"</span>+ s.getPwd());</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">serializ</span><span class="params">(ArrayList&lt;Student&gt; arrayList)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建 序列化流 </span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"list.txt"</span>));</span><br><span class="line"><span class="comment">// 写出对象</span></span><br><span class="line">oos.writeObject(arrayList);</span><br><span class="line"><span class="comment">// 释放资源</span></span><br><span class="line">oos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p><h3 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h3><h4 id="构造方法-14"><a href="#构造方法-14" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</li></ul><p>构造举例，代码如下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>)；</span><br></pre></td></tr></table></figure><h4 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h4><p><code>System.out</code>就是<code>PrintStream</code>类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个”小把戏”，改变它的流向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">      <span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="软件结构"><a href="#软件结构" class="headerlink" title="软件结构"></a>软件结构</h3><ul><li><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204356-130658.jpeg" alt></p><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224204346-894574.jpeg" alt></p><p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p><h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><ul><li><strong>网络通信协议：</strong>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li></ul><ul><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205653-273589.jpeg" alt></p><p>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能。<br>链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。<br>网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。<br>运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。<br>应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</p><h3 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h3><p>通信的协议还是比较复杂的，<code>java.net</code> 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接口，来专注于网络程序开发，而不用考虑通信的细节。</p><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p><ul><li><p><strong>UDP</strong>：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p><p>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。</p></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205700-592149.bmp" alt="UDP通信图解"></p><p>特点:数据被限制在64kb以内，超出这个范围就不能发送了。</p><p>数据报(Datagram):网络传输的基本单位 </p><ul><li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。(服务器确认客户有发送能力)</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。(客户确认服务器有发送和接收能力)</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。(服务器确认客户有接收能力)</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205704-832626.jpeg" alt></p><p>​    完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。</p><h3 id="网络编程三要素"><a href="#网络编程三要素" class="headerlink" title="网络编程三要素"></a>网络编程三要素</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><ul><li><strong>协议：</strong>计算机网络通信必须遵守的规则，已经介绍过了，不再赘述。</li></ul><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><ul><li><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号</li></ul><p><strong>IP地址分类</strong></p><ul><li><p>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。</p></li><li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。</p><p>为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p></li></ul><p><strong>常用命令</strong></p><ul><li>查看本机IP地址，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><ul><li>检查网络是否连通，在控制台输入：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping 空格 IP地址</span><br><span class="line">ping <span class="number">220.181</span>.57.216</span><br></pre></td></tr></table></figure><p><strong>特殊的IP地址</strong></p><ul><li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p><p>如果说<strong>IP地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。</p><ul><li><strong>端口号：用两个字节表示的整数，它的取值范围是0~65535</strong>。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。</li></ul><p>利用<code>协议</code>+<code>IP地址</code>+<code>端口号</code> 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。</p><h2 id="TCP通信程序"><a href="#TCP通信程序" class="headerlink" title="TCP通信程序"></a>TCP通信程序</h2><h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p><p><strong>两端通信时步骤：</strong></p><ol><li>服务端程序，需要事先启动，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li></ol><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><h3 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h3><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><h4 id="构造方法-15"><a href="#构造方法-15" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><p><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。</p><ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><p><code>public void close()</code> ：关闭此套接字。</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><p><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   </p><ul><li>任何先前写出的数据将被发送，随后终止输出流，不然服务器端收不到结束标志，会一直等待</li></ul><h3 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h3></li></ul><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><h4 id="构造方法-16"><a href="#构造方法-16" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><p>构造举例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><h3 id="简单的TCP网络程序"><a href="#简单的TCP网络程序" class="headerlink" title="简单的TCP网络程序"></a>简单的TCP网络程序</h3><h4 id="TCP通信分析图解"><a href="#TCP通信分析图解" class="headerlink" title="TCP通信分析图解"></a>TCP通信分析图解</h4><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205711-27191.jpeg" alt></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><p>#### </p><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTCP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        Socket server = ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        InputStream is = server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="keyword">int</span> len = is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        String msg = <span class="keyword">new</span> String(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      <span class="comment">// =================回写数据=======================</span></span><br><span class="line">      <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">       OutputStream out = server.getOutputStream();</span><br><span class="line">      <span class="comment">// 6. 回写数据</span></span><br><span class="line">       out.write(<span class="string">"我很好,谢谢你"</span>.getBytes());</span><br><span class="line">      <span class="comment">// 7.关闭资源.</span></span><br><span class="line">      out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTCP</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"客户端 发送数据"</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">OutputStream os = client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">"你好么? tcp ,我来了"</span>.getBytes());<span class="comment">// 没有主动关闭，两边应该会一直等待吧</span></span><br><span class="line">      <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      InputStream in = client.getInputStream();</span><br><span class="line">      <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">int</span> len = in.read(b);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      in.close();</span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="综合案例-1"><a href="#综合案例-1" class="headerlink" title="综合案例"></a>综合案例</h2><h3 id="文件上传案例"><a href="#文件上传案例" class="headerlink" title="文件上传案例"></a>文件上传案例</h3><h4 id="文件上传分析图解"><a href="#文件上传分析图解" class="headerlink" title="文件上传分析图解"></a>文件上传分析图解</h4><ol><li>【客户端】输入流，从硬盘读取文件数据到程序中。</li><li>【客户端】输出流，写出文件数据到服务端。</li><li>【服务端】输入流，读取文件数据到服务端程序。</li><li>【服务端】输出流，写出文件数据到服务器硬盘中。</li></ol><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205717-958331.jpeg" alt>    </p><h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h5><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">      ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">  <span class="comment">// 2. 建立连接 </span></span><br><span class="line">        Socket accept = serverSocket.accept();</span><br><span class="line">      <span class="comment">// 3. 创建流对象</span></span><br><span class="line">      <span class="comment">// 3.1 获取输入流,读取文件数据</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">        <span class="comment">// 3.2 创建输出流,保存到本地 .</span></span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>));</span><br><span class="line"><span class="comment">// 4. 读写数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 关闭 资源</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUPload_Client</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 创建输入流,读取本地文件  </span></span><br><span class="line">        BufferedInputStream bis  = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端 </span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream   bos   = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据. </span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ; </span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3.释放资源</span></span><br><span class="line"></span><br><span class="line">        bos.close(); </span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close(); </span><br><span class="line">        System.out.println(<span class="string">"文件上传完毕 "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件上传优化分析"><a href="#文件上传优化分析" class="headerlink" title="文件上传优化分析"></a>文件上传优化分析</h4><ol><li><p><strong>文件名称写死的问题</strong></p><p>服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>循环接收的问题</strong></p><p>服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次接收新的连接,创建一个Socket</span></span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><strong>效率问题</strong></p><p>服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">    Socket accept = serverSocket.accept();</span><br><span class="line">    <span class="comment">// accept 交给子线程处理.</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      ......</span><br><span class="line">        InputStream bis = accept.getInputStream();</span><br><span class="line">      ......</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优化实现"><a href="#优化实现" class="headerlink" title="优化实现"></a>优化实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">      <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          <span class="comment">/* </span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                      bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//4. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信息回写分析图解"><a href="#信息回写分析图解" class="headerlink" title="信息回写分析图解"></a>信息回写分析图解</h4><p>前四步与基本文件上传一致.</p><ol start="5"><li>【服务端】获取输出流，回写数据。</li><li>【客户端】获取输入流，解析回写数据。</li></ol><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205618-423948.jpeg" alt></p><h5 id="回写实现"><a href="#回写实现" class="headerlink" title="回写实现"></a>回写实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器 启动.....  "</span>);</span><br><span class="line">        <span class="comment">// 1. 创建服务端ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2. 循环接收,建立连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          3. socket对象交给子线程处理,进行读写操作</span></span><br><span class="line"><span class="comment">               Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> (</span><br><span class="line">                    <span class="comment">//3.1 获取输入流对象</span></span><br><span class="line">                    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    <span class="comment">//3.2 创建输出流对象, 保存到本地 .</span></span><br><span class="line">                    FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis() + <span class="string">".jpg"</span>);</span><br><span class="line">                    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fis);</span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="comment">// 3.3 读写数据</span></span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = bis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.=======信息回写===========================</span></span><br><span class="line">                    System.out.println(<span class="string">"back ........"</span>);</span><br><span class="line">                    OutputStream out = accept.getOutputStream();</span><br><span class="line">                    out.write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">                    out.close();</span><br><span class="line">                    <span class="comment">//================================</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//5. 关闭 资源</span></span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(<span class="string">"文件上传已保存"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUpload_Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 创建输入流,读取本地文件</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.jpg"</span>));</span><br><span class="line">        <span class="comment">// 1.2 创建输出流,写到服务端</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>, <span class="number">6666</span>);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据.</span></span><br><span class="line">        <span class="keyword">byte</span>[] b  = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span> ];</span><br><span class="line">        <span class="keyword">int</span> len ;</span><br><span class="line">        <span class="keyword">while</span> (( len  = bis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(b, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 关闭输出流,通知服务端,写出数据完毕</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        System.out.println(<span class="string">"文件发送完毕"</span>);</span><br><span class="line">        <span class="comment">// 3. =====解析回写============</span></span><br><span class="line">        InputStream in = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] back = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">        in.read(back);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(back));</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="comment">// ============================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟B-S服务器-扩展知识点"><a href="#模拟B-S服务器-扩展知识点" class="headerlink" title="模拟B\S服务器(扩展知识点)"></a>模拟B\S服务器(扩展知识点)</h3><p>模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。</p><h4 id="案例分析-3"><a href="#案例分析-3" class="headerlink" title="案例分析"></a>案例分析</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224213409-67743.png" alt="image-20200224213408136"></p><ol><li><p>准备页面数据，web文件夹。</p><p>复制到我们Module中，比如复制到day08中</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205607-277291.png" alt></p></li><li><p>我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line">    Socket socket = server.accept();</span><br><span class="line">    InputStream in = socket.getInputStream();</span><br><span class="line">       <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len = in.read(bytes);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">    socket.close();</span><br><span class="line">    server.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205629-919189.jpeg" alt></p></li><li><p>服务器程序中字节输入流可以读取到浏览器发来的请求信息</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205728-178275.jpeg" alt></p></li></ol><p>GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">BufferedReader readWb = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">String requst = readWb.readLine();</span><br><span class="line"><span class="comment">//取出请求资源的路径</span></span><br><span class="line">String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line"><span class="comment">//去掉web前面的/</span></span><br><span class="line">String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure><h4 id="案例实现-4"><a href="#案例实现-4" class="headerlink" title="案例实现"></a>案例实现</h4><p>服务端实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端  启动 , 等待连接 .... "</span>);</span><br><span class="line">        <span class="comment">// 创建ServerSocket 对象</span></span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 转换流读取浏览器的请求消息</span></span><br><span class="line">        BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String requst = readWb.readLine();</span><br><span class="line">        <span class="comment">// 取出请求资源的路径</span></span><br><span class="line">        String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 去掉web前面的/</span></span><br><span class="line">        String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取客户端请求的资源文件</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 字节输出流,将文件写会客户端</span></span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 写入HTTP协议响应头,固定写法</span></span><br><span class="line">        out.write(<span class="string">"HTTP/200 OK\r\n"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">        <span class="comment">// 必须要写入空行,否则浏览器不解析</span></span><br><span class="line">        out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        out.close();</span><br><span class="line">        readWb.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问效果"><a href="#访问效果" class="headerlink" title="访问效果"></a>访问效果</h4><ul><li><strong>火狐</strong></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205637-218119.png" alt></p><blockquote><p>小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。</p></blockquote><p>发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。</p><p>浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Web(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Web</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket=socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//转换流,读取浏览器请求第一行</span></span><br><span class="line">                BufferedReader readWb = <span class="keyword">new</span></span><br><span class="line">                        BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                String requst = readWb.readLine();</span><br><span class="line">                <span class="comment">//取出请求资源的路径</span></span><br><span class="line">                String[] strArr = requst.split(<span class="string">" "</span>);</span><br><span class="line">                System.out.println(Arrays.toString(strArr));</span><br><span class="line">                String path = strArr[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                System.out.println(path);</span><br><span class="line"></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">                System.out.println(fis);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span> ;</span><br><span class="line">                <span class="comment">//向浏览器 回写数据</span></span><br><span class="line">                OutputStream out = socket.getOutputStream();</span><br><span class="line">                out.write(<span class="string">"HTTP/200 OK\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"Content-Type:text/html\r\n"</span>.getBytes());</span><br><span class="line">                out.write(<span class="string">"\r\n"</span>.getBytes());</span><br><span class="line">                <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">                fis.close();</span><br><span class="line">                out.close();</span><br><span class="line">                readWb.close();</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问效果：</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200224205643-71748.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用类&quot;&gt;&lt;a href=&quot;#常用类&quot; class=&quot;headerlink&quot; title=&quot;常用类&quot;&gt;&lt;/a&gt;常用类&lt;/h1&gt;&lt;h2 id=&quot;Object类&quot;&gt;&lt;a href=&quot;#Object类&quot; class=&quot;headerlink&quot; title=&quot;Object类&quot;&gt;&lt;/a&gt;Object类&lt;/h2&gt;&lt;p&gt;&lt;code&gt;java.lang.Object&lt;/code&gt;类是Java语言中的根类，那么默认则继承自Object类。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyClass&lt;/span&gt; /*&lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Object&lt;/span&gt;*/ &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;toString方法&quot;&gt;&lt;a href=&quot;#toString方法&quot; class=&quot;headerlink&quot; title=&quot;toString方法&quot;&gt;&lt;/a&gt;toString方法&lt;/h3&gt;&lt;h4 id=&quot;方法摘要&quot;&gt;&lt;a href=&quot;#方法摘要&quot; class=&quot;headerlink&quot; title=&quot;方法摘要&quot;&gt;&lt;/a&gt;方法摘要&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public String toString()&lt;/code&gt;：返回该对象的字符串表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值的hash值。&lt;/p&gt;
&lt;p&gt;而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。&lt;/p&gt;
&lt;h4 id=&quot;覆盖重写&quot;&gt;&lt;a href=&quot;#覆盖重写&quot; class=&quot;headerlink&quot; title=&quot;覆盖重写&quot;&gt;&lt;/a&gt;覆盖重写&lt;/h4&gt;&lt;p&gt;如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Person&amp;#123;&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;name=&#39;&quot;&lt;/span&gt; + name + &lt;span class=&quot;string&quot;&gt;&#39;\&#39;&#39;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;, age=&quot;&lt;/span&gt; + age + &lt;span class=&quot;string&quot;&gt;&#39;&amp;#125;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 省略构造器与Getter Setter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="heima57" scheme="http://yoursite.com/categories/heima57/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java入门</title>
    <link href="http://yoursite.com/2020/02/13/java%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/02/13/java入门/</id>
    <published>2020-02-13T09:29:50.000Z</published>
    <updated>2020-02-18T09:25:13.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java初识"><a href="#Java初识" class="headerlink" title="Java初识"></a>Java初识</h3><h4 id="发展简史"><a href="#发展简史" class="headerlink" title="发展简史"></a>发展简史</h4><p>95由sun开发，1.5和1.8是两次较大的版本更新</p><p>09年在1.6版本时被Oracle收购</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>各种互联网程序以及服务器后台处理大数据的存储，查询和数据挖掘等</p><h4 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h4><p>win+r进入</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>盘符名:</code></td><td>切换盘符</td></tr><tr><td><code>dir</code></td><td>查看当前文件夹</td></tr><tr><td><code>cd 文件夹名</code></td><td>切换文件夹</td></tr><tr><td><code>cd \</code></td><td>切换到磁盘根目录</td></tr><tr><td><code>cls</code></td><td>清屏</td></tr></tbody></table><a id="more"></a><h4 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h4><p>跨平台性，通过jvm实现</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215123316.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215123646.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215134138.png" alt></p><h4 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h4><p>官网下载安装包</p><h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p>JAVA_HOME    java安装目录</p><p>path中添加    %JAVA_HOME%\bin;</p><h4 id="Java程序开发"><a href="#Java程序开发" class="headerlink" title="Java程序开发"></a>Java程序开发</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215131916.png" alt></p><p><code>javac  xxx.class</code>        编译</p><p><code>java xxx</code>                运行，注意别加后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个文件中仅能有一个公共类，且必须与文件名相同</p><h4 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h4><p>main称为主方法，是程序的入口</p><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>单行   //</p><p>多行   <code>/*  */</code></p><p>文档    <code>/**  */</code></p><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><table><thead><tr><th>访问控制</th><th>private</th><th>protected</th><th>public</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>类,方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td><td>new</td><td>static</td></tr><tr><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td><td>for</td><td>instanceof</td></tr><tr><td>switch</td><td>case</td><td>default</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td><td>short</td><td>null</td></tr><tr><td>true</td><td>false</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h5 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h5><ul><li>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） </li><li>标识符不能以数字开头</li><li>标识符不能是关键字</li></ul><p><strong>建议</strong></p><ul><li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）</li><li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）</li><li>变量名规范：全部小写</li></ul><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>变量名全部大写</p><table><thead><tr><th>类型</th><th>含义</th><th>数据举例</th></tr></thead><tbody><tr><td>整数常量</td><td>所有的整数</td><td>0，1， 567， -9</td></tr><tr><td>小数常量</td><td>所有的小数</td><td>0.0， -0.1， 2.55</td></tr><tr><td>字符常量</td><td>单引号引起来,只能写一个字符,必须有内容</td><td>‘a’ ， ‘ ‘， ‘好’</td></tr><tr><td>字符串常量</td><td>双引号引起来,可以写多个字符,也可以不写</td><td>“A” ，”Hello” ，”你好” ，””</td></tr><tr><td>布尔常量</td><td>只有两个值</td><td>true ， false</td></tr><tr><td>空常量</td><td>只有一个值</td><td>null</td></tr></tbody></table><h5 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h5><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>0</td><td>48</td></tr><tr><td>9</td><td>57</td></tr><tr><td>A</td><td>65</td></tr><tr><td>Z</td><td>90</td></tr><tr><td>a</td><td>97</td></tr><tr><td>z</td><td>122</td></tr></tbody></table><h5 id="jshell"><a href="#jshell" class="headerlink" title="jshell"></a>jshell</h5><p>jdk9提供的，可以方便的进行小片段的代码测试</p><h5 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h5><p>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</p><p>eg：数组作为方法参数传递，传递的参数是<strong>数组内存的地址</strong>。</p><h5 id="变量的默认值"><a href="#变量的默认值" class="headerlink" title="变量的默认值"></a>变量的默认值</h5><p>栈中变量(局部变量)没有默认值，必须初始化，堆中变量(new)有默认值</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215212954.png" alt></p><h5 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h5><p>看包(是否需要导包)</p><p>看构造</p><p>看具体方法</p><h5 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h5><p>有自动装箱和拆箱的存在，使用很方便</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215221338.png" alt></p><h5 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h5><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200218122128.png" alt></p><p><strong>建以</strong></p><ul><li>成员变量使用 private ，隐藏细节。 </li><li>构造方法使用 public ，方便创建对象。 </li><li>成员方法使用 public ，方便调用方法。</li></ul><h5 id="访问顺序"><a href="#访问顺序" class="headerlink" title="访问顺序"></a>访问顺序</h5><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200218170814.png" alt></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>基本数据类型：包括 <strong>整数 、 浮点数 、 字符 、 布尔</strong> 。 </li><li>引用数据类型：包括 <strong>类 、 数组 、 接口</strong> 。</li></ul><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>四类八种</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>取值范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1</td><td>-128~127</td></tr><tr><td>短整型</td><td>short</td><td>2</td><td>-32768~32767</td></tr><tr><td>整型</td><td><strong>int</strong></td><td>4</td><td>-2的31次方~2的31次方</td></tr><tr><td>长整型</td><td>long</td><td>8</td><td>-2的63次方~2的63</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4</td><td>1.4013E-45~3.4028E+38</td></tr><tr><td>双精度浮点数</td><td><strong>double</strong></td><td>8</td><td>4.9E-324~1.7977E+308</td></tr><tr><td>字符型</td><td>char</td><td>2</td><td>0-65535</td></tr><tr><td>布尔类型</td><td>boolean</td><td>1</td><td>true，false</td></tr></tbody></table><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><p><code>数据类型 变量名 = 数据值;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义字节型变量</span></span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">100</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//定义短整型变量</span></span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">1000</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//定义整型变量</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">123456</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//定义长整型变量</span></span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">12345678900L</span>;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        <span class="comment">//定义单精度浮点型变量</span></span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">5.5F</span>;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">//定义双精度浮点型变量</span></span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">8.5</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="comment">//定义布尔型变量</span></span><br><span class="line">        <span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(bool);</span><br><span class="line">        <span class="comment">//定义字符型变量</span></span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><h6 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h6><ul><li><p>将<strong>取值范围小</strong>的类型自动提升为 <strong>取值范围大</strong>的类型 </p><p><strong>注意</strong>：是按取值大小来分，eg：float比long所占字节少，但由于是浮点型取值范围更大</p><p><strong>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</strong></p></li><li><p>byte、short、char 运算时直接提升为 int (类型提升)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span></span><br><span class="line"><span class="comment">// 由于jvm的优化，都是常量会在运算成一个数后编译，所以不存在类型提升，可以通过</span></span><br><span class="line"><span class="keyword">byte</span> b3 = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="comment">// 由于右侧是变量，所以不会优化，编译都无法通过</span></span><br><span class="line"><span class="keyword">byte</span> b4 = b1 + b3</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// +=是一个运算符，所以不存在类型提升，一切ok    </span></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line"><span class="comment">// 这样会被提升为int类型   </span></span><br><span class="line">a = a + <span class="number">1</span></span><br></pre></td></tr></table></figure><h6 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h6><p><code>数据类型 变量名 = （数据类型）被转数据值;</code></p><ul><li><p>将 取值范围大的类型 强制转换成 取值范围小的类型 </p></li><li><p>浮点转成整数，直接取消小数点，可能造成数据损失精度</p></li><li><p>int 强制转成 short 砍掉2个字节，可能造成数据丢失</p></li></ul><h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>数值运算(+_*/)，赋值运算(+=,-=,…)，比较运算，逻辑运算(&amp;&amp;,||,!),</p><p>三元运算符(<code>数据类型 变量名 = 布尔类型表达式？结果1：结果2</code>)</p><p><strong>在运算时可以将数字放大一定倍数来避免小数计算</strong></p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类 型也可以作为成员变量、作为方法的参数、作为方法的返回值</p><ul><li><p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象</p></li><li><p>接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。</p><p>我们使用一个接口作为成员变量，这样的设计更为灵活，增强了程序的扩展性。可以通过多种匿名内部类实现丰富的扩展</p><p>接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。</p><p>当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？都是它的 <strong>子类对象</strong>。</p></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断条件<span class="number">1</span>) &#123;</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (判断条件<span class="number">2</span>) &#123;</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (判断条件n) &#123;</span><br><span class="line">执行语句n;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">执行语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式类型：byte，short，int，char，enum（枚举），JDK7后可以接收字符串</span></span><br><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 最后一个break虽说可有可无，但为了保持良好习惯，应该添加</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化表达式中的值，仅在for循环内有效</span></span><br><span class="line"><span class="keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;</span><br><span class="line">循环体③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure><ul><li>有明确次数时用for</li><li>无限循环，但有退出条件用while</li><li>最少执行一次用do-while</li><li>break，continue进行循环控制</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>相当于别的语言中的函数</p><p>将一些常用的功能抽象为一个方法，便于提高代码的复用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">代码...</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215200107.png" alt></p><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><ul><li>函数名相同，但参数列表不同，与修饰符和返 回值类型无关</li><li>参数列表：个数不同，数据类型不同，顺序不同</li><li>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>容器</strong>：是将多个数据存储到一起，每个数据称为该容器的元素。</p><p><strong>数组</strong>： 数组就是存储数据<strong>长度固定</strong>的容器，保证多个数据的<strong>数据类型要一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 前两种申明和定义可以分开，最后一种必须一体</span></span><br></pre></td></tr></table></figure><p><strong>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值.</strong></p><p>所以数组作为方法参数传递，传递的参数是<strong>数组内存的地址</strong>。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215203842.png" alt></p><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组名[索引]=数值，为数组中的元素赋值</span></span><br><span class="line"><span class="comment">// 变量=数组名[索引]，获取出数组中的元素</span></span><br><span class="line"><span class="comment">// 数组名.length获取数组名中元素个数</span></span><br></pre></td></tr></table></figure><h4 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215201824.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215201906.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215203113.png" alt></p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul><li>NullPointerException：只定义未申明</li><li>ArrayIndexOutOfBoundsException：操作下标越界</li></ul><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取出最大元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;;</span><br><span class="line">    <span class="comment">//定义变量，保存数组中0索引的元素</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//遍历数组，取出每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//遍历到的元素和变量max比较</span></span><br><span class="line">    <span class="comment">//如果数组元素大于max</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">        <span class="comment">//max记录住大值</span></span><br><span class="line">        max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"数组最大值是： "</span> + max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转(双向遍历，交换数据)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环中定义变量min=0最小索引</span></span><br><span class="line"><span class="comment">    max=arr.length‐1最大索引</span></span><br><span class="line"><span class="comment">    min++,max‐‐</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐) &#123;</span><br><span class="line">    <span class="comment">//利用第三方变量完成数组中的元素交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[min];</span><br><span class="line">        arr[min] = arr[max];</span><br><span class="line">        arr[max] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转后，遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下， 使用Java语言去设计、开发计算机程序。 这里的<strong>对象泛指现实中一切事物</strong>，每种事物都具备自己的<strong>属性和行为</strong>。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算 机事件的设计思想。 它区别于面向过程思想，强调的是<strong>通过调用对象的行为来实现功能，而不是自己一步一步的去 操作实现</strong>。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>封装、继承和多态。</p><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p>类：是一组相关属性和行为的集合</p><ul><li>属性：就是该事物的状态信息</li><li>行为：就是该事物能够做什么。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性 和行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名 对象名 = new 类名();</span></span><br><span class="line"><span class="comment">// 对象名.成员变量；</span></span><br><span class="line"><span class="comment">// 对象名.成员方法()；</span></span><br></pre></td></tr></table></figure><h6 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h6><p><code>new 类名(参数列表)；</code></p><p>. 创建匿名对象直接调用方法，没有变量名，对于那些只使用一次的变量(参数，返回值，…)</p><h5 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h5><p>类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。</p><h5 id="内存图-1"><a href="#内存图-1" class="headerlink" title="内存图"></a>内存图</h5><h6 id="一个对象调用一个方法"><a href="#一个对象调用一个方法" class="headerlink" title="一个对象调用一个方法"></a>一个对象调用一个方法</h6><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215213202.png" alt></p><h6 id="两个对象调用一个方法"><a href="#两个对象调用一个方法" class="headerlink" title="两个对象调用一个方法"></a>两个对象调用一个方法</h6><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200215213427.png" alt></p><h5 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h5><ul><li><p>在类中的位置不同</p><ul><li>成员变量：类中，方法外 </li><li>局部变量：方法中或者方法声明上(形式参数) </li></ul></li><li><p>作用范围不一样 </p><ul><li>成员变量：类中 </li><li>局部变量：方法中 </li></ul></li><li><p>初始化值的不同</p><ul><li>成员变量：有默认值 </li><li>局部变量：没有默认值，必须先定义，赋值，最后使用 </li></ul></li><li><p>在内存中的位置不同</p><ul><li>成员变量：堆内存 </li><li>局部变量：栈内存 </li></ul></li><li><p>生命周期不同</p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失 </li><li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li></ul></li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的 方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p><h5 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h5><p>将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li><p>使用 private 关键字来修饰成员变量。 </p></li><li><p>对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。</p></li></ol><h5 id="封装优化"><a href="#封装优化" class="headerlink" title="封装优化"></a>封装优化</h5><ul><li>用this来解决命名冲突</li></ul><p>方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p><ul><li>提供构造方法<ul><li>如果你不提供构造方法，系统会给出无参数构造方法</li><li>如果你提供了构造方法，系统将不再提供无参数构造方法</li><li>构造方法是可以重载的，既可以定义参数，也可以不定义参数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法无须返回值</span></span><br><span class="line">修饰符 构造方法名(参数列表)&#123;</span><br><span class="line"><span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h5><p>JavaBean 是 Java语言编写类的一种<strong>标准规范</strong>，可重用的组件</p><p>符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无 参数的构造方法，提供用来操作成员变量的 set 和 get 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="comment">//无参构造方法【必须】</span></span><br><span class="line">    <span class="comment">//有参构造方法【建议】</span></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="comment">// boolean的get方法为isXxx()</span></span><br><span class="line">    <span class="comment">//getXxx()</span></span><br><span class="line">    <span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h5><h6 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h6><p>它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。可以不靠创建对象来调用了</p><ul><li>类变量</li></ul><p>当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</p><ul><li><p>静态方法 </p><p>当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用</p><ul><li><p>静态方法可以直接访问类变量和静态方法</p></li><li><p>静态方法不能直接访问普通成员变量或成员方法。但反之，成员方法可以直接访问类变量或静态方法</p></li></ul><p>原因：<strong>内存中先加载静态方法，实例化时再加载成员方法</strong></p><ul><li>静态方法中，不能使用this关键字</li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200216094554.png" alt></p></li></ul><h6 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h6><ul><li>位置：类中方法外</li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行</li><li>作用：用于变量的初始化赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 给类变量赋值</span></span><br><span class="line">        number = <span class="number">2</span>;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 添加元素到集合中</span></span><br><span class="line">        list.add(<span class="string">"张三"</span>);</span><br><span class="line">        list.add(<span class="string">"李四"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p><strong>由来：</strong>多个类中存在相同属性和行为时，将这些内容<strong>抽取到单独一个类中</strong>，那么多个类无需再定义这些属性和行为，只要 继承那一个类即可</p><p>子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为</p><ul><li>提高代码重用性</li><li>类与类之间产生了关系，是多态的前提</li></ul><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><blockquote><p>java只支持单继承，但支持<strong>多层继承</strong></p><p>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰</p><p>接口中，没有构造方法，不能创建对象</p><p>接口中，没有静态代码块。</p></blockquote><h5 id="成员变量的访问"><a href="#成员变量的访问" class="headerlink" title="成员变量的访问"></a>成员变量的访问</h5><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰 父类成员变量</p><h5 id="成员方法的访问"><a href="#成员方法的访问" class="headerlink" title="成员方法的访问"></a>成员方法的访问</h5><p>子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效 果，也称为<strong>重写</strong>或者复写。<strong>声明不变，重新实现。</strong></p><ul><li>通过重写，可以实现子类对父类方法的拓展</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span><span class="comment">// 对是否重写做检验</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用父类已经存在的功能使用super在原基础上扩展</span></span><br><span class="line">    <span class="keyword">super</span>.showNum();</span><br><span class="line">    <span class="comment">//增加自己特有显示姓名和图片功能</span></span><br><span class="line">    System.out.println(<span class="string">"显示来电姓名"</span>);</span><br><span class="line">    System.out.println(<span class="string">"显示头像"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ol><li>子类方法覆盖父类方法，必须要保证<strong>权限大于等于父类权限</strong>，一般采用相同权限</li><li>子类方法覆盖父类方法<strong>，返回值类型、函数名和参数列表</strong>都要一模一样。</li></ol><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    Zi()&#123;</span><br><span class="line">    <span class="comment">// super（），调用父类构造方法</span></span><br><span class="line">    <span class="comment">// 子类的每个构造方法中有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()</span></span><br><span class="line"><span class="comment">// super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</span></span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    System.out.println(<span class="string">"Zi（）"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200218101920.png" alt></p><ul><li>super ：代表父类的存储空间标识(可以理解为父亲的引用)。<ul><li>super(…)    super.成员方法名()    super.成员变量</li></ul></li><li>this ：代表当前对象的引用(谁调用就代表谁)。</li></ul><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><h6 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h6><p>抽象方法 ： 没有方法体的方法，只有声明，没有实现</p><p>抽象类：用abstract修饰的类，不必须包含抽象方法，只要不想让该方法可以直接实例化，即可声明为抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修饰符 abstract 返回值类型 方法名 (参数列表)；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。</p><ul><li>抽象类不能实例化</li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的</li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类</li><li>抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h5 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h5><p>接口，是Java语言中一种引用类型，是方法的集合，接口的内部主要就是封装了方法，包含<strong>抽象方法</strong>（JDK 7及以前），<strong>默认方法和静态方法</strong>（JDK 8），<strong>私有方法</strong> （JDK 9）。 </p><p>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并 不是类，而是另外一种引用数据类型。</p><blockquote><p> 引用数据类型：数组，类，接口。 </p></blockquote><p>接口的使用，它不能创建对象，但是可以被实现（ implements）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名称 </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 默认方法用于接口功能扩展，如果再加抽象方法，使用实现类都得改，当然子类也可以重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法供接口直接调用，子类无法继承亦无法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有方法用于将默认方法中的重复代码抽取</span></span><br><span class="line">    <span class="comment">// 私有方法：只有默认方法可以调用。</span></span><br><span class="line"><span class="comment">// 私有静态方法：默认方法和静态方法可以调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多实现"><a href="#多实现" class="headerlink" title="多实现"></a>多实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123;</span><br><span class="line">    <span class="comment">// 重写接口中抽象方法【必须】如果抽象方法有重名的，只需要重写一次。</span></span><br><span class="line">    <span class="comment">// 如果默认方法有重名的，必须重写一次，不重名时随意</span></span><br><span class="line"><span class="comment">// 存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执 行父类的成员方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AAAAAAAAAAAA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"DDDDDDDDDDDD"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="comment">// 未重写methodA方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    c.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果:</span><br><span class="line">DDDDDDDDDDDD</span><br></pre></td></tr></table></figure><h5 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h5><p>一个接口能继承另一个或者多个接口，和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继 承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次</strong></p><ul><li>子接口重写默认方法时，default关键字可以保留</li><li>子类重写默认方法时，default关键字不可以保留</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><p>多态： 是指同一行为，具有多个不同表现形式。(单一的父类来接收多种多样的子类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</span></span><br><span class="line"><span class="comment">// 父类类型 变量名 = new 子类对象；</span></span><br><span class="line"><span class="comment">// 变量名.方法名();</span></span><br><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">f.method();</span><br></pre></td></tr></table></figure><h5 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h5><ul><li>继承或者实现【二选一】 </li><li>方法的重写【意义体现：不重写，无意义】 </li><li>父类引用指向子类对象【格式体现】</li></ul><h5 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h5><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写 后方法        编译看左，运行看右</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>可以使程序编写的更简单，并有良好的扩展</p><h5 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h5><ol><li><p>向上转型</p><p>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类类型 变量名 = new 子类类型();</span></span><br><span class="line">Animal a = <span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>向下转型</p><p>父类类型向子类类型向下转换的过程，这个过程是强制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了调用子类特有的方法</span></span><br><span class="line"><span class="comment">// 子类类型 变量名 = (子类类型) 父类变量名;</span></span><br><span class="line">Cat c =(Cat) a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经常面临ClassCastException</span></span><br><span class="line"><span class="comment">// 变量名 instanceof 数据类型</span></span><br><span class="line"><span class="comment">// 如果变量属于该数据类型，返回true。</span></span><br><span class="line"><span class="comment">// 如果变量不属于该数据类型，返回false。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向上转型</span></span><br><span class="line">    Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">    a.eat(); <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">    <span class="comment">// 向下转型</span></span><br><span class="line">    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">        Cat c = (Cat)a;</span><br><span class="line">        c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">        Dog d = (Dog)a;</span><br><span class="line">        d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><p>final： 不可改变。可以用于修饰类、方法和变量。变量名一般全大写</p><ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。 </li><li>变量：被修饰的变量，不能被重新赋值。</li></ul><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><ul><li><p>基本类型的变量被final修饰后仅能赋值一次</p></li><li><p>成员变量涉及到初始化的问题，初始化方式有两种，必须二选一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示初始化；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String USERNAME = <span class="string">"张三"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造方法初始化。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String USERNAME ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.USERNAME = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的 修改</li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类</p><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>成员内部类 ：定义在类中方法外的类</p><p>在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机 类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> 内部类</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>内部类可以直接访问外部类的成员，包括私有成员。</p><p>当内部类与外部类变量重名时：<code>外部类类名.this.变量名</code></p></li><li><p>外部类要访问内部类的成员，必须要建立内部类的对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建外部类对象</span></span><br><span class="line">    Person p = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="comment">// 创建内部类对象</span></span><br><span class="line">    Heart heart = p.new Heart();</span><br><span class="line">    <span class="comment">// 调用内部类方法</span></span><br><span class="line">    heart.jump();</span><br><span class="line">    <span class="comment">// 调用外部类方法</span></span><br><span class="line">    p.setLive(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 调用内部类方法</span></span><br><span class="line">    heart.jump();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部类是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但前面冠以外部类的类名和$符号</span></span><br><span class="line"><span class="comment">// 比如，Person$Heart.class</span></span><br></pre></td></tr></table></figure><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>是内部类的简化写法。它的本质是一个<strong>带具体实现</strong>的<strong>父类或者父接口的匿名的子类对象</strong>。</p><p>开发中，最常用到的内部类就是匿名内部类了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于那些只实例化一次的方法不配专门创建文件</span></span><br><span class="line"><span class="comment">// 类似匿名对象，那些只使用一次的对象不配拥有姓名</span></span><br><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.等号右边:是匿名内部类，定义并创建该接口的子类对象</span></span><br><span class="line"><span class="comment">    2.等号左边:是多态赋值,接口类型引用指向子类对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FlyAble f = <span class="keyword">new</span> FlyAble()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我飞了~~~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//调用 fly方法,执行重写后的方法</span></span><br><span class="line">    f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别匿名对象和匿名内部类：</p><blockquote><p>​    一个是只实例化一次，但该实例可被变量接收，多次调用</p><p>​    匿名对象是仅调用一次</p></blockquote><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Scanner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 创建键盘录入数据的对象</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//3. 接收数据</span></span><br><span class="line">        System.out.println(<span class="string">"请录入一个整数："</span>);</span><br><span class="line">        <span class="keyword">int</span> i = sc.nextInt();</span><br><span class="line">        <span class="comment">//4. 输出数据</span></span><br><span class="line">        System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01_Random</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//2. 创建键盘录入数据的对象</span></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//3. 随机生成一个数据</span></span><br><span class="line">        <span class="comment">// 可以通过平移和伸缩来实现输出任意范围随机数</span></span><br><span class="line">        <span class="keyword">int</span> number = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//4. 输出数据</span></span><br><span class="line">        System.out.println(<span class="string">"number:"</span>+ number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h4><h5 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h5><p>而数组的长度是固定的，无法适应数据变化的需 求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对 象数据。</p><h5 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h5><p>java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储 的元素。 ArrayList 中可<strong>自动扩容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建jdk1.7之后右侧&lt;&gt;可以留空</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> <span class="comment">// 将指定的元素添加到此集合的尾部。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 移除此集合中指定位置上的元素。返回被删除的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">// 返回此集合中指定位置上的元素。返回获取的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="comment">// 返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</span></span></span><br></pre></td></tr></table></figure><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。所以需要<strong>存入对应的包装类</strong></p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h5><p>Java程序中<strong>所有的字符串文字</strong>（例如 “abc” ）都可以被看作是实现此类的实例。</p><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><ul><li>字符串不变：字符串的值在创建后不能被更改。但凡改变，必定是生成了新的字符串</li><li>因为String对象是不可变的，所以它们可以被共享。</li></ul><p>类似于python中的缓存机制，java中应该被称为常量池</p><ul><li>“abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ }</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">相当于：</span><br><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line"><span class="comment">// String底层是靠字符数组实现的。</span></span><br></pre></td></tr></table></figure><h5 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line">String str = <span class="keyword">new</span> String（）；</span><br><span class="line"><span class="comment">// 通过字符数组构造</span></span><br><span class="line"><span class="keyword">char</span> chars[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(chars);</span><br><span class="line"><span class="comment">// 通过字节数组构造</span></span><br><span class="line"><span class="keyword">byte</span> bytes[] = &#123; <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span> &#125;;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(bytes);</span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object anObject)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将此字符串与指定对象进行比较。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(String anotherString)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将此字符串与指定对象进行比较，忽略大小</span></span></span><br><span class="line"><span class="function">写。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 返回此字符串的长度。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span> <span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将指定的字符串连接到该字符串的末尾。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span> <span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 按索引取char值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span> <span class="params">(String str)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 返回指定子字符串第一次出现在该字符串内的索引。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 返回一个子字符串，从beginIndex开始截取字符串到字符类似切片</span></span></span><br><span class="line"><span class="function">串结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 转换</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">toCharArray</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将此字符串转换为新的字符数组。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">getBytes</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 使用平台的默认字符集将该 String编码转换为新的字节数组。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span> <span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将与target匹配的字符串使用replacement字符串替换。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 分割</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String regex)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 将此字符串按照给定的regex（规则）拆分为字符串数组。</span></span></span><br></pre></td></tr></table></figure><h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span> <span class="comment">// 返回指定数组内容的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义int 数组</span></span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">4</span>,<span class="number">657</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// 打印数组,输出地址值</span></span><br><span class="line">    System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line">    <span class="comment">// 数组内容转为字符串</span></span><br><span class="line">    String s = Arrays.toString(arr);</span><br><span class="line">    <span class="comment">// 打印字符串,输出内容</span></span><br><span class="line">    System.out.println(s); <span class="comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> <span class="comment">// 对指定的 int 型数组按数字升序进行排序，改变原数组</span></span></span><br></pre></td></tr></table></figure><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><p>java.lang.Math 类包含用于执行基本数学运算的方法，其所有方法均为静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回 <span class="keyword">double</span> 值的绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回大于等于参数的最小的整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回小于等于参数最大的整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span> ：返回最接近参数的 <span class="keyword">long</span>。<span class="params">(相当于四舍五入方法)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java初识&quot;&gt;&lt;a href=&quot;#Java初识&quot; class=&quot;headerlink&quot; title=&quot;Java初识&quot;&gt;&lt;/a&gt;Java初识&lt;/h3&gt;&lt;h4 id=&quot;发展简史&quot;&gt;&lt;a href=&quot;#发展简史&quot; class=&quot;headerlink&quot; title=&quot;发展简史&quot;&gt;&lt;/a&gt;发展简史&lt;/h4&gt;&lt;p&gt;95由sun开发，1.5和1.8是两次较大的版本更新&lt;/p&gt;
&lt;p&gt;09年在1.6版本时被Oracle收购&lt;/p&gt;
&lt;h4 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h4&gt;&lt;p&gt;各种互联网程序以及服务器后台处理大数据的存储，查询和数据挖掘等&lt;/p&gt;
&lt;h4 id=&quot;常用DOS命令&quot;&gt;&lt;a href=&quot;#常用DOS命令&quot; class=&quot;headerlink&quot; title=&quot;常用DOS命令&quot;&gt;&lt;/a&gt;常用DOS命令&lt;/h4&gt;&lt;p&gt;win+r进入&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;盘符名:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换盘符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查看当前文件夹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cd 文件夹名&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换文件夹&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cd \&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换到磁盘根目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cls&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;清屏&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
      <category term="heima57" scheme="http://yoursite.com/categories/heima57/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>maven使用</title>
    <link href="http://yoursite.com/2020/02/11/maven%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/11/maven使用/</id>
    <published>2020-02-11T11:31:35.000Z</published>
    <updated>2020-02-14T02:47:28.036Z</updated>
    
    <content type="html"><![CDATA[<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>jar包管理</li><li>一键编译</li><li>一键测试</li><li>一键部署</li></ul><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>maven工程对jar包的管理过程，实现了jar包的重用</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211193637.png" alt></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>去官网解压到一个路径下即可</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200213221931.png" alt></p><p>添加环境变量</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211194608.png" alt></p><p>path中添加</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211194717.png" alt></p><p>maven运行依赖于JAVA_HOME变量</p><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211195150.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211200548.png" alt></p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211201920.png" alt></p><h4 id="pom文件结构"><a href="#pom文件结构" class="headerlink" title="pom文件结构"></a>pom文件结构</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212095810.png" alt></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211204554.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200214103350.png" alt></p><h4 id="idea集成maven"><a href="#idea集成maven" class="headerlink" title="idea集成maven"></a>idea集成maven</h4><p>确认下电脑上是否安装好了maven</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211204851.png" alt></p><p>setting中配置如下信息</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211205521.png" alt></p><p><strong>-DarchetypeCatalog=internal</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211221827.png" alt></p><h4 id="创建java项目"><a href="#创建java项目" class="headerlink" title="创建java项目"></a>创建java项目</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200214104452.png" alt></p><p><strong>web项目所用的骨架</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211222427.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200214104602.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211205917.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211210002.png" alt></p><p>把没有提供全的目录自己添加一下，一般java项目不需要用骨架</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200214104621.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200211223115.png" alt></p><h4 id="jar包添加"><a href="#jar包添加" class="headerlink" title="jar包添加"></a>jar包添加</h4><h5 id="本地添加"><a href="#本地添加" class="headerlink" title="本地添加"></a>本地添加</h5><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212101244.png" alt></p><h6 id="scope标签"><a href="#scope标签" class="headerlink" title="scope标签"></a>scope标签</h6><p>作用：有些jar包仅在编译时需要</p><table><thead><tr><th>包名</th><th>作用域</th></tr></thead><tbody><tr><td>servlet</td><td>provided</td></tr><tr><td>jsp</td><td>provided</td></tr><tr><td>junit</td><td>test</td></tr><tr><td>mysql</td><td>runtime</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212121126.png" alt></p><h5 id="中央仓库添加"><a href="#中央仓库添加" class="headerlink" title="中央仓库添加"></a>中央仓库添加</h5><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212100834.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212100951.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212101030.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200214104708.png" alt></p><h4 id="运行环境修改"><a href="#运行环境修改" class="headerlink" title="运行环境修改"></a>运行环境修改</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212114251.png" alt></p><p>可以将常用的添加为模板</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212114521.png" alt></p><p>先添加一个组</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212114610.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200212115735.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;用处&quot;&gt;&lt;a href=&quot;#用处&quot; class=&quot;headerlink&quot; title=&quot;用处&quot;&gt;&lt;/a&gt;用处&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;jar包管理&lt;/li&gt;
&lt;li&gt;一键编译&lt;/li&gt;
&lt;li&gt;一键测试&lt;/li&gt;
&lt;li&gt;一键部署&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 
      
    
    </summary>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>python例题</title>
    <link href="http://yoursite.com/2020/02/10/python%E4%BE%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/10/python例题/</id>
    <published>2020-02-10T09:46:38.000Z</published>
    <updated>2020-02-10T10:00:29.745Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    func_list.append(<span class="keyword">lambda</span> x:x+i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(func_list)):</span><br><span class="line">    result = func_list[i](i)</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><p>lambda返回的是个函数地址，且里面各变量在真正执行前都是保存着地址</p><p>通过闭包保存传入的参数，其余变量则在命名空间中寻找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    v = <span class="keyword">lambda</span> x: x + name</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v1 = func(<span class="string">'太白'</span>)</span><br><span class="line">v2 = func(<span class="string">'alex'</span>)</span><br><span class="line">v3 = v1(<span class="string">'银角'</span>)</span><br><span class="line">v4 = v2(<span class="string">'金角'</span>)</span><br><span class="line">print(v1, v2, v3, v4)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="习题" scheme="http://yoursite.com/tags/%E4%B9%A0%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>python基础</title>
    <link href="http://yoursite.com/2020/02/01/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/01/python基础/</id>
    <published>2020-02-01T12:07:42.000Z</published>
    <updated>2020-02-15T09:34:06.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><h4 id="计算机基本组件"><a href="#计算机基本组件" class="headerlink" title="计算机基本组件"></a>计算机基本组件</h4><h5 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h5><p>计算机的运算和计算中心</p><p>人类一秒，可以运行10亿条指令，比内存快百度，硬盘快百万倍</p><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>暂时存储数据，临时加载数据应用程序，分为RAM，ROM</p><h5 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h5><p>长期存储数据</p><h5 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h5><p>一个软件，连接计算机的硬件与所有软件之间的一个软件</p><h4 id="python历史"><a href="#python历史" class="headerlink" title="python历史"></a>python历史</h4><p>python崇尚优雅，简洁</p><p>2和3有较多区别</p><h4 id="python的种类"><a href="#python的种类" class="headerlink" title="python的种类"></a>python的种类</h4><ul><li>Cpython：官方推荐解释器。可以转化成C语言能识别的字节码。</li><li>Jpython: 可以转化成Java语言能识别的字节码。</li><li>Ironpython：可以转化成.net语言能识别的字节码</li><li>pypy: 动态编译</li></ul><a id="more"></a><h4 id="编程语言分类"><a href="#编程语言分类" class="headerlink" title="编程语言分类"></a>编程语言分类</h4><h5 id="编译型"><a href="#编译型" class="headerlink" title="编译型"></a>编译型</h5><p>​        将代码一次性全部编译成二进制，然后再执行。</p><p>​        优点：执行效率高。</p><p>​        缺点：开发效率低，不能跨平台。</p><p>​        代表语言：C</p><h5 id="解释型"><a href="#解释型" class="headerlink" title="解释型"></a>解释型</h5><p>​        逐行解释成二进制，逐行运行。</p><p>​        优点：开发效率高，可以跨平台。</p><p>​        缺点：执行效率低。</p><p>​        代表语言：python</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>相当于为对应内存空间起别名，不同类型变量为不同大小内存块或有不同作用</p><h5 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h5><ul><li>变量全部由数字，字母下划线任意组合。</li><li>不能以数字开头。 </li><li>不能是python的关键字。<ul><li>[‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’]</li></ul></li><li>要具有描述性。name= ‘太白金星’ sex</li><li>不能使用中文。</li><li>不能过长。</li><li>推荐<ul><li>驼峰体：AgeOfOldboy = 73</li><li>下划线：age_of_oldboy = 73</li></ul></li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>代指生活中一直不变的</p><p>python中<strong>没有真正的常量</strong>，为了应和其他语言的口味，全部大写的变量称之为常量。所以是一种约定俗成的东西，没有实际约束。<strong>将变量名全部大写，放在文件的最上面</strong></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>便于你理解对方的代码，自己的代码。</p><ul><li>单行注释： # </li><li>多行注释： ‘’’被注释内容’’’  “””被注释内容”””</li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h5 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h5><p>以下假设变量：a=10，b=20</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208181809.png" alt></p><p> <strong>/ 是除法，例如：2/3 = 0.6666。而//是表示向下取整的除法，例如3//2=1，6.0//4 = 1。也就是说 / 返回的是浮点类型的结果， 而 // 返回的是整数结果(可以理解为/的整数部分)</strong></p><h5 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h5><p>以下假设变量：a=10，b=20</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208181841.png" alt></p><h5 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h5><p>以下假设变量：a=10，b=20</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208181910.png" alt></p><h5 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h5><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183226.png" alt></p><p><strong>断路与或</strong></p><p>x or y , x为真，值就是x，x为假，值是y</p><p>x and y, x为真，值是y,x为假，值是x。</p><h5 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h5><p>判断子元素是否在原字符串（字典，列表，集合）中</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183245.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'喜欢'</span> <span class="keyword">in</span> <span class="string">'dkfljadklf喜欢hfjdkas'</span>)</span><br><span class="line">print(<span class="string">'a'</span> <span class="keyword">in</span> <span class="string">'bcvd'</span>)</span><br><span class="line">print(<span class="string">'y'</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'ofkjdslaf'</span>)</span><br></pre></td></tr></table></figure><h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">max = a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b</span><br><span class="line"><span class="comment"># 两者等价</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">max = a</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">max = b</span><br></pre></td></tr></table></figure><h5 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h5><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>**</td><td>指数 (最高优先级)</td></tr><tr><td>~ + -</td><td>按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td>* / % //</td><td>乘，除，取模和取整除</td></tr><tr><td>+ -</td><td>加法减法</td></tr><tr><td>&gt;&gt; &lt;&lt;</td><td>右移，左移运算符</td></tr><tr><td>&amp;</td><td>位 ‘AND’</td></tr><tr><td>^ |</td><td>位运算符</td></tr><tr><td>&lt;= &lt; &gt; &gt;=</td><td>比较运算符</td></tr><tr><td>&lt;&gt; == !=</td><td>等于运算符</td></tr><tr><td>= %= /= //= -= += <em>= *</em>=</td><td>赋值运算符</td></tr><tr><td>is is not</td><td>身份运算符</td></tr><tr><td>in not in</td><td>成员运算符</td></tr><tr><td>not and or</td><td>逻辑运算符</td></tr></tbody></table><h4 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h4><p>Python pass 是空语句，是为了保持程序结构的完整性。</p><p><strong>pass</strong> 不做任何事情，一般用做占位语句。</p><h4 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h4><p>返回输入对象的内存地址</p><h4 id="is和"><a href="#is和" class="headerlink" title="is和=="></a>is和==</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">is</span> b<span class="comment"># 比较内存地址</span></span><br><span class="line">a == b<span class="comment"># 比较值</span></span><br></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>不可变（可哈希）的数据类型：int，str，bool，tuple。</p><p>可变（不可哈希）的数据类型：list，dict，set。</p></li></ul><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><p>不同进制间转化</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>bit_length(self)</td><td>转为对应二进制后有效位的长度</td></tr></tbody></table><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>常用于条件</p><p>while 1：比while True：更高效</p><h4 id="str"><a href="#str" class="headerlink" title="str"></a>str</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由单(双)引号引起</span></span><br><span class="line"><span class="comment"># 三引号：带换行的字符串</span></span><br><span class="line"> msg = <span class="string">'''</span></span><br><span class="line"><span class="string"> 今天我想写首小诗，</span></span><br><span class="line"><span class="string"> 歌颂我的同桌，</span></span><br><span class="line"><span class="string"> 你看他那乌黑的短发，</span></span><br><span class="line"><span class="string"> 好像一只炸毛鸡。</span></span><br><span class="line"><span class="string"> '''</span></span><br></pre></td></tr></table></figure><h5 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h5><ul><li>法一</li></ul><table><thead><tr><th align="center">符号</th><th align="center">指代</th></tr></thead><tbody><tr><td align="center">%s</td><td align="center">str</td></tr><tr><td align="center">%d</td><td align="center">digit</td></tr><tr><td align="center">%i</td><td align="center">int</td></tr><tr><td align="center">%r</td><td align="center">输出时对应字符串带引号</td></tr><tr><td align="center">%%</td><td align="center">普通%号</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">"Name:"</span>)</span><br><span class="line">age = input(<span class="string">"Age:"</span>)</span><br><span class="line">job = input(<span class="string">"Job:"</span>)</span><br><span class="line">hobbie = input(<span class="string">"Hobbie:"</span>)</span><br><span class="line"></span><br><span class="line">info = <span class="string">'''</span></span><br><span class="line"><span class="string">------------ info of %s ----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 name </span></span><br><span class="line"><span class="string">Name  : %s  #代表 name </span></span><br><span class="line"><span class="string">Age   : %s  #代表 age  </span></span><br><span class="line"><span class="string">job   : %s  #代表 job </span></span><br><span class="line"><span class="string">Hobbie: %s  #代表 hobbie </span></span><br><span class="line"><span class="string">------------- end -----------------</span></span><br><span class="line"><span class="string">'''</span> %(name,name,age,job,hobbie)  <span class="comment"># 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来 </span></span><br><span class="line"><span class="comment"># %%来输出普通百分号</span></span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure><ul><li>法二</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="string">'&#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(<span class="string">'egon'</span>,<span class="number">18</span>,<span class="string">'male'</span>)</span><br><span class="line">res=<span class="string">'&#123;1&#125; &#123;0&#125; &#123;1&#125;'</span>.format(<span class="string">'egon'</span>,<span class="number">18</span>,<span class="string">'male'</span>)</span><br><span class="line">res=<span class="string">'&#123;name&#125; &#123;age&#125; &#123;sex&#125;'</span>.format(sex=<span class="string">'male'</span>,name=<span class="string">'egon'</span>,age=<span class="number">18</span>)</span><br></pre></td></tr></table></figure><ul><li><p>法三</p><p>f-strings 是python3.6开始加入标准库的格式化输出新的写法，这个格式化输出比之前的%s 或者 format 效率高并且更加简化，非常的好用</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任意表达式</span></span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;<span class="number">3</span>*<span class="number">21</span>&#125;</span>'</span>)  <span class="comment"># 63</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">'barry'</span></span><br><span class="line">print(<span class="string">f"全部大写：<span class="subst">&#123;name.upper()&#125;</span>"</span>)  <span class="comment"># 全部大写：BARRY</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典也可以</span></span><br><span class="line">teacher = &#123;<span class="string">'name'</span>: <span class="string">'太白金星'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">msg = <span class="string">f"The teacher is <span class="subst">&#123;teacher[<span class="string">'name'</span>]&#125;</span>, aged <span class="subst">&#123;teacher[<span class="string">'age'</span>]&#125;</span>"</span></span><br><span class="line">print(msg)  <span class="comment"># The comedian is 太白金星, aged 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表也行</span></span><br><span class="line">l1 = [<span class="string">'太白金星'</span>, <span class="number">18</span>]</span><br><span class="line">msg = <span class="string">f'姓名：<span class="subst">&#123;l1[<span class="number">0</span>]&#125;</span>,年龄：<span class="subst">&#123;l1[<span class="number">1</span>]&#125;</span>.'</span></span><br><span class="line">print(msg)  <span class="comment"># 姓名：太白金星,年龄：18.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用函数完成相应的功能，然后将返回值返回到字符串相应的位置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_a_b</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">print(<span class="string">'求和的结果为'</span> + <span class="string">f'<span class="subst">&#123;sum_a_b(a,b)&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行</span></span><br><span class="line">name = <span class="string">'barry'</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">ajd = <span class="string">'handsome'</span></span><br><span class="line"></span><br><span class="line">speaker = <span class="string">f'''Hi <span class="subst">&#123;name&#125;</span>.</span></span><br><span class="line"><span class="string">You are <span class="subst">&#123;age&#125;</span> years old.</span></span><br><span class="line"><span class="string">You are a <span class="subst">&#123;ajd&#125;</span> guy!'''</span></span><br><span class="line"></span><br><span class="line">speaker = <span class="string">f'Hi <span class="subst">&#123;name&#125;</span>.'</span>\</span><br><span class="line">          <span class="string">f'You are <span class="subst">&#123;age&#125;</span> years old.'</span>\</span><br><span class="line">          <span class="string">f'You are a <span class="subst">&#123;ajd&#125;</span> guy!'</span></span><br><span class="line">print(speaker)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些细节</span></span><br><span class="line">print(<span class="string">f"<span class="subst">&#123;&#123;<span class="number">73</span>&#125;</span>&#125;"</span>)  <span class="comment"># &#123;73&#125;</span></span><br><span class="line">print(<span class="string">f"<span class="subst">&#123;&#123;&#123;<span class="number">73</span>&#125;</span>&#125;&#125;"</span>)  <span class="comment"># &#123;73&#125;</span></span><br><span class="line">print(<span class="string">f"<span class="subst">&#123;&#123;&#123;&#123;<span class="number">73</span>&#125;</span>&#125;&#125;&#125;"</span>)  <span class="comment"># &#123;&#123;73&#125;&#125;</span></span><br><span class="line">m = <span class="number">21</span></span><br><span class="line"><span class="comment"># ! , : &#123; &#125; ;这些标点不能出现在&#123;&#125; 这里面。</span></span><br><span class="line"><span class="comment"># print(f'&#123;;12&#125;')  # 报错</span></span><br><span class="line"><span class="comment"># 所以使用lambda 表达式会出现一些问题。</span></span><br><span class="line"><span class="comment"># 解决方式：可将lambda嵌套在圆括号里面解决此问题。</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;(<span class="keyword">lambda</span> x: x*<span class="number">2</span>) (x)&#125;</span>'</span>)  <span class="comment"># 10</span></span><br></pre></td></tr></table></figure><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><p>按下标取值，从零开始</p><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串</p><p><strong>左闭右开</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">'ABCDEFGHIJK'</span></span><br><span class="line">print(a[<span class="number">0</span>:<span class="number">3</span>])  <span class="comment"># print(a[:3]) 从开头开始取0可以默认不写</span></span><br><span class="line">print(a[<span class="number">2</span>:<span class="number">5</span>])</span><br><span class="line">print(a[:]) <span class="comment">#默认到最后</span></span><br><span class="line">print(a[:<span class="number">-1</span>]) <span class="comment"># -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素</span></span><br><span class="line">print(a[:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment">#加步长</span></span><br><span class="line">print(a[<span class="number">-1</span>:<span class="number">-5</span>:<span class="number">-2</span>]) <span class="comment">#反向加步长</span></span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>upper(self)</td><td>转为大写</td></tr><tr><td>lower(self)</td><td>转为小写</td></tr><tr><td>count(str,i,j)</td><td>从i到j的切片中str出现了几次</td></tr><tr><td>startswith(str,i,j)</td><td>从i到j，是不是str，不写i，j时从头匹配</td></tr><tr><td>endswith(str,i,j)</td><td>从i到j，是不是str，不写i，j时从尾匹配</td></tr><tr><td>replace(str,i)</td><td>默认全部替换，i可以指定替换个数</td></tr><tr><td>strip()</td><td>去除空拍字符(\t,\n,空格)，从左右两边开始删到都一个非空白为止</td></tr><tr><td>lstrip()</td><td>删左侧</td></tr><tr><td>rstrip()</td><td>删右侧</td></tr><tr><td>strip(str)</td><td>去除在str中的字符</td></tr><tr><td>isalnum()</td><td>字符串由字母或数字组成</td></tr><tr><td>isalpha()</td><td>字符串只由字母组成</td></tr><tr><td>isdecimal()</td><td>字符串只由十进制组成</td></tr></tbody></table><p>len(str)    获取数据的元素个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split 以什么分割，最终形成一个列表此列表不含有这个分割的元素。</span></span><br><span class="line">ret9 = <span class="string">'title,Tilte,atre,'</span>.split(<span class="string">'t'</span>)</span><br><span class="line">print(ret9)</span><br><span class="line">ret91 = <span class="string">'title,Tilte,atre,'</span>.rsplit(<span class="string">'t'</span>,<span class="number">1</span>)</span><br><span class="line">print(ret91)</span><br><span class="line"></span><br><span class="line"><span class="comment"># join与split相对，若是str则以每个元素都以指定字符连接，多是给链表使用</span></span><br><span class="line">s1 = <span class="string">"advewvbe"</span></span><br><span class="line">s2 = <span class="string">"+"</span>.join(s1)</span><br><span class="line"><span class="comment">#  a+d+v+e+w+v+b+e</span></span><br><span class="line">l1 = [<span class="string">"2"</span>,<span class="string">"chjs"</span>,<span class="string">"你好"</span>]</span><br><span class="line">l2 = <span class="string">":"</span>.join(l1)</span><br><span class="line"><span class="comment">#  2:chjs:你好</span></span><br><span class="line"><span class="comment">#  列表中元素必须全是字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#寻找字符串中的元素是否存在</span></span><br><span class="line">ret6 = a4.find(<span class="string">"fjdk"</span>,<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line">print(ret6)  <span class="comment"># 返回的找到的元素的索引，如果找不到返回-1</span></span><br><span class="line"></span><br><span class="line">ret61 = a4.index(<span class="string">"fjdk"</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">print(ret61) <span class="comment"># 返回的找到的元素的索引，找不到报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#captalize,swapcase,title</span></span><br><span class="line">print(name.capitalize()) <span class="comment">#首字母大写</span></span><br><span class="line">print(name.swapcase()) <span class="comment">#大小写翻转</span></span><br><span class="line">msg=<span class="string">'taibai say hi'</span></span><br><span class="line">print(msg.title()) <span class="comment">#每个单词的首字母大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内同居中，总长度，空白处填充</span></span><br><span class="line">ret2 = a1.center(<span class="number">20</span>,<span class="string">"*"</span>)</span><br><span class="line">print(ret2)</span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>l1 = [100, ‘alex’,True,[1, 2, 3]] </p><ul><li>承载任意数据类型，存储大量的数据</li><li>python常用的容器型数据类型。相当于其他语言的数组</li><li>列表是有序的，可索引，切片（步长）</li></ul><h5 id="切片，索引"><a href="#切片，索引" class="headerlink" title="切片，索引"></a>切片，索引</h5><p>同str</p><h5 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表的创建</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="comment"># l1 = [1, 2, 'Alex']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二  对可迭代的数据类型</span></span><br><span class="line"><span class="comment"># l1 = list()</span></span><br><span class="line"><span class="comment"># l1 = list('fhdsjkafsdafhsdfhsdaf')</span></span><br><span class="line"><span class="comment"># print(l1)</span></span><br><span class="line"><span class="comment"># ['f', 'h', 'd', 's', 'j', 'k', 'h', 's', 'd', 'a', 'f']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式三：列表推导式</span></span><br><span class="line"><span class="comment"># [i(对i的简单处理) 循环(可多层，但一般最多两到三层) 条件]</span></span><br><span class="line"><span class="comment"># 循环模式[变量(加工的变量) for 变量 in iterable]</span></span><br><span class="line"><span class="comment"># 多层循环[变量(加工的变量) for i in iterable for j in iterable]</span></span><br><span class="line">l1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>)]</span><br><span class="line">print(l1)  <span class="comment"># [1, 2, 3, 4]</span></span><br><span class="line">l2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,<span class="number">11</span>)] + list(<span class="string">"JQKA"</span>)<span class="comment">#扑克(不完整)</span></span><br><span class="line"><span class="comment"># 筛选模式[变量(加工的变量) for 变量 in iterable if 条件]</span></span><br></pre></td></tr></table></figure><h5 id="列表的增删改查"><a href="#列表的增删改查" class="headerlink" title="列表的增删改查"></a>列表的增删改查</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增删改查</span></span><br><span class="line">l1 = [<span class="string">'太白'</span>, <span class="string">'女神'</span>, <span class="string">'xiao'</span>,<span class="string">'吴老师'</span>, <span class="string">'闫龙'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增：</span></span><br><span class="line"><span class="comment"># append:追加</span></span><br><span class="line"><span class="comment"># l1.append('xx')</span></span><br><span class="line"><span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># insert 插入</span></span><br><span class="line"><span class="comment"># l1.insert(2,'wusir')</span></span><br><span class="line"><span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#extend 迭代着追加</span></span><br><span class="line"><span class="comment"># l1.extend('abcd')</span></span><br><span class="line"><span class="comment"># l1.extend(['alex',])</span></span><br><span class="line"><span class="comment"># l1.extend(['alex', 1, 3])</span></span><br><span class="line"><span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="comment"># pop 按照索引位置删除，返回的是删除的元素</span></span><br><span class="line"><span class="comment"># l1.pop(-2)  # 按照索引删除</span></span><br><span class="line"><span class="comment"># print(l1.pop(-2))</span></span><br><span class="line"><span class="comment"># l1.pop()  # 默认删除最后一个</span></span><br><span class="line"><span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove  指定元素删除,如果有重名元素，默认删除从左数第一个</span></span><br><span class="line"><span class="comment"># l1.remove('xiao')</span></span><br><span class="line"><span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clear(了解)</span></span><br><span class="line"><span class="comment"># l1.clear() # 清空</span></span><br><span class="line"><span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># del</span></span><br><span class="line">    <span class="comment"># 按照索引删除</span></span><br><span class="line">    <span class="comment"># del l1[-1]</span></span><br><span class="line">    <span class="comment"># print(l1)</span></span><br><span class="line">    <span class="comment"># 按照切片(步长)删除</span></span><br><span class="line">    <span class="comment"># del l1[::2]</span></span><br><span class="line">    <span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">    <span class="comment"># 按照索引改值</span></span><br><span class="line">    <span class="comment"># l1[0] = '男神'</span></span><br><span class="line">    <span class="comment"># 按照切片改（了解）整个切片替换</span></span><br><span class="line">    <span class="comment"># l1[2:] = 'fsdafsdafsdfdsfsadfdsfdsgsfdag'</span></span><br><span class="line">    <span class="comment"># print(l1)</span></span><br><span class="line">    <span class="comment"># 按照切片（步长）逐个替换，对应个数必须相同</span></span><br><span class="line">    <span class="comment"># l1[::2] = 'abc'</span></span><br><span class="line">    <span class="comment"># l1[::2] = 'abcd'</span></span><br><span class="line">    <span class="comment"># print(l1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查：</span></span><br><span class="line"><span class="comment"># 索引，切片（步长）</span></span><br><span class="line"><span class="comment"># for i in l1:</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br></pre></td></tr></table></figure><h5 id="列表相加或相乘"><a href="#列表相加或相乘" class="headerlink" title="列表相加或相乘"></a>列表相加或相乘</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># print(l1+l2)  # [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">print(l1*<span class="number">3</span>)  <span class="comment"># [1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><p>count（数）（方法统计某个元素在列表中出现的次数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">"q"</span>,<span class="string">"w"</span>,<span class="string">"q"</span>,<span class="string">"r"</span>,<span class="string">"t"</span>,<span class="string">"y"</span>]</span><br><span class="line">print(a.count(<span class="string">"q"</span>))</span><br></pre></td></tr></table></figure><p>index（方法用于从列表中找出某个值第一个匹配项的索引位置）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">"q"</span>,<span class="string">"w"</span>,<span class="string">"r"</span>,<span class="string">"t"</span>,<span class="string">"y"</span>]</span><br><span class="line">print(a.index(<span class="string">"r"</span>))</span><br></pre></td></tr></table></figure><p>sort （方法用于在原位置对列表进行排序）</p><p> reverse （方法将列表中的元素反向存放）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.sort()<span class="comment"># 他没有返回值，所以只能打印a</span></span><br><span class="line">a.sort(reverse=<span class="literal">True</span>)<span class="comment"># 默认单增，这样可以单减</span></span><br><span class="line">print(a)</span><br><span class="line">a.reverse()<span class="comment">#他也没有返回值，所以只能打印a</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h5 id="列表的嵌套"><a href="#列表的嵌套" class="headerlink" title="列表的嵌套"></a>列表的嵌套</h5><p>相当于多维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">'taibai'</span>, [<span class="number">1</span>, <span class="string">'alex'</span>, <span class="number">3</span>,]]</span><br><span class="line"><span class="comment"># 1, 将l1中的'taibai'变成大写并放回原处。</span></span><br><span class="line"><span class="comment"># 2，给小列表[1,'alex',3,]追加一个元素,'老男孩教育'。</span></span><br><span class="line">l1[<span class="number">3</span>] = l1[<span class="number">3</span>].append(<span class="string">"老男孩教育"</span>)</span><br><span class="line"><span class="comment"># 3，将列表中的'alex'通过字符串拼接的方式在列表中变成'alexsb'</span></span><br></pre></td></tr></table></figure><h5 id="循环列表，改变列表大小的问题"><a href="#循环列表，改变列表大小的问题" class="headerlink" title="循环列表，改变列表大小的问题"></a>循环列表，改变列表大小的问题</h5><p>用这个进行举例：当你循环到22时，你将列表中的22删除了，但是你带来的影响是：33,44,55都会往前进一位，他们的索引由原来的2,3,4变成了1,2,3 所以你在往下进行循环时，就会发现，额……..完全不对了</p><p>所以for循环遍历本质是在<strong>按索引遍历</strong>，正序遍历时删除元素会打乱原有顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> len(l1):</span><br><span class="line">    <span class="keyword">if</span> index % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        l1.pop(index)</span><br><span class="line"><span class="comment"># [11,33,44]</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208200213.png" alt></p><ul><li>直接删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line"><span class="keyword">del</span> l1[<span class="number">1</span>::<span class="number">2</span>]</span><br></pre></td></tr></table></figure><ul><li>倒序删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l1)<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">l1.pop(i)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208201450.png" alt></p><ul><li>思维转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">new_l1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> len(l1):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        new_l1.append(i)</span><br><span class="line">l1 = new_l1</span><br></pre></td></tr></table></figure><p>循环一个列表时<strong>最好不要改变</strong>列表的大小，容易出现错误</p><p>必须修改时可以用<strong>上诉三种方法</strong></p><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p>俗称不可变的列表,又被成为只读列表,也是python的基本数据类型之一,用小括号括起来,里面可以放任何数据类型的数据,查询可以,循环也可以,切片也可以.但就是不能改.</p><p>当元组中包含可变类型时，其仍可变，如包含链表时，该链表仍可修改</p><p>python中元组有一个特性，元组中如果只含有一个元素且没有逗号，则该元组不是元组，与改元素数据类型一致，如果有逗号，那么它是元组</p><p><strong>拆包专用</strong>，虽然链表也可以拆</p><h5 id="拆包-分别赋值"><a href="#拆包-分别赋值" class="headerlink" title="拆包(分别赋值)"></a>拆包(分别赋值)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">print(a,b)</span><br><span class="line">结果:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">a,b = (<span class="string">'你好'</span>,<span class="string">'世界'</span>)  <span class="comment"># 这个用专业名词就叫做元组的拆包</span></span><br><span class="line">print(a,b)</span><br><span class="line">结果:</span><br><span class="line">你好 世界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a,b = [<span class="string">'你好'</span>,<span class="string">'大飞哥'</span>]</span><br><span class="line">print(a,b)</span><br><span class="line">结果:</span><br><span class="line">你好 世界</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a,b = &#123;<span class="string">'汪峰'</span>:<span class="string">'北京北京'</span>,<span class="string">'王菲'</span>:<span class="string">'天后'</span>&#125;</span><br><span class="line">print(a,b)</span><br><span class="line">结果:</span><br><span class="line">汪峰 王菲</span><br></pre></td></tr></table></figure><h5 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tu1 = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'太白'</span>, <span class="number">3</span>, <span class="number">666</span>)</span><br><span class="line">print(tu1[<span class="number">0</span>])  <span class="comment"># 'a'</span></span><br><span class="line">print(tu1[<span class="number">-1</span>])  <span class="comment"># 666</span></span><br><span class="line">print(tu1[<span class="number">1</span>:<span class="number">3</span>])  <span class="comment"># ('b', '太白')</span></span><br><span class="line">print(tu1[:<span class="number">-1</span>])  <span class="comment"># ('a', 'b', '太白', 3)</span></span><br><span class="line">print(tu1[::<span class="number">2</span>])  <span class="comment"># ('a', '太白', 666)</span></span><br><span class="line">print(tu1[::<span class="number">-1</span>])  <span class="comment"># (666, 3, '太白', 'b', 'a')</span></span><br></pre></td></tr></table></figure><h5 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h5><p>因为元组的特性，直接从属于元组的元素不能更改，所以元组只能查看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以利用for循环查询</span></span><br><span class="line"></span><br><span class="line">tu1 = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'太白'</span>, <span class="number">3</span>, <span class="number">666</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tu1:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p><strong>index</strong>：通过元素找索引（可切片），找到第一个元素就返回，找不到该元素即报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tu = (<span class="string">'太白'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ], <span class="string">'WuSir'</span>, <span class="string">'女神'</span>)</span><br><span class="line">print(tu.index(<span class="string">'太白'</span>)) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><p><strong>count</strong>: 获取某元素在列表中出现的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tu = (<span class="string">'太白'</span>, <span class="string">'太白'</span>, <span class="string">'WuSir'</span>, <span class="string">'吴超'</span>)</span><br><span class="line">print(tu.count(<span class="string">'太白'</span>)) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h4 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h4><p>字典是Python语言中的映射类型，他是以{}括起来，里面的内容是以键值对的形式储存的：</p><p> Key: 不可变（可哈希）的数据类型.并且键是唯一的，不重复的。</p><p> Value:任意数据(int，str，bool，tuple，list，dict，set)，包括后面要学的实例对象等。</p><p>在Python3.5版本（包括此版本）之前，字典是无序的。</p><p>在Python3.6版本之后，字典会按照初建字典时的顺序排列(即第一次插入数据的顺序排序)。</p><p>当然，字典也有缺点：他的缺点就是内存消耗巨大。</p><h5 id="为何查询快？"><a href="#为何查询快？" class="headerlink" title="为何查询快？"></a>为何查询快？</h5><p>底层用了散列表</p><p><img src="http://crm.pythonav.com/media/uploads/2019/03/28/IMAGE.PNG" alt></p><h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1:元组</span></span><br><span class="line">dic = dict(((<span class="string">'one'</span>, <span class="number">1</span>),(<span class="string">'two'</span>, <span class="number">2</span>),(<span class="string">'three'</span>, <span class="number">3</span>)))</span><br><span class="line"><span class="comment"># dic = dict([('one', 1),('two', 2),('three', 3)])</span></span><br><span class="line">print(dic)  <span class="comment"># &#123;'one': 1, 'two': 2, 'three': 3&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2:关键字</span></span><br><span class="line">dic = dict(one=<span class="number">1</span>,two=<span class="number">2</span>,three=<span class="number">3</span>)</span><br><span class="line">print(dic)  <span class="comment"># &#123;'one': 1, 'two': 2, 'three': 3&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3:键值对</span></span><br><span class="line">dic = dict(&#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">print(dic)  <span class="comment"># &#123;'one': 1, 'two': 2, 'three': 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式5:内置函数zip</span></span><br><span class="line">dic = dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>],[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式6:字典推导式</span></span><br><span class="line">dic = &#123; k: v <span class="keyword">for</span> k,v <span class="keyword">in</span> [(<span class="string">'one'</span>, <span class="number">1</span>),(<span class="string">'two'</span>, <span class="number">2</span>),(<span class="string">'three'</span>, <span class="number">3</span>)]&#125;</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式7:利用fromkey("keys(可迭代类型)","所有键共用的值")</span></span><br><span class="line">dic = dict.fromkeys(<span class="string">'abcd'</span>,<span class="string">'太白'</span>)</span><br><span class="line">print(dic) <span class="comment"># &#123;'a': '太白', 'b': '太白', 'c': '太白', 'd': '太白'&#125;</span></span><br><span class="line"></span><br><span class="line">dic = dict.fromkeys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],<span class="string">'太白'</span>)</span><br><span class="line">print(dic) <span class="comment"># &#123;1: '太白', 2: '太白', 3: '太白'&#125; </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里有一个坑，就是如果通过fromkeys得到的字典的值为可变的数据类型，那么你的小心了。</span></span><br><span class="line">dic = dict.fromkeys([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [])</span><br><span class="line">dic[<span class="number">1</span>].append(<span class="number">666</span>)</span><br><span class="line">print(id(dic[<span class="number">1</span>]),id(dic[<span class="number">2</span>]),id(dic[<span class="number">3</span>]))  <span class="comment"># &#123;1: [666], 2: [666], 3: [666]&#125;</span></span><br><span class="line">print(dic)  <span class="comment"># &#123;1: [666], 2: [666], 3: [666]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">lst1 = [<span class="string">'jay'</span>,<span class="string">'jj'</span>,<span class="string">'meet'</span>]</span><br><span class="line">lst2 = [<span class="string">'周杰伦'</span>,<span class="string">'林俊杰'</span>,<span class="string">'郭宝元'</span>]</span><br><span class="line">dic = &#123;lst1[i]:lst2[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst1))&#125;</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure><h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增</span></span><br><span class="line">    <span class="comment"># 通过键值对直接增加  有则改之，无则增加</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    dic[<span class="string">'weight'</span>] = <span class="number">75</span> <span class="comment"># 没有weight这个键，就增加键值对</span></span><br><span class="line">    print(dic) <span class="comment"># &#123;'name': '太白', 'age': 18, 'weight': 75&#125;</span></span><br><span class="line">    dic[<span class="string">'name'</span>] = <span class="string">'barry'</span> <span class="comment"># 有name这个键，就成了字典的改值</span></span><br><span class="line">    print(dic) <span class="comment"># &#123;'name': 'barry', 'age': 18, 'weight': 75&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># setdefault有则不变，无则加之</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    dic.setdefault(<span class="string">'height'</span>,<span class="number">175</span>) <span class="comment"># 没有height此键，则添加</span></span><br><span class="line">    print(dic) <span class="comment"># &#123;'name': '太白', 'age': 18, 'height': 175&#125;</span></span><br><span class="line">    dic.setdefault(<span class="string">'name'</span>,<span class="string">'barry'</span>) <span class="comment"># 有此键则不变</span></span><br><span class="line">    print(dic) <span class="comment"># &#123;'name': '太白', 'age': 18, 'height': 175&#125;</span></span><br><span class="line">    <span class="comment">#它有返回值可用于查看</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    ret = dic.setdefault(<span class="string">'name'</span>)</span><br><span class="line">    print(ret)  <span class="comment"># 太白</span></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">    <span class="comment"># pop 通过key删除字典的键值对，有返回值，可设置返回值。</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    <span class="comment"># ret = dic.pop('name')</span></span><br><span class="line">    <span class="comment"># print(ret,dic) # 太白 &#123;'age': 18&#125;</span></span><br><span class="line">    ret1 = dic.pop(<span class="string">'n'</span>,<span class="literal">None</span>)</span><br><span class="line">    print(ret1,dic) <span class="comment"># None &#123;'name': '太白', 'age': 18&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#popitem 3.5版本之前，popitem为随机删除，3.6之后为删除最后一个，有返回值</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    ret = dic.popitem()</span><br><span class="line">    print(ret,dic) <span class="comment"># ('age', 18) &#123;'name': '太白'&#125;</span></span><br><span class="line"><span class="comment"># 值可以重复，所以不像其他有remove方法</span></span><br><span class="line">    <span class="comment"># clear 清空字典</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    dic.clear()</span><br><span class="line">    print(dic) <span class="comment"># &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># del</span></span><br><span class="line">    <span class="comment"># 通过键删除键值对</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    <span class="keyword">del</span> dic[<span class="string">'name'</span>]</span><br><span class="line">    print(dic) <span class="comment"># &#123;'age': 18&#125;</span></span><br><span class="line">    <span class="comment">#删除整个字典</span></span><br><span class="line">    <span class="keyword">del</span> dic</span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">    <span class="comment"># 通过键值对直接改</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    dic[<span class="string">'name'</span>] = <span class="string">'barry'</span></span><br><span class="line">    print(dic) <span class="comment"># &#123;'name': 'barry', 'age': 18&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># update类似于创建字典</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    </span><br><span class="line">    dic.update(sex=<span class="string">'男'</span>, height=<span class="number">175</span>)</span><br><span class="line">    print(dic) <span class="comment"># &#123;'name': '太白', 'age': 18, 'sex': '男', 'height': 175&#125;</span></span><br><span class="line"></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    dic.update([(<span class="number">1</span>, <span class="string">'a'</span>),(<span class="number">2</span>, <span class="string">'b'</span>),(<span class="number">3</span>, <span class="string">'c'</span>),(<span class="number">4</span>, <span class="string">'d'</span>)])</span><br><span class="line">    print(dic) <span class="comment"># &#123;'name': '太白', 'age': 18, 1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有则加之，无则不变</span></span><br><span class="line">    dic1 = &#123;<span class="string">"name"</span>:<span class="string">"jin"</span>,<span class="string">"age"</span>:<span class="number">18</span>,<span class="string">"sex"</span>:<span class="string">"male"</span>&#125;</span><br><span class="line">    dic2 = &#123;<span class="string">"name"</span>:<span class="string">"alex"</span>,<span class="string">"weight"</span>:<span class="number">75</span>&#125;</span><br><span class="line">    dic1.update(dic2)</span><br><span class="line">    print(dic1) <span class="comment"># &#123;'name': 'alex', 'age': 18, 'sex': 'male', 'weight': 75&#125;</span></span><br><span class="line">    print(dic2) <span class="comment"># &#123;'name': 'alex', 'weight': 75&#125; </span></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line">    <span class="comment"># 通过键查询</span></span><br><span class="line">    <span class="comment"># 直接dic[key](没有此键会报错)</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    print(dic[<span class="string">'name'</span>]) <span class="comment"># 太白</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get</span></span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    v = dic.get(<span class="string">'name'</span>)</span><br><span class="line">    print(v) <span class="comment"># '太白'</span></span><br><span class="line">    v = dic.get(<span class="string">'name1'</span>)</span><br><span class="line">    print(v) <span class="comment"># None</span></span><br><span class="line">    v = dic.get(<span class="string">'name2'</span>,<span class="string">'没有此键'</span>)</span><br><span class="line">    print(v) <span class="comment"># 没有此键 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    keys()</span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    print(dic.keys()) <span class="comment"># dict_keys(['name', 'age']) </span></span><br><span class="line"></span><br><span class="line">    values()</span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    print(dic.values()) <span class="comment"># dict_values(['太白', 18])</span></span><br><span class="line"></span><br><span class="line">    items()</span><br><span class="line">    dic = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">    print(dic.items()) <span class="comment"># dict_items([('name', '太白'), ('age', 18)])</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    dict_keys(['name', 'age'])  dict_values(['太白', 18]) dict_items([('name', '太白'), ('age', 18)])</span></span><br><span class="line"><span class="string">    这些高仿的列表可以用于for循环，亦可传入list()来转换为真正的列表</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><h5 id="字典的嵌套"><a href="#字典的嵌套" class="headerlink" title="字典的嵌套"></a>字典的嵌套</h5><h5 id="循环字典，改变字典大小的问题"><a href="#循环字典，改变字典大小的问题" class="headerlink" title="循环字典，改变字典大小的问题"></a>循环字典，改变字典大小的问题</h5><p>来，先来研究一个小题，有如下字典：</p><p>dic = {‘k1’:’太白’,’k2’:’barry’,’k3’: ‘白白’, ‘age’: 18} 请将字典中所有键带k元素的键值对删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'太白'</span>,<span class="string">'k2'</span>:<span class="string">'barry'</span>,<span class="string">'k3'</span>: <span class="string">'白白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'k'</span> <span class="keyword">in</span> i:</span><br><span class="line">        <span class="keyword">del</span> dic[i]</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你会发现，报错了。。。。。</span></span><br><span class="line"><span class="comment"># 错误原因：</span></span><br><span class="line"><span class="comment"># RuntimeError: dictionary changed size during iteration</span></span><br><span class="line"><span class="comment"># 翻译过来是：字典在循环迭代时，改变了大小。</span></span><br></pre></td></tr></table></figure><p>所以说，他和列表差不多，只不过比列表更暴力一些，对其进行总结就是：</p><p>在循环一个字典的过程中，<strong>不要改变字典的大小</strong>（增，删字典的元素），这样会直接报错。</p><ul><li>思维转换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l1 = []</span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'太白'</span>,<span class="string">'k2'</span>:<span class="string">'barry'</span>,<span class="string">'k3'</span>: <span class="string">'白白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dic:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'k'</span> <span class="keyword">in</span> key:</span><br><span class="line">        l1.append(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">    dic.pop(i)</span><br></pre></td></tr></table></figure><ul><li>简化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'太白'</span>,<span class="string">'k2'</span>:<span class="string">'barry'</span>,<span class="string">'k3'</span>: <span class="string">'白白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> list(dic.keys()):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'k'</span> <span class="keyword">in</span> key:</span><br><span class="line">        dic.pop(key)</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>集合是无序的，不重复的数据集合</p><p>它里面的元素是可哈希的(不可变类型)，但是集合本身不可哈希（所以集合做不了字典的键）</p><p>以下是集合最重要的两点：</p><p>　　<strong>去重</strong>，把一个列表变成集合，就自动去重了。</p><p>　　<strong>关系测试</strong>，测试两组数据之前的交集、差集、并集等关系。</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一</span></span><br><span class="line">set1 = set(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">'barry'</span>&#125;)</span><br><span class="line"><span class="comment"># 二</span></span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">'barry'</span>&#125;</span><br><span class="line">print(set1,set2)  <span class="comment"># &#123;1, 2, 'barry'&#125; &#123;1, 2, 'barry'&#125;</span></span><br><span class="line"><span class="comment"># 集合推导式</span></span><br><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-3</span>,<span class="number">-7</span>,<span class="number">9</span>]</span><br><span class="line">s = &#123;abs(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst&#125;</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h5 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 增</span></span><br><span class="line">    set1 = &#123;<span class="string">'alex'</span>,<span class="string">'wusir'</span>,<span class="string">'ritian'</span>,<span class="string">'egon'</span>,<span class="string">'barry'</span>&#125;</span><br><span class="line">    set1.add(<span class="string">'景女神'</span>)</span><br><span class="line">    print(set1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#update：迭代着增加</span></span><br><span class="line">    set1.update(<span class="string">'A'</span>)</span><br><span class="line">    print(set1)</span><br><span class="line">    set1.update(<span class="string">'老师'</span>)</span><br><span class="line">    print(set1)</span><br><span class="line">    set1.update([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">    print(set1)</span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line">    set1 = &#123;<span class="string">'alex'</span>,<span class="string">'wusir'</span>,<span class="string">'ritian'</span>,<span class="string">'egon'</span>,<span class="string">'barry'</span>&#125;</span><br><span class="line"><span class="comment"># 因为无序，所以没有按所以删除</span></span><br><span class="line">    set1.remove(<span class="string">'alex'</span>)  <span class="comment"># 按内容删</span></span><br><span class="line">    print(set1)</span><br><span class="line"></span><br><span class="line">    set1.pop()  <span class="comment"># 随机删除一个元素</span></span><br><span class="line">    print(set1)</span><br><span class="line"></span><br><span class="line">    set1.clear()  <span class="comment"># 清空集合</span></span><br><span class="line">    print(set1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> set1  <span class="comment"># 删除集合</span></span><br><span class="line">    print(set1)</span><br><span class="line"><span class="comment"># 无序，所以无法改查</span></span><br><span class="line"><span class="comment"># 但改可以通过先把要改元素删除，再把要改成的数据作为新值加入</span></span><br></pre></td></tr></table></figure><h5 id="集合的其他操作"><a href="#集合的其他操作" class="headerlink" title="集合的其他操作"></a>集合的其他操作</h5><p>4.1 交集。（&amp; 或者 intersection）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">print(set1 &amp; set2)  <span class="comment"># &#123;4, 5&#125;</span></span><br><span class="line">print(set1.intersection(set2))  <span class="comment"># &#123;4, 5&#125;</span></span><br></pre></td></tr></table></figure><p>　　4.2 并集。（| 或者 union）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">print(set1 | set2)  <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7,8&#125;print(set2.union(set1))  # &#123;1, 2, 3, 4, 5, 6, 7,8&#125;</span></span><br></pre></td></tr></table></figure><p>　　4.3 差集。（- 或者 difference）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">print(set1 - set2)  <span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line">print(set1.difference(set2))  <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure><p> 　4.4反交集。 （^ 或者 symmetric_difference）        排斥或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">print(set1 ^ set2)  <span class="comment"># &#123;1, 2, 3, 6, 7, 8&#125;</span></span><br><span class="line">print(set1.symmetric_difference(set2))  <span class="comment"># &#123;1, 2, 3, 6, 7, 8&#125;</span></span><br></pre></td></tr></table></figure><p>　　4.5子集与超集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">print(set1 &lt; set2)</span><br><span class="line">print(set1.issubset(set2))  <span class="comment"># 这两个相同，都是说明set1是set2子集。</span></span><br><span class="line"></span><br><span class="line">print(set2 &gt; set1)</span><br><span class="line">print(set2.issuperset(set1))  <span class="comment"># 这两个相同，都是说明set2是set1超集。</span></span><br></pre></td></tr></table></figure><p>5，frozenset不可变集合，让集合变成不可变类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = frozenset(<span class="string">'barry'</span>)</span><br><span class="line">print(s,type(s))  <span class="comment"># frozenset(&#123;'a', 'y', 'b', 'r'&#125;) &lt;class 'frozenset'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h3><h4 id="bool，int，str互化"><a href="#bool，int，str互化" class="headerlink" title="bool，int，str互化"></a>bool，int，str互化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int ---&gt; bool</span></span><br><span class="line">i = <span class="number">100</span></span><br><span class="line">print(bool(i))  <span class="comment"># True  # 非零即True</span></span><br><span class="line">i1 = <span class="number">0</span></span><br><span class="line">print(bool(i1))  <span class="comment"># False 零即False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bool ---&gt; int</span></span><br><span class="line">t = <span class="literal">True</span></span><br><span class="line">print(int(t))  <span class="comment"># 1  True --&gt; 1</span></span><br><span class="line">t = <span class="literal">False</span></span><br><span class="line">print(int(t))  <span class="comment"># 0  False --&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int ---&gt; str</span></span><br><span class="line">i1 = <span class="number">100</span></span><br><span class="line">print(str(i1))  <span class="comment"># '100'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str ---&gt; int  # 全部由数字组成的字符串才可以转化成数字</span></span><br><span class="line">s1 = <span class="string">'90'</span></span><br><span class="line">print(int(s1))  <span class="comment"># 90</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str ---&gt; bool</span></span><br><span class="line">s1 = <span class="string">'太白'</span></span><br><span class="line">s2 = <span class="string">''</span></span><br><span class="line">print(bool(s1))  <span class="comment"># True 非空即True</span></span><br><span class="line">print(bool(s2))  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># bool ---&gt; str</span></span><br><span class="line">t1 = <span class="literal">True</span></span><br><span class="line">print(str(<span class="literal">True</span>))  <span class="comment"># 'True'</span></span><br></pre></td></tr></table></figure><h4 id="str，list互化"><a href="#str，list互化" class="headerlink" title="str，list互化"></a>str，list互化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str ---&gt; list</span></span><br><span class="line">s1 = <span class="string">'alex 太白 武大'</span></span><br><span class="line">print(s1.split())  <span class="comment"># ['alex', '太白', '武大']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list ---&gt; str  # 前提 list 里面所有的元素必须是字符串类型才可以</span></span><br><span class="line">l1 = [<span class="string">'alex'</span>, <span class="string">'太白'</span>, <span class="string">'武大'</span>]</span><br><span class="line">print(<span class="string">' '</span>.join(l1))  <span class="comment"># 'alex 太白 武大'</span></span><br></pre></td></tr></table></figure><h4 id="list-set互化"><a href="#list-set互化" class="headerlink" title="list set互化"></a>list set互化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list ---&gt; set</span></span><br><span class="line">s1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">print(set(s1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set ---&gt; list</span></span><br><span class="line">set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>,&#125;</span><br><span class="line">print(list(set1))  <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="str，bytes互化"><a href="#str，bytes互化" class="headerlink" title="str，bytes互化"></a>str，bytes互化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str ---&gt; bytes</span></span><br><span class="line">s1 = <span class="string">'太白'</span></span><br><span class="line">print(s1.encode(<span class="string">'utf-8'</span>))  <span class="comment"># b'\xe5\xa4\xaa\xe7\x99\xbd'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes ---&gt; str</span></span><br><span class="line">b = <span class="string">b'\xe5\xa4\xaa\xe7\x99\xbd'</span></span><br><span class="line">print(b.decode(<span class="string">'utf-8'</span>))  <span class="comment"># '太白'</span></span><br></pre></td></tr></table></figure><h4 id="所有皆可转为bool"><a href="#所有皆可转为bool" class="headerlink" title="所有皆可转为bool"></a>所有皆可转为bool</h4><p>转化成bool值为False的数据类型有：<br>‘’, 0, (), {}, [], set(), None</p><h3 id="基础数据类型总结"><a href="#基础数据类型总结" class="headerlink" title="基础数据类型总结"></a>基础数据类型总结</h3><p><a href="https://www.processon.com/view/link/5c99fe1fe4b0353e3c62e606#map" target="_blank" rel="noopener">思维导图</a></p><h4 id="按存储空间的占用分（从低到高）"><a href="#按存储空间的占用分（从低到高）" class="headerlink" title="按存储空间的占用分（从低到高）"></a>按存储空间的占用分（从低到高）</h4><p>数字<br>字符串<br>集合：无序，即无序存索引相关信息<br>元组：有序，需要存索引相关信息，不可变<br>列表：有序，需要存索引相关信息，可变，需要处理数据的增删改<br>字典：有序，需要存key与value映射的相关信息，可变，需要处理数据的增删改（3.6之后有序）</p><h4 id="按存值个数区分"><a href="#按存值个数区分" class="headerlink" title="按存值个数区分"></a>按存值个数区分</h4><table><thead><tr><th>标量／原子类型</th><th>数字，字符串</th></tr></thead><tbody><tr><td>容器类型</td><td>列表，元组，字典</td></tr></tbody></table><h4 id="按可变不可变区分"><a href="#按可变不可变区分" class="headerlink" title="按可变不可变区分"></a>按可变不可变区分</h4><table><thead><tr><th>可变</th><th>列表，字典</th></tr></thead><tbody><tr><td>不可变</td><td>数字，字符串，元组，布尔值</td></tr></tbody></table><h4 id="按访问顺序区分"><a href="#按访问顺序区分" class="headerlink" title="按访问顺序区分"></a>按访问顺序区分</h4><table><thead><tr><th>直接访问</th><th>数字</th></tr></thead><tbody><tr><td>顺序访问（序列类型）</td><td>字符串，列表，元组</td></tr><tr><td>key值访问（映射类型）</td><td>字典</td></tr></tbody></table><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>相当于生活中的一次次决策</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本结构</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    结果</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> int(age) &gt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'恭喜你，成年了'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'小屁孩儿'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 多个条件，python中无switch...case...    </span></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'晚上请你吃饭'</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">3</span>:</span><br><span class="line">    print(<span class="string">'一起溜达'</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">2</span>:</span><br><span class="line">    print(<span class="string">'请你大宝剑'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'太笨了....'</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># if可以嵌套</span></span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>用于重复执行的代码，一般没有明确次数用while，有确定次数用for</p><p>一般得在循环体内改变条件，或使用break，否则会出现死循环</p><p><img src="http://crm.pythonav.com/media/uploads/2019/03/27/IMAGE.PNG" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">在循环正常结束时执行</span><br><span class="line">若通过<span class="keyword">break</span>跳出则不执行</span><br></pre></td></tr></table></figure><p>continue：跳过本次条件</p><p>break：跳出循环</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> str:</span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure><p>for…else   同while用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">'老男孩python是全国范围内最好的python培训机构'</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> msg:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line">li = [<span class="string">'alex'</span>,<span class="string">'银角'</span>,<span class="string">'女神'</span>,<span class="string">'egon'</span>,<span class="string">'太白'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> li:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">'name'</span>:<span class="string">'太白'</span>,<span class="string">'age'</span>:<span class="number">18</span>,<span class="string">'sex'</span>:<span class="string">'man'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dic.items():</span><br><span class="line">    print(k,v)</span><br></pre></td></tr></table></figure><h4 id="与循环配合的方法"><a href="#与循环配合的方法" class="headerlink" title="与循环配合的方法"></a>与循环配合的方法</h4><h5 id="range"><a href="#range" class="headerlink" title="range"></a>range</h5><p>指定范围，生成指定数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>):  <span class="comment"># 步长</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">1</span>,<span class="number">-2</span>): <span class="comment"># 反向步长</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h5 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h5><p>枚举，对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">li = [<span class="string">'alex'</span>,<span class="string">'银角'</span>,<span class="string">'女神'</span>,<span class="string">'egon'</span>,<span class="string">'太白'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enumerate(li):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> index,name <span class="keyword">in</span> enumerate(li,<span class="number">1</span>):</span><br><span class="line">    print(index,name)</span><br><span class="line"><span class="keyword">for</span> index, name <span class="keyword">in</span> enumerate(li, <span class="number">100</span>):  <span class="comment"># 起始位置默认是0，可更改</span></span><br><span class="line">    print(index, name)</span><br></pre></td></tr></table></figure><h3 id="控制台输入输出"><a href="#控制台输入输出" class="headerlink" title="控制台输入输出"></a>控制台输入输出</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">"请输入用户名"</span>)</span><br></pre></td></tr></table></figure><h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"name"</span>)</span><br><span class="line"><span class="comment"># 默认输出自带换行</span></span><br><span class="line">print(name,end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h4><p>计算机存储，传输文件底层都是二进制码</p><p>解码：将二进制文件按对应编码还原为数据</p><p>编码：将数据按指定编码转为二进制数据</p><h4 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h4><h5 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h5><p>最早的编码，只包含英文字母，数字，特殊字符</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>0</td><td>48</td></tr><tr><td>9</td><td>57</td></tr><tr><td>A</td><td>65</td></tr><tr><td>Z</td><td>90</td></tr><tr><td>a</td><td>97</td></tr><tr><td>z</td><td>122</td></tr></tbody></table><p><strong>每个字符对应8bit</strong></p><h5 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h5><p>国标，包含英文字母，数字，特殊字符，中文</p><p><strong>一个英文字符占1byte</strong></p><p><strong>一个中文字符占2byte</strong></p><h5 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h5><p>万国码，把世界上所有的文字都记录</p><p>起初每个字符用2byte，后来为了记录所有，每个字符用4byte</p><p>虽然全面，但浪费资源</p><h5 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h5><p>Unicode升级版</p><table><thead><tr><th align="left">字符</th><th align="left">大小</th></tr></thead><tbody><tr><td align="left">英文</td><td align="left">1byte</td></tr><tr><td align="left">欧洲文字</td><td align="left">2byte</td></tr><tr><td align="left">中文，亚洲文字</td><td align="left">3byte</td></tr></tbody></table><h4 id="数据大小"><a href="#数据大小" class="headerlink" title="数据大小"></a>数据大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8bit = 1byte</span><br><span class="line">1024byte = 1KB</span><br><span class="line">1024KB = 1MB</span><br><span class="line">1024MB = 1GB</span><br><span class="line">1024GB = 1TB</span><br><span class="line">1024TB = 1PB</span><br><span class="line">1024TB = 1EB</span><br><span class="line">1024EB = 1ZB</span><br><span class="line">1024ZB = 1YB</span><br><span class="line">1024YB = 1NB</span><br><span class="line">1024NB = 1DB</span><br></pre></td></tr></table></figure><h4 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h4><p>　　<strong>1. 在计算机内存中，统一使用Unicode编码，当需要将数据保存到硬盘或者需要网络传输的时候，就转换为非Unicode编码比如：UTF-8编码。</strong></p><p>　　其实这个不用深入理解，他就是规定，举个例子：用文件编辑器（word，wps,等）编辑文件的时候，从文件将你的数据（此时你的数据是非Unicode（可能是UTF-8，也可能是gbk，这个编码取决于你的编辑器设置））字符被转换为Unicode字符读到内存里，进行相应的编辑，编辑完成后，保存的时候再把Unicode转换为非Unicode（UTF-8，GBK 等）保存到文件。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208211253.png" alt></p><p>　　<strong>2. 不同编码之间，不能直接互相识别。</strong></p><p>　　比如你的一个数据：‘老铁没毛病’是以utf-8的编码方式编码并发送给一个朋友，那么你发送的肯定是通过utf-8的编码转化成的二进制01010101，那么你的朋友接收到你发的这个数据，他如果想查看这个数据必须将01010101转化成汉字，才可以查看，那么此时那也必须通过utf-8编码反转回去，如果要是通过gbk编码反转，那么这个内容可能会出现乱码或者报错</p><p><strong>前提条件</strong>：python3x版本（python2x版本与这个不同）。</p><p><strong>主要用途</strong>：数据的存储或者传输。</p><p>刚才咱们也说过了，在计算机内存中，统一使用Unicode编码，当需要将数据<strong>保存到硬盘或者需要网络传输</strong>的时候，就转换为非Unicode编码比如：UTF-8编码</p><h4 id="引例：网络传输"><a href="#引例：网络传输" class="headerlink" title="引例：网络传输"></a>引例：网络传输</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208211432.png" alt></p><p>解决方式：用bytes做中介</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208211510.png" alt></p><h4 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h4><table><thead><tr><th>类名</th><th>str类型</th><th>bytes类型</th><th>标注</th></tr></thead><tbody><tr><td>名称</td><td>str,字符串,文本文字</td><td>bytes,字节文字</td><td></td></tr><tr><td>组成单位</td><td>字符</td><td>字节</td><td></td></tr><tr><td>组成形式</td><td>‘’ 或者 “” 或者 ‘’’ ‘’’ 或者 “”” “””</td><td>b’’ 或者 b”” 或者 b’’’ ‘’’ 或者 b””” “””</td><td>不同，bytes类型就是在引号前面+b(B)大小写都可以</td></tr><tr><td>表现形式</td><td>英文： ‘alex’ 中文： ‘中国’</td><td>英文：b’alex’中文：b’\xe4\xb8\xad\xe5\x9b\xbd’</td><td>字节文字对于ascii中的元素是可以直接显示的。</td></tr><tr><td>编码方式</td><td>Unicode</td><td>可指定编码（除Unicode之外）比如UTF-8，GBK 等</td><td>非ascii码中的元素是以十六进制的形式表示的</td></tr><tr><td>相应功能</td><td>upper lower spllit 等等</td><td>upper lower spllit 等等</td><td>几乎相同</td></tr><tr><td>转译</td><td>可在最前面加r进行转译</td><td>可在最前面加r进行转译</td><td>相同</td></tr><tr><td>重要用途</td><td>python基础数据类型，用于存储少量的常用的数据</td><td>负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。<br>Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等<br>bytes是唯一可以指定编码化为非unicode编码的</td><td>bytes就是用于数据存储和网络传输数据</td></tr></tbody></table><p>bytes类型也称作字节文本，他的主要用途就是网络的数据传输，与数据存储。那么有些同学肯定问，bytes类型既然与str差不多，而且操作方法也很相似，就是在字符串前面加个b不就行了，python为什么还要这两个数据类型呢？我只用bytes不行么？</p><p>如果你只用bytes开发，不方便。因为对于非ascii码里面的文字来说，bytes只是显示的是16进制。很不方便。</p><h4 id="str-bytes互化"><a href="#str-bytes互化" class="headerlink" title="str bytes互化"></a>str bytes互化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过编码将str转为对应bytes</span></span><br><span class="line"><span class="comment"># encode称作编码:将 str 转化成 bytes类型</span></span><br><span class="line">s1 = <span class="string">'中国'</span></span><br><span class="line">b1 = s1.encode(<span class="string">'utf-8'</span>)  <span class="comment"># 转化成utf-8的bytes类型</span></span><br><span class="line">print(s1)  <span class="comment"># 中国</span></span><br><span class="line">print(b1)  <span class="comment"># b'\xe4\xb8\xad\xe5\x9b\xbd'</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">'中国'</span></span><br><span class="line">b1 = s1.encode(<span class="string">'gbk'</span>)  <span class="comment"># 转化成gbk的bytes类型</span></span><br><span class="line">print(s1)  <span class="comment"># 中国</span></span><br><span class="line">print(b1)  <span class="comment"># b'\xd6\xd0\xb9\xfa'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过解码将bytes还原为对应字符串</span></span><br><span class="line"><span class="comment"># decode称作解码, 将 bytes 转化成 str类型</span></span><br><span class="line">b1 = <span class="string">b'\xe4\xb8\xad\xe5\x9b\xbd'</span></span><br><span class="line">s1 = b1.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(s1)  <span class="comment"># 中国</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200209135539.png" alt></p><h4 id="不同编码间转换"><a href="#不同编码间转换" class="headerlink" title="不同编码间转换"></a>不同编码间转换</h4><p>本质为不同编码形成的bytes，故以str为中介</p><p>示例：将gbk转为utf-8</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208215158.png" alt></p><h3 id="代码块和缓存机制"><a href="#代码块和缓存机制" class="headerlink" title="代码块和缓存机制"></a>代码块和缓存机制</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>Python程序是由代码块构造的。块是一个python程序的文本，他是作为一个单元执行的。</p><p>代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。</p><p>而作为交互方式输入的每个命令都是一个代码块</p><h4 id="代码块的缓存机制"><a href="#代码块的缓存机制" class="headerlink" title="代码块的缓存机制"></a>代码块的缓存机制</h4><ul><li><p><strong>前提条件</strong>：在同一个代码块内。</p></li><li><p><strong>机制内容：</strong>Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用。换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这个值。所以在你给出的例子中，文件执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足缓存机制则他们在内存中只存在一个，即：id相同。</p></li><li><p><strong>适用对象</strong>： int（float），str，bool。</p></li><li><p>变量之间相互赋值时都是直接指向了这些对象，而不是相互指向</p></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183914.png" alt></p><ul><li><strong>对象的具体细则：（了解）</strong></li></ul><p>int(float):任何数字在同一代码块下都会复用。</p><p>bool:True和False在字典中会以1，0方式存在，并且复用。</p><p>str：几乎所有的字符串都会符合缓存机制，具体规定如下（<strong>了解即可！</strong>）：</p><blockquote><p>1，非乘法得到的字符串都满足代码块的缓存机制：</p><p>2,乘法得到的字符串分两种情况：</p><blockquote><p>2.1 乘数为1时，任何字符串满足代码块的缓存机制：</p><p>2.2 乘数&gt;=2时：仅含大小写字母，数字，下划线，总长度&lt;=20，满足代码块的缓存机制：</p></blockquote></blockquote><ul><li>优点</li></ul><p>能够提高一些字符串，整数处理人物在时间和空间上的性能；需要值相同的字符串，整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。</p><h4 id="小数据池"><a href="#小数据池" class="headerlink" title="小数据池"></a>小数据池</h4><p>小数据池，不同代码块的缓存机制，也称为小整数缓存机制，或者称为驻留机制等等，</p><h5 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a><strong>前提条件</strong></h5><p>在不同代码块内。</p><h5 id="机制内容"><a href="#机制内容" class="headerlink" title="*机制内容*"></a>*机制内容*</h5><p>Python自动将-5~256的整数进行了<strong>缓存</strong>，当你将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。</p><p>python会将一定规则的字符串在<strong>字符串驻留池</strong>中，创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。</p><p>　　其实，无论是缓存还是字符串驻留池，都是python做的一个优化，就是将~5-256的整数，和一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中那些变量指向这些范围内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存中之创建一个。</p><h5 id="适用对象"><a href="#适用对象" class="headerlink" title="适用对象"></a><strong>适用对象</strong></h5><p> <strong>int（float），str，bool</strong> </p><h5 id="对象的具体细则：（了解即可）"><a href="#对象的具体细则：（了解即可）" class="headerlink" title="\对象的具体细则：（了解即可）**"></a><strong><em>\</em>对象的具体细则：（了解即可）**</strong></h5><p><strong>int：</strong>那么大家都知道对于整数来说，小数据池的范围是-5~256 ，如果多个变量都是指向同一个（在这个范围内的）数字，他们在内存中指向的都是一个内存地址。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183354.png" alt></p><p><strong>str:</strong>字符串要从下面这几个大方向讨论（<strong>了解即可！</strong>）：</p><p><strong>1,字符串的长度为0或者1，默认都采用了驻留机制（小数据池）。</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183432.png" alt><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183447.png" alt></p><p><strong>2,字符串的长度&gt;1,且只含有大小写字母，数字，下划线时，才会默认驻留。</strong></p><p> <img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183511.png" alt></p><p><strong>3,用乘法得到的字符串，分两种情况。</strong></p><p>　　<strong>3.1 乘数为1时：</strong></p><p>仅含大小写字母，数字，下划线，默认驻留。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183530.png" alt></p><p>含其他字符，长度&lt;=1,默认驻留。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183551.png" alt></p><p>含其他字符，长度&gt;1,默认驻留。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183615.png" alt></p><p>　　<strong>3.2 乘数&gt;=2时：</strong></p><p>仅含大小写字母，数字，下划线，总长度&lt;=20,默认驻留。</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183631.png" alt></p><p><strong>4，指定驻留。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> intern</span><br><span class="line">a = intern(<span class="string">'hello!@'</span>*<span class="number">20</span>)</span><br><span class="line">b = intern(<span class="string">'hello!@'</span>*<span class="number">20</span>)</span><br><span class="line">print(a <span class="keyword">is</span> b)</span><br><span class="line"><span class="comment"># 指定驻留是你可以指定任意的字符串加入到小数据池中，让其只在内存中创建一个对象，多个变量都是指向这一个字符串</span></span><br></pre></td></tr></table></figure><p><strong>bool</strong>：值就是True，False，无论你创建多少个变量指向True，False，那么他在内存中只存在一个。</p><h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>显而易见，节省大量内存在字符串比较时，非驻留比较效率o(n)，驻留时比较效率o(1)</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183651.png" alt></p><h3 id="深浅copy"><a href="#深浅copy" class="headerlink" title="深浅copy"></a>深浅copy</h3><h4 id="浅copy"><a href="#浅copy" class="headerlink" title="浅copy"></a>浅copy</h4><p>对于浅copy来说，只是在内存中重新创建了开辟了一个空间存放一个新列表，但是新列表中的元素与原列表中的元素是公用的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同一代码块下：</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="string">'太白'</span>, <span class="literal">True</span>, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), [<span class="number">22</span>, <span class="number">33</span>]]</span><br><span class="line">l2 = l1.copy()</span><br><span class="line">print(id(l1), id(l2))  <span class="comment"># 2713214468360 2713214524680</span></span><br><span class="line">print(id(l1[<span class="number">-2</span>]), id(l2[<span class="number">-2</span>]))  <span class="comment"># 2547618888008 2547618888008</span></span><br><span class="line">print(id(l1[<span class="number">-1</span>]),id(l2[<span class="number">-1</span>]))  <span class="comment"># 2547620322952 2547620322952</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同代码块下：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>, <span class="string">'太白'</span>, <span class="literal">True</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), [<span class="number">22</span>, <span class="number">33</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = l1.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(l1), id(l2))</span><br><span class="line"><span class="number">1477183162696</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(l1[<span class="number">-2</span>]), id(l2[<span class="number">-2</span>]))</span><br><span class="line"><span class="number">1477181814032</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(l1[<span class="number">-1</span>]), id(l2[<span class="number">-1</span>]))</span><br><span class="line"><span class="number">1477183162504</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183717.png" alt></p><h4 id="深copy"><a href="#深copy" class="headerlink" title="深copy"></a>深copy</h4><p>对于深copy来说，列表是在内存中重新创建的，列表中可变的数据类型是重新创建的，列表中的不可变的数据类型是公用的</p><p><strong>切片相当于浅copy</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同一代码块下</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">l1 = [<span class="number">1</span>, <span class="string">'alex'</span>, <span class="literal">True</span>, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), [<span class="number">22</span>, <span class="number">33</span>]]</span><br><span class="line">l2 = copy.deepcopy(l1)</span><br><span class="line">print(id(l1), id(l2))  <span class="comment"># 2788324482440 2788324483016</span></span><br><span class="line">print(id(l1[<span class="number">0</span>]),id(l2[<span class="number">0</span>]))  <span class="comment"># 1470562768 1470562768</span></span><br><span class="line">print(id(l1[<span class="number">-1</span>]),id(l2[<span class="number">-1</span>]))  <span class="comment"># 2788324482632 2788324482696</span></span><br><span class="line">print(id(l1[<span class="number">-2</span>]),id(l2[<span class="number">-2</span>]))  <span class="comment"># 2788323047752 2788323047752</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同代码块下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>, <span class="string">'太白'</span>, <span class="literal">True</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), [<span class="number">22</span>, <span class="number">33</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = copy.deepcopy(l1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(l1), id(l2))</span><br><span class="line"><span class="number">1477183162632</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(<span class="number">0</span>), id(<span class="number">0</span>))</span><br><span class="line"><span class="number">1470562736</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(<span class="number">-2</span>), id(<span class="number">-2</span>))</span><br><span class="line"><span class="number">1470562672</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(l1[<span class="number">-1</span>]), id(l2[<span class="number">-1</span>]))</span><br><span class="line"><span class="number">1477183162312</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208183827.png" alt></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>计算机系统分为：计算机硬件，操作系统，应用程序三部分。</p><p>我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。</p><p>有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程</p><p>文件操作的内容流程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 打开文件，得到文件句柄并赋值给一个变量</span></span><br><span class="line">f=open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="comment">#默认打开模式就为r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 通过句柄对文件进行操作</span></span><br><span class="line">data=f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h4 id="常出的错"><a href="#常出的错" class="headerlink" title="常出的错"></a>常出的错</h4><h5 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h5><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208223321.png" alt></p><p>这个是没有找到该文件，很可能是你的文件路径错了</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208223256.png" alt></p><p>你的的路径里面的\与后面的字符产生了特殊意义类似于\t，\n，换行符一样</p><ul><li><p>C:\Users\金鑫\Desktop\111.txt’ 凡是路径会产生特殊意义的地方，多加一个\ 这样就是前面\对后面的\进行转译，告诉计算机这个只是想单纯的表示\路径而已。即用\\代替\</p></li><li><p>r’C:\Users\金鑫\Desktop\111.txt’ 在路径的整体前面加一个r。（<strong>推荐</strong>）</p></li></ul><p>相对路径与绝对路径：</p><ul><li><p>绝对路径:从磁盘根目录开始一直到文件名</p></li><li><p>相对路径:用一个文件夹下的文件,相对于当前这个程序所在的文件而言.如果在同一个文件中,则相对路劲就是这个文件名.如果再上一层文件夹则要使用../相对路径下，你就可以直接写文件名即可。</p></li></ul><h5 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h5><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200208223511.png" alt></p><p>用了错误的编码来打开文件</p><h4 id="读"><a href="#读" class="headerlink" title="读"></a>读</h4><h5 id="r模式"><a href="#r模式" class="headerlink" title="r模式"></a>r模式</h5><p>以只读方式打开文件，文件的指针将会放在文件的开头。是文件操作最常用的模式，也是<strong>默认模式</strong></p><h5 id="rb模式"><a href="#rb模式" class="headerlink" title="rb模式"></a>rb模式</h5><p>以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。记住下面讲的也是一样，带b的都是以二进制的格式操作文件，他们主要是操作非文字文件：图片，音频，视频等,<strong>并且如果你要是带有b的模式操作文件，那么不用声明编码方式</strong></p><h4 id="写"><a href="#写" class="headerlink" title="写"></a>写</h4><h5 id="w模式"><a href="#w模式" class="headerlink" title="w模式"></a>w模式</h5><ul><li><p>如果文件不存在，利用w模式操作文件，那么它会先创建文件，然后写入内容.</p></li><li><p>如果文件存在，利用w模式操作文件，先清空原文件内容，在写入新内容。</p></li></ul><h5 id="wb模式"><a href="#wb模式" class="headerlink" title="wb模式"></a>wb模式</h5><p>wb模式：以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如：图片，音频，视频等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先以rb的模式将一个图片的内容以bytes类型全部读取出来，</span></span><br><span class="line"><span class="comment"># 然后在以wb将全部读取出来的数据写入一个新文件，这样就完成了类似于一个图片复制的流程</span></span><br><span class="line">f = open(<span class="string">"a.jpg"</span>,mode = <span class="string">"rb"</span>)</span><br><span class="line">content = f.read()</span><br><span class="line">f.close()</span><br><span class="line">f1 = open(<span class="string">"b.jpg"</span>, mode = <span class="string">"wb"</span>)</span><br><span class="line">f1.write(content)</span><br><span class="line">f1.close</span><br></pre></td></tr></table></figure><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><h5 id="a模式"><a href="#a模式" class="headerlink" title="a模式"></a>a模式</h5><p>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="各种模式"><a href="#各种模式" class="headerlink" title="各种模式"></a>各种模式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件的模式有(默认为文本模式)：</span></span><br><span class="line">r，只读模式【默认模式，文件必须存在，不存在则抛出异常】</span><br><span class="line">w，只写模式【不可读；不存在则创建；存在则清空内容】</span><br><span class="line">a， 只追加写模式【不可读；不存在则创建；存在则只追加内容】</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 对于非文本文件，我们只能使用b模式，"b"表示以字节的方式操作</span></span><br><span class="line"><span class="comment">#（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、</span></span><br><span class="line"><span class="comment"># 图片文件的jgp格式、视频文件的avi格式）</span></span><br><span class="line">rb </span><br><span class="line">wb</span><br><span class="line">ab</span><br><span class="line">注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3,‘+’模式（就是增加了一个功能）</span></span><br><span class="line">r+， 读写【可读，可写】</span><br><span class="line">w+，写读【可写，可读】</span><br><span class="line">a+， 写读【可写，可读】</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4，以bytes类型操作的读写，写读，写读模式</span></span><br><span class="line">r+b， 读写【可读，可写】</span><br><span class="line">w+b，写读【可写，可读】</span><br><span class="line">a+b， 写读【可写，可读】</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果你在读写模式下，先写后读，那么文件就会出问题，因为默认光标是在文件的最开始，你要是先写，则写入的内容会讲原内容覆盖掉，直到覆盖到你写完的内容，然后在后面开始读取。</p><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f.read()一次性读取所有内容</span></span><br><span class="line">f = open(<span class="string">'path1/小娃娃.txt'</span>,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">msg = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># f.read(n)以字符为单位，读取n个字符  光标亦随之移动了n个字符</span></span><br><span class="line"><span class="comment"># 1. 文件打开方式为文本模式时，代表读取n个字符</span></span><br><span class="line"><span class="comment"># 2. 文件打开方式为b模式时，代表读取n个字节</span></span><br><span class="line">f = open(<span class="string">'path1/小娃娃.txt'</span>,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">msg = f.read(<span class="number">3</span>)</span><br><span class="line">msg1 = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># readline()读取每次只读取一行,注意点:readline()读取出来的数据在后面都有一个\n，</span></span><br><span class="line"><span class="comment"># 加上print本身自动换行所以一般会加strip</span></span><br><span class="line">f = open(<span class="string">'path1/小娃娃.txt'</span>,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">msg1 = f.readline().strip()</span><br><span class="line">msg2 = f.readline().strip()</span><br><span class="line">msg3 = f.readline().strip()</span><br><span class="line">msg4 = f.readline().strip()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># readlines() 返回一个列表，列表里面每个元素是原文件的每一行，如果文件很大，占内存，容易崩盘</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过for循环去读取，文件句柄是一个迭代器，他的特点就是每次循环只在内存中占一行的数据，非常节省内存</span></span><br><span class="line">f = open(<span class="string">'../path1/弟子规'</span>,mode=<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    print(line)      <span class="comment">#这种方式就是在一行一行的进行读取,它就执行了下边的功能</span></span><br><span class="line"></span><br><span class="line">print(f.readline())</span><br><span class="line">print(f.readline())</span><br><span class="line">print(f.readline())</span><br><span class="line">print(f.readline())</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意:读完的文件句柄一定要关闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># seek(n)光标移动到n位置,注意: 移动单位是byte,所有如果是utf-8的中文部分要是3的倍数</span></span><br><span class="line"><span class="comment"># 通常我们使用seek都是移动到开头或者结尾</span></span><br><span class="line"><span class="comment"># 移动到开头:seek(0)</span></span><br><span class="line"><span class="comment"># 移动到结尾:seek(0,2) </span></span><br><span class="line"><span class="comment"># seek的第二个参数表示的是从哪个位置进行偏移,默认是0,表示开头,1表示当前位置,2表示结尾</span></span><br><span class="line">f = open(<span class="string">"小娃娃"</span>, mode=<span class="string">"r+"</span>, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 光标移动到开头</span></span><br><span class="line">content = f.read() <span class="comment"># 读取内容, 此时光标移动到结尾</span></span><br><span class="line">print(content)</span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 再次将光标移动到开头</span></span><br><span class="line">f.seek(<span class="number">0</span>, <span class="number">2</span>) <span class="comment"># 将光标移动到结尾</span></span><br><span class="line">content2 = f.read() <span class="comment"># 读取内容. 什么都没有</span></span><br><span class="line">print(content2)</span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 移动到开头</span></span><br><span class="line">f.write(<span class="string">"张国荣"</span>) <span class="comment"># 写入信息. 此时光标在9 中文3 * 3个 = 9</span></span><br><span class="line">f.flush()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tell()可以帮我们获取当前光标在什么位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  readable(),writeable()</span></span><br><span class="line">f = open(<span class="string">'Test'</span>,encoding=<span class="string">'utf-8'</span>,mode=<span class="string">'r'</span>)</span><br><span class="line">print(f.readable())  <span class="comment"># True</span></span><br><span class="line">print(f.writable())  <span class="comment"># False</span></span><br><span class="line">content = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># flush()刷新文件内部缓冲区</span></span><br></pre></td></tr></table></figure><h5 id="另一种打开方式"><a href="#另一种打开方式" class="headerlink" title="另一种打开方式"></a>另一种打开方式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1,利用with上下文管理这种方式，它会自动在一段时间后哦关闭文件句柄。</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'t1'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    f1.read()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2，一个with 语句可以操作多个文件，产生多个文件句柄。</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'t1'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f1,\</span><br><span class="line">        open(<span class="string">'Test'</span>, encoding=<span class="string">'utf-8'</span>, mode = <span class="string">'w'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    f1.read()</span><br><span class="line">    f2.write(<span class="string">'老男孩老男孩'</span>)</span><br></pre></td></tr></table></figure><h4 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h4><p>文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，我们平时看到的修改文件，都是模拟出来的效果</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200209140134.png" alt></p><p>具体的说有两种实现方式：</p><p>方式一：将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘（word，vim，nodpad++等编辑器）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  <span class="comment"># 调用系统模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>) <span class="keyword">as</span> read_f,open(<span class="string">'.a.txt.swap'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> write_f:</span><br><span class="line">    data=read_f.read() <span class="comment">#全部读入内存,如果文件很大,会很卡</span></span><br><span class="line">    data=data.replace(<span class="string">'alex'</span>,<span class="string">'SB'</span>) <span class="comment">#在内存中完成修改</span></span><br><span class="line"></span><br><span class="line">    write_f.write(data) <span class="comment">#一次性写入新文件</span></span><br><span class="line"></span><br><span class="line">os.remove(<span class="string">'a.txt'</span>)  <span class="comment">#删除原文件</span></span><br><span class="line">os.rename(<span class="string">'.a.txt.swap'</span>,<span class="string">'a.txt'</span>)   <span class="comment">#将新建的文件重命名为原文件</span></span><br></pre></td></tr></table></figure><p>方式二：将硬盘存放的该文件的内容一行一行地读入内存，修改完毕就写入新文件，最后用新文件覆盖源文件</p><p>(当文件过大无法全部加载入内存中时用此法)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>) <span class="keyword">as</span> read_f,open(<span class="string">'.a.txt.swap'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> write_f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> read_f:</span><br><span class="line">        line=line.replace(<span class="string">'alex'</span>,<span class="string">'SB'</span>)</span><br><span class="line">        write_f.write(line)</span><br><span class="line"></span><br><span class="line">os.remove(<span class="string">'a.txt'</span>)</span><br><span class="line">os.rename(<span class="string">'.a.txt.swap'</span>,<span class="string">'a.txt'</span>)</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p> 1，对一些功能就行封装，减少代码的重复性。</p><p> 2，使代码可读性更好</p><h4 id="函数结构"><a href="#函数结构" class="headerlink" title="函数结构"></a>函数结构</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">()</span>:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure><p>def 关键词开头，空格之后接函数名称和圆括号()，最后还有一个”:”。</p><p>def 是固定的，不能变，他就是定义函数的关键字。</p><p>空格 为了将def关键字和函数名分开</p><p>函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并且要具有可描述性</p><p>括号：是必须加的，用于写形参</p><p>下面的函数体一定全部都要缩进，这代表是这个函数的代码</p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>使用函数名加小括号就可以调用了 写法:函数名() 这个时候函数的函数体会被执行</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>1.遇到return,函数结束,return下面的（函数内）的代码不会执行。</p><p>2.return 会给函数的执行者返回值。</p><p>​    如果return后面什么都不写，或者函数中没有return,则返回的结果是None</p><p>​    如果return后面写了一个值,返回给调用者这个值</p><p>​    如果return后面写了多个结果,,返回给调用者一个tuple(元组),调用者可以直接使用元组的解构获取多个变量。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>将函数盘活，使函数能应对更多情况</p><h5 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h5><p>写在函数声明的位置的变量叫形参,形式上的一个完整.表示这个函数需要xxx</p><p>位置参数，args，默认参数，仅限关键字参数，**kwargs</p><h5 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h5><p>在函数调用的时候给函数传递的值</p><p>函数的传参就是函数将实际参数交给形式参数的过程.</p><p>按需传入</p><h5 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h5><h6 id="动态接收位置参数：-args"><a href="#动态接收位置参数：-args" class="headerlink" title="动态接收位置参数：*args"></a>动态接收位置参数：*args</h6><p>*args实参所有的位置参数接收，放置在一个元组中，并将这个元组赋值给args这个形参，PEP8规范中规定就使用args，约定俗成的</p><h6 id="动态接收关键字参数-kwargs"><a href="#动态接收关键字参数-kwargs" class="headerlink" title="动态接收关键字参数: kwargs"></a>动态接收关键字参数: kwargs</h6><p>**kwargs接受所有的关键字参数然后将其转换成一个字典赋值给kwargs这个形参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">    print(args) <span class="comment"># ('蒸羊羔儿', '蒸熊掌', '蒸鹿尾儿')</span></span><br><span class="line">    print(kwargs) <span class="comment"># &#123;'name': '太白金星', 'sex': '男'&#125;</span></span><br><span class="line">func(<span class="string">'蒸羊羔儿'</span>, <span class="string">'蒸熊掌'</span>, <span class="string">'蒸鹿尾儿'</span>,name=<span class="string">'太白金星'</span>,sex=<span class="string">'男'</span>)</span><br></pre></td></tr></table></figure><h5 id="的用法"><a href="#的用法" class="headerlink" title="*的用法"></a>*的用法</h5><h6 id="函数中"><a href="#函数中" class="headerlink" title="函数中"></a>函数中</h6><p> <strong>聚合</strong></p><p>在函数的定义时： *起到的是聚合的作用，将多个参数聚合为一个元组(字典)</p><p> <strong>打散</strong></p><p>出一个小题：你如何将三个数据（这三个数据都是可迭代对象类型的每一元素传给动态参数*args？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'alex'</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">tu1 = (<span class="string">'武sir'</span>, <span class="string">'太白'</span>, <span class="string">'女神'</span>,)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args) <span class="comment"># ('alex', [1, 2, 3, 4], ('武sir', '太白', '女神'))</span></span><br><span class="line">func(s1,l1,tu1)</span><br></pre></td></tr></table></figure><p>这样肯定是不行，他会将这个三个数据类型当成三个位置参数传给args，没有实现我的要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'alex'</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">tu1 = (<span class="string">'武sir'</span>, <span class="string">'太白'</span>, <span class="string">'女神'</span>,)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args) <span class="comment"># ('a', 'l', 'e', 'x', 1, 2, 3, 4, '武sir', '太白', '女神')</span></span><br><span class="line">func(*s1,*l1,*tu1)</span><br></pre></td></tr></table></figure><p>将位置参数的实参（可迭代类型）前面加上<em>，相当于将这些实参给拆解成一个一个的组成元素当成位置参数，然后传给args，所以在函数的执行时：\</em>，**起到的是打散的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">dic2 = &#123;<span class="string">'hobby'</span>: <span class="string">'喝茶'</span>, <span class="string">'sex'</span>: <span class="string">'男'</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs) <span class="comment"># &#123;'name': '太白', 'age': 18, 'hobby': '喝茶', 'sex': '男'&#125;</span></span><br><span class="line">func(**dic1,**dic2)</span><br></pre></td></tr></table></figure><h6 id="函数外"><a href="#函数外" class="headerlink" title="函数外"></a>函数外</h6><p>接收时聚合，传值时打散</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 之前讲过的分别赋值</span><br><span class="line">a,b = (1,2)</span><br><span class="line">print(a, b) # 1 2</span><br><span class="line"># 其实还可以这么用：</span><br><span class="line">a,*b = (1, 2, 3, 4,)</span><br><span class="line">print(a, b) # 1 [2, 3, 4]</span><br><span class="line">*rest,a,b = range(5)</span><br><span class="line">print(rest, a, b) # [0, 1, 2] 3 4</span><br><span class="line">print([1, 2, *[3, 4, 5]]) # [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h5 id="仅限关键字参数"><a href="#仅限关键字参数" class="headerlink" title="仅限关键字参数"></a>仅限关键字参数</h5><p>他的位置要放在<em>args后面，*</em>kwargs前面（如果有**kwargs），也就是默认参数的位置，它与默认参数的前后顺序无所谓，它只接受关键字传的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,*args,c)</span>:</span></span><br><span class="line">print(a,b) <span class="comment"># 1 2</span></span><br><span class="line">print(args) <span class="comment"># (4, 5)</span></span><br><span class="line"><span class="comment"># 这样传参是错误的，因为仅限关键字参数c只接受关键字参数</span></span><br><span class="line"><span class="comment"># func(1, 2, 3, 4, 5)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a,b,*args,c)</span>:</span></span><br><span class="line">print(a,b) <span class="comment"># 1 2</span></span><br><span class="line">print(args) <span class="comment"># (3, 4)</span></span><br><span class="line">print(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 这样就正确了：</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, c=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p> 这个仅限关键字参数从名字定义就可以看出他只能通过关键字参数传参，其实可以把它当成不设置默认值的默认参数而且必须要传参数，不传就报错。</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>内置命名空间–&gt; 存放python解释器为我们提供的名字, list, tuple, str, int这些都是内置命名空间</p><p>全局命名空间–&gt; 我们直接在py文件中, 函数外声明的变量都属于全局命名空间</p><p>局部命名空间–&gt; 在函数中声明的变量会放在局部命名空间</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200209133542.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200209133620.png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200209140957.png" alt></p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>全局作用域: 包含内置命名空间和全局命名空间. 在整个文件的任何位置都可以使用(遵循 从上到下逐⾏执行).</p><p>局部作用域: 在函数内部可以使用.</p><h5 id="两个内置函数"><a href="#两个内置函数" class="headerlink" title="两个内置函数"></a>两个内置函数</h5><p>globals(): 以字典的形式返回<strong>全局作用域</strong>所有的变量对应关系。</p><p>locals(): 以字典的形式返回<strong>当前作用域</strong>的变量的对应关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在全局作用域下打印，则他们获取的都是全局作用域的所有的内容。</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">print(globals())</span><br><span class="line">print(locals())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'__name__': '__main__', '__doc__': None, '__package__': None,</span></span><br><span class="line"><span class="string">'__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001806E50C0B8&gt;, </span></span><br><span class="line"><span class="string">'__spec__': None, '__annotations__': &#123;&#125;,</span></span><br><span class="line"><span class="string">'__builtins__': &lt;module 'builtins' (built-in)&gt;, </span></span><br><span class="line"><span class="string">'__file__': 'D:/lnh.python/py project/teaching_show/day09~day15/function.py',</span></span><br><span class="line"><span class="string">'__cached__': None, 'a': 2, 'b': 3&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在局部作用域中打印。</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    c = <span class="number">3</span></span><br><span class="line">    print(globals()) <span class="comment"># 和上面一样，还是全局作用域的内容</span></span><br><span class="line">    print(locals()) <span class="comment"># &#123;'c': 3&#125;</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><h4 id="高阶函数-函数嵌套"><a href="#高阶函数-函数嵌套" class="headerlink" title="高阶函数(函数嵌套)"></a>高阶函数(函数嵌套)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例1：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func1'</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func2'</span>)</span><br><span class="line">    print(<span class="number">4</span>)</span><br><span class="line">func1()</span><br><span class="line">print(<span class="number">1</span>)</span><br><span class="line">func2()</span><br><span class="line">print(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例2：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func1'</span>)</span><br><span class="line">    print(<span class="number">3</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func2'</span>)</span><br><span class="line">    func1()</span><br><span class="line">    print(<span class="number">4</span>)</span><br><span class="line">print(<span class="number">1</span>)</span><br><span class="line">func2()</span><br><span class="line">print(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 例3：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">()</span>:</span> </span><br><span class="line">    print(<span class="number">2</span>) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun3</span><span class="params">()</span>:</span> </span><br><span class="line">        print(<span class="number">6</span>) </span><br><span class="line">    print(<span class="number">4</span>) </span><br><span class="line">    fun3() </span><br><span class="line">    print(<span class="number">8</span>)</span><br><span class="line">print(<span class="number">3</span>)</span><br><span class="line">fun2()</span><br><span class="line">print(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="global"><a href="#global" class="headerlink" title="global"></a>global</h5><p>global关键字有两个作用：</p><p>1，声明一个全局变量。</p><p>2，在局部作用域想要对全局作用域的全局变量进行修改时，需要用到 global(限于字符串，数字)</p><h5 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h5><p>nonlocal的总结：</p><p>1，不能更改全局变量。</p><p>2，在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变</p><h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><p>函数名指向的是这个函数的内存地址，其实深一步理解可得知，与其说函数名()可以执行这个函数，不如说是函数的内存地址()才是执行这个函数的关键</p><ul><li>函数名可以赋值给其他变量</li><li>函数名可以当做容器类的元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in func1: 嘻嘻"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in func2: 哈哈"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in func3: 咯咯"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func4</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in func4: 吱吱"</span>)</span><br><span class="line">lst = [func1, func2, func3, func4]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">    i()</span><br></pre></td></tr></table></figure><ul><li>函数名可以当做函数的参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(f)</span>:</span></span><br><span class="line">    print(<span class="string">'in func2'</span>)</span><br><span class="line">    f()</span><br><span class="line"></span><br><span class="line">func2(func1)</span><br></pre></td></tr></table></figure><ul><li>函数名可以当做函数的返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'in func1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(f)</span>:</span></span><br><span class="line">    print(<span class="string">'in func2'</span>)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">ret = func2(func1)</span><br><span class="line">ret()  <span class="comment"># ret, f, func1 都是指向的func1这个函数的内存地址</span></span><br></pre></td></tr></table></figure><p>函数名是一个特殊的变量，他除了具有变量的功能，还有最主要一个特点就是加上() 就执行，其实他还有一个学名叫<strong>第一类对象</strong></p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p>  从字面意思来说：可迭代对象就是一个可以重复取值的实实在在的东西。</p><p>  从专业角度来说：但凡内部含有<strong>iter</strong>方法的对象，都是可迭代对象。</p><p>  可迭代对象可以通过判断该对象是否有’<strong>iter</strong>’方法来判断。</p><h6 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h6><p>  可迭代对象的<strong>优点</strong>：</p><ul><li><p>可以直观的查看里面的数据。</p><p>可迭代对象的<strong>缺点</strong>：</p></li><li><p>占用内存。</p></li><li><p>可迭代对象不能迭代取值（除去索引，key以外</p></li></ul><p>即使抛去索引,key以外，这些我可以通过for循环进行取值呀！对，他们都可以通过for循环进行取值，其实for循环在底层做了一个转化，就是<strong>先将可迭代对象转化成迭代器</strong>，然后在进行取值的</p><h6 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h6><p><strong>dir()</strong>会返回一个列表，这个列表中含有该对象的以字符串的形式所有方法名。这样我们就可以判断python中的一个对象是不是可迭代对象了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'alex'</span></span><br><span class="line">i = <span class="number">100</span></span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(i))  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(s1))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><p>  从字面意思来说迭代器，是一个可以迭代取值的工具，器：在这里当做工具比较合适。</p><p>  从专业角度来说：迭代器是这样的对象：实现了无参数的<strong>next</strong>方法，返回序列中的下一个元素，如果没有元素了，那么抛出StopIteration异常.python中的迭代器还实现了<strong>iter</strong>方法，因此迭代器也可以迭代。 出自《流畅的python》</p><p> 简单来说：<strong>在python中，内部含有’<strong>Iter</strong>‘方法并且含有’<strong>next</strong>‘方法的对象就是迭代器。</strong></p><h6 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">o1 = <span class="string">'alex'</span></span><br><span class="line">o2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">o3 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">o4 = &#123;<span class="string">'name'</span>: <span class="string">'太白'</span>,<span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line">o5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">f = open(<span class="string">'file'</span>,encoding=<span class="string">'utf-8'</span>, mode=<span class="string">'w'</span>)</span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(o1))  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(o2))  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(o3))  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(o4))  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(o5))  <span class="comment"># True</span></span><br><span class="line">print(<span class="string">'__iter__'</span> <span class="keyword">in</span> dir(f))  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># hsagn</span></span><br><span class="line">print(<span class="string">'__next__'</span> <span class="keyword">in</span> dir(o1))  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'__next__'</span> <span class="keyword">in</span> dir(o2))  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'__next__'</span> <span class="keyword">in</span> dir(o3))  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'__next__'</span> <span class="keyword">in</span> dir(o4))  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'__next__'</span> <span class="keyword">in</span> dir(o5))  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'__next__'</span> <span class="keyword">in</span> dir(f))  <span class="comment"># True</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>之前我们学过的这些对象，只有文件句柄是迭代器，剩下的那些数据类型都是可迭代对象。</p><h6 id="迭代器取值"><a href="#迭代器取值" class="headerlink" title="迭代器取值"></a>迭代器取值</h6><p>取值之前仅是保存了那些地址</p><p>  可迭代对象是不可以一直迭代取值的（除去用索引，切片以及Key），但是转化成迭代器就可以了，迭代器是利用<strong>next</strong>()进行取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,]</span><br><span class="line">obj = l1.__iter__()  <span class="comment"># 或者 iter(l1)</span></span><br><span class="line"><span class="comment"># print(obj)  # &lt;list_iterator object at 0x000002057FE1A3C8&gt;</span></span><br><span class="line">ret = obj.__next__()</span><br><span class="line">print(ret)</span><br><span class="line">ret = obj.__next__()</span><br><span class="line">print(ret)</span><br><span class="line">ret = obj.__next__()</span><br><span class="line">print(ret)</span><br><span class="line">ret = obj.__next__()  <span class="comment"># StopIteration</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 迭代器利用next取值：一个next取对应的一个值，如果迭代器里面的值取完了，还要next，</span></span><br><span class="line"><span class="comment"># 那么就报StopIteration的错误。</span></span><br></pre></td></tr></table></figure><h6 id="while模拟for"><a href="#while模拟for" class="headerlink" title="while模拟for"></a>while模拟for</h6><p>for循环的内部机制是：将可迭代对象转换成迭代器，然后利用next进行取值，最后利用异常处理处理StopIteration抛出的异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 1 将可迭代对象转化成迭代器</span></span><br><span class="line">obj = iter(l1)</span><br><span class="line"><span class="comment"># 2,利用while循环，next进行取值</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 3,利用异常处理终止循环</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(obj))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h6 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h6><p>​    迭代器的<strong>优点</strong>：</p><p>​        节省内存。<br>​          迭代器在内存中相当于只占一个数据的空间：因为每次取值都上一条数据会在内存释放，加载当前的此条数据。</p><p>​        惰性机制。<br>​          next一次，取一个值，绝不过多取值。​</p><p>​    迭代器的<strong>缺点</strong>：</p><p>​      不能直观的查看里面的数据。</p><p>​      取值时不走回头路，只能一直向下取值。</p><h5 id="可迭代对象转化成迭代器"><a href="#可迭代对象转化成迭代器" class="headerlink" title="可迭代对象转化成迭代器"></a>可迭代对象转化成迭代器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">obj = l1.__iter__() </span><br><span class="line"><span class="comment"># 或者 iter(l1)</span></span><br><span class="line"><span class="comment"># &lt;list_iterator object at 0x000002057FE1A3C8&gt;</span></span><br></pre></td></tr></table></figure><h5 id="迭代器与可迭代对象对比"><a href="#迭代器与可迭代对象对比" class="headerlink" title="迭代器与可迭代对象对比"></a>迭代器与可迭代对象对比</h5><p> <strong>可迭代对象：</strong></p><p>  是一个私有的方法比较多，操作灵活（比如列表，字典的增删改查，字符串的常用操作方法等）,比较直观，但是占用内存，而且不能直接通过循环迭代取值的这么一个数据集。</p><p>  <strong>应用</strong>：当你侧重于对于数据可以灵活处理，并且内存空间足够，将数据集设置为可迭代对象是明确的选择。</p><p>  <strong>迭代器：</strong></p><p>  是一个非常节省内存，可以记录取值位置，可以直接通过循环+next方法取值，但是不直观，操作方法比较单一的数据集。</p><p>  <strong>应用</strong>：当你的数据量过大，大到足以撑爆你的内存或者你以节省内存为首选因素时，将数据集设置为迭代器是一个不错的选择。（可参考为什么python把文件句柄设置成迭代器）。</p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>什么是生成器？各种文献都有不同的理解，但是核心基本相同。生成器的本质就是迭代器，在python社区中，大多数时候都把迭代器和生成器是做同一个概念。生成器和迭代器也有不同，唯一的不同就是：迭代器都是Python给你提供的已经写好的工具或者通过数据转化得来的，（比如文件句柄，iter([1,2,3])。<strong>生成器是需要我们自己用python代码构建的工具</strong>。最大的区别也就如此了</p><h5 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h5><p>通过生成器函数</p><p>通过生成器推导式</p><p>python内置函数或者模块提供</p><p>（其实1,3两种本质上差不多，只不过1是自己写的生成器函数，3是python提供的生成器函数而已）</p><h5 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">11</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">22</span></span><br><span class="line">ret = func()</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 运行结果:</span></span><br><span class="line">&lt;generator object func at <span class="number">0x000001A575163888</span>&gt;</span><br></pre></td></tr></table></figure><p>由于函数中存在yield,那么这个函数就是一个生成器函数.</p><p>我们在执行这个函数的时候.就不再是函数的执行了.而是获取这个生成器对象，那么生成器对象如何取值呢？</p><p>生成器的本质就是迭代器。所以我们可以直接执行<strong>next</strong>()来执行以下生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">     print(<span class="string">"111"</span>)</span><br><span class="line">     <span class="keyword">yield</span> <span class="number">222</span></span><br><span class="line">gener = func() <span class="comment"># 这个时候函数不会执⾏. ⽽是获取到⽣成器</span></span><br><span class="line">ret = gener.__next__() <span class="comment"># 这个时候函数才会执⾏</span></span><br><span class="line">print(ret)  <span class="comment"># 并且yield会将func生产出来的数据 222 给了 ret</span></span><br></pre></td></tr></table></figure><p>当程序运行完最后一个yield,那么后面继续运行<strong>next</strong>()程序会报错，一个yield对应一个next，next超过yield数量，就会报错，与迭代器一样。</p><h5 id="yield与return的区别"><a href="#yield与return的区别" class="headerlink" title="yield与return的区别"></a>yield与return的区别</h5><p>​    return一般在函数中只设置一个，他的作用是终止函数，并且给函数的执行者返回值。</p><p>​    yield在生成器函数中可设置多个，他并不会终止函数，next会获取对应yield生成的元素。</p><p><strong>举例：</strong></p><p>我们来看一下这个需求：老男孩向楼下卖包子的老板订购了10000个包子.包子铺老板非常实在，一下就全部都做出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        lst.append(<span class="string">'包子'</span>+str(i))</span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line">e = eat()</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><p>这样做没有问题，但是我们由于学生没有那么多，只吃了2000个左右，剩下的8000个，就只能占着一定的空间，放在一边了。如果包子铺老板效率够高，我吃一个包子，你做一个包子，那么这就不会占用太多空间存储了，完美。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'包子'</span>+str(i)</span><br><span class="line">e = eat()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">200</span>):</span><br><span class="line">    next(e)</span><br></pre></td></tr></table></figure><p><strong>这两者的区别:</strong></p><p>  第一种是直接把包子全部做出来，占用内存。</p><p>  第二种是吃一个生产一个，非常的节省内存，而且还可以保留上次的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'包子'</span>+str(i)</span><br><span class="line">e = eat()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">200</span>):</span><br><span class="line">    next(e)    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">300</span>):</span><br><span class="line">    next(e)</span><br><span class="line"><span class="comment"># 多次next包子的号码是按照顺序记录的。</span></span><br></pre></td></tr></table></figure><h5 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h5><p>可以直接把可迭代对象中的每一个数据作为生成器的结果进行返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比yield 与 yield from </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    lst = [<span class="string">'卫龙'</span>,<span class="string">'老冰棍'</span>,<span class="string">'北冰洋'</span>,<span class="string">'牛羊配'</span>]</span><br><span class="line">    <span class="keyword">yield</span> lst</span><br><span class="line">g = func()</span><br><span class="line">print(g)</span><br><span class="line">print(next(g))  <span class="comment"># 只是返回一个列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    lst = [<span class="string">'卫龙'</span>,<span class="string">'老冰棍'</span>,<span class="string">'北冰洋'</span>,<span class="string">'牛羊配'</span>]</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> lst</span><br><span class="line">g = func()</span><br><span class="line">print(g)</span><br><span class="line"><span class="comment"># 他会将这个可迭代对象(列表)的每个元素当成迭代器的每个结果进行返回。</span></span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line">print(next(g))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">yield from ['卫龙','老冰棍','北冰洋','牛羊配'] </span></span><br><span class="line"><span class="string">等同于：</span></span><br><span class="line"><span class="string">    yield '卫龙'</span></span><br><span class="line"><span class="string">    yield '老冰棍'</span></span><br><span class="line"><span class="string">    yield '北冰洋'</span></span><br><span class="line"><span class="string">    yield '牛羊配'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>两个yield from不会交替输出，而会先打印完第一个，在打印第二个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    lst1 = [<span class="string">'卫龙'</span>,<span class="string">'老冰棍'</span>,<span class="string">'北冰洋'</span>,<span class="string">'牛羊配'</span>]</span><br><span class="line">    lst2 = [<span class="string">'馒头'</span>,<span class="string">'花卷'</span>,<span class="string">'豆包'</span>,<span class="string">'大饼'</span>]</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> lst1</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> lst2</span><br><span class="line">    </span><br><span class="line">g = func()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h5 id="send方法-补充"><a href="#send方法-补充" class="headerlink" title="send方法(补充)"></a>send方法(补充)</h5><p><strong>send和next()区别:</strong></p><p>​    相同点：</p><p>​      send 和 next()都可以让生成器对应的yield向下执行一次。</p><p>​      都可以获取到yield生成的值。</p><p>​    不同点：</p><p>​      第一次获取yield值只能用next不能用send（可以用send(None)）。</p><p>​      send可以给上一个yield置传递值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># next只能获取yield生成的值，但是不能传递值。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;name&#125;</span> ready to eat'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        food = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;name&#125;</span> start to eat <span class="subst">&#123;food&#125;</span>'</span>)</span><br><span class="line">dog = gen(<span class="string">'alex'</span>)</span><br><span class="line">next(dog)</span><br><span class="line">next(dog)</span><br><span class="line">next(dog)</span><br><span class="line"><span class="comment"># 而使用send这个方法是可以的。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;name&#125;</span> ready to eat'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        food = <span class="keyword">yield</span> <span class="number">222</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;name&#125;</span> start to eat <span class="subst">&#123;food&#125;</span>'</span>)</span><br><span class="line">dog = gen(<span class="string">'alex'</span>)</span><br><span class="line">next(dog)  <span class="comment"># 第一次必须用next让指针停留在第一个yield后面</span></span><br><span class="line"><span class="comment"># 与next一样，可以获取到yield的值</span></span><br><span class="line">ret = dog.send(<span class="string">'骨头'</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;name&#125;</span> ready to eat'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        food = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;name&#125;</span> start to eat <span class="subst">&#123;food&#125;</span>'</span>)</span><br><span class="line">dog = gen(<span class="string">'alex'</span>)</span><br><span class="line">next(dog)</span><br><span class="line"><span class="comment"># 还可以给上一个yield发送值</span></span><br><span class="line">dog.send(<span class="string">'骨头'</span>)</span><br><span class="line">dog.send(<span class="string">'狗粮'</span>)</span><br><span class="line">dog.send(<span class="string">'香肠'</span>)</span><br></pre></td></tr></table></figure><h5 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h5><p>形式上仅是将列表生成式的[]改为()</p><p>生成器表达式和列表推导式的区别:</p><ul><li>列表推导式比较耗内存,所有数据一次性加载到内存。而.生成器表达式遵循迭代器协议，逐个产生元素。</li><li>得到的值不一样,列表推导式得到的是一个列表.生成器表达式获取的是一个生成器</li><li>列表推导式一目了然，生成器表达式只是一个内存地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> gen:</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p><a href="https://www.processon.com/view/link/5b4ee15be4b0edb750de96ac#map" target="_blank" rel="noopener">思维导图</a></p><p>函数就是以功能为导向，一个函数封装一个功能，那么Python将一些常用的功能（比如len）给我们封装成了一个一个的函数，供我们使用，他们不仅效率高（底层都是用C语言写的），而且是拿来即用，避免重复早轮子，那么这些函数就称为内置函数，到目前为止python给我们提供的内置函数一共是68个</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/pythonBasic/20200210104550.png" alt></p><h5 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h5><p>all：可迭代对象中，全都是True才是True</p><p>any：可迭代对象中，有一个True 就是True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># all  可迭代对象中，全都是True才是True</span></span><br><span class="line"><span class="comment"># any  可迭代对象中，有一个True 就是True</span></span><br><span class="line">print(all([<span class="number">1</span>,<span class="number">2</span>,<span class="literal">True</span>,<span class="number">0</span>]))</span><br><span class="line">print(any([<span class="number">1</span>,<span class="string">''</span>,<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>bytes：用于不同编码之间的转化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'你好'</span></span><br><span class="line">bs = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line">s1 = bs.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(s1)</span><br><span class="line">bs = bytes(s,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line">b = <span class="string">'你好'</span>.encode(<span class="string">'gbk'</span>)</span><br><span class="line">b1 = b.decode(<span class="string">'gbk'</span>)</span><br><span class="line">print(b1.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>ord:输入字符找该字符编码的位置</p><p>chr:输入位置数字找出其对应的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ord 输入字符找该字符编码的位置</span></span><br><span class="line">print(ord(<span class="string">'a'</span>))</span><br><span class="line">print(ord(<span class="string">'中'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># chr 输入位置数字找出其对应的字符</span></span><br><span class="line">print(chr(<span class="number">97</span>))</span><br><span class="line">print(chr(<span class="number">20013</span>))</span><br></pre></td></tr></table></figure><p>repr:返回一个对象的string形式（原形毕露）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %r  原封不动的写出来</span></span><br><span class="line">name = <span class="string">'taibai'</span></span><br><span class="line">print(<span class="string">'我叫%r'</span>%name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># repr 原形毕露</span></span><br><span class="line">print(repr(<span class="string">'&#123;"name":"alex"&#125;'</span>))</span><br><span class="line">print(<span class="string">'&#123;"name":"alex"&#125;'</span>)</span><br></pre></td></tr></table></figure><p>eval：执行字符串类型的代码，并返回最终结果。</p><p>exec:执行字符串类型的代码。</p><p>用于网络上数据处理时易出现安全分险</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eval(<span class="string">'2 + 2'</span>)  <span class="comment"># 4</span></span><br><span class="line">n=<span class="number">81</span></span><br><span class="line">eval(<span class="string">"n + 4"</span>)  <span class="comment"># 85</span></span><br><span class="line">eval(<span class="string">'print(666)'</span>)  <span class="comment"># 666</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''</span></span><br><span class="line"><span class="string">for i in [1,2,3]:</span></span><br><span class="line"><span class="string">    print(i)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">exec(s)</span><br></pre></td></tr></table></figure><p>hash：获取一个对象（可哈希对象：int，str，Bool，tuple）的哈希值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(hash(<span class="number">12322</span>))</span><br><span class="line">print(hash(<span class="string">'123'</span>))</span><br><span class="line">print(hash(<span class="string">'arg'</span>))</span><br><span class="line">print(hash(<span class="string">'alex'</span>))</span><br><span class="line">print(hash(<span class="literal">True</span>))</span><br><span class="line">print(hash(<span class="literal">False</span>))</span><br><span class="line">print(hash((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">-2996001552409009098</span></span><br><span class="line"><span class="string">-4637515981888139739</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2528502973977326415</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>help：函数用于查看函数或模块用途的详细说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(help(list))</span><br><span class="line">print(help(str.split))</span><br></pre></td></tr></table></figure><p><strong>callable</strong>：函数用于检查一个对象是否是可调用的。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'alex'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(callable(name))  <span class="comment"># False</span></span><br><span class="line">print(callable(func))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>int：函数用于将一个字符串或数字(取整)转换为整型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(int())  <span class="comment"># 0</span></span><br><span class="line">print(int(<span class="string">'12'</span>))  <span class="comment"># 12</span></span><br><span class="line">print(int(<span class="number">3.6</span>))  <span class="comment"># 3</span></span><br><span class="line">print(int(<span class="string">'0100'</span>,base=<span class="number">2</span>))  <span class="comment"># 将2进制的 0100 转化成十进制。结果为 4</span></span><br></pre></td></tr></table></figure><p>float：函数用于将整数和字符串转换成浮点数。</p><p>complex：函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(float(<span class="number">3</span>))  <span class="comment"># 3.0</span></span><br><span class="line">print(complex(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment"># (1+2j)</span></span><br></pre></td></tr></table></figure><p>bin：将十进制转换成二进制并返回。</p><p>oct：将十进制转化成八进制字符串并返回。</p><p>hex：将十进制转化成十六进制字符串并返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(bin(<span class="number">10</span>),type(bin(<span class="number">10</span>)))  <span class="comment"># 0b1010 &lt;class 'str'&gt;</span></span><br><span class="line">print(oct(<span class="number">10</span>),type(oct(<span class="number">10</span>)))  <span class="comment"># 0o12 &lt;class 'str'&gt;</span></span><br><span class="line">print(hex(<span class="number">10</span>),type(hex(<span class="number">10</span>)))  <span class="comment"># 0xa &lt;class 'str'&gt;</span></span><br></pre></td></tr></table></figure><p>divmod：计算除数与被除数的结果，返回一个包含商和余数的元组(a // b, a % b)。</p><p>round：保留浮点数的小数位数，默认保留整数。</p><p>pow：求x<strong>y次幂。（三个参数为x</strong>y的结果对z取余）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(divmod(<span class="number">7</span>,<span class="number">2</span>))  <span class="comment"># (3, 1)</span></span><br><span class="line">print(round(<span class="number">7</span>/<span class="number">3</span>,<span class="number">2</span>))  <span class="comment"># 2.33</span></span><br><span class="line">print(round(<span class="number">7</span>/<span class="number">3</span>))  <span class="comment"># 2</span></span><br><span class="line">print(round(<span class="number">3.32567</span>,<span class="number">3</span>))  <span class="comment"># 3.326</span></span><br><span class="line">print(pow(<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 两个参数为2**3次幂</span></span><br><span class="line">print(pow(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>))  <span class="comment"># 三个参数为2**3次幂，对3取余。</span></span><br></pre></td></tr></table></figure><h5 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h5><p><strong>print() 屏幕输出。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''' 源码分析</span></span><br><span class="line"><span class="string">def print(self, *args, sep=' ', end='\n', file=None): # known special case of print</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="string">    print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)</span></span><br><span class="line"><span class="string">    file:  默认是输出到屏幕，如果设置为文件句柄，输出到文件</span></span><br><span class="line"><span class="string">    sep:   打印多个值之间的分隔符，默认为空格</span></span><br><span class="line"><span class="string">    end:   每一次打印的结尾，默认为换行符</span></span><br><span class="line"><span class="string">    flush: 立即把内容输出到流文件，不作缓存</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>,sep=<span class="string">'*'</span>)  <span class="comment"># 111*222*333</span></span><br><span class="line"></span><br><span class="line">print(<span class="number">111</span>,end=<span class="string">''</span>)</span><br><span class="line">print(<span class="number">222</span>)  <span class="comment">#两行的结果 111222</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'log'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(<span class="string">'写入文件'</span>,fle=f,flush=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>int():pass</strong></p><p><strong>str():pass</strong></p><p><strong>bool():pass</strong></p><p><strong>set(): pass</strong></p><p><strong>list() 将一个可迭代对象转换成列表</strong></p><p><strong>tuple() 将一个可迭代对象转换成元组</strong></p><p><strong>dict() 通过相应的方式创建字典。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list</span><br><span class="line">l1 = list(<span class="string">'abcd'</span>)</span><br><span class="line">print(l1)  <span class="comment"># ['a', 'b', 'c', 'd']</span></span><br><span class="line">tu1 = tuple(<span class="string">'abcd'</span>)</span><br><span class="line">print(tu1)  <span class="comment"># ('a', 'b', 'c', 'd')</span></span><br></pre></td></tr></table></figure><p><strong>abs() 返回绝对值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">-5</span></span><br><span class="line">print(abs(i))  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><p><strong>sum() 求和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(sum([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">print(sum((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p><strong>min() 求最小值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(min([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))  <span class="comment"># 返回此序列最小值</span></span><br><span class="line">ret = min([<span class="number">1</span>,<span class="number">2</span>,<span class="number">-5</span>,],key=abs)  <span class="comment"># 按照绝对值的大小，返回此序列最小值</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 加key是可以加函数名，min自动会获取传入函数中的参数的每个元素，然后通过你设定的返回值比较大小，</span></span><br><span class="line"><span class="comment"># 返回最小的传入的那个参数。</span></span><br><span class="line">print(min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">-5</span>,<span class="number">6</span>,<span class="number">-3</span>,key=<span class="keyword">lambda</span> x:abs(x)))  <span class="comment"># 可以设置很多参数比较大小</span></span><br><span class="line">dic = &#123;<span class="string">'a'</span>:<span class="number">3</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">1</span>&#125;</span><br><span class="line">print(min(dic,key=<span class="keyword">lambda</span> x:dic[x]))</span><br><span class="line"><span class="comment"># x为dic的key，lambda的返回值（即dic的值进行比较）返回最小的值对应的键</span></span><br></pre></td></tr></table></figure><p><strong>max() 最大值与最小值用法相同。</strong></p><p><strong>reversed() 将一个序列翻转, 返回翻转序列的迭代器</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = reversed(<span class="string">'你好'</span>)  <span class="comment"># l 获取到的是一个生成器</span></span><br><span class="line">print(list(l))</span><br><span class="line">ret = reversed([<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">print(list(ret))  <span class="comment"># [9, 7, 3, 4, 1]</span></span><br></pre></td></tr></table></figure><p><strong>bytes() 把字符串转换成bytes类型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'你好太白'</span></span><br><span class="line">bs = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line"><span class="comment"># 结果:b'\xe4\xbd\xa0\xe5\xa5\xbd\xe6\xad\xa6\xe5\xa4\xa7'</span></span><br><span class="line">s1 = bs.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(s1)</span><br><span class="line"><span class="comment"># 结果: 你好太白</span></span><br><span class="line">s = <span class="string">'你好'</span></span><br><span class="line">bs = bytes(s,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line"><span class="comment"># 将字符串转换成字节</span></span><br><span class="line">bs1 = str(bs,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs1)</span><br><span class="line"><span class="comment"># 将字节转换成字符串</span></span><br></pre></td></tr></table></figure><p><strong>zip() 拉链方法。</strong>函数用于将可迭代的对象作为参数,将对象中对应的元素打包成一个个元组,</p><p>然后返回由这些元祖组成的内容,如果各个迭代器的元素个数不一致,则按照长度最短的返回，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">lst2 = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line">lst3 = (<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(lst1,lst2,lst3):</span><br><span class="line">    print(i)</span><br><span class="line">结果:</span><br><span class="line">(<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">11</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">12</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'c'</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure><p><strong>sorted</strong>排序函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法:sorted(iterable,key=None,reverse=False)</span></span><br><span class="line"><span class="comment"># iterable : 可迭代对象</span></span><br><span class="line"><span class="comment"># key: 排序规则(排序函数),在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数.</span></span><br><span class="line"><span class="comment">#      根据函数运算的结果进行排序</span></span><br><span class="line"><span class="comment"># reverse :是否是倒叙,True 倒叙 False 正序</span></span><br><span class="line">lst = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">lst2 = sorted(lst)</span><br><span class="line">print(lst)    <span class="comment">#原列表不会改变</span></span><br><span class="line">print(lst2)   <span class="comment">#返回的新列表是经过排序的  </span></span><br><span class="line">lst3 = sorted(lst,reverse=<span class="literal">True</span>)</span><br><span class="line">print(lst3)   <span class="comment">#倒叙 </span></span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 字典使用sorted排序</span></span><br><span class="line">dic = &#123;<span class="number">1</span>:<span class="string">'a'</span>,<span class="number">3</span>:<span class="string">'c'</span>,<span class="number">2</span>:<span class="string">'b'</span>&#125;</span><br><span class="line">print(sorted(dic))   <span class="comment"># 字典排序返回的就是排序后的key </span></span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 和函数组合使用</span></span><br><span class="line"><span class="comment"># 定义一个列表,然后根据一元素的长度排序</span></span><br><span class="line">lst = [<span class="string">'天龙八部'</span>,<span class="string">'西游记'</span>,<span class="string">'红楼梦'</span>,<span class="string">'三国演义'</span>] </span><br><span class="line"><span class="comment"># 计算字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(s)</span><br><span class="line">print(sorted(lst,key=func)) </span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line"><span class="comment"># ['西游记', '红楼梦', '天龙八部', '三国演义']</span></span><br><span class="line">和<span class="keyword">lambda</span>组合使用</span><br><span class="line">lst = [<span class="string">'天龙八部'</span>,<span class="string">'西游记'</span>,<span class="string">'红楼梦'</span>,<span class="string">'三国演义'</span>] </span><br><span class="line">print(sorted(lst,key=<span class="keyword">lambda</span> s:len(s))) </span><br><span class="line">结果:</span><br><span class="line">[<span class="string">'西游记'</span>, <span class="string">'红楼梦'</span>, <span class="string">'天龙八部'</span>, <span class="string">'三国演义'</span>]  </span><br><span class="line">lst = [&#123;<span class="string">'id'</span>:<span class="number">1</span>,<span class="string">'name'</span>:<span class="string">'alex'</span>,<span class="string">'age'</span>:<span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'id'</span>:<span class="number">2</span>,<span class="string">'name'</span>:<span class="string">'wusir'</span>,<span class="string">'age'</span>:<span class="number">17</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'id'</span>:<span class="number">3</span>,<span class="string">'name'</span>:<span class="string">'taibai'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;,] </span><br><span class="line"><span class="comment"># 按照年龄对学生信息进行排序 </span></span><br><span class="line">print(sorted(lst,key=<span class="keyword">lambda</span> e:e[<span class="string">'age'</span>])) </span><br><span class="line">结果:</span><br><span class="line">[&#123;<span class="string">'id'</span>: <span class="number">3</span>, <span class="string">'name'</span>: <span class="string">'taibai'</span>, <span class="string">'age'</span>: <span class="number">16</span>&#125;, \</span><br><span class="line">&#123;<span class="string">'id'</span>: <span class="number">2</span>, <span class="string">'name'</span>: <span class="string">'wusir'</span>, <span class="string">'age'</span>: <span class="number">17</span>&#125;, &#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'alex'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;]</span><br></pre></td></tr></table></figure><p><strong>filter</strong>筛选过滤</p><p>类似于各种推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法: filter(function,iterable)</span></span><br><span class="line"><span class="comment"># function: 用来筛选的函数,在filter中会自动的把iterable中的元素传递给function,</span></span><br><span class="line"><span class="comment"># 然后根据function返回的True或者False来判断是否保留此项数据</span></span><br><span class="line">iterable:可迭代对象</span><br><span class="line">lst = [&#123;<span class="string">'id'</span>:<span class="number">1</span>,<span class="string">'name'</span>:<span class="string">'alex'</span>,<span class="string">'age'</span>:<span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'id'</span>:<span class="number">1</span>,<span class="string">'name'</span>:<span class="string">'wusir'</span>,<span class="string">'age'</span>:<span class="number">17</span>&#125;,</span><br><span class="line">        &#123;<span class="string">'id'</span>:<span class="number">1</span>,<span class="string">'name'</span>:<span class="string">'taibai'</span>,<span class="string">'age'</span>:<span class="number">16</span>&#125;,] </span><br><span class="line">ls = filter(<span class="keyword">lambda</span> e:e[<span class="string">'age'</span>] &gt; <span class="number">16</span>,lst) </span><br><span class="line">print(list(ls)) </span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line">[&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'alex'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;,</span><br><span class="line"> &#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'wusir'</span>, <span class="string">'age'</span>: <span class="number">17</span>&#125;]</span><br></pre></td></tr></table></figure><p><strong>map</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 映射函数</span></span><br><span class="line"><span class="comment"># 语法: map(function,iterable) 可以对可迭代对象中的每一个元素进映射,分别取执行function,返回一个迭代器</span></span><br><span class="line"><span class="comment"># 计算列表中每个元素的平方,返回新列表</span></span><br><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>  s*s</span><br><span class="line">mp = map(func,lst)</span><br><span class="line">print(mp)</span><br><span class="line">print(list(mp))</span><br><span class="line"><span class="comment"># 改写成lambda</span></span><br><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">print(list(map(<span class="keyword">lambda</span> s:s*s,lst)))</span><br><span class="line"><span class="comment"># 计算两个列表中相同位置的数据的和</span></span><br><span class="line">lst1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">lst2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">print(list(map(<span class="keyword">lambda</span> x, y: x+y, lst1, lst2)))</span><br><span class="line"><span class="comment"># 结果:</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>]</span><br></pre></td></tr></table></figure><p><img src="http://crm.pythonav.com/media/uploads/2019/04/12/IMAGE-20190412120136-9.GIF" alt="img"><strong>reduce</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="comment"># reduce 的使用方式:</span></span><br><span class="line"><span class="comment"># reduce(函数名,可迭代对象)  # 这两个参数必须都要有,缺一个不行</span></span><br><span class="line">ret = reduce(func,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line">print(ret)  <span class="comment"># 结果 25</span></span><br><span class="line"><span class="comment"># reduce的作用是先把列表中的前俩个元素取出计算出一个值然后临时保存着,</span></span><br><span class="line"><span class="comment"># 接下来用这个临时保存的值和列表中第三个元素进行计算,求出一个新的值将最开始</span></span><br><span class="line"><span class="comment"># 临时保存的值覆盖掉,然后在用这个新的临时值和列表中第四个元素计算.依次类推</span></span><br><span class="line"><span class="comment"># 注意:我们放进去的可迭代对象没有更改</span></span><br><span class="line"><span class="comment"># 以上这个例子我们使用sum就可以完全的实现了.我现在有[1,2,3,4]想让列表中的数变成1234,就要用到reduce了.</span></span><br><span class="line"><span class="comment"># 普通函数版</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">10</span> + y</span><br><span class="line">l = reduce(func,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># 匿名函数版</span></span><br><span class="line">l = reduce(<span class="keyword">lambda</span> x,y:x*<span class="number">10</span>+y,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># 在Python2.x版本中recude是直接 import就可以的, Python3.x版本中需要从functools这个包中导入</span></span><br><span class="line"><span class="comment"># 龟叔本打算将 lambda 和 reduce 都从全局名字空间都移除, 舆论说龟叔不喜欢lambda 和 reduce</span></span><br><span class="line"><span class="comment"># 最后lambda没删除是因为和一个人写信写了好多封,进行交流然后把lambda保住了.</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>匿名函数 lambda，顾名思义就是没有名字的函数，也叫一句话函数。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>　　<strong>函数名 = lambda 参数:返回值(对参数的简单处理)</strong></p><p>  1）此函数不是没有名字，他是有名字的，他的名字就是你给其设置的变量，比如func.</p><p>  2）lambda 是定义匿名函数的关键字，相当于函数的def.</p><p>  3）lambda 后面直接加形参，形参加多少都可以，只要用逗号隔开就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> a,b,*args,sex= <span class="string">'alex'</span>,c,**kwargs: kwargs</span><br><span class="line">print(func(<span class="number">3</span>, <span class="number">4</span>,c=<span class="number">666</span>,name=<span class="string">'alex'</span>))  <span class="comment"># &#123;'name': 'alex'&#125;</span></span><br><span class="line"><span class="comment"># 所有类型的形参都可以加，但是一般使用匿名函数只是加位置参数，其他的用不到。</span></span><br></pre></td></tr></table></figure><p>  4）返回值在冒号之后设置，返回值和正常的函数一样,可以是任意数据类型。</p><p>  5）匿名函数不管多复杂.只能写一行.且逻辑结束后直接返回数据</p><h5 id="小题"><a href="#小题" class="headerlink" title="小题"></a>小题</h5><p>写匿名函数：接收一个可切片的数据，返回索引为0与2的对应的元素（元组形式）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func = lambda x:(x[0],x[2])</span><br><span class="line">print(func(&apos;afafasd&apos;))</span><br></pre></td></tr></table></figure><p>写匿名函数：接收两个int参数，将较大的数据返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func = lambda x,y: x if x &gt; y else y</span><br><span class="line">print(func(3,100))</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    series = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line">avg = make_averager()</span><br><span class="line">print(avg(<span class="number">100000</span>))</span><br><span class="line">print(avg(<span class="number">110000</span>))</span><br><span class="line">print(avg(<span class="number">120000</span>))</span><br></pre></td></tr></table></figure><p><strong>大家仔细看一下这个代码，我是在函数中嵌套了一个函数。那么avg 这个变量接收的实际是averager函数名，也就是其对应的内存地址，我执行了三次avg 也就是执行了三次averager这个函数。那么此时你们有什么问题？</strong></p><p>肯定有学生就会问，那么我的make_averager这个函数只是执行了一次，为什么series这个列表没有消失？反而还可以被调用三次呢？这个就是最关键的地方，也是闭包的精华所在。我给大家说一下这个原理，以图为证：</p><p><img src="http://crm.pythonav.com/media/uploads/2019/04/12/IMAGE.PNG" alt="img"></p><p>  上面被红色方框框起来的区域就是闭包，被蓝色圈起来的那个变量应该是make_averager()函数的局部变量，它应该是随着make_averager()函数的执行结束之后而消失。但是他没有，是因为此区域形成了闭包，series变量就变成了一个叫<strong>自由变量</strong>的东西，averager函数的作用域会延伸到包含自由变量series的绑定。也就是说，每次我调用avg对应的averager函数 时，都可以引用到这个自用变量series，这个就是闭包。</p><h5 id="闭包的定义："><a href="#闭包的定义：" class="headerlink" title="闭包的定义："></a>闭包的定义：</h5><ol><li><p>闭包是嵌套在函数中的函数。</p></li><li><p>闭包必须是内层函数对外层函数的变量（非全局变量）的引用。</p></li></ol><h5 id="判断-2"><a href="#判断-2" class="headerlink" title="判断"></a>判断</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 例一：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">ret = wrapper()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例二：</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">ret = wrapper()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例三：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line">ret = wrapper(a,b)</span><br></pre></td></tr></table></figure><p>以上三个例子，最难判断的是第三个，其实第三个也是闭包，如果我们每次去研究代码判断其是不是闭包，有一些不科学，或者过于麻烦了，那么有一些函数的属性是可以获取到此函数是否拥有自由变量的，如果此函数拥有自由变量，那么就可以侧面证明其是否是闭包函数了（<strong>了解</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    series = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line">avg = make_averager()</span><br><span class="line"><span class="comment"># 函数名.__code__.co_freevars 查看函数的自由变量</span></span><br><span class="line">print(avg.__code__.co_freevars)  <span class="comment"># ('series',)</span></span><br><span class="line">当然还有一些参数，仅供了解：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名.__code__.co_freevars 查看函数的自由变量</span></span><br><span class="line">print(avg.__code__.co_freevars)  <span class="comment"># ('series',)</span></span><br><span class="line"><span class="comment"># 函数名.__code__.co_varnames 查看函数的局部变量</span></span><br><span class="line">print(avg.__code__.co_varnames)  <span class="comment"># ('new_value', 'total')</span></span><br><span class="line"><span class="comment"># 函数名.__closure__ 获取具体的自由变量对象，也就是cell对象。</span></span><br><span class="line"><span class="comment"># (&lt;cell at 0x0000020070CB7618: int object at 0x000000005CA08090&gt;,)</span></span><br><span class="line"><span class="comment"># cell_contents 自由变量具体的值</span></span><br><span class="line">print(avg.__closure__[<span class="number">0</span>].cell_contents)  <span class="comment"># []</span></span><br></pre></td></tr></table></figure><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>保存局部信息不被销毁，保证数据的安全性。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ol><li>可以保存一些非全局变量但是不易被销毁、改变的数据。</li><li>装饰器</li></ol><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><h5 id="开发封闭原则"><a href="#开发封闭原则" class="headerlink" title="开发封闭原则"></a>开发封闭原则</h5><p>  1.对扩展是开放的</p><p>​    我们说，任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。</p><p>  2.对修改是封闭的</p><p>​    就像我们刚刚提到的，因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对函数内部进行修改，或者修改了函数的调用方式，很有可能影响其他已经在使用该函数的用户。OK，理解了开封封闭原则之后，我们聊聊装饰器。</p><p><strong>所以装饰器最终最完美的定义就是：在不改变原被装饰的函数的源代码以及调用方式下，为其添加额外的功能。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常识&quot;&gt;&lt;a href=&quot;#常识&quot; class=&quot;headerlink&quot; title=&quot;常识&quot;&gt;&lt;/a&gt;常识&lt;/h3&gt;&lt;h4 id=&quot;计算机基本组件&quot;&gt;&lt;a href=&quot;#计算机基本组件&quot; class=&quot;headerlink&quot; title=&quot;计算机基本组件&quot;&gt;&lt;/a&gt;计算机基本组件&lt;/h4&gt;&lt;h5 id=&quot;cpu&quot;&gt;&lt;a href=&quot;#cpu&quot; class=&quot;headerlink&quot; title=&quot;cpu&quot;&gt;&lt;/a&gt;cpu&lt;/h5&gt;&lt;p&gt;计算机的运算和计算中心&lt;/p&gt;
&lt;p&gt;人类一秒，可以运行10亿条指令，比内存快百度，硬盘快百万倍&lt;/p&gt;
&lt;h5 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h5&gt;&lt;p&gt;暂时存储数据，临时加载数据应用程序，分为RAM，ROM&lt;/p&gt;
&lt;h5 id=&quot;硬盘&quot;&gt;&lt;a href=&quot;#硬盘&quot; class=&quot;headerlink&quot; title=&quot;硬盘&quot;&gt;&lt;/a&gt;硬盘&lt;/h5&gt;&lt;p&gt;长期存储数据&lt;/p&gt;
&lt;h5 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h5&gt;&lt;p&gt;一个软件，连接计算机的硬件与所有软件之间的一个软件&lt;/p&gt;
&lt;h4 id=&quot;python历史&quot;&gt;&lt;a href=&quot;#python历史&quot; class=&quot;headerlink&quot; title=&quot;python历史&quot;&gt;&lt;/a&gt;python历史&lt;/h4&gt;&lt;p&gt;python崇尚优雅，简洁&lt;/p&gt;
&lt;p&gt;2和3有较多区别&lt;/p&gt;
&lt;h4 id=&quot;python的种类&quot;&gt;&lt;a href=&quot;#python的种类&quot; class=&quot;headerlink&quot; title=&quot;python的种类&quot;&gt;&lt;/a&gt;python的种类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Cpython：官方推荐解释器。可以转化成C语言能识别的字节码。&lt;/li&gt;
&lt;li&gt;Jpython: 可以转化成Java语言能识别的字节码。&lt;/li&gt;
&lt;li&gt;Ironpython：可以转化成.net语言能识别的字节码&lt;/li&gt;
&lt;li&gt;pypy: 动态编译&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="老男孩" scheme="http://yoursite.com/tags/%E8%80%81%E7%94%B7%E5%AD%A9/"/>
    
  </entry>
  
  <entry>
    <title>requests</title>
    <link href="http://yoursite.com/2020/01/31/requests/"/>
    <id>http://yoursite.com/2020/01/31/requests/</id>
    <published>2020-01-31T13:04:33.000Z</published>
    <updated>2020-02-01T11:02:01.390Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="python爬虫" scheme="http://yoursite.com/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫踩得坑</title>
    <link href="http://yoursite.com/2020/01/31/%E7%88%AC%E8%99%AB%E8%B8%A9%E5%BE%97%E5%9D%91/"/>
    <id>http://yoursite.com/2020/01/31/爬虫踩得坑/</id>
    <published>2020-01-31T01:35:10.000Z</published>
    <updated>2020-02-08T01:28:12.106Z</updated>
    
    <content type="html"><![CDATA[<h5 id="百度最近更新，需要过安检"><a href="#百度最近更新，需要过安检" class="headerlink" title="百度最近更新，需要过安检"></a>百度最近更新，需要过安检</h5><p>默认情况 下先请求一次百度获取这些参数，然后每次请求带上即可 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">item.Header.Add(&quot;Bdpagetype&quot;, &quot; 3&quot;);//设置请求头信息（Header） </span><br><span class="line">item.Header.Add(&quot;Bdqid&quot;, &quot; 0xd30b86920004fb3f&quot;);//设置请求头信息（Header） </span><br><span class="line">item.Header.Add(&quot;Cache-Control&quot;, &quot; private&quot;);//设置请求头信息（Header） </span><br><span class="line">item.Header.Add(&quot;Ckpacknum&quot;, &quot; 2&quot;);//设置请求头信息（Header） </span><br><span class="line">item.Header.Add(&quot;Ckrndstr&quot;, &quot; 20004fb3f&quot;);//设置请求头信息（Header） </span><br><span class="line">item.Header.Add(&quot;Strict-Transport-Security&quot;, &quot; max-age=172800&quot;);//设置请求头信息（Header） </span><br><span class="line">item.Header.Add(&quot;Traceid&quot;, &quot; 1574759518274850689015207396528370285375&quot;);//设置请求头信息（Header）</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="抓取简书登录cookie"><a href="#抓取简书登录cookie" class="headerlink" title="抓取简书登录cookie"></a>抓取简书登录cookie</h5><p>登录发现post需要包含参数</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/20200131201546.png" alt></p><p>检查页面，发现在这儿，但不知如何取值</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/20200131201659.png" alt></p><p>authenticity_token应该每个页面动态生成</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/20200131201905.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;百度最近更新，需要过安检&quot;&gt;&lt;a href=&quot;#百度最近更新，需要过安检&quot; class=&quot;headerlink&quot; title=&quot;百度最近更新，需要过安检&quot;&gt;&lt;/a&gt;百度最近更新，需要过安检&lt;/h5&gt;&lt;p&gt;默认情况 下先请求一次百度获取这些参数，然后每次请求带上即可 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;item.Header.Add(&amp;quot;Bdpagetype&amp;quot;, &amp;quot; 3&amp;quot;);//设置请求头信息（Header） &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item.Header.Add(&amp;quot;Bdqid&amp;quot;, &amp;quot; 0xd30b86920004fb3f&amp;quot;);//设置请求头信息（Header） &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item.Header.Add(&amp;quot;Cache-Control&amp;quot;, &amp;quot; private&amp;quot;);//设置请求头信息（Header） &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item.Header.Add(&amp;quot;Ckpacknum&amp;quot;, &amp;quot; 2&amp;quot;);//设置请求头信息（Header） &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item.Header.Add(&amp;quot;Ckrndstr&amp;quot;, &amp;quot; 20004fb3f&amp;quot;);//设置请求头信息（Header） &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item.Header.Add(&amp;quot;Strict-Transport-Security&amp;quot;, &amp;quot; max-age=172800&amp;quot;);//设置请求头信息（Header） &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;item.Header.Add(&amp;quot;Traceid&amp;quot;, &amp;quot; 1574759518274850689015207396528370285375&amp;quot;);//设置请求头信息（Header）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫入门</title>
    <link href="http://yoursite.com/2020/01/30/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/01/30/爬虫入门/</id>
    <published>2020-01-30T09:26:18.000Z</published>
    <updated>2020-02-01T11:01:40.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/http.png" alt></p><a id="more"></a><h3 id="爬虫入门"><a href="#爬虫入门" class="headerlink" title="爬虫入门"></a>爬虫入门</h3><h4 id="爬虫简介"><a href="#爬虫简介" class="headerlink" title="爬虫简介"></a>爬虫简介</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/%E7%88%AC%E8%99%AB%E7%9A%84%E7%AE%80%E4%BB%8B1.png" alt></p><p>&lt;</p><h4 id="urllib-request"><a href="#urllib-request" class="headerlink" title="urllib.request"></a>urllib.request</h4><p>python3内置的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 用https时拿不到数据</span></span><br><span class="line">    url = <span class="string">"http://www.baidu.com/"</span></span><br><span class="line">    response = urllib.request.urlopen(url)</span><br><span class="line">    <span class="comment"># print(response)</span></span><br><span class="line">    data = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="comment"># print(data)</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"baidu.html"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br><span class="line">    <span class="comment"># python爬取到的多为str,bytes</span></span><br><span class="line">    <span class="comment"># str通过对应encode("编码")转为bytes，同理bytes通过decode转为str</span></span><br><span class="line">    <span class="comment"># 具体编码格式见html页面head头信息中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">load_data()</span><br></pre></td></tr></table></figure><p><strong>get传参要注意转成url编码</strong></p><p>由于百度更新，以下过不了安检，实际上拿不到数据了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_param</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">"http://www.baidu.com/s?wd="</span></span><br><span class="line">    param = <span class="string">"美女"</span></span><br><span class="line">    final_url = url + param</span><br><span class="line">    <span class="comment"># python解释器只支持ASCII码，所以必须转码</span></span><br><span class="line">    final_url = urllib.parse.quote(final_url, safe=string.printable)</span><br><span class="line">    response = urllib.request.urlopen(final_url)</span><br><span class="line">    data_str = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"meinv.html"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_param()</span><br></pre></td></tr></table></figure><p>字典传参时,这样得到字符串参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;</span><br><span class="line">    <span class="string">"wd"</span>: <span class="string">"中文"</span>,</span><br><span class="line">    <span class="string">"key"</span>: <span class="string">"zhang"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="string">"san"</span></span><br><span class="line">&#125;</span><br><span class="line">params_str = urllib.parse.urlencode(params)</span><br></pre></td></tr></table></figure><p>绑定请求头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3"</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="comment"># 浏览器版本</span></span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36"</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 创建时绑定请求头，也可以requset.add_header()来动态绑定</span></span><br><span class="line">request = urllib.request.Request(url, headers=header)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br></pre></td></tr></table></figure><p>获取随机的User-Agent(第三方包)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line">    print(UserAgent().chrome)</span><br><span class="line">    print(UserAgent().ie)</span><br><span class="line">    print(UserAgent().firefox)</span><br><span class="line">    print(UserAgent().opera)</span><br><span class="line">    print(UserAgent().safari)</span><br><span class="line">    print(UserAgent().random)</span><br></pre></td></tr></table></figure><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p>对urlopen进行扩展</p><p>urlopen源码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> _opener</span><br><span class="line"><span class="keyword">if</span> cafile <span class="keyword">or</span> capath <span class="keyword">or</span> cadefault:</span><br><span class="line">    <span class="keyword">import</span> warnings</span><br><span class="line">    warnings.warn(<span class="string">"cafile, capath and cadefault are deprecated, use a "</span></span><br><span class="line">                  <span class="string">"custom context instead."</span>, DeprecationWarning, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> context <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(</span><br><span class="line">            <span class="string">"You can't pass both context and any of cafile, capath, and "</span></span><br><span class="line">            <span class="string">"cadefault"</span></span><br><span class="line">        )</span><br><span class="line">  <span class="comment"># 安全套阶层，第三方CA数字证书</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _have_ssl:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'SSL support not available'</span>)</span><br><span class="line">    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,</span><br><span class="line">                                         cafile=cafile,</span><br><span class="line">                                         capath=capath)</span><br><span class="line">    <span class="comment"># 默认用HTTPSHandler，可以用别的Handler来实现功能扩展</span></span><br><span class="line">    https_handler = HTTPSHandler(context=context)</span><br><span class="line">    opener = build_opener(https_handler)</span><br><span class="line"><span class="keyword">elif</span> context:</span><br><span class="line">    https_handler = HTTPSHandler(context=context)</span><br><span class="line">    opener = build_opener(https_handler)</span><br><span class="line"><span class="keyword">elif</span> _opener <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    _opener = opener = build_opener()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    opener = _opener</span><br><span class="line"><span class="keyword">return</span> opener.open(url, data, timeout)</span><br></pre></td></tr></table></figure><h6 id="HTTPHandler演示"><a href="#HTTPHandler演示" class="headerlink" title="HTTPHandler演示"></a>HTTPHandler演示</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">"https://www.baidu.com/"</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="comment"># 浏览器版本</span></span><br><span class="line">    <span class="string">"User-Agent"</span>: UserAgent().random</span><br><span class="line">&#125;</span><br><span class="line">request = urllib.request.Request(url, headers=header)</span><br><span class="line">handler = urllib.request.HTTPHandler()</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(request)</span><br><span class="line">data = response.read().decode(<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><h6 id="ProxyHandler"><a href="#ProxyHandler" class="headerlink" title="ProxyHandler"></a>ProxyHandler</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_proxy_handler</span><span class="params">()</span>:</span></span><br><span class="line">    url = <span class="string">"https://blog.csdn.net/willsnowdev/article/details/90140266"</span></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="comment"># 浏览器版本</span></span><br><span class="line">        <span class="string">"User-Agent"</span>: UserAgent().random</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 可以用多个IP，到时候随机选取</span></span><br><span class="line">    <span class="comment"># "http": "163.204.247.20:9999"也可</span></span><br><span class="line">    proxy = &#123;</span><br><span class="line">        <span class="string">"http"</span>: <span class="string">"http://163.204.247.20:9999"</span></span><br><span class="line">    &#125;</span><br><span class="line">    request = urllib.request.Request(url, headers=header)</span><br><span class="line">    proxy_handler = urllib.request.ProxyHandler(proxy)</span><br><span class="line">    opener = urllib.request.build_opener(proxy_handler)</span><br><span class="line">    response = opener.open(request)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"requset_header.html"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.read().decode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create_proxy_handler()</span><br></pre></td></tr></table></figure><p>多个免费代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy_list = [</span><br><span class="line">        &#123;<span class="string">"https"</span>:<span class="string">"106.75.226.36:808"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"https"</span>:<span class="string">"61.135.217.7:80"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"https"</span>:<span class="string">"125.70.13.77:8080"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"https"</span>:<span class="string">"118.190.95.35:9001"</span>&#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>付费代理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方式</span></span><br><span class="line">proxy = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"username:pwd@163.204.247.20:9999"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 第二种方式</span></span><br><span class="line">username = <span class="string">"xunzhao"</span></span><br><span class="line">pwd = <span class="string">"173hjgew8"</span></span><br><span class="line">money_proxy1 = <span class="string">"163.204.247.20:9999"</span></span><br><span class="line"><span class="comment"># 创建密码管理器</span></span><br><span class="line">password_manger = urllib.request.HTTPPasswordMgr()</span><br><span class="line">password_manger.add_password(<span class="literal">None</span>, money_proxy1, username, pwd)</span><br><span class="line">handle_auth = urllib.request.ProxyBasicAuthHandler(password_manger)</span><br><span class="line">opener_auth = urllib.request.build_opener(handle_auth)</span><br><span class="line">response = opener_auth.open(url)</span><br></pre></td></tr></table></figure><p>用公司内网爬数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth_nei_wang</span><span class="params">()</span>:</span></span><br><span class="line">    nei_url = <span class="string">"https://www.jianshu.com/p/325bdc0ae92f"</span></span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">"User-Agent"</span>: UserAgent().random</span><br><span class="line">    &#125;</span><br><span class="line">    username = <span class="string">"admin"</span></span><br><span class="line">    pwd = <span class="string">"admin007"</span></span><br><span class="line">    password_manger = urllib.request.HTTPPasswordMgrWithDefaultRealm()</span><br><span class="line">    password_manger.add_password(<span class="literal">None</span>, nei_url, username, pwd)</span><br><span class="line">    <span class="comment"># handle不同，其他和付费代理很像</span></span><br><span class="line">    handle_nei = urllib.request.HTTPBasicAuthHandler(password_manger)</span><br><span class="line">    opener_nei = urllib.request.build_opener(handle_nei)</span><br><span class="line">    response = opener_nei.open(nei_url)</span><br><span class="line">    print(response.read().decode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure><h5 id="cookie认证"><a href="#cookie认证" class="headerlink" title="cookie认证"></a>cookie认证</h5><p>手动获取cookie，添加到header中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;</span><br><span class="line">    <span class="string">"User-Agent"</span>: UserAgent().random,</span><br><span class="line">    <span class="string">"Cookie"</span>: <span class="string">"__yadk_uid=e2gl8vcNK8DLVH2eQd6vHpvH1QvuStkO; web_login_version=MTU4MDA5MDc3OQ%3D%3D--366eb244926d0d504aa444afc85df5e80948cee6; remember_user_token=W1syMTAxNzY3NV0sIiQyYSQxMSRUVGNQenhyZjFtMzdiN3Mxc0xzT25lIiwiMTU4MDQ2MzkzNy42MjQ5NjA0Il0%3D--2fd8938f7291d2405e0c23b0f267c631fad3fd9b; read_mode=day; default_font=font2; locale=zh-CN; _m7e_session_core=ad86ea9fddf5bd5d6969bc414a322298; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%2221017675%22%2C%22%24device_id%22%3A%2216bea6ca2e9365-067bb910973608-e343166-1049088-16bea6ca2ea5c2%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E8%87%AA%E7%84%B6%E6%90%9C%E7%B4%A2%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fwww.baidu.com%2Fs%22%2C%22%24latest_search_keyword%22%3A%22%E7%AE%80%E4%B9%A6%22%2C%22%24latest_utm_source%22%3A%22desktop%22%2C%22%24latest_utm_medium%22%3A%22not-signed-in-like-note-btn-in-bottom%22%2C%22%24latest_referrer_host%22%3A%22www.baidu.com%22%7D%2C%22first_id%22%3A%2216bea6ca2e9365-067bb910973608-e343166-1049088-16bea6ca2ea5c2%22%7D; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1580090858,1580277385,1580463938,1580466286; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1580466310"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动获取，用cookiejar来保存cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取 个人中心的页面</span><br><span class="line"></span><br><span class="line">1. 代码登录  登录成功 cookie(有效)</span><br><span class="line">2. 自动带着cookie 去请求个人中心</span><br><span class="line"></span><br><span class="line">cookiejar 自动保存这个cookie</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;</span><br><span class="line">        <span class="string">"User-Agent"</span>: UserAgent().random,</span><br><span class="line">    &#125;</span><br><span class="line">    url = <span class="string">'https://www.yaozh.com/login'</span></span><br><span class="line">    <span class="comment"># 1.2 登录的参数</span></span><br><span class="line">    login_form_data = &#123;</span><br><span class="line">        <span class="string">"username"</span>: <span class="string">"xiaomaoera12"</span>,</span><br><span class="line">        <span class="string">"pwd"</span>: <span class="string">"lina081012"</span>,</span><br><span class="line">        <span class="string">"formhash"</span>: <span class="string">"CE3ADF28C5"</span>,</span><br><span class="line">        <span class="string">"backurl"</span>: <span class="string">"https%3A%2F%2Fwww.yaozh.com%2F"</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    login_form_data_str = urllib.parse.urlencode(login_form_data).encode(<span class="string">"utf-8"</span>)</span><br><span class="line">    cookie_jar = cookiejar.CookieJar()</span><br><span class="line">    cookie_handle = urllib.request.HTTPCookieProcessor(cookie_jar)</span><br><span class="line">    cookie_opener = urllib.request.build_opener(cookie_handle)</span><br><span class="line">    requset = urllib.request.Request(url, headers=header, data=login_form_data_str)</span><br><span class="line">    cookie_opener.open(requset)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 代码带着cooke去访问 个人中心</span></span><br><span class="line">    center_url = <span class="string">'https://www.yaozh.com/member/'</span></span><br><span class="line">    center_request = urllib.request.Request(center_url, headers=header)</span><br><span class="line">    response = cookie_opener.open(center_url)</span><br><span class="line">    data = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"jianshu.html"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(data)</span><br></pre></td></tr></table></figure><h6 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h6><p>cookiejar原理和urlencode中safe=string.printable作用</p><h5 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h5><h6 id="URLError"><a href="#URLError" class="headerlink" title="URLError"></a>URLError</h6><p>url不存在</p><h6 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h6><p>4××，5××，可通过catch到error后，error.code来打印状态码</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/python3(urlib.request).png" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/handler%E5%A4%84%E7%90%86%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/guardwarm/imageBed/master/http.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python爬虫" scheme="http://yoursite.com/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="http://yoursite.com/2020/01/30/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/01/30/前端基础/</id>
    <published>2020-01-30T09:06:22.000Z</published>
    <updated>2020-01-30T09:21:09.495Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/%E5%89%8D%E7%AB%AF.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/guardwarm/imageBed/master/%E5%89%8D%E7%AB%AF.png&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="python爬虫" scheme="http://yoursite.com/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="http://yoursite.com/tags/python%E7%88%AC%E8%99%AB/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="http://yoursite.com/2019/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    <id>http://yoursite.com/2019/10/01/数据结构和算法之美/</id>
    <published>2019-10-01T13:20:26.000Z</published>
    <updated>2020-02-18T01:58:53.260Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前提须知"><a href="#前提须知" class="headerlink" title="前提须知"></a>前提须知</h3><h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><ul><li>写出性能更高的程序</li><li>更快更深的掌握一门技术</li><li>数据结构+算法=程序</li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ol><li><p>定义<br> 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p></li><li><p>链表适合插入、删除，时间复杂度O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1)</p></li><li><p>警惕数组的访问越界问题</p></li><li><p>我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p></li><li><p>如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。</p></li><li><p>容器可否完全替代数组</p><ul><li>.Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li><li>如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。</li><li>.还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList &gt; array。</li><li>总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</li></ul></li><li><p>数组下标为何从零开始<br> 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure></li></ol><pre><code>但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure>对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非0开始不可。所以我觉得最主要的原因可能是历史原因。</code></pre><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul><li>常见的缓存淘汰策略有三种：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。</li></ul><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前提须知&quot;&gt;&lt;a href=&quot;#前提须知&quot; class=&quot;headerlink&quot; title=&quot;前提须知&quot;&gt;&lt;/a&gt;前提须知&lt;/h3&gt;&lt;h4 id=&quot;用处&quot;&gt;&lt;a href=&quot;#用处&quot; class=&quot;headerlink&quot; title=&quot;用处&quot;&gt;&lt;/a&gt;用处&lt;/h
      
    
    </summary>
    
      <category term="极客时间" scheme="http://yoursite.com/categories/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://yoursite.com/2019/09/21/XML/"/>
    <id>http://yoursite.com/2019/09/21/XML/</id>
    <published>2019-09-21T06:35:31.000Z</published>
    <updated>2020-01-31T12:55:23.328Z</updated>
    
    <content type="html"><![CDATA[<h5 id="XML介绍"><a href="#XML介绍" class="headerlink" title="XML介绍"></a>XML介绍</h5><p>XML:可扩展的标记语言。</p><p>可扩展的:扩展性特别强,语法上比较松</p><p>标记: <dog> </dog></p><p>我们用的是1.0的版本</p><p>用于存放数据或配置文件</p><h5 id="XML的语法"><a href="#XML的语法" class="headerlink" title="XML的语法:"></a>XML的语法:</h5><p>a.文档声明</p><blockquote><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p><p>版本一般选1.0，编码默认是utf8</p></blockquote><p>b.注释:</p><blockquote><p>开始：&lt;!– </p><p>结束    –&gt;</p></blockquote><p>c.元素(Element)/标签(Tag)</p><blockquote><p>必须有开始和结束标签组成  &lt;dan&gt; &lt;/dan&gt;</p><p>一般只有一个跟标签，可以相互嵌套</p></blockquote><a id="more"></a><p>d.属性:attribute</p><blockquote><p>属性名=“属性值”</p><p>必须写在开始标签中</p><p>必须以字母开头</p></blockquote><p>e.转义字符</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">---</span> &amp;<span class="attr">lt</span>;</span></span><br><span class="line"><span class="tag">&gt;</span> --- &amp;gt;</span><br><span class="line">" --- &amp;quot;</span><br><span class="line">' --- &amp;apos;</span><br><span class="line">&amp; --- &amp;amp</span><br></pre></td></tr></table></figure><p>f.CDATA区</p><p>当内容中出现大量的需要转译的字符<br>    XML提供了CDATA区</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abc</span>&gt;</span></span><br><span class="line">&lt;![CDATA[</span><br><span class="line">String s = "abc";</span><br><span class="line">int count = 0;</span><br><span class="line">for(int i = 0;i &lt; s.length() ; i++)&#123;</span><br><span class="line">char c = s.charAt(i);</span><br><span class="line">if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')&#123;</span><br><span class="line">count++;]]&gt;</span><br><span class="line"><span class="comment">&lt;!--  特例：里面还包含了]]&gt;,需要分开成两个CDATA区 --&gt;</span></span><br><span class="line">    ]]&amp;gt;</span><br><span class="line">&lt;![CDATA[</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println("count = " + count);</span><br><span class="line">]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">abc</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="XML约束"><a href="#XML约束" class="headerlink" title="XML约束"></a>XML约束</h5><ul><li>DTD约束</li></ul><p>文档开始注释会提示在xml文档前添加&lt;!DOCTYPE beans SYSTEM “bean.dtd”&gt;</p><p>第一个值为跟标签名字</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/javase31.JPG" alt></p><p>根据智能提示编写即可</p><p>三种引入方式</p><blockquote><p>内部DTD</p><p>外部DTD</p><blockquote><p>SYSTEM    本地DTD,后面一般跟个文件名</p><p>PUBLIC    公共DTD，后面一般跟个网址</p></blockquote></blockquote><ul><li>Schema约束</li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/javase32.JPG" alt></p><p>文档开头注释会提示应在xml中1导入的信息</p><p>&lt;beans xmlns=”<a href="http://www.itcast.cn/bean&quot;" target="_blank" rel="noopener">http://www.itcast.cn/bean&quot;</a>   xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance&quot;</a>   xsi:schemaLocation=”<a href="http://www.itcast.cn/bean" target="_blank" rel="noopener">http://www.itcast.cn/bean</a> bean-schema.xsd”&gt;</p><p>注意这是一个开始标签，添加一下结束标签即可，其余使用方法和DTD差不多</p><p>如果有多个schema约束文件名字冲突时，需使用targetname来指定，但显得很冗长，可以给其起个别名</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/javase33.JPG" alt></p><h5 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h5><p>用io流来解析太过繁琐，一般使用第三方提供的解析开发包</p><p><strong>三种解析方式</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/javase34.JPG" alt></p><p><strong>常用解析开发包</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/javase35.JPG" alt></p><h5 id="dom4j"><a href="#dom4j" class="headerlink" title="dom4j"></a>dom4j</h5><p>1.核心类 SAXReader:加载XML文件</p><p>2.Document对象,表示整个XML文件对象</p><p>3.元素:Element</p><p>获取根元素: document.getRootElement();</p><p>获取属性: element.attributeValue(“属性名”)</p><p>获取子元素:List<element> element.elements();//好几个重载</element></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被解析文件</span></span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;bean id=<span class="string">"001"</span> className=<span class="string">"cn.itcast.demo.User"</span>&gt;</span><br><span class="line">&lt;property name="username" value="jack"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="password" value="123"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"002"</span> className=<span class="string">"cn.itcast.demo.Admin"</span>&gt;</span><br><span class="line">&lt;property name="username" value="admin"&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name="password" value="123321"&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dom4JDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//1.把整个要解析的XML文件加载到内存</span></span><br><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="comment">//2.会生产一个Documnet对象</span></span><br><span class="line">Document document =reader.read(<span class="keyword">new</span> File(<span class="string">"beans.xml"</span>));</span><br><span class="line"><span class="comment">//3.获取根标签</span></span><br><span class="line">Element rootEle = document.getRootElement();</span><br><span class="line"><span class="comment">//4.获取根标签的子标签</span></span><br><span class="line">List&lt;Element&gt; beanElements = rootEle.elements();</span><br><span class="line"><span class="comment">//5.遍历elements集合</span></span><br><span class="line"><span class="keyword">for</span> (Element beanElement : beanElements) &#123;</span><br><span class="line"><span class="comment">//6.获取子标签bean的属性</span></span><br><span class="line">String idValue = beanElement.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">String classNameValue = beanElement.attributeValue(<span class="string">"className"</span>);</span><br><span class="line">System.out.println(idValue+<span class="string">".."</span>+classNameValue);</span><br><span class="line"><span class="comment">//获取bean的子标签</span></span><br><span class="line">List&lt;Element&gt; propertyElements = beanElement.elements();</span><br><span class="line"><span class="comment">//遍历property标签</span></span><br><span class="line"><span class="keyword">for</span> (Element propertyElement : propertyElements) &#123;</span><br><span class="line"><span class="comment">//propertyElement Property标签</span></span><br><span class="line"><span class="comment">//获取Property的属性</span></span><br><span class="line">String nameValue = propertyElement.attributeValue(<span class="string">"name"</span>);</span><br><span class="line">String valuevalue = propertyElement.attributeValue(<span class="string">"value"</span>);</span><br><span class="line">System.out.println(nameValue+<span class="string">"==="</span>+valuevalue);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;XML介绍&quot;&gt;&lt;a href=&quot;#XML介绍&quot; class=&quot;headerlink&quot; title=&quot;XML介绍&quot;&gt;&lt;/a&gt;XML介绍&lt;/h5&gt;&lt;p&gt;XML:可扩展的标记语言。&lt;/p&gt;
&lt;p&gt;可扩展的:扩展性特别强,语法上比较松&lt;/p&gt;
&lt;p&gt;标记: &lt;dog&gt; &lt;/dog&gt;&lt;/p&gt;
&lt;p&gt;我们用的是1.0的版本&lt;/p&gt;
&lt;p&gt;用于存放数据或配置文件&lt;/p&gt;
&lt;h5 id=&quot;XML的语法&quot;&gt;&lt;a href=&quot;#XML的语法&quot; class=&quot;headerlink&quot; title=&quot;XML的语法:&quot;&gt;&lt;/a&gt;XML的语法:&lt;/h5&gt;&lt;p&gt;a.文档声明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;lt;?xml version=”1.0” encoding=”UTF-8”?&amp;gt;&lt;/p&gt;
&lt;p&gt;版本一般选1.0，编码默认是utf8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;b.注释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开始：&amp;lt;!– &lt;/p&gt;
&lt;p&gt;结束    –&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;c.元素(Element)/标签(Tag)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;必须有开始和结束标签组成  &amp;lt;dan&amp;gt; &amp;lt;/dan&amp;gt;&lt;/p&gt;
&lt;p&gt;一般只有一个跟标签，可以相互嵌套&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="xml" scheme="http://yoursite.com/tags/xml/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://yoursite.com/2019/09/20/MySQL/"/>
    <id>http://yoursite.com/2019/09/20/MySQL/</id>
    <published>2019-09-20T14:52:34.000Z</published>
    <updated>2020-02-25T13:47:13.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL4. 常见的数据库软件    * 参见《MySQL基础.pdf》</code></pre><a id="more"></a><h2 id="MySQL数据库软件"><a href="#MySQL数据库软件" class="headerlink" title="MySQL数据库软件"></a>MySQL数据库软件</h2><pre><code>1. 安装    * 参见《MySQL基础.pdf》2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200225181027-136224.bmp" alt="SQL分类"></p><h3 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL:操作数据库、表"></a>DDL:操作数据库、表</h3><h4 id="操作库"><a href="#操作库" class="headerlink" title="操作库"></a>操作库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 操作数据库：CRUD</span><br><span class="line">1. C(Create):创建</span><br><span class="line">* 创建数据库：</span><br><span class="line">* create database 数据库名称;</span><br><span class="line">* 创建数据库，判断不存在，再创建：</span><br><span class="line">* create database if not exists 数据库名称;</span><br><span class="line">* 创建数据库，并指定字符集</span><br><span class="line">* create database 数据库名称 character set 字符集名;</span><br><span class="line"></span><br><span class="line">* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk</span><br><span class="line">* create database if not exists db4 character set gbk;</span><br><span class="line">2. R(Retrieve)：查询</span><br><span class="line">* 查询所有数据库的名称:</span><br><span class="line">* show databases;</span><br><span class="line">* 查询某个数据库的字符集、某个数据库的创建语句</span><br><span class="line">* show create database 数据库名称;</span><br><span class="line">3. U(Update):修改</span><br><span class="line">* 修改数据库的字符集</span><br><span class="line">* alter database 数据库名称 character set 字符集名称;</span><br><span class="line">4. D(Delete):删除</span><br><span class="line">* 删除数据库</span><br><span class="line">* drop database 数据库名称;</span><br><span class="line">* 判断数据库存在，存在再删除</span><br><span class="line">* drop database if exists 数据库名称;</span><br><span class="line">5. 使用数据库</span><br><span class="line">* 查询当前正在使用的数据库名称</span><br><span class="line">* select database();</span><br><span class="line">* 使用数据库</span><br><span class="line">* use 数据库名称;</span><br></pre></td></tr></table></figure><h4 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">       1. C(Create):创建</span><br><span class="line">           1. 语法：</span><br><span class="line">               create table 表名(</span><br><span class="line">                   列名1 数据类型1,</span><br><span class="line">                   列名2 数据类型2,</span><br><span class="line">                   ....</span><br><span class="line">                   列名n 数据类型n</span><br><span class="line">               );</span><br><span class="line">               * 注意：最后一列，不需要加逗号（,）</span><br><span class="line">               * 数据库类型：</span><br><span class="line">                   1. int：整数类型</span><br><span class="line">                       * age int,</span><br><span class="line">                   2. double:小数类型</span><br><span class="line">                       * score double(5,2)</span><br><span class="line">                   3. date:日期，只包含年月日，yyyy-MM-dd</span><br><span class="line">                   4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss</span><br><span class="line">                   5. timestamp:时间错类型包含年月日时分秒 yyyy-MM-dd HH:mm:ss</span><br><span class="line">                       * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</span><br><span class="line">                   6. varchar：字符串</span><br><span class="line">                       * name varchar(20):姓名最大20个字符</span><br><span class="line">                       * zhangsan 8个字符  张三 2个字符</span><br><span class="line">               * 创建表</span><br><span class="line">                   create table student(</span><br><span class="line">                       id int,</span><br><span class="line">                       name varchar(32),</span><br><span class="line">                       age int ,</span><br><span class="line">                       score double(4,1),</span><br><span class="line">                       birthday date,</span><br><span class="line">                       insert_time timestamp</span><br><span class="line">                   );</span><br><span class="line">               * 复制表：</span><br><span class="line">                   * create table 表名 like 被复制的表名;  </span><br><span class="line">2. R(Retrieve)：查询</span><br><span class="line">* 查询某个数据库中所有的表名称</span><br><span class="line">* show tables;</span><br><span class="line">* 查询表结构</span><br><span class="line">* desc 表名;</span><br><span class="line">3. U(Update):修改</span><br><span class="line">1. 修改表名</span><br><span class="line">alter table 表名 rename to 新的表名;</span><br><span class="line">2. 修改表的字符集</span><br><span class="line">alter table 表名 character set 字符集名称;</span><br><span class="line">3. 添加一列</span><br><span class="line">alter table 表名 add 列名 数据类型;</span><br><span class="line">4. 修改列名称 类型</span><br><span class="line">alter table 表名 change 列名 新列名 新数据类型;</span><br><span class="line">alter table 表名 modify 列名 新数据类型;</span><br><span class="line">5. 删除列</span><br><span class="line">alter table 表名 drop 列名;</span><br><span class="line">4. D(Delete):删除</span><br><span class="line">* drop table 表名;</span><br><span class="line">* drop table  if exists 表名 ;</span><br></pre></td></tr></table></figure><h5 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。</span><br><span class="line">* 分类：</span><br><span class="line">1. 主键约束：primary key</span><br><span class="line">2. 非空约束：not null</span><br><span class="line">3. 唯一约束：unique</span><br><span class="line">4. 外键约束：foreign key</span><br><span class="line"></span><br><span class="line">* 非空约束：not null，某一列的值不能为null</span><br><span class="line">1. 创建表时添加约束</span><br><span class="line">CREATE TABLE stu(</span><br><span class="line">id INT,</span><br><span class="line">NAME VARCHAR(20) NOT NULL -- name为非空</span><br><span class="line">);</span><br><span class="line">2. 创建表完后，添加非空约束</span><br><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;</span><br><span class="line"></span><br><span class="line">3. 删除name的非空约束</span><br><span class="line">ALTER TABLE stu MODIFY NAME VARCHAR(20);</span><br><span class="line"></span><br><span class="line">* 唯一约束：unique，某一列的值不能重复</span><br><span class="line">1. 注意：</span><br><span class="line">* 唯一约束可以有NULL值，但是只能有一条记录为null</span><br><span class="line">2. 在创建表时，添加唯一约束</span><br><span class="line">CREATE TABLE stu(</span><br><span class="line">id INT,</span><br><span class="line">phone_number VARCHAR(20) UNIQUE -- 手机号</span><br><span class="line">);</span><br><span class="line">3. 删除唯一约束</span><br><span class="line">ALTER TABLE stu DROP INDEX phone_number;</span><br><span class="line">4. 在表创建完后，添加唯一约束</span><br><span class="line">ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;</span><br><span class="line"></span><br><span class="line">* 主键约束：primary key。</span><br><span class="line">1. 注意：</span><br><span class="line">1. 含义：非空且唯一</span><br><span class="line">2. 一张表只能有一个字段为主键</span><br><span class="line">3. 主键就是表中记录的唯一标识</span><br><span class="line"></span><br><span class="line">2. 在创建表时，添加主键约束</span><br><span class="line">create table stu(</span><br><span class="line">id int primary key,-- 给id添加主键约束</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">3. 删除主键</span><br><span class="line">-- 错误 alter table stu modify id int ;</span><br><span class="line">ALTER TABLE stu DROP PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">4. 创建完表后，添加主键</span><br><span class="line">ALTER TABLE stu MODIFY id INT PRIMARY KEY;</span><br><span class="line"></span><br><span class="line">5. 自动增长：</span><br><span class="line">1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</span><br><span class="line"></span><br><span class="line">2. 在创建表时，添加主键约束，并且完成主键自增长</span><br><span class="line">create table stu(</span><br><span class="line">id int primary key auto_increment,-- 给id添加主键约束</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br><span class="line">3. 删除自动增长</span><br><span class="line">ALTER TABLE stu MODIFY id INT;</span><br><span class="line">4. 添加自动增长</span><br><span class="line">ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</span><br><span class="line">* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。</span><br><span class="line">1. 在创建表时，可以添加外键</span><br><span class="line">* 语法：</span><br><span class="line">create table 表名(</span><br><span class="line">....</span><br><span class="line">外键列</span><br><span class="line">constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">2. 删除外键</span><br><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br><span class="line"></span><br><span class="line">3. 创建表之后，添加外键</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 </span><br><span class="line">FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</span><br><span class="line">4. 级联操作</span><br><span class="line">1. 添加级联操作</span><br><span class="line">语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 </span><br><span class="line">FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) </span><br><span class="line">ON UPDATE CASCADE ON DELETE CASCADE  ;</span><br><span class="line">2. 分类：</span><br><span class="line">1. 级联更新：ON UPDATE CASCADE </span><br><span class="line">2. 级联删除：ON DELETE CASCADE 添加需谨慎</span><br></pre></td></tr></table></figure><h3 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 添加数据：</span><br><span class="line">* 语法：</span><br><span class="line">* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);</span><br><span class="line">* 注意：</span><br><span class="line">1. 列名和值要一一对应。</span><br><span class="line">2. 如果表名后，不定义列名，则默认给所有列添加值</span><br><span class="line">insert into 表名 values(值1,值2,...值n);</span><br><span class="line">3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来</span><br><span class="line">2. 删除数据：</span><br><span class="line">* 语法：</span><br><span class="line">* delete from 表名 [where 条件]</span><br><span class="line">* 注意：</span><br><span class="line">1. 如果不加条件，则删除表中所有记录。</span><br><span class="line">2. 如果要删除所有记录</span><br><span class="line">1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作</span><br><span class="line">2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span><br><span class="line">3. 修改数据：</span><br><span class="line">* 语法：</span><br><span class="line">* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];</span><br><span class="line"></span><br><span class="line">* 注意：</span><br><span class="line">1. 如果不加任何条件，则会将表中所有记录全部修改。</span><br></pre></td></tr></table></figure><h3 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">1. 语法：</span><br><span class="line">select</span><br><span class="line">字段列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where</span><br><span class="line">条件列表</span><br><span class="line">group by</span><br><span class="line">分组字段</span><br><span class="line">having</span><br><span class="line">分组之后的条件</span><br><span class="line">order by</span><br><span class="line">排序</span><br><span class="line">limit</span><br><span class="line">分页限定</span><br><span class="line">2. 基础查询</span><br><span class="line">1. 多个字段的查询</span><br><span class="line">select 字段名1，字段名2... from 表名；</span><br><span class="line">* 注意：</span><br><span class="line">* 如果查询所有字段，则可以使用*来替代字段列表，但不推荐使用</span><br><span class="line">2. 去除重复：</span><br><span class="line">* distinct</span><br><span class="line">3. 计算列</span><br><span class="line">* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</span><br><span class="line">* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null</span><br><span class="line">* 表达式1：哪个字段需要判断是否为null</span><br><span class="line">* 如果该字段为null后的替换值。</span><br><span class="line">4. 起别名：</span><br><span class="line">* as：as也可以省略</span><br><span class="line">3. 条件查询</span><br><span class="line">1. where子句后跟条件</span><br><span class="line">2. 运算符</span><br><span class="line">* &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;</span><br><span class="line">* BETWEEN...AND  </span><br><span class="line">* IN( 集合) </span><br><span class="line">* LIKE：模糊查询</span><br><span class="line">* 占位符：</span><br><span class="line">* _:单个任意字符</span><br><span class="line">* %：多个任意字符</span><br><span class="line">* IS NULL  </span><br><span class="line">* and  或 &amp;&amp;</span><br><span class="line">* or  或 || </span><br><span class="line">* not  或 !</span><br><span class="line"></span><br><span class="line">-- 查询年龄大于等于20 小于等于30</span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;</span><br><span class="line">SELECT * FROM student WHERE age BETWEEN 20 AND 30;</span><br><span class="line"></span><br><span class="line">-- 查询年龄22岁，18岁，25岁的信息</span><br><span class="line">SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25</span><br><span class="line">SELECT * FROM student WHERE age IN (22,18,25);</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩为null</span><br><span class="line">SELECT * FROM student WHERE english = NULL; -- null值不能使用 = （!=） 判断</span><br><span class="line">SELECT * FROM student WHERE english IS NULL;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩不为null</span><br><span class="line">SELECT * FROM student WHERE english  IS NOT NULL;</span><br><span class="line"></span><br><span class="line">-- 查询姓马的有哪些？ like</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;;</span><br><span class="line">-- 查询姓名第二个字是化的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;</span><br><span class="line">-- 查询姓名是3个字的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &apos;___&apos;;</span><br><span class="line">-- 查询姓名中包含德的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;;</span><br></pre></td></tr></table></figure><h4 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1. 排序查询</span><br><span class="line">* 语法：order by 子句</span><br><span class="line">* order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...</span><br><span class="line">* 排序方式：</span><br><span class="line">* ASC：升序，默认的。</span><br><span class="line">* DESC：降序。</span><br><span class="line">* 注意：</span><br><span class="line">* 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</span><br><span class="line">2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。</span><br><span class="line">1. count：计算个数</span><br><span class="line">1. 一般选择非空的列：主键</span><br><span class="line">2. count(*)</span><br><span class="line">2. max：计算最大值</span><br><span class="line">3. min：计算最小值</span><br><span class="line">4. sum：计算和</span><br><span class="line">5. avg：计算平均值</span><br><span class="line">* 注意：聚合函数的计算，排除null值。</span><br><span class="line">解决方案：</span><br><span class="line">1. 选择不包含非空的列进行计算</span><br><span class="line">2. IFNULL函数</span><br><span class="line"></span><br><span class="line">3. 分组查询:</span><br><span class="line">1. 语法：group by 分组字段；</span><br><span class="line">2. 注意：</span><br><span class="line">1. 分组之后查询的字段：分组字段、聚合函数</span><br><span class="line">2. where 和 having 的区别？</span><br><span class="line">1. where 在分组之前进行限定，如果不满足条件，则不参与分组。</span><br><span class="line">   having在分组之后进行限定，如果不满足结果，则不会被查询出来</span><br><span class="line">2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。</span><br><span class="line"></span><br><span class="line">-- 按照性别分组。分别查询男、女同学的平均分</span><br><span class="line">SELECT sex , AVG(math) FROM student GROUP BY sex;</span><br><span class="line"></span><br><span class="line">-- 按照性别分组。分别查询男、女同学的平均分,人数</span><br><span class="line">SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;</span><br><span class="line"></span><br><span class="line">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组</span><br><span class="line">SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;</span><br><span class="line"></span><br><span class="line">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,</span><br><span class="line">--  分组之后。人数要大于2个人</span><br><span class="line">SELECT sex , AVG(math),COUNT(id) FROM student </span><br><span class="line">WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;</span><br><span class="line"></span><br><span class="line">SELECT sex , AVG(math),COUNT(id) 人数 FROM student </span><br><span class="line">WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;</span><br><span class="line">4. 分页查询</span><br><span class="line">1. 语法：limit 开始的索引,每页查询的条数;</span><br><span class="line">2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</span><br><span class="line">-- 每页显示3条记录 </span><br><span class="line"></span><br><span class="line">SELECT * FROM student LIMIT 0,3; -- 第1页</span><br><span class="line"></span><br><span class="line">SELECT * FROM student LIMIT 3,3; -- 第2页</span><br><span class="line"></span><br><span class="line">SELECT * FROM student LIMIT 6,3; -- 第3页</span><br><span class="line"></span><br><span class="line">3. limit 是一个MySQL&quot;方言&quot;</span><br></pre></td></tr></table></figure><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">* 查询语法：</span><br><span class="line">select</span><br><span class="line">列名列表</span><br><span class="line">from</span><br><span class="line">表名列表</span><br><span class="line">where....</span><br><span class="line">* 笛卡尔积：</span><br><span class="line">* 有两个集合A,B .取这两个集合的所有组成情况。</span><br><span class="line">* 要完成多表查询，需要消除无用的数据</span><br><span class="line">* 多表查询的分类：</span><br><span class="line">1. 内连接查询：</span><br><span class="line">1. 隐式内连接：使用where条件消除无用数据</span><br><span class="line">-- 查询员工表的名称，性别。部门表的名称</span><br><span class="line">SELECT </span><br><span class="line">t1.name, -- 员工表的姓名</span><br><span class="line">t1.gender,-- 员工表的性别</span><br><span class="line">t2.name -- 部门表的名称</span><br><span class="line">FROM</span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line">WHERE </span><br><span class="line">t1.`dept_id` = t2.`id`;</span><br><span class="line">2. 显式内连接：</span><br><span class="line">* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件</span><br><span class="line">* 例如：</span><br><span class="line">* SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;</span><br><span class="line">* SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;</span><br><span class="line">2. 外链接查询：</span><br><span class="line">1. 左外连接：</span><br><span class="line">* 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；</span><br><span class="line">* 查询的是左表所有数据以及其交集部分</span><br><span class="line">* 例子：</span><br><span class="line">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span><br><span class="line">SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 </span><br><span class="line">ON t1.`dept_id` = t2.`id`;</span><br><span class="line">2. 右外连接：</span><br><span class="line">* 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；</span><br><span class="line">* 查询的是右表所有数据以及其交集部分---右表+与左表符合条件的交集</span><br><span class="line">* 例子：</span><br><span class="line">SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;</span><br><span class="line">3. 子查询：</span><br><span class="line">* 概念：查询中嵌套查询，称嵌套查询为子查询。</span><br><span class="line">* 子查询不同情况</span><br><span class="line">1. 子查询的结果是单行单列的：</span><br><span class="line">* 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</span><br><span class="line">-- 查询员工工资小于平均工资的人</span><br><span class="line">SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</span><br><span class="line">2. 子查询的结果是多行单列的：</span><br><span class="line">* 子查询可以作为条件，使用运算符in来判断</span><br><span class="line">-- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息</span><br><span class="line">SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;;</span><br><span class="line">SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;</span><br><span class="line">-- 子查询</span><br><span class="line">SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept </span><br><span class="line">                        WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;);</span><br><span class="line"></span><br><span class="line">3. 子查询的结果是多行多列的：</span><br><span class="line">* 子查询可以作为一张虚拟表参与查询</span><br><span class="line">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span><br><span class="line">-- 子查询</span><br><span class="line">SELECT * </span><br><span class="line">FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2</span><br><span class="line">WHERE t1.id = t2.dept_id;</span><br><span class="line"></span><br><span class="line">-- 普通内连接</span><br><span class="line">SELECT * FROM emp t1,dept t2 </span><br><span class="line">WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &apos;2011-11-11&apos;</span><br></pre></td></tr></table></figure><h5 id="多表查询练习"><a href="#多表查询练习" class="headerlink" title="多表查询练习"></a>多表查询练习</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">-- 部门表</span><br><span class="line">CREATE TABLE dept (</span><br><span class="line">  id INT PRIMARY KEY PRIMARY KEY, -- 部门id</span><br><span class="line">  dname VARCHAR(50), -- 部门名称</span><br><span class="line">  loc VARCHAR(50) -- 部门所在地</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加4个部门</span><br><span class="line">INSERT INTO dept(id,dname,loc) VALUES </span><br><span class="line">(10,&apos;教研部&apos;,&apos;北京&apos;),</span><br><span class="line">(20,&apos;学工部&apos;,&apos;上海&apos;),</span><br><span class="line">(30,&apos;销售部&apos;,&apos;广州&apos;),</span><br><span class="line">(40,&apos;财务部&apos;,&apos;深圳&apos;);</span><br><span class="line">-- 职务表，职务名称，职务描述</span><br><span class="line">CREATE TABLE job (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  jname VARCHAR(20),</span><br><span class="line">  description VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加4个职务</span><br><span class="line">INSERT INTO job (id, jname, description) VALUES</span><br><span class="line">(1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;),</span><br><span class="line">(2, &apos;经理&apos;, &apos;管理部门员工&apos;),</span><br><span class="line">(3, &apos;销售员&apos;, &apos;向客人推销产品&apos;),</span><br><span class="line">(4, &apos;文员&apos;, &apos;使用办公软件&apos;);</span><br><span class="line">-- 员工表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">  id INT PRIMARY KEY, -- 员工id</span><br><span class="line">  ename VARCHAR(50), -- 员工姓名</span><br><span class="line">  job_id INT, -- 职务id</span><br><span class="line">  mgr INT , -- 上级领导</span><br><span class="line">  joindate DATE, -- 入职日期</span><br><span class="line">  salary DECIMAL(7,2), -- 工资</span><br><span class="line">  bonus DECIMAL(7,2), -- 奖金</span><br><span class="line">  dept_id INT, -- 所在部门编号</span><br><span class="line">  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),</span><br><span class="line">  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加员工</span><br><span class="line">INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES </span><br><span class="line">(1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),</span><br><span class="line">(1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),</span><br><span class="line">(1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),</span><br><span class="line">(1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),</span><br><span class="line">(1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),</span><br><span class="line">(1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),</span><br><span class="line">(1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),</span><br><span class="line">(1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),</span><br><span class="line">(1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),</span><br><span class="line">(1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),</span><br><span class="line">(1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),</span><br><span class="line">(1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),</span><br><span class="line">(1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),</span><br><span class="line">(1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10);</span><br><span class="line">-- 工资等级表</span><br><span class="line">CREATE TABLE salarygrade (</span><br><span class="line">  grade INT PRIMARY KEY,   -- 级别</span><br><span class="line">  losalary INT,  -- 最低工资</span><br><span class="line">  hisalary INT -- 最高工资</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加5个工资等级</span><br><span class="line">INSERT INTO salarygrade(grade,losalary,hisalary) VALUES </span><br><span class="line">(1,7000,12000),</span><br><span class="line">(2,12010,14000),</span><br><span class="line">(3,14010,20000),</span><br><span class="line">(4,20010,30000),</span><br><span class="line">(5,30010,99990);</span><br><span class="line"></span><br><span class="line">-- 需求：</span><br><span class="line"></span><br><span class="line">-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</span><br><span class="line">/*</span><br><span class="line">分析：</span><br><span class="line">1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表</span><br><span class="line">2.查询条件 emp.job_id = job.id</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">t1.`id`, -- 员工编号</span><br><span class="line">t1.`ename`, -- 员工姓名</span><br><span class="line">t1.`salary`,-- 工资</span><br><span class="line">t2.`jname`, -- 职务名称</span><br><span class="line">t2.`description` -- 职务描述</span><br><span class="line">FROM </span><br><span class="line">emp t1, job t2</span><br><span class="line">WHERE </span><br><span class="line">t1.`job_id` = t2.`id`;</span><br><span class="line">-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</span><br><span class="line">SELECT </span><br><span class="line">t1.`id`, -- 员工编号</span><br><span class="line">t1.`ename`, -- 员工姓名</span><br><span class="line">t1.`salary`,-- 工资</span><br><span class="line">t2.`jname`, -- 职务名称</span><br><span class="line">t2.`description`, -- 职务描述</span><br><span class="line">t3.`dname`, -- 部门名称</span><br><span class="line">t3.`loc` -- 部门位置</span><br><span class="line">FROM </span><br><span class="line">emp t1, job t2,dept t3</span><br><span class="line">WHERE </span><br><span class="line">t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;</span><br><span class="line">   </span><br><span class="line">-- 3.查询员工姓名，工资，工资等级</span><br><span class="line">SELECT </span><br><span class="line">t1.ename ,</span><br><span class="line">t1.`salary`,</span><br><span class="line">t2.*</span><br><span class="line">FROM emp t1, salarygrade t2</span><br><span class="line">WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;</span><br><span class="line">-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</span><br><span class="line">SELECT </span><br><span class="line">t1.`ename`,</span><br><span class="line">t1.`salary`,</span><br><span class="line">t2.`jname`,</span><br><span class="line">t2.`description`,</span><br><span class="line">t3.`dname`,</span><br><span class="line">t3.`loc`,</span><br><span class="line">t4.`grade`</span><br><span class="line">FROM </span><br><span class="line">emp t1,job t2,dept t3,salarygrade t4</span><br><span class="line">WHERE </span><br><span class="line">t1.`job_id` = t2.`id` </span><br><span class="line">AND t1.`dept_id` = t3.`id`</span><br><span class="line">AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;</span><br><span class="line">-- 5.查询出部门编号、部门名称、部门位置、部门人数</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">分析：</span><br><span class="line">1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表</span><br><span class="line">2.使用分组查询。按照emp.dept_id完成分组，查询count(id)</span><br><span class="line">3.使用子查询将第2步的查询结果和dept表进行关联查询</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">t1.`id`,t1.`dname`,t1.`loc` , t2.total</span><br><span class="line">FROM </span><br><span class="line">dept t1,</span><br><span class="line">(SELECT</span><br><span class="line">dept_id,COUNT(id) total</span><br><span class="line">FROM </span><br><span class="line">emp</span><br><span class="line">GROUP BY dept_id) t2</span><br><span class="line">WHERE t1.`id` = t2.dept_id;</span><br><span class="line">-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">分析：</span><br><span class="line">1.姓名 emp， 直接上级的姓名 emp</span><br><span class="line">* emp表的id 和 mgr 是自关联</span><br><span class="line">2.条件 emp.id = emp.mgr</span><br><span class="line">3.查询左表的所有数据，和 交集数据</span><br><span class="line">* 使用左外连接查询</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">select</span><br><span class="line">t1.ename,</span><br><span class="line">t1.mgr,</span><br><span class="line">t2.`id`,</span><br><span class="line">t2.ename</span><br><span class="line">from emp t1, emp t2</span><br><span class="line">where t1.mgr = t2.`id`;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">t1.ename,</span><br><span class="line">t1.mgr,</span><br><span class="line">t2.`id`,</span><br><span class="line">t2.`ename`</span><br><span class="line">FROM emp t1</span><br><span class="line">LEFT JOIN emp t2</span><br><span class="line">ON t1.`mgr` = t2.`id`;</span><br></pre></td></tr></table></figure><h3 id="DCL：用户及其权限管理"><a href="#DCL：用户及其权限管理" class="headerlink" title="DCL：用户及其权限管理"></a>DCL：用户及其权限管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">* SQL分类：</span><br><span class="line">1. DDL：操作数据库和表</span><br><span class="line">2. DML：增删改表中数据</span><br><span class="line">3. DQL：查询表中数据</span><br><span class="line">4. DCL：管理用户，授权</span><br><span class="line"></span><br><span class="line">* DBA：数据库管理员</span><br><span class="line"></span><br><span class="line">* DCL：管理用户，授权</span><br><span class="line">1. 管理用户</span><br><span class="line">1. 添加用户：</span><br><span class="line">* 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;;</span><br><span class="line">2. 删除用户：</span><br><span class="line">* 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;;</span><br><span class="line">3. 修改用户密码：</span><br><span class="line"></span><br><span class="line">UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;;</span><br><span class="line">UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;;</span><br><span class="line"></span><br><span class="line">SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;);</span><br><span class="line">SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;);</span><br><span class="line"></span><br><span class="line">* mysql中忘记了root用户的密码？</span><br><span class="line">1. cmd -- &gt; net stop mysql 停止mysql服务</span><br><span class="line">* 需要管理员运行该cmd</span><br><span class="line"></span><br><span class="line">2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables</span><br><span class="line">3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</span><br><span class="line">4. use mysql;</span><br><span class="line">5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;;</span><br><span class="line">6. 关闭两个窗口</span><br><span class="line">7. 打开任务管理器，手动结束mysqld.exe 的进程</span><br><span class="line">8. 启动mysql服务</span><br><span class="line">9. 使用新密码登录。</span><br><span class="line">4. 查询用户：</span><br><span class="line">-- 1. 切换到mysql数据库</span><br><span class="line">USE myql;</span><br><span class="line">-- 2. 查询user表</span><br><span class="line">SELECT * FROM USER;</span><br><span class="line"></span><br><span class="line">* 通配符： % 表示可以在任意主机使用用户登录数据库</span><br><span class="line"></span><br><span class="line">2. 权限管理：</span><br><span class="line">1. 查询权限：</span><br><span class="line">-- 查询权限</span><br><span class="line">SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;;</span><br><span class="line">SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;;</span><br><span class="line"></span><br><span class="line">2. 授予权限：</span><br><span class="line">-- 授予权限</span><br><span class="line">grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;;</span><br><span class="line">-- 给张三用户授予所有权限，在任意数据库任意表上</span><br><span class="line">GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;;</span><br><span class="line">3. 撤销权限：</span><br><span class="line">-- 撤销权限：</span><br><span class="line">revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;;</span><br><span class="line">REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure><h2 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 多表之间的关系</span><br><span class="line">1. 分类：</span><br><span class="line">1. 一对一(了解)：</span><br><span class="line">* 如：人和身份证</span><br><span class="line">* 分析：一个人只有一个身份证，一个身份证只能对应一个人</span><br><span class="line">2. 一对多(多对一)：</span><br><span class="line">* 如：部门和员工</span><br><span class="line">* 分析：一个部门有多个员工，一个员工只能对应一个部门</span><br><span class="line">3. 多对多：</span><br><span class="line">* 如：学生和课程</span><br><span class="line">* 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</span><br><span class="line">2. 实现关系：</span><br><span class="line">1. 一对多(多对一)：</span><br><span class="line">* 如：部门和员工</span><br><span class="line">* 实现方式：在多的一方建立外键，指向一的一方的主键。</span><br><span class="line">2. 多对多：</span><br><span class="line">* 如：学生和课程</span><br><span class="line">* 实现方式：多对多关系实现需要借助第三张中间表。</span><br><span class="line">  中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</span><br><span class="line">3. 一对一(了解)：</span><br><span class="line">* 如：人和身份证</span><br><span class="line">* 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200225182029-694089.png" alt="image-20200225182028636"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-- 创建旅游线路分类表 tab_category</span><br><span class="line">-- cid 旅游线路分类主键，自动增长</span><br><span class="line">-- cname 旅游线路分类名称非空，唯一，字符串 100</span><br><span class="line">CREATE TABLE tab_category (</span><br><span class="line">cid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">cname VARCHAR(100) NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建旅游线路表 tab_route</span><br><span class="line">/*</span><br><span class="line">rid 旅游线路主键，自动增长</span><br><span class="line">rname 旅游线路名称非空，唯一，字符串 100</span><br><span class="line">price 价格</span><br><span class="line">rdate 上架时间，日期类型</span><br><span class="line">cid 外键，所属分类</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">price DOUBLE,</span><br><span class="line">rdate DATE,</span><br><span class="line">cid INT,</span><br><span class="line">FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*创建用户表 tab_user</span><br><span class="line">uid 用户主键，自增长</span><br><span class="line">username 用户名长度 100，唯一，非空</span><br><span class="line">password 密码长度 30，非空</span><br><span class="line">name 真实姓名长度 100</span><br><span class="line">birthday 生日</span><br><span class="line">sex 性别，定长字符串 1</span><br><span class="line">telephone 手机号，字符串 11</span><br><span class="line">email 邮箱，字符串长度 100</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_user (</span><br><span class="line">uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">username VARCHAR(100) UNIQUE NOT NULL,</span><br><span class="line">PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">NAME VARCHAR(100),</span><br><span class="line">birthday DATE,</span><br><span class="line">sex CHAR(1) DEFAULT &apos;男&apos;,</span><br><span class="line">telephone VARCHAR(11),</span><br><span class="line">email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">创建收藏表 tab_favorite</span><br><span class="line">rid 旅游线路 id，外键</span><br><span class="line">date 收藏时间</span><br><span class="line">uid 用户 id，外键</span><br><span class="line">rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_favorite (</span><br><span class="line">rid INT, -- 线路id</span><br><span class="line">DATE DATETIME,</span><br><span class="line">uid INT, -- 用户id</span><br><span class="line">-- 创建复合主键</span><br><span class="line">PRIMARY KEY(rid,uid), -- 联合主键</span><br><span class="line">FOREIGN KEY (rid) REFERENCES tab_route(rid),</span><br><span class="line">FOREIGN KEY(uid) REFERENCES tab_user(uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="数据库设计的范式"><a href="#数据库设计的范式" class="headerlink" title="数据库设计的范式"></a>数据库设计的范式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</span><br><span class="line"></span><br><span class="line">设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，</span><br><span class="line">这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。</span><br><span class="line">目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、</span><br><span class="line">巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</span><br><span class="line"></span><br><span class="line">* 分类：</span><br><span class="line">1. 第一范式（1NF）：每一列都是不可分割的原子数据项</span><br><span class="line">2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码</span><br><span class="line">                       （在1NF基础上消除非主属性对主码的部分函数依赖）</span><br><span class="line">* 几个概念：</span><br><span class="line">1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A</span><br><span class="line">例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数</span><br><span class="line">2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，</span><br><span class="line">                          则B属性值得确定需要依赖于A属性组中所有的属性值。</span><br><span class="line">例如：（学号，课程名称） --&gt; 分数</span><br><span class="line">3. 部分函数依赖：A--&gt;B，若A是一个属性组，则B属性值确定只需依赖于A属性组中某些值</span><br><span class="line">例如：（学号，课程名称） -- &gt; 姓名</span><br><span class="line">4. 传递函数依赖：A--&gt;B, B -- &gt;C . </span><br><span class="line">              如果通过A属性(属性组)的值，可以确定唯一B属性的值，</span><br><span class="line">              在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A</span><br><span class="line">例如：学号--&gt;系名，系名--&gt;系主任</span><br><span class="line">5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，</span><br><span class="line">                              则称这个属性(属性组)为该表的码</span><br><span class="line">例如：该表中码为：（学号，课程名称）</span><br><span class="line">* 主属性：码属性组中的所有属性</span><br><span class="line">* 非主属性：除过码属性组的属性</span><br><span class="line"></span><br><span class="line">3. 第三范式（3NF）:在2NF基础上,任何非主属性不依赖于其它非主属性，即在2NF基础上消除传递依赖</span><br></pre></td></tr></table></figure><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200225182141-288535.png" alt></p><ul><li>系下面有两个子项，根据范式一将其拆分–  即所有可以建表的都满足范式一</li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200225182454-341727.png" alt></p><ul><li><p>范式二：消除非主属性对主码的部分函数依赖    </p><p>学号-&gt;姓名，系名，系主任(包含传递依赖)</p><p>学号，课程名称-&gt;成绩</p><p>姓名，系名，系主任对（学号，课程名称）存在部分依赖</p></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200225183302-587709.png" alt="image-20200225183302339"></p><ul><li><p>选课表不存在传递依赖</p><p>学号 –&gt;  姓名 –&gt;  系名  –&gt;  系主任        存在传递依赖</p></li></ul><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/typora20200225183458-120425.png" alt="image-20200225183458064"></p><h2 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 命令行：</span><br><span class="line">* 语法：</span><br><span class="line">* 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</span><br><span class="line">* 还原：</span><br><span class="line">1. 登录数据库</span><br><span class="line">2. 创建数据库</span><br><span class="line">3. 使用数据库</span><br><span class="line">4. 执行文件source 文件路径</span><br><span class="line">2. 图形化工具：</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1. 事务的基本介绍</span><br><span class="line">1. 概念：</span><br><span class="line">*  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</span><br><span class="line"></span><br><span class="line">2. 操作：</span><br><span class="line">1. 开启事务： start transaction;</span><br><span class="line">2. 回滚：rollback;</span><br><span class="line">3. 提交：commit;</span><br><span class="line">3. MySQL数据库中事务默认自动提交</span><br><span class="line">* 事务提交的两种方式：</span><br><span class="line">* 自动提交：</span><br><span class="line">* mysql就是自动提交的</span><br><span class="line">* 一条DML(增删改)语句会自动提交一次事务。</span><br><span class="line">* 手动提交：</span><br><span class="line">* Oracle 数据库默认是手动提交事务</span><br><span class="line">* 需要先开启事务，再提交</span><br><span class="line">* 修改事务的默认提交方式：</span><br><span class="line">* 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交</span><br><span class="line">* 修改默认提交方式： set @@autocommit = 0;</span><br><span class="line">2. 事务的四大特征：</span><br><span class="line">1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</span><br><span class="line">2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。</span><br><span class="line">3. 隔离性：多个事务之间。相互独立。</span><br><span class="line">4. 一致性：事务操作前后，数据总量不变</span><br><span class="line">3. 事务的隔离级别（了解）</span><br><span class="line">* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</span><br><span class="line">* 存在问题：</span><br><span class="line">1. 脏读：一个事务，读取到另一个事务中没有提交的数据</span><br><span class="line">2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</span><br><span class="line">3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</span><br><span class="line">* 隔离级别：</span><br><span class="line">1. read uncommitted：读未提交</span><br><span class="line">* 产生的问题：脏读、不可重复读、幻读</span><br><span class="line">2. read committed：读已提交 （Oracle）</span><br><span class="line">* 产生的问题：不可重复读、幻读</span><br><span class="line">3. repeatable read：可重复读 （MySQL默认）</span><br><span class="line">* 产生的问题：幻读</span><br><span class="line">4. serializable：串行化</span><br><span class="line">* 可以解决所有的问题</span><br><span class="line"></span><br><span class="line">* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低</span><br><span class="line">* 数据库查询隔离级别：</span><br><span class="line">* select @@tx_isolation;</span><br><span class="line">* 数据库设置隔离级别：</span><br><span class="line">* set global transaction isolation level  级别字符串;</span><br><span class="line"></span><br><span class="line">* 演示：</span><br><span class="line">set global transaction isolation level read uncommitted;</span><br><span class="line">start transaction;</span><br><span class="line">-- 转账操作</span><br><span class="line">update account set balance = balance - 500 where id = 1;</span><br><span class="line">update account set balance = balance + 500 where id = 2;</span><br></pre></td></tr></table></figure><h2 id="异常解决"><a href="#异常解决" class="headerlink" title="异常解决"></a>异常解决</h2><p>【MySQL】SELECT list is not in GROUP BY clause… </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.*  FROM tbl_inspection_equipment_record a</span><br><span class="line">RIGHT  JOIN   (</span><br><span class="line">    SELECT * FROM tbl_inspection_equipment_record </span><br><span class="line">        WHERE state =  1 </span><br><span class="line">        AND build_id = ?</span><br><span class="line">    ORDER BY end_time DESC</span><br><span class="line">)  AS temp</span><br><span class="line">ON a.id  = temp.id</span><br><span class="line">GROUP BY room_id</span><br><span class="line">ORDER BY end_time DESC</span><br></pre></td></tr></table></figure><p>问题原因</p><p>MySQL 5.7.5及以上功能依赖检测功能。如果启用了 ONLY_FULL_GROUP_BY SQL 模式（默认情况下），MySQL 将拒绝选择列表，HAVING 条件或 ORDER BY 列表的查询引用在 GROUP BY 子句中既未命名的非集合列，也不在功能上依赖于它们。（5.7.5之前，MySQL 没有检测到功能依赖关系，默认情况下不启用 ONLY_FULL_GROUP_BY。有关5.7.5之前的行为的说明，请参见“MySQL 5.6参考手册”。）</p><p>解决方案<br>方法一(该方式每次mysql服务重新启动恢复原来的模式)</p><p>S1：select @@global.sql_mode;</p><p>S2：执行以下sql语句，去除步骤1中 <code>ONLY_FULL_GROUP_BY</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set @@global.sql_mode =</span><br><span class="line">&apos;STRICT_TRANS_TABLES,</span><br><span class="line">NO_ZERO_IN_DATE,</span><br><span class="line">NO_ZERO_DATE,</span><br><span class="line">ERROR_FOR_DIVISION_BY_ZERO,</span><br><span class="line">NO_AUTO_CREATE_USER,</span><br><span class="line">NO_ENGINE_SUBSTITUTION&apos;;</span><br></pre></td></tr></table></figure><p>方法二：修改配置文件</p><ul><li>远程服务器找到 <code>my.cnf</code> 文件</li><li>在文件底部加入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,</span><br><span class="line">ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><ul><li>重启mysql</li></ul><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="JDBC简单实现"><a href="#JDBC简单实现" class="headerlink" title="JDBC简单实现"></a>JDBC简单实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</span><br><span class="line">* JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 快速入门：</span><br><span class="line">* 步骤：</span><br><span class="line"><span class="number">1</span>. 导入驱动jar包 mysql-connector-java-<span class="number">5.1</span>.37-bin.jar</span><br><span class="line"><span class="number">1</span>.复制mysql-connector-java-<span class="number">5.1</span>.37-bin.jar到项目的libs目录下</span><br><span class="line"><span class="number">2</span>.右键--&gt;Add As Library</span><br><span class="line"><span class="number">2</span>. 注册驱动</span><br><span class="line"><span class="number">3</span>. 获取数据库连接对象 Connection</span><br><span class="line"><span class="number">4</span>. 定义sql</span><br><span class="line"><span class="number">5</span>. 获取执行sql语句的对象 Statement</span><br><span class="line"><span class="number">6</span>. 执行sql，接受返回结果</span><br><span class="line"><span class="number">7</span>. 处理结果</span><br><span class="line"><span class="number">8</span>. 释放资源</span><br><span class="line"></span><br><span class="line">* 代码实现：</span><br><span class="line">  <span class="comment">//1. 导入驱动jar包</span></span><br><span class="line">        <span class="comment">//2.注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//3.获取数据库连接对象</span></span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db3"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">        <span class="comment">//4.定义sql语句</span></span><br><span class="line">        String sql = <span class="string">"update account set balance = 500 where id = 1"</span>;</span><br><span class="line">        <span class="comment">//5.获取执行sql的对象 Statement</span></span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line">        <span class="comment">//6.执行sql</span></span><br><span class="line">        <span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line">        <span class="comment">//7.处理结果</span></span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//8.释放资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 详解各个对象：</span><br><span class="line"><span class="number">1</span>. DriverManager：驱动管理对象</span><br><span class="line">* 功能：</span><br><span class="line"><span class="number">1</span>. 注册驱动：告诉程序该使用哪一个数据库驱动jar</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver)</span> :注册与给定的驱动程序 DriverManager 。 </span></span><br><span class="line"><span class="function">写代码使用：  Class.<span class="title">forName</span><span class="params">(<span class="string">"com.mysql.jdbc.Driver"</span>)</span></span>;</span><br><span class="line">通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</span><br><span class="line"><span class="number">2</span>. 获取数据库连接：</span><br><span class="line">* 方法：<span class="function"><span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, String user, String password)</span> </span></span><br><span class="line"><span class="function">* 参数：</span></span><br><span class="line"><span class="function">* url：指定连接的路径</span></span><br><span class="line"><span class="function">* 语法：jdbc:mysql:<span class="comment">//ip地址(域名):端口号/数据库名称</span></span></span><br><span class="line"><span class="function">* 例子：jdbc:mysql:<span class="comment">//localhost:3306/db3</span></span></span><br><span class="line"><span class="function">* 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:<span class="comment">///数据库名称</span></span></span><br><span class="line"><span class="function">* user：用户名</span></span><br><span class="line"><span class="function">* password：密码 </span></span><br><span class="line"><span class="function">2. Connection：数据库连接对象</span></span><br><span class="line"><span class="function">1. 功能：</span></span><br><span class="line"><span class="function">1. 获取执行sql 的对象</span></span><br><span class="line"><span class="function">* Statement <span class="title">createStatement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span>  </span></span><br><span class="line"><span class="function">2. 管理事务：</span></span><br><span class="line"><span class="function">* 开启事务：<span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span> ：调用该方法设置参数为<span class="keyword">false</span>，即开启事务</span></span><br><span class="line"><span class="function">* 提交事务：<span class="title">commit</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">* 回滚事务：<span class="title">rollback</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">3. Statement：执行sql的对象</span></span><br><span class="line"><span class="function">1. 执行sql</span></span><br><span class="line"><span class="function">1. <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> ：可以执行任意的sql 了解 </span></span><br><span class="line"><span class="function">2. <span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span> ：执行DML（insert、update、delete）语句、<span class="title">DDL</span><span class="params">(create，alter、drop)</span>语句</span></span><br><span class="line"><span class="function">* 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。</span></span><br><span class="line"><span class="function">3. ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span>  ：执行DQL（select)语句</span></span><br><span class="line"><span class="function">4. ResultSet：结果集对象,封装查询结果</span></span><br><span class="line"><span class="function">* <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span>: 游标向下移动一行，判断当前行是否是最后一行末尾<span class="params">(是否有数据)</span>，如果是，则返回<span class="keyword">false</span>，如果不是则返回<span class="keyword">true</span></span></span><br><span class="line"><span class="function">* <span class="title">getXxx</span><span class="params">(参数)</span>:获取数据</span></span><br><span class="line"><span class="function">* Xxx：代表数据类型   如： <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> ,String <span class="title">getString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">* 参数：</span></span><br><span class="line"><span class="function">1. <span class="keyword">int</span>：代表列的编号,从1开始   如： <span class="title">getString</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">2. String：代表列名称。 如： <span class="title">getDouble</span><span class="params">(<span class="string">"balance"</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">* 注意：</span></span><br><span class="line"><span class="function">* 使用步骤：</span></span><br><span class="line"><span class="function">1. 游标向下移动一行</span></span><br><span class="line"><span class="function">2. 判断是否有数据</span></span><br><span class="line"><span class="function">3. 获取数据</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   <span class="comment">//循环判断游标是否是最后一行末尾。</span></span></span><br><span class="line"><span class="function">            <span class="title">while</span><span class="params">(rs.next()</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//获取数据</span></span><br><span class="line">                <span class="comment">//6.2 获取数据</span></span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                <span class="keyword">double</span> balance = rs.getDouble(<span class="number">3</span>);</span><br><span class="line">                System.out.println(id + <span class="string">"---"</span> + name + <span class="string">"---"</span> + balance);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="number">5</span>. PreparedStatement：执行sql的对象</span><br><span class="line"><span class="number">1</span>. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</span><br><span class="line"><span class="number">1</span>. 输入用户随便，输入密码：a<span class="string">' or '</span>a<span class="string">' = '</span>a</span><br><span class="line"><span class="number">2</span>. sql：select * from user where username = <span class="string">'fhdsjkf'</span> and password = <span class="string">'a'</span> or <span class="string">'a'</span> = <span class="string">'a'</span> </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 解决sql注入问题：使用PreparedStatement对象来解决</span><br><span class="line"><span class="number">3</span>. 预编译的SQL：参数使用?作为占位符</span><br><span class="line"><span class="number">4</span>. 步骤：</span><br><span class="line"><span class="number">1</span>. 导入驱动jar包 mysql-connector-java-<span class="number">5.1</span>.37-bin.jar</span><br><span class="line"><span class="number">2</span>. 注册驱动</span><br><span class="line"><span class="number">3</span>. 获取数据库连接对象 Connection</span><br><span class="line"><span class="number">4</span>. 定义sql</span><br><span class="line">* 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</span><br><span class="line"><span class="number">5</span>. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </span><br><span class="line"><span class="number">6</span>. 给？赋值：</span><br><span class="line">* 方法： setXxx(参数<span class="number">1</span>,参数<span class="number">2</span>)</span><br><span class="line">* 参数<span class="number">1</span>：？的位置编号 从<span class="number">1</span> 开始</span><br><span class="line">* 参数<span class="number">2</span>：？的值</span><br><span class="line"><span class="number">7</span>. 执行sql，接受返回结果，不需要传递sql语句</span><br><span class="line"><span class="number">8</span>. 处理结果</span><br><span class="line"><span class="number">9</span>. 释放资源</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作</span><br><span class="line"><span class="number">1</span>. 可以防止SQL注入</span><br><span class="line"><span class="number">2</span>. 效率更高</span><br></pre></td></tr></table></figure><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 注册驱动也抽取</span></span><br><span class="line"><span class="comment">2. 抽取一个方法获取连接对象</span></span><br><span class="line"><span class="comment">* 需求：不想传递参数（麻烦），还得保证工具类的通用性。</span></span><br><span class="line"><span class="comment">* 解决：配置文件</span></span><br><span class="line"><span class="comment">jdbc.properties</span></span><br><span class="line"><span class="comment">url=</span></span><br><span class="line"><span class="comment">user=</span></span><br><span class="line"><span class="comment">password=</span></span><br><span class="line"><span class="comment">3. 抽取一个方法释放资源</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取资源文件，获取值。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 创建Properties集合类。</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span></span><br><span class="line">            ClassLoader classLoader = JDBCUtils.class.getClassLoader();</span><br><span class="line">            URL res  = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            String path = res.getPath();</span><br><span class="line">            System.out.println(path);<span class="comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span></span><br><span class="line">            <span class="comment">//2. 加载文件</span></span><br><span class="line">           <span class="comment">// pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties"));</span></span><br><span class="line">            pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3. 获取数据，赋值</span></span><br><span class="line">            url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            <span class="comment">//4. 注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stmt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    </p><pre><code>    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn){        if( rs != null){            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)            );            INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;);            INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;);        2. 代码实现：            public class JDBCDemo9 {                public static void main(String[] args) {                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag){                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    }else{                        System.out.println(&quot;用户名或密码错误！&quot;);                    }</code></pre><p>​                </p><pre><code>}</code></pre><p>​<br>​                </p><pre><code>/** * 登录方法 */public boolean login(String username ,String password){    if(username == null || password == null){        return false;    }    //连接数据库判断是否登录成功    Connection conn = null;    Statement stmt =  null;    ResultSet rs = null;    //1.获取连接    try {        conn =  JDBCUtils.getConnection();        //2.定义sql        String sql = &quot;select * from user where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos; &quot;;        //3.获取执行sql的对象        stmt = conn.createStatement();        //4.执行查询        rs = stmt.executeQuery(sql);        //5.判断       /* if(rs.next()){//如果有下一行，则返回true            return true;        }else{            return false;        }*/       return rs.next();//如果有下一行，则返回true    } catch (SQLException e) {        e.printStackTrace();    }finally {        JDBCUtils.close(rs,stmt,conn);    }</code></pre><p>​                </p><pre><code>        return false;    }}</code></pre><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</span></span><br><span class="line"><span class="comment">2. 操作：</span></span><br><span class="line"><span class="comment">1. 开启事务</span></span><br><span class="line"><span class="comment">2. 提交事务</span></span><br><span class="line"><span class="comment">3. 回滚事务</span></span><br><span class="line"><span class="comment">3. 使用Connection对象来管理事务</span></span><br><span class="line"><span class="comment">* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</span></span><br><span class="line"><span class="comment">* 在执行sql之前开启事务</span></span><br><span class="line"><span class="comment">* 提交事务：commit() </span></span><br><span class="line"><span class="comment">* 当所有sql都执行完提交事务</span></span><br><span class="line"><span class="comment">* 回滚事务：rollback() </span></span><br><span class="line"><span class="comment">* 在catch中回滚事务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.定义sql</span></span><br><span class="line">            <span class="comment">//2.1 张三 - 500</span></span><br><span class="line">            String sql1 = <span class="string">"update account set balance = balance - ? where id = ?"</span>;</span><br><span class="line">            <span class="comment">//2.2 李四 + 500</span></span><br><span class="line">            String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line">            <span class="comment">//3.获取执行sql对象</span></span><br><span class="line">            pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">            <span class="comment">//4. 设置参数</span></span><br><span class="line">            pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">            pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//5.执行sql</span></span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            <span class="comment">// 手动制造异常</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//事务回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">            JDBCUtils.close(pstmt2,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。</span></span><br><span class="line"><span class="comment">    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，</span></span><br><span class="line"><span class="comment">    从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 好处：</span></span><br><span class="line"><span class="comment">1. 节约资源</span></span><br><span class="line"><span class="comment">2. 用户访问高效</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 实现：</span></span><br><span class="line"><span class="comment">1. 标准接口：DataSource   javax.sql包下的</span></span><br><span class="line"><span class="comment">1. 方法：</span></span><br><span class="line"><span class="comment">* 获取连接：getConnection()</span></span><br><span class="line"><span class="comment">* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，</span></span><br><span class="line"><span class="comment">  那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 一般我们不去实现它，有数据库厂商来实现</span></span><br><span class="line"><span class="comment">1. C3P0：数据库连接池技术</span></span><br><span class="line"><span class="comment">2. Druid：数据库连接池实现技术，由阿里巴巴提供的</span></span><br><span class="line"><span class="comment">4. C3P0：数据库连接池技术</span></span><br><span class="line"><span class="comment">* 步骤：</span></span><br><span class="line"><span class="comment">1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</span></span><br><span class="line"><span class="comment">* 不要忘记导入数据库驱动jar包</span></span><br><span class="line"><span class="comment">2. 定义配置文件：</span></span><br><span class="line"><span class="comment">* 名称： c3p0.properties 或者 c3p0-config.xml</span></span><br><span class="line"><span class="comment">* 路径：直接将文件放在src目录下即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 创建核心对象 数据库连接池对象 ComboPooledDataSource</span></span><br><span class="line"><span class="comment">4. 获取连接： getConnection</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="comment">//1.创建数据库连接池对象</span></span><br><span class="line">        DataSource ds  = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="comment">//2. 获取连接对象</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5. Druid：数据库连接池实现技术，由阿里巴巴提供的</span></span><br><span class="line"><span class="comment">1. 步骤：</span></span><br><span class="line"><span class="comment">1. 导入jar包 druid-1.0.9.jar</span></span><br><span class="line"><span class="comment">2. 定义配置文件：</span></span><br><span class="line"><span class="comment">* 是properties形式的</span></span><br><span class="line"><span class="comment">* 可以叫任意名称，可以放在任意目录下</span></span><br><span class="line"><span class="comment">3. 加载配置文件。Properties</span></span><br><span class="line"><span class="comment">4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</span></span><br><span class="line"><span class="comment">5. 获取连接：getConnection</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="comment">//3.加载配置文件</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">//4.获取连接池对象</span></span><br><span class="line">        DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        <span class="comment">//5.获取连接</span></span><br><span class="line">        Connection conn = ds.getConnection();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. 定义工具类</span></span><br><span class="line"><span class="comment">1. 定义一个类 JDBCUtils</span></span><br><span class="line"><span class="comment">2. 提供静态代码块加载配置文件，初始化连接池对象</span></span><br><span class="line"><span class="comment">3. 提供方法</span></span><br><span class="line"><span class="comment">1. 获取连接方法：通过数据库连接池获取连接</span></span><br><span class="line"><span class="comment">2. 释放资源</span></span><br><span class="line"><span class="comment">3. 获取连接池的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.定义成员变量 DataSource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>));</span><br><span class="line">            <span class="comment">//2.获取DataSource</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">       <span class="comment">/* if(stmt != null)&#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                stmt.close();</span></span><br><span class="line"><span class="comment">            &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        if(conn != null)&#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                conn.close();//归还连接</span></span><br><span class="line"><span class="comment">            &#125; catch (SQLException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">       close(<span class="keyword">null</span>,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs , Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();<span class="comment">//归还连接</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><pre><code>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发步骤：   1. 导入jar包   2. 创建JdbcTemplate对象。依赖于数据源DataSource       * JdbcTemplate template = new JdbcTemplate(ds);   3. 调用JdbcTemplate的方法来完成CRUD的操作       * update():执行DML语句。增、删、改语句       * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合           * 注意：这个方法查询的结果集长度只能是1       * queryForList():查询结果将结果集封装为list集合           * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中       * query():查询结果，将结果封装为JavaBean对象           * query的参数：RowMapper               * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装               * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)       * queryForObject：查询结果，将结果封装为对象           * 一般用于聚合函数的查询</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 需求：</span></span><br><span class="line"><span class="comment">4. 查询id为1的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment">6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">7. 查询总记录数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.domain.Emp;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.utils.JDBCUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Junit单元测试，可以让方法独立执行    </span></span><br><span class="line">    <span class="comment">//1. 获取JDBCTemplate对象</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.查询id为1001的记录，将其封装为Map集合</span></span><br><span class="line"><span class="comment">     * 注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp where id = ? or id = ?"</span>;</span><br><span class="line">        Map&lt;String, Object&gt; map = template.queryForMap(sql, <span class="number">1001</span>,<span class="number">1002</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5. 查询所有记录，将其封装为List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Emp <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                Emp emp = <span class="keyword">new</span> Emp();</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">                <span class="keyword">int</span> job_id = rs.getInt(<span class="string">"job_id"</span>);</span><br><span class="line">                <span class="keyword">int</span> mgr = rs.getInt(<span class="string">"mgr"</span>);</span><br><span class="line">                Date joindate = rs.getDate(<span class="string">"joindate"</span>);</span><br><span class="line">                <span class="keyword">double</span> salary = rs.getDouble(<span class="string">"salary"</span>);</span><br><span class="line">                <span class="keyword">double</span> bonus = rs.getDouble(<span class="string">"bonus"</span>);</span><br><span class="line">                <span class="keyword">int</span> dept_id = rs.getInt(<span class="string">"dept_id"</span>);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job_id);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 7. 查询总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"select count(id) from emp"</span>;</span><br><span class="line">        Long total = template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySql&quot;&gt;&lt;a href=&quot;#MySql&quot; class=&quot;headerlink&quot; title=&quot;MySql&quot;&gt;&lt;/a&gt;MySql&lt;/h1&gt;&lt;h2 id=&quot;数据库的基本概念&quot;&gt;&lt;a href=&quot;#数据库的基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据库的基本概念&quot;&gt;&lt;/a&gt;数据库的基本概念&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. 数据库的英文单词： DataBase 简称 ： DB
2. 什么数据库？
    * 用于存储和管理数据的仓库。
3. 数据库的特点：
    1. 持久化存储数据的。其实数据库就是一个文件系统
    2. 方便存储和管理数据
    3. 使用了统一的方式操作数据库 -- SQL
4. 常见的数据库软件
    * 参见《MySQL基础.pdf》&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="黑马57" scheme="http://yoursite.com/categories/%E9%BB%91%E9%A9%AC57/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://yoursite.com/2019/09/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/09/17/正则表达式/</id>
    <published>2019-09-17T14:47:12.000Z</published>
    <updated>2020-01-31T12:54:49.704Z</updated>
    
    <content type="html"><![CDATA[<h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><p>正则表达式（regular expression，简称regex）：是一些用来匹配和处理文本的字符串</p><p>正则表达式通常被简称为模式，其实是一些由字符构成的字符串</p><p>这些字符可以是普通字符（纯文本）或元字符（有特殊含义的特殊字符）</p><h5 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h5><p> .    匹配任何单个的字符</p><p>\    对特殊字符进行转义</p><h5 id="匹配一组字符"><a href="#匹配一组字符" class="headerlink" title="匹配一组字符"></a>匹配一组字符</h5><p>[和]    定义字符集合    [0-9a-zA-Z]</p><p>-    定义字符区间    0-9 a-z</p><p>^    对字符集合进行取非匹配    [^0-9a-zA-Z]</p><a id="more"></a><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><ul><li>空白字符</li></ul><p>[\b]    回退（删除）一个字符</p><p>\f    换页符</p><p>\n    换行符</p><p>\r    回车符</p><p>\t    制表符（tab）</p><p>\v    垂直制表符</p><p>\s    任何一个空白字符    [\f\n\r\t\v]</p><p>\S    任何一个非空白字符</p><ul><li>匹配数字</li></ul><p>\d    任何一个数字</p><p>\D    任何一个非数字</p><ul><li>匹配字母和数字</li></ul><p>\w    任何一个字母，数字和下划线</p><p>\W    任何一个非字母，数字和下划线</p><ul><li>进制</li></ul><p>\x    十六进制</p><p>\0    八进制</p><ul><li>POSIX字符串</li></ul><p>[[:alnum:]]                 数字字符</p><p>[[:alpha:]]                  字母字符</p><p>[[:lower:]]                  小写字母字符</p><p>[[:print:]]                    可显示的字符</p><p>[[:blank:]]                   空格(space)与定位字符</p><p>[[:punct:]]                   除[[:cntrl:]]和[[:alnum:]]外</p><p>[[:cntrl:]]                     ASCII控制字符(0-31和127)</p><p>[[:space:]]                   空白(whitespace)字符</p><p>[[:upper:]]                   大写字母字符</p><p>[[:digit:]]                      数字字符</p><p>[[:graph:]]                   非空格(nonspace)字符</p><p>[[:xdigit:]]                    十六进制数字字符</p><h5 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h5><p>+    给字符或字符集合作为后缀，表示匹配一个或多个字符或字符合集</p><p>*    给字符或字符集合作为后缀，表示匹配零个或多个字符或字符合集</p><p>{num1，num2}    精确重复次数    {6} {1,4}  {3,}</p><p>?    给字符或字符集合作为后缀，表示匹配零个或一个字符或字符合集</p><p>前三个为贪婪型元字符，为了防止过度匹配，会在其后加个？变为懒惰型元字符</p><h5 id="位置匹配"><a href="#位置匹配" class="headerlink" title="位置匹配"></a>位置匹配</h5><p>\b    用来匹配单词的开始或结束（\w与非\w之间）    只匹配一个位置，而不匹配任何字符</p><p>\B    匹配一个前后都不是单词边界</p><p>\&lt;    单词开始    \&gt;    单词结束</p><p>^    字符串开始    $    字符串结束</p><p>(?m)    分行匹配模式，必须写在模式最前面</p><h5 id="子表达式"><a href="#子表达式" class="headerlink" title="子表达式"></a>子表达式</h5><p>(和)    字表达式可以多层嵌套</p><h5 id="回溯引用：前后一致匹配"><a href="#回溯引用：前后一致匹配" class="headerlink" title="回溯引用：前后一致匹配"></a>回溯引用：前后一致匹配</h5><p>\n    匹配前面第n个子表达式</p><p>$n    替换时使用匹配上一条查询中的第n个子表达式匹配到的内容</p><ul><li>大小写转换（替换时使用）</li></ul><p>\E    结束\L或\U转换</p><p>\I    把下一个字符转换为小写</p><p>\L    把后面的字符转换为小写</p><p>\u    把下一个字符转换为大写</p><p>\U    把后面的字符转换为大写</p><h5 id="前后查找"><a href="#前后查找" class="headerlink" title="前后查找"></a>前后查找</h5><p>都是只匹配但不消费</p><p>(?=字符)    正向前查找，匹配到指定字符，停止匹配</p><p>(?!字符)    正向前查找，匹配到不是指定字符的，停止匹配</p><p>(?&lt;=字符)    正向后查找，匹配到指定字符，停止匹配</p><p>(&lt;=字符)    负向后查找，匹配到不是指定字符，停止匹配</p><h5 id="嵌入条件"><a href="#嵌入条件" class="headerlink" title="嵌入条件"></a>嵌入条件</h5><p>(?(n)regex)    如果前一个子表达式匹配到了则执行该正则</p><p>(?(前后查找)regex)    如果前后查找成功了则执行该正则</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;用途&quot;&gt;&lt;a href=&quot;#用途&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h5&gt;&lt;p&gt;正则表达式（regular expression，简称regex）：是一些用来匹配和处理文本的字符串&lt;/p&gt;
&lt;p&gt;正则表达式通常被简称为模式，其实是一些由字符构成的字符串&lt;/p&gt;
&lt;p&gt;这些字符可以是普通字符（纯文本）或元字符（有特殊含义的特殊字符）&lt;/p&gt;
&lt;h5 id=&quot;匹配单个字符&quot;&gt;&lt;a href=&quot;#匹配单个字符&quot; class=&quot;headerlink&quot; title=&quot;匹配单个字符&quot;&gt;&lt;/a&gt;匹配单个字符&lt;/h5&gt;&lt;p&gt; .    匹配任何单个的字符&lt;/p&gt;
&lt;p&gt;\    对特殊字符进行转义&lt;/p&gt;
&lt;h5 id=&quot;匹配一组字符&quot;&gt;&lt;a href=&quot;#匹配一组字符&quot; class=&quot;headerlink&quot; title=&quot;匹配一组字符&quot;&gt;&lt;/a&gt;匹配一组字符&lt;/h5&gt;&lt;p&gt;[和]    定义字符集合    [0-9a-zA-Z]&lt;/p&gt;
&lt;p&gt;-    定义字符区间    0-9 a-z&lt;/p&gt;
&lt;p&gt;^    对字符集合进行取非匹配    [^0-9a-zA-Z]&lt;/p&gt;
    
    </summary>
    
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="http://yoursite.com/2019/09/04/git%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/04/git使用/</id>
    <published>2019-09-04T15:43:18.000Z</published>
    <updated>2020-02-03T13:35:29.655Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git版本控制系统"><a href="#Git版本控制系统" class="headerlink" title="Git版本控制系统"></a>Git版本控制系统</h4><ul><li>记录版本信息（记录每一次的修改）</li><li>方便团队相互之间协作，共同开发</li></ul><p>常用版本控制系统</p><ul><li>svn/cvs：集中式版本控制系统    共用一个服务器，一旦出问题就全完了，保存差异</li><li>git：分布式版本控制系统    保存的是所有文件的快照，每个人本地都相当于一个服务器</li></ul><h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><p>这个网上很常见，自行参考网上教程</p><h4 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h4><h5 id="目的：托管项目代码"><a href="#目的：托管项目代码" class="headerlink" title="目的：托管项目代码"></a>目的：托管项目代码</h5><p>工作区 -&gt; 暂存区 -&gt; 历史区</p><h5 id="1-Git的全局配置"><a href="#1-Git的全局配置" class="headerlink" title="1.Git的全局配置"></a>1.Git的全局配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一次安装完成git后，要在全局环境下配置基本信息：我是谁？</span><br><span class="line"><span class="meta">$</span> git config -l查看配置信息</span><br><span class="line"><span class="meta">$</span> git config --global -l查看全局配置信息</span><br><span class="line">配置全局信息，用户名和邮箱</span><br><span class="line"><span class="meta">$</span> git config --global user.name 'xxx'</span><br><span class="line"><span class="meta">$</span> git config --global user.email 'xxx@xx.xx'</span><br><span class="line">初始化ssh</span><br><span class="line"><span class="meta">$</span> ssh-Keygon先是确定保存路径，再是密码，三次回车即可</span><br><span class="line">在C:\Users\asus\.ssh用记事本打开id_ssh.pub,复制其中内容</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git6.JPG" alt></p><a id="more"></a><h5 id="2-创建仓库完成版本控制"><a href="#2-创建仓库完成版本控制" class="headerlink" title="2.创建仓库完成版本控制"></a>2.创建仓库完成版本控制</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">创建本地git仓库</span><br><span class="line"><span class="meta">$</span> git init</span><br><span class="line">会生成一个隐藏文件夹“.git”（这个文件夹很重要，暂存区和历史区以及一些其他数据都在里面存着）</span><br><span class="line"></span><br><span class="line">在本地编写完成代码后（在工作区），把一些文件提交到暂存区</span><br><span class="line"><span class="meta">$</span> git add xxx把某一个文件或者文件夹提交到暂存区</span><br><span class="line"><span class="meta">$</span> git add .|| git add A把当前仓库中所有最新修改的文件都提交到暂存区</span><br><span class="line"><span class="meta">$</span> git status查看当前文件的状态（红色代表工作区，绿色代表暂存区，看不见东西代表所有东西都已提交到历史区）</span><br><span class="line"></span><br><span class="line">把暂存区内容提交到历史区</span><br><span class="line"><span class="meta">$</span> git commit -m'描述信息'</span><br><span class="line">本地版本库回退</span><br><span class="line"><span class="meta">$</span> git checkout -- 文件名回到最近的一次add/commit时的状态</span><br><span class="line"><span class="meta">$</span> git reset --hard/mixed/soft HEAD~num</span><br><span class="line">--hard回退全部，包括HEAD，index，working tree</span><br><span class="line">--mixed 回退部分，包括HEAD，index</span><br><span class="line">--soft只回退HEAD</span><br><span class="line">查看历史版本信息（历史记录）</span><br><span class="line"><span class="meta">$</span> git log</span><br><span class="line"><span class="meta">$</span> git reflog包含回滚的信息可以获得版本号</span><br><span class="line">差异比较</span><br><span class="line"><span class="meta">$</span> git diff比较工作区和暂存区</span><br><span class="line"><span class="meta">$</span> git diff --cached比较暂存区和本地库最近一次提交的区别</span><br><span class="line"><span class="meta">$</span> git diff HEAD比较工作区和本地库最近一次提交的区别</span><br><span class="line">分支操作</span><br><span class="line"><span class="meta">$</span> git branch -d 分支名删除分支</span><br><span class="line"><span class="meta">$</span> git remote push 分支一：分支二将分支一推给分支二</span><br><span class="line"><span class="meta">$</span> git branch查看现在有哪些分支</span><br><span class="line"><span class="meta">$</span> git checkout 分支名切换到分支</span><br><span class="line"><span class="meta">$</span> git checkout -b 分支名创建并切换到新分支</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git7.JPG" alt></p><p>通过移动head指针来改变版本</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git8.JPG" alt></p><p>一般多分支同时开发，然后由项目组长来分支合并</p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git5.jpg" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git4.jpg" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git3.jpg" alt></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git2.jpg" alt></p><p><strong>git小技巧</strong></p><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git9.JPG" alt></p><p>把一些暂时用不到的修改，暂存起来</p><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><p>一个网站（开源的代码管理平台），用户注册号，可以在自己账户下创建仓库，用来管理项目的源代码（源代码基于git传到仓库中）</p><p>我们所熟知的插件，类库，框架等都在这个平台上有托管，我们可以下载观看和研究源码等</p><p><strong>settings用户设置</strong></p><ul><li>profile    修改自己的基本信息</li><li>account    作用修改用户名</li><li>security    可以改自己的密码</li><li>emails    私有仓库作为内部团队协作管理的项目</li><li>……</li></ul><p>new  repository -&gt; 填写信息，公私有都免费 -&gt; create repository</p><ul><li>public    公共开源</li><li>private    私有，作为内部团队项目</li></ul><p>settings -&gt; 删除仓库</p><p>​               -&gt; collaborators 设置协助开发人员，需对方同意邀请</p><p>code可以查看历史版本和分支信息</p><p><strong>把本地仓库信息提交到远程仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">查看本地仓库和哪些远程仓库保持连接</span><br><span class="line"><span class="meta">$</span> git remote -v</span><br><span class="line">让本地仓库和远程仓库创建一个连接origin是随便起的一个名字，但一般都用这个</span><br><span class="line"><span class="meta">$</span> git remote add origin [仓库地址]</span><br><span class="line"><span class="meta">$</span> git remote rename old new重命名</span><br><span class="line">解除关联信息</span><br><span class="line"><span class="meta">$</span> git remote rm origin</span><br><span class="line">提交之前最好先拉取</span><br><span class="line"><span class="meta">$</span> git pull origin master</span><br><span class="line">将本地代码提交到远程仓库（第一次需要输入用户名和密码）</span><br><span class="line"><span class="meta">$</span> git push origin master</span><br><span class="line">将远程仓库代码拉取到本地</span><br><span class="line"><span class="meta">$</span> git clone [远程仓库git地址] [别名，默认为仓库名，也可以起一个作为拉取后的文件夹名]</span><br><span class="line">/*</span><br><span class="line"> *真实项目开发流程：</span><br><span class="line"> *1.组长或者负责人先创建中央仓库</span><br><span class="line"> *2.小组成员基于$ git clone 把远程仓库及默认的内容克隆到本地（解决了三个事情：初始化一个</span><br><span class="line"> 本地仓库“git init”，和对应的远程仓库也保持了关联“git remote add”，把远程仓库默认内人拉取到本地</span><br><span class="line"> “git pull”</span><br><span class="line"> *3.每个组员写自己的程序后，基于“git add/git commit”把自己修改的内容存放到历史区，然后通过</span><br><span class="line"> “git pull/git push”把本地信息和远程仓库信息保持同步即可（可能涉及冲突处理）</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/git1.jpg" alt></p><h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><p>node package manger:NODE模块管理工具，根据NPM我们可快速安装、卸载所需要的资源文件</p><p>区NODE官网：下载NODE重启支持版，安装NODE后，NPM也跟着安装了</p><p>基于npm是从<a href>npmjs.com</a>平台下下载安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//在终端中检测安装是否成功，出现版本号即成功了</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ npm install xxx把模块安装在当前项目中（node_modules）</span><br><span class="line">$ npm install xxx -g把模块安装在全局环境中</span><br><span class="line">$ npm i xxx@<span class="number">1.0</span>.<span class="number">0</span>安装指定版本号的模块</span><br><span class="line">$ npm view xx version &gt; xxx.version.json查看某个模块的版本信息（输出到指定json文件中）</span><br><span class="line"></span><br><span class="line">$ npm init -y初始化当前项目的配置依赖清单</span><br><span class="line">$ npm i xxx -save把模块保存在清单生产依赖中</span><br><span class="line">$ npm i xxx --save-dev把模块保存在清单开发依赖中</span><br><span class="line">$ npm install跑环境，按照清单安装所需模块</span><br><span class="line"></span><br><span class="line">$ npm root -g查看全局安装模块的目录</span><br><span class="line">$ npm -uninstall xxx</span><br><span class="line">$ npm -uninstall xxx -g卸载安装过的模块</span><br></pre></td></tr></table></figure><h4 id="高级搜索"><a href="#高级搜索" class="headerlink" title="高级搜索"></a>高级搜索</h4><p><img src="https://raw.githubusercontent.com/guardwarm/imageBed/master/%E6%9F%A5%E6%89%BE%E9%A1%B9%E7%9B%AE1.png" alt></p><p><a href="https://help.github.com/en/github/searching-for-information-on-github/searching-for-repositories" target="_blank" rel="noopener">更多高级搜索</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Git版本控制系统&quot;&gt;&lt;a href=&quot;#Git版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;Git版本控制系统&quot;&gt;&lt;/a&gt;Git版本控制系统&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;记录版本信息（记录每一次的修改）&lt;/li&gt;
&lt;li&gt;方便团队相互之间协作，共同开发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用版本控制系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;svn/cvs：集中式版本控制系统    共用一个服务器，一旦出问题就全完了，保存差异&lt;/li&gt;
&lt;li&gt;git：分布式版本控制系统    保存的是所有文件的快照，每个人本地都相当于一个服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Git安装&quot;&gt;&lt;a href=&quot;#Git安装&quot; class=&quot;headerlink&quot; title=&quot;Git安装&quot;&gt;&lt;/a&gt;Git安装&lt;/h4&gt;&lt;p&gt;这个网上很常见，自行参考网上教程&lt;/p&gt;
&lt;h4 id=&quot;使用GitHub&quot;&gt;&lt;a href=&quot;#使用GitHub&quot; class=&quot;headerlink&quot; title=&quot;使用GitHub&quot;&gt;&lt;/a&gt;使用GitHub&lt;/h4&gt;&lt;h5 id=&quot;目的：托管项目代码&quot;&gt;&lt;a href=&quot;#目的：托管项目代码&quot; class=&quot;headerlink&quot; title=&quot;目的：托管项目代码&quot;&gt;&lt;/a&gt;目的：托管项目代码&lt;/h5&gt;&lt;p&gt;工作区 -&amp;gt; 暂存区 -&amp;gt; 历史区&lt;/p&gt;
&lt;h5 id=&quot;1-Git的全局配置&quot;&gt;&lt;a href=&quot;#1-Git的全局配置&quot; class=&quot;headerlink&quot; title=&quot;1.Git的全局配置&quot;&gt;&lt;/a&gt;1.Git的全局配置&lt;/h5&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第一次安装完成git后，要在全局环境下配置基本信息：我是谁？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; git config -l		查看配置信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; git config --global -l		查看全局配置信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;配置全局信息，用户名和邮箱&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; git config --global user.name &#39;xxx&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; git config --global user.email &#39;xxx@xx.xx&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;初始化ssh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; ssh-Keygon	先是确定保存路径，再是密码，三次回车即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在C:\Users\asus\.ssh用记事本打开id_ssh.pub,复制其中内容&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/guardwarm/imageBed/master/git6.JPG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>javaSE</title>
    <link href="http://yoursite.com/2019/08/16/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/08/16/java基础/</id>
    <published>2019-08-16T05:15:33.000Z</published>
    <updated>2020-02-15T09:26:38.033Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据类型和运算符"><a href="#数据类型和运算符" class="headerlink" title="数据类型和运算符"></a>数据类型和运算符</h4><h5 id="基本数据类型（四类八种）"><a href="#基本数据类型（四类八种）" class="headerlink" title="基本数据类型（四类八种）"></a>基本数据类型（四类八种）</h5><p>byte(1)  boolean(1)  short(2)  char(2)unicode字符集  int()4  float(4)  long(8)  double(8)</p><p><strong>限制double小数点数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"0.00"</span>);</span><br><span class="line">df.format(total);</span><br></pre></td></tr></table></figure><p><strong>string与基本类型转换</strong></p><p>包装类的parse和tostring方法</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><p>string，数组，集合ArrayList，Scanner，Random，自定义类型</p><a id="more"></a><h4 id="包的声明和访问"><a href="#包的声明和访问" class="headerlink" title="包的声明和访问"></a>包的声明和访问</h4><p>包的本质就是文件夹，在包名中以.来区分上下级文件关系</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase8.JPG" alt></p><p>作用：分类管理文件</p><p>包的声明：package 包名        指示某个类在哪个包下    包的声明必须和类的实际位置保持一致</p><p>包的导入：用来告诉编译器我们要用的类在哪个包下        import 包名.类名</p><p>不导包时需采用全限定类名：包名.类名（所有用到类名的地方都需这样写）</p><h4 id="四种访问权限修饰符"><a href="#四种访问权限修饰符" class="headerlink" title="四种访问权限修饰符"></a>四种访问权限修饰符</h4><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase9.JPG" alt></p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向对象是一种编程思想，是相当于面向过程的</p><p>面向过程：遇到问题，亲力亲为一步一步解决        核心理念：谁的功能谁负责</p><p>面向对象：遇到一个问题，找具有解决这个问题能力的对象，调用它的方法</p><p>面向对象三大特性：封装（安全性），继承（拓展性），多态（）</p><p>类的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="comment">//成员类名</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个标准的类封装：隐藏细节，对外暴露公共防蚊1方式构造：无参必须有，全参最好有</span></span><br><span class="line"><span class="comment">//类名作为方法参数或返回值时需要传入或返回的应该是该类的对象</span></span><br></pre></td></tr></table></figure><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase1.JPG" alt></p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是两个类之间的关系，子类继承父类</p><h5 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h5><p>区分局部变量和成员变量同名的情况</p><p>this的本质：实际上是个对象    谁调用的方法，this指的就是谁</p><p>匿名对象：（可用可不用）    没有名字的对象</p><p>只创建对象，但不用变量接收</p><p>在一些用来传参后续不调用时使用</p><p>特点：匿名对象也是一个对象，具有对象所有功能</p><p>​            每次调用都是一个新的对象，所一每个对象只能使用一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.xxx<span class="comment">//调用该对象属性</span></span><br><span class="line"><span class="keyword">this</span>.aaa()<span class="comment">//调用该对象方法</span></span><br><span class="line"><span class="comment">//高级使用：用来调用本类的其他构造通过输入不同参数来调用不同构造</span></span><br></pre></td></tr></table></figure><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase4.JPG" alt></p><h5 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h5><p>区分子类和父类成员同名的情况，但默认优先调用子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.xxx<span class="comment">//调用父类属性</span></span><br><span class="line"><span class="keyword">super</span>.aaa()<span class="comment">//调用父类方法</span></span><br><span class="line"><span class="keyword">super</span>();<span class="comment">//调用父类构造方法，通过输入不同参数来调用不同构造，默认调用无参构造</span></span><br><span class="line"><span class="comment">//无论调用子类那个构造，都会先调用父类构造，符合单一职责原则，一个类只需负责给本类变量初始化</span></span><br></pre></td></tr></table></figure><h5 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承必须合理人是人他妈生的，妖是妖他妈生的</span></span><br><span class="line"><span class="comment">//继承中的成员抽取了子类中的共性内容</span></span><br><span class="line"><span class="comment">//子类会自动继承父类中所有成员，但private不可访问</span></span><br><span class="line"><span class="comment">//创建子类对象时会先创建其父类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承后成员变量不同时，没有任何问题，相同时优先访问子类</span></span><br><span class="line"><span class="comment">//继承后成员方法不同时，没有任何问题，相同时(子类重写了父类方法时)优先访问子类，但可以通过super.方法名访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只能单继承，但可以多层继承（直接父类唯一，但可以有多个间接父类）</span></span><br><span class="line"><span class="comment">//多继承的话调用方法时会产生不确定性，同名父类成员不知道该掉哪个</span></span><br></pre></td></tr></table></figure><p>继承大大提高代码重用性</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase3.JPG" alt></p><ul><li><p>方法的重载：在同一个类中，方法名相同，但参数列表不同（参数类型，参数顺序，参数个数任一不同）</p></li><li><p>方法的重写（覆盖，覆写override）：子类中出现了和父类一模一样的方法</p><ul><li>重写原因：当子类发现继承过来的方法不适用时需要重写自己的方法</li><li>重写要求：该方法子类权限需大于等于父类权限（一般都是相同权限）    public  protected  default  private</li></ul><p>private方法不可重写    方法名，参数列表，返回值类型必须一模一样</p></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>一个对象的多种状态</p><p>java中的前提：必须有字符类关系，必须有方法的重写</p><h5 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h5><p>抽象类：以前一个类中包含抽象方法即为抽象类，现在只要由关键字abstract修饰即为抽象类</p><p>抽象类不可以实例化，天生就是作为父类的</p><p>抽象方法：只有声明而没有实现        向上抽取时会出现一种特殊情况，方法功能声明相同，但方法主体不同，这时只抽取方法声明，所得即为抽象方法        必须用关键字abstract修饰        不能调用，为了强制子类去重写</p><blockquote><p>类名作为返回值或参数时，传递和返回的应是该类对象</p><p>抽象类作为返回值或参数时，传递和返回的应是该类的子类的对象</p></blockquote><p>链式编程：当返回值为调用这个方法的对象时，便可以链式的调用下去</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase5.JPG" alt></p><p><strong>小练习</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例：武警开坦克打飞机</span></span><br><span class="line"><span class="comment">//名词提取：武警 坦克  飞机再分析每个类对应属性和方法</span></span><br></pre></td></tr></table></figure><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>类：一堆具有共同属性和成员方法的对象的集合</p><p>接口：方法的集合，只能定义抽象方法    天生作为父接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class类</span></span><br><span class="line"><span class="comment">//abstract class抽象类</span></span><br><span class="line"><span class="comment">//interface接口</span></span><br><span class="line"><span class="comment">//enum枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line"><span class="comment">//不能定义普通成员变量，只能定义抽象方法</span></span><br><span class="line"><span class="comment">//可以定义常量public static final 变量名即使不加修饰，编译器也会自动添加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开发中常用模式：一个类继承一个抽象类，实现多个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> <span class="title">B</span> <span class="keyword">implements</span> 接口<span class="title">A</span>，接口<span class="title">B</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类与类之间是单继承，一个子类只能有一个直接父类</p><p>接口与接口之间支持多继承也支持多层继承</p><p>类与接口之间不叫继承（extends）而是实现（implements）    可以多实现</p><p><strong>比较抽象类和接口</strong></p><p>相同点：都不能实例化，都是作为父类/父接口，子类继承/实现都不行重写抽象方法</p><p>不同点：抽象类中不全是抽象方法，可以有普通成员变量，修饰的关键字不同    弥补了java的单继承</p><p>思想上的区别：抽象类中必须定义整个体系的共性内容</p><p>​                            接口中定义整个继承体系之外额外的扩展功能（谁想有这些功能就来是实现下这个接口）</p><p>优先使用接口    需要定义子类行为又要为子类提供共性功能时才用抽象类</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase6.JPG" alt></p><h5 id="多态-1"><a href="#多态-1" class="headerlink" title="多态"></a>多态</h5><p>父类类型 变量名 = new 子类类型();</p><p>父类类型变量指向了子类对象</p><p>注意事项：多态使用变量是，编译和运行都看父类        调用成员方法，编译看父类，运行看子类</p><p>多态的弊端：只能调用子父类共有的方法，不能调用子类特有的（因为编译时看父类，特有的编译过不了）</p><p>好处：提高灵活性，父类可以接收任何一个子类对象    传哪个子类运行哪个子类的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//弊端解决方案</span></span><br><span class="line"><span class="comment">//向下转型：强制类型转换double转int，父类转之类把向下和强转关联记忆吧</span></span><br><span class="line"><span class="comment">//向上转型:隐式类型转换  子类转父类（多态） 向下转换会面临不知道该转成哪个子类的困扰，易出现类型转换异常</span></span><br><span class="line"><span class="comment">//向下转型弊端解决：instanceof格式：boolean b = 父类对象名 instanceof 子类对象名</span></span><br></pre></td></tr></table></figure><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ul><li><p>成员内部类：定义类中方法外</p><p>在其他类中创建对象    外部类名.内部类名 对象名 = new 外部类名().new 内部类();</p></li><li><p>局部内部类：定义方法中</p><p>在其他类中无法使用，只能局部使用</p></li></ul><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>一种特殊的语法，用于快速创建抽象类的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建抽闲类对象</span><br><span class="line">//创建子类继承抽象类重写抽象方法new子类对象</span><br><span class="line">//用匿名内部类可以一步完成</span><br><span class="line">new 抽象类名()&#123;</span><br><span class="line">//重写方法</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new 抽象类名()&#123;</span><br><span class="line">//重写方法</span><br><span class="line">&#125;.调用属性/方法;</span><br><span class="line"></span><br><span class="line">//最常用</span><br><span class="line">抽象类名 对象名 = new 抽象类名()&#123;</span><br><span class="line">//重写方法</span><br><span class="line">&#125;;</span><br><span class="line">//只重写抽象方法而不写独有的方法，因为没有名字，即使写了也无法向下强转为子类调用</span><br></pre></td></tr></table></figure><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//当我们使用到这个类的时候（实例化或使用静态成员等等），JVM会自动执行静态代码块中的内容</span></span><br><span class="line">        <span class="comment">//仅在第一次使用到这个类的时候会执行一次，第二次就不会了</span></span><br><span class="line">        <span class="comment">//优先级高于main和构造方法</span></span><br><span class="line">        <span class="comment">//用于初始化类，比如MySQL加载驱动等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><h5 id="static-静态的"><a href="#static-静态的" class="headerlink" title="static    静态的"></a>static    静态的</h5><p>用于修饰类中的成员    被static修饰的成员访问时无需实例化再调用，可以直接通过类名访问（推荐）</p><p>当一个对象不独属于某个成员，而是所有成员共享事应加static修饰</p><p><strong>静态没有多态性</strong>，静态属于类，而多态属于对象    多态调用静态成员时没有多态性（访问的是父类而非子类）</p><p>静态优先于对象存在</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase7.JPG" alt></p><h5 id="final-最终的"><a href="#final-最终的" class="headerlink" title="final    最终的"></a>final    最终的</h5><p>可以修饰类，成员变量，成员方法，局部变量（基本类型，引用类型）</p><p>通过最终来理解这些性质</p><blockquote><p>final修饰类——最终类：不能被继承，但可以有父类（太监类）</p><p>final修饰成员变量：该变量必需在被实例化前赋值，且只能赋值一次</p><p>final修饰成员方法：该方法不能被子类重写</p><p>final修饰的基本类型局部变量只能赋值一次</p><p>final修饰的引用类型局部变量只能赋值一次，但其所指向的对象的内容可以随意改变</p></blockquote><h5 id="类中各种成员的初始化的顺序"><a href="#类中各种成员的初始化的顺序" class="headerlink" title="类中各种成员的初始化的顺序"></a>类中各种成员的初始化的顺序</h5><blockquote><p>1.如果类中存在继承关系(像 Son 继承 Father)  则首先会初始化导出类(Son)的基类(Father)，然后再是导出类</p><p>2.在基类首先会初始化静态 的东西  静态代码块&gt;静态变量  而且只初始化一次 （因为静态的东西都是跟着类的加载而加载的）</p><p>3.随后就是初始化导出类的静态东西  跟基类的静态初始化一样（同上）</p><p>4.初始化基类无参构造器（调用有参就初始化有参构造器）</p><p>5.初始化导出类无参构造器（注意：导出类的成员变量和代码块都是是比构造函数的初始化要早。。看输出结果可知）可知）</p></blockquote><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><p>是类层次的根类，所有类都直接或间接继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//两个重要方法</span><br><span class="line">boolean equals(Object obj);//obj中定义的是根据地址计算出的hashcode</span><br><span class="line">//string类中重写了，改为比较字符串内容,我们自己定义类也一般会重写</span><br><span class="line">String toString(Object obj)//返回该对象的字符串表示默认包名.类名@hashcode(地址)</span><br><span class="line">//system.out 打印对象会默认调用tostring    我们一般会重写这个方法</span><br></pre></td></tr></table></figure><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>java代码编译或执行过程中出现的一些问题</p><h5 id="异常的继承体系"><a href="#异常的继承体系" class="headerlink" title="异常的继承体系"></a>异常的继承体系</h5><blockquote><p>Throwable：可以抛出去的东西</p><blockquote><p>Exception：异常（普通问题）</p><blockquote><p>编译时异常：Exception及其子类（RuntimeException除外）</p><p>运行时异常：RuntimeException及其子类</p></blockquote><p>Errow：错误（严重的问题）</p></blockquote></blockquote><h5 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h5><p>异常处理：异常处理指的是一种可能性，只有当出现了异常时才会执行异常处理代码，否则正常执行</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase10.JPG" alt></p><blockquote><p>异常处理方式</p><p>不处理</p><blockquote><p>throw：动词，真正的抛出一个异常</p><p>throws：形容词，用来形容一个方法，表示该方法可能抛出的异常 要求调用者去处理它</p><p>public void 方法名（参数）throws 可能抛出的异常类型{</p><p>}</p></blockquote><p>捕获处理</p><blockquote><p>try(){</p><p>​    可能出现异常的代码</p><p>}catch(对应类型的异常对象){</p><p>​    //catch可以有多个</p><p>​    //处理异常</p><p>}finally{</p><p>​    //写上必须要执行的代码，比如释放资源等</p><p>}</p><p>一次捕获多次处理: 一个try 多个catch  (多个catch中 必须是异常子类在前,父类在后)</p><p>多次捕获多次处理: 多个try,每个try多应一个catch</p><p>一次捕获一次处理(最常用的):一个try一个catch(catch中异常类必须所有可能出现异常的父类)</p></blockquote></blockquote><p>注意事项：子类异常必须从属于父类异常  </p><p>技巧: 如何区分一个异常类 到底是编译时还是运行时异常</p><blockquote><p>1.编译时异常 在编译的时候会报错的 (需要我们去处理)</p><p>2.运行时异常 在编译的时候不会报错</p><p>只要定义一个方法,在方法中抛出一个异常对象,如果编译报错那么就是编译时异常</p><p>如果编译成功,那么就是运行时异常</p></blockquote><p>请你说出十个运行时异常:</p><blockquote><p>1.RuntimeException</p><p>2.ClassCastException:类型转换异常 (向下转型的时候)</p><p>3.ArrayIndexOutOfBoundsException:数组下标越界</p><p>4.StringIndexOutOfBoundsException:字符串下标越界</p><p>5.NullPointerException:空指针异常</p></blockquote><p>自定义异常类：</p><blockquote><p>1.创建一个类,这个类必须用Exception结尾</p><p>2.必须继承 Exception 或者 RumtimeException</p><p>3.自定义的异常 至少有两个构造</p><blockquote><p>a.空参数构造</p><p>b.带有String类型参数的构造        </p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo09_自定义异常的练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSuchAgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NoSuchAgeException</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//带有String的构造内部调用super(s)，将传入的string交给父类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NoSuchAgeException</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h4><p>Date类:日期类    多数方法都过时了，不常用</p><p>标准时间1970年1月1日0时0分0秒</p><p>构造:</p><blockquote><p>public Date();//代表当前系统时间的Date对象</p><p>public Date(long time);//代表距离标准时间 time毫秒值的Date对象</p></blockquote><p>成员方法:</p><blockquote><p>public String toString();//Date    重写Object类的toString方法</p><p>public long getTime();//获取当前Date对象的毫米值        与public Date(long time)互逆</p></blockquote><p>DateFormat:日期格式化类,是一个抽象类</p><p>具体的子类:SimpleDateFormat</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/java12.JPG" alt></p><p>构造:</p><blockquote><p>public SimpleDateFormat(String pattern);//以指定的模式创建格式化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(yyyy年MM月dd日HH时mm分ss秒);</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>成员方法:</p><blockquote><p>public String format(Date d);//把date对象按照指定的模式 转成字符串</p><p>public Date parse(String s);//把字符串转成Date对象,如果字符串有问题,就会抛出ParseException</p></blockquote><h4 id="Calendar-日历类"><a href="#Calendar-日历类" class="headerlink" title="Calendar:日历类"></a>Calendar:日历类</h4><p>获取Calendar对象</p><blockquote><p>public static Calendar getInstance();//返回的是抽象类Calendar的某一个子类</p></blockquote><p>成员方法:</p><blockquote><p>public int get(int field);//获取指定字段的值</p><p>public void add(int field,int amount);//给指定的字段增加值</p><p>public void set(int field,int value);//修改指定字段的值</p><p>public Date getTime();//把Calendar对象转成Date 对象</p><p>getTime().getTime()    相当于调用date的方法来获取毫秒值</p></blockquote><h4 id="System-系统类"><a href="#System-系统类" class="headerlink" title="System:系统类"></a>System:系统类</h4><p>该类无法思力华，被私有化了</p><blockquote><p>public static void exit(0);//结束JVM</p><p>public static void gc();//通知垃圾回收器过来收垃圾，只是通知，不一定会来</p><p>public static getProperty(String key);//根据键 获取值</p><p>public static long currentTimeMillis();//获取当前系统的毫秒值</p></blockquote><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase13.JPG" alt></p><h4 id="Math-数学类"><a href="#Math-数学类" class="headerlink" title="Math:数学类"></a>Math:数学类</h4><p>都是些静态方法，直接调用就好</p><blockquote><p>求最大值    max</p><p>求最小值     min</p><p>求绝对值    abs</p><p>求随机数      random    返回一个[0,1)之间的数，通过简单计算得到自己想要的范围</p><p>求四舍五入    </p><p>ceil(向上取整) </p><p>floor(向下取整) </p><p>pow(求次幂)</p></blockquote><h4 id="基类数据类型包装类"><a href="#基类数据类型包装类" class="headerlink" title="基类数据类型包装类"></a>基类数据类型包装类</h4><p>八种基本类对应的包装类型</p><blockquote><p>byte    boolean    short    char    int    float    double    long</p><p>Byte    Boolean    Short    Character    Interger    Float    Double    Long</p></blockquote><p>作用</p><blockquote><p>在集合中只允许存储包装类型，不可以存基本类型</p><p><strong>实现字符串的转换</strong>   public static int parseInt(String s);    将字符串转为int，其它基本类型类比即可</p></blockquote><p>自动拆箱装箱</p><blockquote><p>装箱：基本类型-&gt;包装类型    </p><p>拆箱：包装类型-&gt;基本类型</p></blockquote><blockquote><p>哪些数据类型 重写了toString()</p><p>1.String类</p><p>2.保存数据的引用类型 (Integer,Double…,集合,map)</p><p>3.自定义类 可以重写toString  </p></blockquote><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>所有编程语言都支持，用来匹配字符串的</p><p>boolean b = 普通字符串  匹配  正则表达式</p><blockquote><p>public boolean matches(String regex);</p><p>boolean b = “普通字符串”.matches(“正则表达式”);</p></blockquote><blockquote><p>public String[] split(String regex);        切割字符串,返回切割后的字符串数组</p></blockquote><p>书写技巧：一位一位的匹配</p><p>通配符</p><blockquote><p>正则表达式中 “.”代表任意字符</p><p>在DOS中 “*”代表任意内容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * QQ号码需要满足的规则:</span></span><br><span class="line"><span class="comment"> * 1.必须是0-9的数字</span></span><br><span class="line"><span class="comment"> * 2.开头必须1-9中的一个数字</span></span><br><span class="line"><span class="comment"> * 3.位数必须 5-12位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qq</span><span class="params">()</span></span>&#123;</span><br><span class="line">String qq = <span class="string">"12355a63564"</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = qq.matches(<span class="string">"[1-9][0-9]&#123;4,11&#125;"</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 举例：校验手机号码</span></span><br><span class="line"><span class="comment"> * 1：要求为11位0-9的数字</span></span><br><span class="line"><span class="comment"> * 2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">phone</span><span class="params">()</span></span>&#123;</span><br><span class="line">String phone = <span class="string">"18600363521"</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = phone.matches(<span class="string">"1[34578][0-9]&#123;9&#125;"</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 案例:切割电话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split01</span><span class="params">()</span></span>&#123;</span><br><span class="line">String phone = <span class="string">"2345--4564----6546-----1345"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切割phone  把号码切割出来</span></span><br><span class="line"><span class="comment">//+号 在正则表达式中有特殊意义,表示连续的多个相同的字符</span></span><br><span class="line">String[] phones = phone.split(<span class="string">"-+"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phones.length; i++) &#123;</span><br><span class="line">System.out.println(phones[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 案例:切割ip</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split02</span><span class="params">()</span></span>&#123;</span><br><span class="line">String ip = <span class="string">"192...168....123......110"</span>;</span><br><span class="line"><span class="comment">//"."号 在正则表达式中 表示 任意字符</span></span><br><span class="line"><span class="comment">//转译字符</span></span><br><span class="line"><span class="comment">//\t</span></span><br><span class="line"><span class="comment">//\n</span></span><br><span class="line">String[] ips = ip.split(<span class="string">"\\.+"</span>);<span class="comment">//在正则表达式中 "\\" 代表一个"\"</span></span><br><span class="line">System.out.println(ips.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ips.length; i++) &#123;</span><br><span class="line">System.out.println(ips[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String中的方法（4532）"><a href="#String中的方法（4532）" class="headerlink" title="String中的方法（4532）"></a>String中的方法（4532）</h4><h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIngoreCase</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String str)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(String str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> startIndex)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span>;<span class="comment">//左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexof</span><span class="params">(String subStr)</span></span>;<span class="comment">//少用</span></span><br></pre></td></tr></table></figure><h5 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">toCharArray</span><span class="params">()</span>；</span></span><br></pre></td></tr></table></figure><h5 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;<span class="comment">//去掉两端空格</span></span><br><span class="line">String[] split(String str);<span class="comment">//一某一个字符串来分割字符串</span></span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合框架:</p><blockquote><p>List–&gt; ArrayList,LinkedList,Vector</p><p>Set –&gt; HashSet,LinkedHashSet,TreeSet</p></blockquote><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase14.JPG" alt></p><h5 id="Collection接口中的公共方法"><a href="#Collection接口中的公共方法" class="headerlink" title="Collection接口中的公共方法:"></a>Collection接口中的公共方法:</h5><p>子类不是都有下标，所有Collection无下标，故而无法进行改查操作</p><blockquote><p>增: add(E e);</p><p>删: remove(Object obj);</p><p>改: 无</p><p>查: 无</p><p>其他:</p><blockquote><p>int size();//长度</p><p>boolean contains(Object obj);</p><p>void clear();//清空</p><p>Object[] toArray();    //集合转换成数组</p></blockquote></blockquote><p>在ArrayList中 有一个方法  </p><p>addAll(Collection c);//把集合c里面的每一个元素添加到ArrayList中</p><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>在Collection根解扣子中定义一种公共的遍历方式:迭代器遍历</p><p>Iterator&lt;泛型和集合的一样&gt; it = 集合对象.iterator();    底层类似链表</p><p>迭代器对象 有两个方法:</p><blockquote><p>hasNext();//判断有没有下一个</p><p>next();//取出下一个</p></blockquote><p><strong>以上两个方法必须配合使用</strong></p><p>补充</p><blockquote><p>Concurrent(并发)Modification(修改)Exception</p><p>java规定,如果一个集合使用迭代器遍历,那么在遍历的过程中 <strong>不允许修改集合的长度(</strong>增加或者删除)</p></blockquote><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase15.JPG" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个集合对象,使用多态</span></span><br><span class="line">Collection&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//2.添加</span></span><br><span class="line">names.add(<span class="string">"郭德纲"</span>);</span><br><span class="line">names.add(<span class="string">"刘德华"</span>);</span><br><span class="line">names.add(<span class="string">"柳岩"</span>);</span><br><span class="line">names.add(<span class="string">"范伟"</span>);</span><br><span class="line">names.add(<span class="string">"范伟1"</span>);</span><br><span class="line"><span class="comment">//3.获取names集合的迭代器对象</span></span><br><span class="line">Iterator&lt;String&gt; it = names.iterator();</span><br><span class="line"><span class="comment">//4.标准代码</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//反复判断有没有下一个元素</span></span><br><span class="line">String s = it.next();<span class="comment">//如果有取出下一个元素</span></span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h5><p>增强for循环比普通的for循环增强在哪?</p><blockquote><p>增强在语法上更加简单</p></blockquote><p>格式:</p><blockquote><p>for(数据类型 变量名:数组/集合){</p><p>syso(变量名);</p><p>}</p></blockquote><p>注意:</p><blockquote><p>当你使用增强for循环遍历集合的时候</p><p>底层采用的是迭代器    </p></blockquote><p>总结: </p><blockquote><p>当你使用增强for循环遍历集合的时候,不能修改集合的长度</p></blockquote><h5 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h5><p>泛泛的类型,不确定的类型，类型参数化</p><p>格式:</p><blockquote><p><e>,&lt;K,V&gt;</e></p></blockquote><p>好处</p><blockquote><p>避免了强制类型转换</p><p>将运行时的ClassCsatException变为了编译错误</p></blockquote><p><img src="/.com//java%E8%BF%9B%E9%98%B6/java16.JPG" alt></p><p>泛型通配符</p><blockquote><p>?:代表任意类型</p><p>&lt;? extends Animal&gt; : 表示一种泛型,这种泛型必须是Animal 或者Animal的子类</p><p>&lt;? super Animal&gt;:表示一种泛型,这种泛型必须是Animal  或者Animal的父类</p></blockquote><p>泛型可以用在类上，方法上，接口上</p><blockquote><p>泛型用在类上: 泛型类</p><blockquote><p>格式:public class 类名<e></e></p><p>当你创建该类的对象的时候,就可以确定</p></blockquote><p>泛型用在方法上:泛型方法</p><blockquote><p>格式:public <t> 返回值类型 方法名(T t);</t></p><p>当你调用方法,传递参数的时候确定</p></blockquote><p>泛型用在接口上:泛型接口</p><blockquote><p>格式:public interface 接口名<e>    </e></p><p>1.实现类实现接口的时候,直接确定</p><p>2.实现类实现接口的时候,不确定泛型,而是直接把泛型继承下来,当这个实现类创建对象的时候确定</p></blockquote></blockquote><h5 id="堆栈和队列"><a href="#堆栈和队列" class="headerlink" title="堆栈和队列"></a>堆栈和队列</h5><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase18.JPG" alt></p><h5 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h5><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase19.JPG" alt></p><h5 id="list接口"><a href="#list接口" class="headerlink" title="list接口"></a>list接口</h5><p>List接口的特点:</p><blockquote><p>a.有下标</p><p>b.有序的(有序不是自然顺序,不是123,abc,有序指的是存和取的顺序一致)</p><p>c.可重复</p></blockquote><p>实现类:ArrayList,LinkedList,Vector</p><blockquote><p>ArrayList:底层采用数组结构,查询快,增删慢</p><p>LinkedList:底层采用链表结构,查询慢,增删快</p><p>Vector:底层采用数组结构,查询快,增删慢（基本不用）</p></blockquote><p>List结构中具有的方法:</p><blockquote><p>增: add(E e);add(int index,E e);</p><p>删: remove(Object obj);remove(int index);</p><p>改: set(int index,E e);</p><p>查: get(int index);</p><p>其他:</p><p>size(),clear(),contains(Object obj),toArray()</p><p>iterator();isEmpty()</p></blockquote><p>实现类的方法:</p><blockquote><p>1.ArrayList:方法基本和List中定义的一模一样</p><p>2.LinkedList:除了和List接口中一样的方法之外</p><p>LinkedList提供了大量首位操作的方法</p><blockquote><p>第一组:</p><p>void addFirst(E e);</p><p>void addLast(E e);</p><p>第二组:</p><p>E removeFirst();//删除首个元素,返回被删除的元素</p><p>E removeLast();//删除尾部元素,返回被删除的元素</p><p>第三组:</p><p>E getFirst();</p><p>E getLast();</p><p>第四组:</p><p>E pop();//弹出,删除集合中的某一个元素,和 removeFirst功能是一样的</p><p>void push(E e);//推入,把一个元素添加到集合中, 和addFist功能是一样的</p></blockquote></blockquote><h5 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h5><p>Set接口的特点:</p><blockquote><p>a.无下标</p><p>b.无序的(无序指的是存和取的顺序不一定一致,LinkedHashSet和TreeSet除外)</p><p>c.不可重复</p></blockquote><p>实现类:HashSet,LinkedHashSet,TreeSet</p><blockquote><p>HashSet:底层采用哈希表结构,查询快,增删快,无序的</p><p>LinkedHashSet:底层采用 链表+哈希表,查询快,增删快,有序的</p></blockquote><p>Set接口中的特有方法: 没有,和父接口Collection基本一模一样</p><p>实现类:HashSet和LinkedHashSet中的方法基本和Set接口一模一样</p><p><strong>对象的哈希值:</strong></p><blockquote><p>任何对象,都有一个哈希值,哈希值是对象的一个数字表示</p><p>对象的字符串表示,toString方法,默认表示格式:包名.类名@地址值</p><p>如果获取对象的哈希值?</p><p>每一个对象都有一个方法,hashCode方法,这方法定义在了Object类中,所以每个对象都具有</p><p>我们以前说的地址值,实际上根本不是地址值,而是哈希值的16进制</p><p>在java中怎么看真正地址值? 看不了</p><p>哈希值的由来</p><blockquote><p>是由真正的地址值计算的,通过一种散列算法(哈希算法)</p><p>所以 一般来说 地址值 不一样, 哈希值也是不一样的</p><p>不可逆算法(MD5,WPA2)</p><p>碰撞算法(一个一个试)</p><p>暴力破解&amp;字典破解(破解wifi教程)</p></blockquote><p>字符串的哈希值:</p><blockquote><p>由于String类重写了HashCode  那么哈希值不在通过地址值计算</p><p>我们观察源码,发现通过字符串的内容计算,所以只要字符串内容相同,哈希值必定相同</p><p>思考:</p><p>只要字符串内容一样,哈希值 必定一样</p><p>两个字符串的内容不一样,哈希值可能一样</p><p>比如: abc 和 acD</p></blockquote></blockquote><p><strong>哈希表结构:</strong></p><blockquote><blockquote><p>数组结构+链表结构的组合,查询快,增删快</p><p>HashSet:采用了哈希表结构</p><p>LinkedHashSet:采用了链表+哈希表结构</p></blockquote><p>哈希表结构,判断元素是否重复的原理:</p><blockquote><p>1.先判断 新元素的哈希值 和 所有旧元素的哈希值是否相同</p><p>如果都不相同,直接判断不重复,添加</p><p>2.再调用  新元素 和  哈希值相同的旧元素的equals方法</p><p>如果返回是true 判定重复元素 ,不添加</p><p>如果返回是false 判定不重复,添加</p></blockquote><p>总结:</p><blockquote><p>只有哈希值相同,并且equals返回true,才判定重复</p></blockquote></blockquote><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase20.JPG" alt></p><blockquote><p>判断元素重复不重复的原理:</p><blockquote><p>1 比较哈希值</p><p>2 调用equals方法</p><p>只有 哈希值相同,并且equals方法true,才是重复元素,才不存储</p></blockquote><blockquote><p>contains方法,判断是否包含某一个元素</p><blockquote><p>ArrayList的contains方法:</p><p>names.contains(“abc”);//判断 names集合中是否包含 “abc”</p><p>只比较 equals的返回值,如果某一个元素和要判断的元素equals方法true,那么就是包含该元素</p></blockquote><p>HashSet的contains方法:</p><blockquote><p>set.contains(“abc”);//</p><p>先判断哈希值</p><p>再使用equals方法</p><p>只有旧元素和判断的元素 的哈希值相同 并且 euqals方法true 才判定包含</p></blockquote></blockquote></blockquote><p><strong>使用HashSet存储自定义元素(Dog对象)</strong></p><blockquote><p>结论:</p><p>如果我们<strong>自定义了类</strong> 要使用HashSet存储</p><p>如何保证元素的唯一性:</p><p>必须重写自定义类的两个方法,hashCode和equals</p><p>定义一个标准的类:</p><blockquote><p>1.封装(private+get/set)</p><p>2.构造(无参+全参)</p><p>3.toString(快速打印对象信息)</p><p>4.hashCode和equals(保证元素使用哈希表结构存储时的唯一性)</p></blockquote></blockquote><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><h5 id="Map集合的特点"><a href="#Map集合的特点" class="headerlink" title="Map集合的特点:"></a>Map集合的特点:</h5><blockquote><p>1.Map集合 和 Collection集合 没有继承关系,所以不能直接用迭代器</p><p>2.Collection集合 每一个元素都是单独存在</p><p>Map集合的每一个元素都是成对存在的</p><p>3.Collection<e>一个泛型</e></p><p>Map&lt;K,V&gt;两个泛型, K代表键的类型,V代表值的类型</p><p>K,V可以相同  也可以不同,必须都是引用类型</p><p>4.在Map集合的元素中,<strong>键是唯一的,</strong>值是可以重复的</p><p>5.常用的实现类:</p><p>HashMap:无序</p><p>底层哈希表结构,保证键的唯一性<strong>,需要重写键对应类的hashCode和equals方法</strong></p><p>LinkedHashMap:有序</p><p>底层哈希表结构+链表,哈希表保证键的唯一,链表保证元素的有序</p><p>需要重写键对应类的hashCode和equals方法</p></blockquote><h5 id="Map-lt-K-V-gt-集合常用的方法"><a href="#Map-lt-K-V-gt-集合常用的方法" class="headerlink" title="Map&lt;K,V&gt;集合常用的方法:"></a>Map&lt;K,V&gt;集合常用的方法:</h5><blockquote><p>增: V put(K key,V value);//向集合中添加键值对</p><p>//如果集合中已存在该键,覆盖整个键值对,并返回被覆盖的键值对的值        </p><p>删: V remove(OBject key);//根据键 从map集合中删除 键值对,返回值表示被删除的键值对的值</p><p>改: 隐藏到了put方法</p><p>查: V get(K key);//根据键 从map集合中找到唯一对应的值</p></blockquote><h5 id="Map集合第一种遍历方法-以键找值"><a href="#Map集合第一种遍历方法-以键找值" class="headerlink" title="Map集合第一种遍历方法:以键找值"></a>Map集合第一种遍历方法:以键找值</h5><blockquote><p>1.先获取map集合的键的集合,这个集合是一个Set集合</p><p>Set<k> keys = map集合.keySet();</k></p><p>2.遍历keys集合    </p><p>a.foreach b.迭代器</p><p>3.在遍历的过程中,从map集合获取键对应的值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.获取map的键的集合</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="comment">//4.遍历keys这个集合,获取到每一个键</span></span><br><span class="line"><span class="comment">//4.1迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; it = keys.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line"> String key = it.next();</span><br><span class="line"> <span class="comment">//根据key 从map集合中查找 对应值</span></span><br><span class="line"> String value = map.get(key);</span><br><span class="line"> <span class="comment">//打印</span></span><br><span class="line"> System.out.println(key+<span class="string">":"</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase21.JPG" alt></p><h5 id="map集合第二种遍历-：键值对遍历"><a href="#map集合第二种遍历-：键值对遍历" class="headerlink" title="map集合第二种遍历 ：键值对遍历"></a>map集合第二种遍历 ：键值对遍历</h5><blockquote><p>1.获取map集合中所有 结婚证对象</p><p>Set&lt;Map.Entry&lt;K,V&gt;&gt; set = map集合.entrySet();</p><p>2.遍历这个set集合,获取每一个Map.Entry类型的对象</p><p>a.迭代器 b.foreach</p><p>3.获取到 Map.Entry类型的对象之后</p><p>K key = entry.getKey();</p><p>V value = entry.getValue();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.获取所有键值对关系对象的集合</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">//4.遍历 这个entry集合, 拿出每一个结婚证对象</span></span><br><span class="line"><span class="comment">//使用迭代器遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line"><span class="comment">//获取这个entry中的 键和值</span></span><br><span class="line">String key = entry.getKey();</span><br><span class="line">String value = entry.getValue();</span><br><span class="line">System.out.println(key+<span class="string">"="</span>+value);</span><br></pre></td></tr></table></figure><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase22.JPG" alt></p><p><strong>回顾：内部类和内部接口</strong></p><blockquote><p>内部类:</p><p>一个类A,定义在另外一个类B 的内部,这个类A 这个类被称为内部类</p><p>OuterClass.InnerClass ic = new OuterClass().new InnerClass();</p><p>内部接口:</p><p>一个接口A,定义在另外一个接口B的内部,这个接口A, 这个接口A被称为内部接口</p><p>class Class2 implements OuterInter.InnerInter    只重写内部类中的方法即可</p></blockquote><h5 id="使用map存储自定义类型"><a href="#使用map存储自定义类型" class="headerlink" title="使用map存储自定义类型"></a>使用map存储自定义类型</h5><p>使用map存储:键为学号,值为一个学生的对象, 学生对象有属性（姓名，年龄）</p><p>使用map存储:键为学生（姓名，年龄）值为学生自己的家庭住址。</p><p>结论:</p><p>如果Map中的键是自定义类型,那么要保证键的唯一性,必须重写键对应类的hashCode和equals方法</p><h4 id="Properties属性集"><a href="#Properties属性集" class="headerlink" title="Properties属性集"></a>Properties属性集</h4><p>在开发中Map集合可能用到,但是Properties属性集,1000%会用到</p><h5 id="Properties类到底是什么"><a href="#Properties类到底是什么" class="headerlink" title="Properties类到底是什么?"></a>Properties类到底是什么?</h5><p>属性集,</p><p>class Propeties extends HashTable implements Map</p><p>所以:Properties本质上 就是一个Map集合</p><p>Properties是一个持久的属性集</p><p>所谓持久 就是 它具有自己写数据到文件的方法</p><p>Properties是没有泛型,泛型是固定,String 和 String</p><h5 id="Properties类-具有Map接口的一切方法"><a href="#Properties类-具有Map接口的一切方法" class="headerlink" title="Properties类,具有Map接口的一切方法"></a>Properties类,具有Map接口的一切方法</h5><blockquote><p>还有具有一些自己特有的方法:</p><blockquote><p>public String getProperty(String key)用指定的键在此属性列表中搜索属性的值,功能和Map中的get是一样</p><p>public Object setProperty(String key, String value);添加键值对,功能和Map的put方法是一样</p><p>public Set<string> stringPropertyNames()://和Map中的keySet方法是一样</string></p></blockquote><p>Properties具有持久化到文件的功能</p><blockquote><p>store();//保存数据到文件,实际上不是保存到文件 而是写入到流中,由流写到文件</p><p>load();//从文件中加载数据,实际上不是直接加载文件,而是加载流中的数据,而流的数据是从该文件中读取的</p></blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//和Properties持久化有关的方法</span></span><br><span class="line">Properties ps = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//从文件中读取数据</span></span><br><span class="line">ps.load(<span class="keyword">new</span> FileReader(<span class="string">"phones.properties"</span>));</span><br><span class="line">System.out.println(ps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Properties持久化数据到文件中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writePs</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//1.定义Properties</span></span><br><span class="line">Properties ps = <span class="keyword">new</span> Properties();</span><br><span class="line">ps.setProperty(<span class="string">"iphoneX"</span>, <span class="string">"8888"</span>);</span><br><span class="line">ps.setProperty(<span class="string">"xiaomiMix"</span>, <span class="string">"3888"</span>);</span><br><span class="line">ps.setProperty(<span class="string">"huaweiMate11"</span>, <span class="string">"6888"</span>);</span><br><span class="line">ps.setProperty(<span class="string">"vivoX20"</span>, <span class="string">"1888"</span>);</span><br><span class="line"><span class="comment">//2.把ps的数据持久化到文件中</span></span><br><span class="line">ps.store(<span class="keyword">new</span> FileWriter(<span class="string">"phones.properties"</span>), <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//1.创建一个Properties对象</span></span><br><span class="line">Properties ps = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//2.添加数据</span></span><br><span class="line">ps.setProperty(<span class="string">"张三"</span>, <span class="string">"18"</span>);</span><br><span class="line">ps.setProperty(<span class="string">"李四"</span>, <span class="string">"28"</span>);</span><br><span class="line">ps.setProperty(<span class="string">"王五"</span>, <span class="string">"38"</span>);</span><br><span class="line">ps.setProperty(<span class="string">"前妻"</span>, <span class="string">"48"</span>);</span><br><span class="line"><span class="comment">//3.遍历</span></span><br><span class="line"><span class="comment">//1.stringPropertyNames 就是keySet</span></span><br><span class="line">Set&lt;String&gt; propertyNames = ps.stringPropertyNames();</span><br><span class="line"><span class="comment">//4.遍历</span></span><br><span class="line"><span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line"><span class="comment">//根据属性名 propertyName获取属性值</span></span><br><span class="line">String propertyValue = ps.getProperty(propertyName);</span><br><span class="line">System.out.println(propertyName+<span class="string">"="</span>+propertyValue); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h4><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>说的不是参数类型可变,而是<strong>参数的个数</strong>可以变化</p><p>语法: JDK1.5 出现新特性</p><p>public 返回值类型 方法名(数据类型… 参数名){}</p><p>注意:</p><blockquote><p>1.可变参数只是参数的个数是任意个,参数的类型不能改变    </p><p>2.一个方法中 只能有一个可变参数</p><p>3.当一个方法中有多个参数,并且有一个是可变参数的时候,要求这个可变参数必须在最后</p></blockquote><p>可变参数的<strong>本质</strong>: 就是一个数组</p><h5 id="Collections中的静态方法"><a href="#Collections中的静态方法" class="headerlink" title="Collections中的静态方法:"></a>Collections中的静态方法:</h5><blockquote><p>public static void shuffle(List list);//打乱顺序</p><p>public static void sort(List list);//把集合元素按照自然顺序(123,abc)排序</p></blockquote><p>Arrays:数组工具类</p><blockquote><p>public static List asList(数组/可变参数);//把一个数组 转成List集合</p><p>public static void sort(数组);//排序数组</p><p>public static String toString(数组);//把数组转成字符串</p></blockquote><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><blockquote><p>递归:是一个通用技术,所有的编程语言,只要有方法概念的编程语言都具有递归</p><p>什么叫递归:在一个方法的内部,再调用方法本身</p><p>无限递归本身是错误的:因为方法运行需要进栈,而栈空间不是无限大的</p><p>使用递归的前提****:</p><p>1.必须有一个可以是递归结束的出口</p><p>2.递归的次数,不能太多(具体的次数不好确定,与内存,CPU…都有关)</p><p>我们建议在开发中 能不用递归 就是不要用</p><p>急剧消耗内存(最常见是杀毒软件 扫描硬盘)</p><p>递归的其他分类:</p><p>直接递归:</p><p>在A方法的内部 直接调用A方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//定义一个方法,求1-n的和先想一下基于n-1步如何解决</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">&gt; <span class="comment">//1+2+3...n = (1+2+3..n-1)+n</span></span><br><span class="line">&gt; <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">&gt; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">return</span> getSum(n-<span class="number">1</span>)+n;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//求1-n的和常用</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">&gt; <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">&gt; sum+=i;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="keyword">return</span> sum;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">&gt;      <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">&gt;          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      <span class="keyword">return</span> getSum2(n - <span class="number">2</span>) + n;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>间接递归:</p><p>在A方法的内部调用B方法,在B方法的内部调用C方法,在C方法的内部调用A方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> com.guardwarm.递归;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//定义方法  求 n个式子的和</span></span><br><span class="line">&gt; <span class="comment">//n=5</span></span><br><span class="line">&gt; <span class="comment">//1+(1+2)+(1+2+3)+(1+2+3+4)+(1+2+3+4+5)</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">undirectDiGui</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;         System.out.println(<span class="string">"please enter a num"</span>);</span><br><span class="line">&gt;         Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">&gt;         <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">&gt;         <span class="keyword">int</span> sum = getsum(n);</span><br><span class="line">&gt;         System.out.println(sum);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;         <span class="keyword">return</span> getsum(n-<span class="number">1</span>)+zigetsum(n);</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zigetsum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">&gt;             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&gt;         <span class="keyword">return</span> zigetsum(n-<span class="number">1</span>)+n;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase23.bmp" alt></p><h4 id="斗地主案例"><a href="#斗地主案例" class="headerlink" title="斗地主案例"></a>斗地主案例</h4><h5 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h5><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase17.JPG" alt></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guardwarm.斗地主;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 斗地主步骤:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.创建编号和牌对应的map集合</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.准备一副牌(54个数字1-54)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3.洗牌</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4.发牌</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5.排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 6.从map集合查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 7.看牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">doudizhuMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备一副牌</span></span><br><span class="line">        Map&lt;Integer,String&gt; allcard = <span class="keyword">new</span> LinkedHashMap&lt;Integer, String&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; cards = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; p1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; p2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; p3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; dp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">        String[] colors = &#123;<span class="string">"♠"</span>,<span class="string">"♥"</span>,<span class="string">"♣"</span>,<span class="string">"♦"</span>&#125;;</span><br><span class="line">        String[] nums = &#123;<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"10"</span>,<span class="string">"J"</span>,<span class="string">"Q"</span>,<span class="string">"K"</span>,<span class="string">"A"</span>,<span class="string">"2"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(String num : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String color : colors)&#123;</span><br><span class="line">                String card = num+ color;</span><br><span class="line">                allcard.put(id,card);</span><br><span class="line">                cards.add(id);</span><br><span class="line">                id++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allcard.put(id,<span class="string">"大S"</span>);</span><br><span class="line">        cards.add(id);</span><br><span class="line">        id++;</span><br><span class="line">        allcard.put(id,<span class="string">"小S"</span>);</span><br><span class="line">        cards.add(id);</span><br><span class="line">        id++;</span><br><span class="line">        Collections.shuffle(cards);</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line"><span class="comment">//        System.out.println(cards);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cards.size(); ++i) &#123;</span><br><span class="line">            Integer cd = cards.get(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>) &#123;</span><br><span class="line">                dp.add(cd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                p1.add(cd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                p2.add(cd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">                p3.add(cd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(p1);</span><br><span class="line">        Collections.sort(p2);</span><br><span class="line">        Collections.sort(p3);</span><br><span class="line">        Collections.sort(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*        System.out.println(p1);</span></span><br><span class="line"><span class="comment">        System.out.println(p2);</span></span><br><span class="line"><span class="comment">        System.out.println(p3);</span></span><br><span class="line"><span class="comment">        System.out.println(dp);*/</span></span><br><span class="line">        outputcard(p1,allcard);</span><br><span class="line">        outputcard(p2,allcard);</span><br><span class="line">        outputcard(p3,allcard);</span><br><span class="line">        outputcard(dp,allcard);</span><br><span class="line">       <span class="comment">/* Collections.sort(cards);</span></span><br><span class="line"><span class="comment">        System.out.println(cards);*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputcard</span><span class="params">(ArrayList&lt;Integer&gt; ls,Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Integer cardid:ls)&#123;</span><br><span class="line">            String card = map.get(cardid);</span><br><span class="line">            System.out.print(card+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO流-读写文件"><a href="#IO流-读写文件" class="headerlink" title="IO流_读写文件"></a>IO流_读写文件</h4><p>（输入输出是相对程序而言的）</p><p>输出流：数据从java程序到文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)</span></span><br><span class="line">write(<span class="keyword">int</span> ch);<span class="comment">//可以写ascll码值</span></span><br><span class="line">write(<span class="keyword">char</span>[] ch);</span><br><span class="line">write(<span class="keyword">char</span>[] ch,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> len);</span><br><span class="line">write(String s);</span><br><span class="line">write(String s,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure><p>输入流：数据从文件到java程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">//读取一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] chs)</span></span>;<span class="comment">//读取一个字符数组，返回值表示读取到的字符个数</span></span><br></pre></td></tr></table></figure><h4 id="File类"><a href="#File类" class="headerlink" title="File类:"></a>File类:</h4><p><strong>描述:文件和 目录路径名的抽象表示</strong></p><blockquote><p>文件:可以直接保存数据</p><p>目录路径名:文件夹,分类管理文件</p><p>结论:File类可以表示文件 也可以表示文件夹</p></blockquote><p><strong>构造:</strong></p><p>public File(String filepath);</p><p>绝对路径:以盘符开头的路径</p><p>相对路径:相对当前项目的根目录</p><p><strong>File对象的获取方法:</strong></p><blockquote><p>1.public String getAbsolutePath();//获取绝对路径</p><p>2.public String getName()//获取当前File对象的名字</p><p>3.public String getPath();//获取创建File对象时 传递的路径</p><p>4.public long length();//获取表示文件的File对象的占用的字节数,如果是文件夹的File对象,返回值不确定</p></blockquote><p><strong>File对象的删除和创建方法:</strong></p><p>1.创建方法:</p><blockquote><p>创建文件:</p><p>public boolean createNewFile();//创建一个新的文件(只能是文件,不能是文件夹),返回是否创建成功</p><p>创建文件夹</p><p>public boolean mkdir();//创建一个新的文件夹,返回是否创建成功</p><p>public boolean mkdirs();//可以一次性创建多层文件夹</p></blockquote><p>2.判断方法:</p><blockquote><p>判断是否是文件</p><p>public boolean isFile();//返回是否是文件</p><p>判断是否是文件夹</p><p>public boolean isDirectory();//返回是否是文件夹</p><p>判断文件或者文件夹是否存在,是前面两个前提</p><p>public boolean exists();//返回该File 对象是否存在</p></blockquote><p>3.删除方法:</p><blockquote><p>public boolean delete();//删除文件或者文件夹</p><p>可以删除的是单个文件,或者空文件夹</p></blockquote><p>File类的list和listFiles方法</p><blockquote><p>1.public String[] list();</p><p>2.public File[] listFiles();</p><p>注意:</p><p>只能列出当前文件夹下的一级子文件或者子文件夹，那个对象必须存在且是文件夹才可以调用</p></blockquote><p><strong>案例：使用递归遍历使用文件夹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用递归遍历 一个文件夹aaa下的所有文件(包括一级的也包括n级文件)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.定义方法,遍历一个文件夹下的所有文件</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.在方法中判断 某一个File对象 ,如果是文件 直接打印</span></span><br><span class="line"><span class="comment"> * 如果不是文件,递归调用第1步定义的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiguiDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.创建aaa文件夹的File 对象</span></span><br><span class="line">File aaa = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\yingpeng\\Desktop\\aaa"</span>);</span><br><span class="line"><span class="comment">//2.调用方法 列出 aaa下的所有文件</span></span><br><span class="line">printFiles(aaa);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个方法:列出一个文件夹下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFiles</span><span class="params">(File objFileDir)</span></span>&#123;</span><br><span class="line"><span class="comment">//2.列出aaa文件夹下的所有File 对象</span></span><br><span class="line">File[] files = objFileDir.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line"><span class="comment">//判断是否是文件 或者 文件夹</span></span><br><span class="line"><span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//是文件夹.列出该文件夹下的所有东西</span></span><br><span class="line">printFiles(file);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件过滤器:FileFilter</strong></p><p>在list和listFiles方法中使用，用来过滤文件，有多少个文件就会执行多少次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFileFilter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">".."</span>);<span class="comment">//用来看这个方法执行了多少次</span></span><br><span class="line"><span class="keyword">if</span>(pathname.getName().endsWith(<span class="string">".PNG"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例：map集合嵌套遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guardwarm.map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 案例:</span></span><br><span class="line"><span class="comment"> * 需要定义一个Map集合,保存学生的学号和他对应的名字</span></span><br><span class="line"><span class="comment"> * Map&lt;String,String&gt;</span></span><br><span class="line"><span class="comment"> * JavaEE:</span></span><br><span class="line"><span class="comment"> * heima001  张三</span></span><br><span class="line"><span class="comment"> * heima003 李四</span></span><br><span class="line"><span class="comment"> * heima005 王五</span></span><br><span class="line"><span class="comment"> * UI:</span></span><br><span class="line"><span class="comment"> * heima001 小丽</span></span><br><span class="line"><span class="comment"> * heima004 小红</span></span><br><span class="line"><span class="comment"> * heima005 小美</span></span><br><span class="line"><span class="comment"> * PHP:</span></span><br><span class="line"><span class="comment"> * heima002 小黑</span></span><br><span class="line"><span class="comment"> * heima003 小白</span></span><br><span class="line"><span class="comment"> * heima006 小猪</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapQianTao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义所需map</span></span><br><span class="line">        Map&lt;String,String&gt; eeMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        Map&lt;String,String&gt; uiMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        Map&lt;String,String&gt; phpMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        Map&lt;String,Map&lt;String,String&gt;&gt; outMap = <span class="keyword">new</span> HashMap&lt;String, Map&lt;String, String&gt;&gt;();</span><br><span class="line">        eeMap.put(<span class="string">"heima001"</span>,<span class="string">"张三"</span>);</span><br><span class="line">        eeMap.put(<span class="string">"heima003"</span>,<span class="string">"李四"</span>);</span><br><span class="line">        eeMap.put(<span class="string">"heima005"</span>,<span class="string">"王五"</span>);</span><br><span class="line"></span><br><span class="line">        uiMap.put(<span class="string">"heima001"</span>,<span class="string">"小丽"</span>);</span><br><span class="line">        uiMap.put(<span class="string">"heima004"</span>,<span class="string">"小红"</span>);</span><br><span class="line">        uiMap.put(<span class="string">"heima005"</span>,<span class="string">"小美"</span>);</span><br><span class="line"></span><br><span class="line">        phpMap.put(<span class="string">"heima002"</span>,<span class="string">"小黑"</span>);</span><br><span class="line">        phpMap.put(<span class="string">"heima004"</span>,<span class="string">"小白"</span>);</span><br><span class="line">        phpMap.put(<span class="string">"heima005"</span>,<span class="string">"小猪"</span>);</span><br><span class="line"></span><br><span class="line">        outMap.put(<span class="string">"javaee"</span>,eeMap);</span><br><span class="line">        outMap.put(<span class="string">"ui"</span>,uiMap);</span><br><span class="line">        outMap.put(<span class="string">"php"</span>,phpMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先通过entrySet获取Set，然后再用set获取迭代器开始遍历</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outSet = outMap.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outit = outSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (outit.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String,Map&lt;String,String&gt;&gt; outEntry = outit.next();</span><br><span class="line">            String outKey = outEntry.getKey();</span><br><span class="line">            <span class="comment">//由于值是map，所以内部还得再遍历</span></span><br><span class="line">            Map&lt;String,String&gt; outvalue = outEntry.getValue();</span><br><span class="line">            System.out.println(outKey);</span><br><span class="line">            Set&lt;String&gt; mapKeys = outvalue.keySet();</span><br><span class="line">            <span class="keyword">for</span>(String key:mapKeys)&#123;</span><br><span class="line">                String mapValue = outvalue.get(key);</span><br><span class="line">                System.out.println(mapValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p>根据流的流向分类:</p><blockquote><p>Input:输入流</p><p>Output:输出流</p></blockquote><p>根据流操作的数据来分类</p><blockquote><p>字符流: 操作字符    只能操作普通文本文件,</p><p>​        最常见的文本文件:.txt,.java,.c,.cpp等其他语言的源代码</p><p>​        只要用文本工具(记事本,notepad++,editplus) 可以打开的 ,而且打开后我们人类能看懂的 都是文本文件</p><p>​        注意:我们用的.doc,excel,ppt这些不是文本文件</p><p>字节流: 操作字节</p><p>​        能操作一切文件(文本文件,.mp3,视频.avi,.rmvb,mp4,doc,excel,ppt)</p></blockquote><p>java中的四大流:</p><blockquote><p>字符输入流:共同父类 Reader   比如:FileReader,BufferedReader</p><p>功能:读取一个字符,读取一个字符数组</p><p>字符输出流:共同的父类 Writer    比如:FileWriter BufferedWriter</p><p>功能:写一个字符,写一个字符数组(一部分),写一个字符串</p><p>字节输入流:共同父类 InputStream  比如:FileInputStream,BufferedInputStream</p><p>功能:读取一个字节,读取一个字节数组</p><p>字节输出流:共同父类 OutputStream 比如:FileOutputStream,BufferedOutputStream</p><p>功能:写一个字节,写一个字节数组(一部分)</p></blockquote><p>只要是输入流   此流的方法名 一定叫做 read</p><p>只要是输出流  此流的方法名 一定叫做 write</p><p>java中流的命名是十分规范的:    <strong>功能+父类的名字（4种）</strong></p><h5 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream:"></a>OutputStream:</h5><p>字节输出流的根类,这是一个抽象类</p><blockquote><p>public void close();//关闭流</p><p>public void flush();//刷新流</p></blockquote><p>和写数据有关系的方法;</p><blockquote><p>public void write(int b);//写一个字节 </p><p>public void write(byte[] bs);//写一个字节数组</p><p>public void write(byte[] bs,int startIndex,int lenght);//写一个字节数组的一部分</p></blockquote><p><strong>FileOutputStream</strong></p><p>OutputStream具体子类</p><p>追加:</p><blockquote><p>以前用的构造:</p><p>​    public FileOutputStream(String filename);//默认就是覆盖</p><p>​    public FileOutputStream(File file);//给定一个File对象,这个File对象代表我们要写入的文件</p><p>请用这个构造,实现追加:</p><p>​    public FileOutputStream(String filename,boolean flag)</p><p>​    public FileOutputStream(File file,boolean flag)</p></blockquote><p>换行（不同操作系统用不同换行）:</p><blockquote><p>windows:\r\n</p><p>Linux:\n</p><p>Mac:\r</p></blockquote><h5 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream:"></a>InputStream:</h5><p>字节输入流的根类,这是一个抽象类</p><p>public int read();//读取一个字节,返回的是码值</p><p>public int read(byte[] bs);//读取一个字节数组,返回值表示实际读取到的字节数</p><p>我们用InputStream具体子类:<strong>FileInputStream</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guardwarm.文件;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 复制文件练习:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.源文件: 是读取用的, new FileInputStream("源文件")</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.目标文件: 是写入用的, new OutputStream("目标文件")</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 一边读取 源文件  一边写出到目标文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4.关闭流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\书\\史铁生.docx"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"F:\\书\\copy.docx"</span>);</span><br><span class="line">        <span class="keyword">long</span> s = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((b=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*        //一次读取一个字节数组</span></span><br><span class="line"><span class="comment">        byte[] bs = new byte[1024];//用来保存读取到的字节数据</span></span><br><span class="line"><span class="comment">        int len = 0;//保存实际读取到的字节个数</span></span><br><span class="line"><span class="comment">        while((len=fis.read(bs))!=-1)&#123;</span></span><br><span class="line"><span class="comment">            fos.write(bs, 0, len);//写入bs中的从0下标开始len个字节 到文件中</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">long</span> e = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> time = e-s;</span><br><span class="line">        System.out.println(time);</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="缓冲流-相比较没有缓冲区的流-效率更高"><a href="#缓冲流-相比较没有缓冲区的流-效率更高" class="headerlink" title="缓冲流: 相比较没有缓冲区的流,效率更高"></a>缓冲流: 相比较没有缓冲区的流,效率更高</h5><p>BufferedOutputStream 缓冲输出流</p><p>构造方法</p><blockquote><p>public BufferedOutputStream(OutputStream out)  </p></blockquote><p>BufferedInputStream  缓冲输入流</p><p>构造方法</p><blockquote><p>public BufferedInputStream(InputStream in) </p></blockquote><h5 id="小案例：复制单级文件夹"><a href="#小案例：复制单级文件夹" class="headerlink" title="小案例：复制单级文件夹"></a>小案例：复制单级文件夹</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guardwarm.文件;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopySingleDirectory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建文件夹</span></span><br><span class="line">        File srcfl = <span class="keyword">new</span> File(<span class="string">"F:\\demo1"</span>);</span><br><span class="line">        File dstfl = <span class="keyword">new</span> File(<span class="string">"F:\\demo2"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!dstfl.exists())&#123;</span><br><span class="line">            <span class="keyword">boolean</span> b = dstfl.mkdirs();</span><br><span class="line">            <span class="keyword">if</span> (b)&#123;</span><br><span class="line">                System.out.println(<span class="string">"文件夹不存在，成功创建"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"目标文件夹已存在，直接复制即可"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历文件  注意创建目标文件</span></span><br><span class="line">        File[] srcfiles = srcfl.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File src : srcfiles)&#123;</span><br><span class="line">            File dst = <span class="keyword">new</span> File(dstfl,src.getName());</span><br><span class="line">            copyfile(src,dst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyfile</span><span class="params">(File srcfl,File dstfl)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(srcfl));</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dstfl));</span><br><span class="line">        <span class="comment">//固定格式</span></span><br><span class="line">        <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bs))!= -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bs,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line">        System.out.println(<span class="string">"复制文件"</span>+srcfl.getName()+<span class="string">"成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="小知识点-1"><a href="#小知识点-1" class="headerlink" title="小知识点"></a>小知识点</h5><p><strong>使用字节流读取中文的乱码问题:</strong></p><blockquote><p>如果是一个一个字节读取, 100%会出现乱码</p><p>如果是一个一个字节数组读取,可能也会出现乱码</p></blockquote><p>解决方法</p><blockquote><p>字符流</p><p>转换流</p></blockquote><h5 id="字符编码集"><a href="#字符编码集" class="headerlink" title="字符编码集"></a>字符编码集</h5><ul><li>ASCII码表    美国    每个字符对应一个字节    保存了字母，数字，以及一些常用符号    a-97 A-65 0-48</li><li>GB2313    保存常用汉字，一个中文占两字节，这两个字节全是负数</li><li>GBK    保存了基本所有汉字，统统占两个字节第一个字节为负，第二个字节随意</li><li>Unicode    统一码表（万国码表）所有文字统统两字符，向下兼容ASCII</li><li>UTF-8  在Unicode的基础上做了一些优化，能用一个字节的不用两个字节，且在每一个字节头加入了编码信息，一个中文占三个字节</li><li>Latin-1（ISO-8859-1）  拉丁码表，Tomact会用到</li></ul><p>编码 – &gt;文字到对应码值</p><p>解码 – &gt;码值到对应文字</p><h5 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h5><p>字符流的子类</p><p><strong>OutputStreamWriter</strong></p><p>查码表，是字符流通向字节流的桥梁，write方法与其他流一致</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase23.JPG" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeCN</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//创建可以把字符转成字节的转换流对象，并指定编码两种构造，指定编码也可不写，默认GBK</span></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\cn8.txt"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//调用转换流，把文字写出去，其实是写到转换流的高效区中</span></span><br><span class="line">osw.write(<span class="string">"你好"</span>);<span class="comment">//写入高效区。</span></span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><p><strong>InputStreamReader</strong></p><p>注意选择正确的解码方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//演示字节转字符流的转换流</span></span><br><span class="line">readCN();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readCN</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//创建读取文件的字节流对象</span></span><br><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\cn8.txt"</span>);</span><br><span class="line"><span class="comment">//创建转换流对象 </span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(in);这样创建对象，会用本地默认码表读取，将会发生错误解码的错误</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in,<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//使用转换流去读字节流中的字节</span></span><br><span class="line"><span class="keyword">int</span> ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((ch = isr.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println((<span class="keyword">char</span>)ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">isr.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换流和子类区别：转换流可以选择解码/编码方式</p><p>java.lang.Object<br>    java.io.Writer<br>        java.io.OutputStreamWriter<br>            java.io.FileWriter</p><p>​    FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编    码表时可以不用父类，而直接用子类就完成操作了，简化了代码。</p><h5 id="序列化流和反序列化流"><a href="#序列化流和反序列化流" class="headerlink" title="序列化流和反序列化流"></a>序列化流和反序列化流</h5><p>用于从流中读取对象的操作流 ObjectInputStream   称为 反序列化流</p><p>用于向流中写入对象的操作流 ObjectOutputStream   称为 序列化流</p><p>构造方法类似转换流，具体看API</p><p><strong>常见异常</strong></p><ul><li><p>当一个对象要能被序列化，这个对象所属的类必须实现Serializable接口。否则会发生异常NotSerializableException异常。</p></li><li><p>同时当反序列化对象时，如果对象所属的class文件在序列化之后进行的修改，那么进行反序列化也会发生异常InvalidClassException。发生这个异常的原因如下：</p><blockquote><p>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </p><p>该类包含未知数据类型 </p><p>该类没有可访问的无参数构造方法 </p><p>版本号默认有java管理，也可以生成版本号自己管理</p></blockquote></li></ul><p><strong>transient关键字</strong></p><p>不需要序列化的属性可以使用关键字transient修饰        同时static修饰的也不会序列化</p><h5 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h5><p>字节打印流  PrintStream</p><p>字符打印流  PrintWriter</p><p>两者基本一致，可以打印的目的地略有不同</p><blockquote><p>PrintStream    字符串的文件名，file对象，其他的tOutputStream，其他的Writer</p><p>PrintWriter    字符串的文件名，file对象，其他的tOutputStream</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintWriterDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//创建流</span></span><br><span class="line"><span class="comment">//PrintWriter out = new PrintWriter(new FileWriter("printFile.txt"));</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">"printFile.txt"</span>);</span><br><span class="line"><span class="comment">//2，写数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">out.println(<span class="string">"helloWorld"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3,关闭流</span></span><br><span class="line">out.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三方小框架：commons-io"><a href="#第三方小框架：commons-io" class="headerlink" title="第三方小框架：commons-io"></a>第三方小框架：commons-io</h5><p>ps.第一方：官方，第二方：我们</p><p>jar包：java专用压缩包</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase24.JPG" alt></p><p>从上到下依次为：api文档，框架class文件，生成api文档的源文件，框架源文件，测试class文件，测试源文件，许可，注意事项</p><p><strong>添加jar包</strong></p><p>eclipse</p><blockquote><p>1.创建lib文件夹</p><p>2.将commons-io.jar拷贝到lib文件夹</p><p>3.右键点击，→</p></blockquote><p>IDEA</p><blockquote><p>file-&gt; project structure</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase25.JPG" alt></p><p>点最右侧那个+，然后OK就好</p></blockquote><p><strong>FileUtils</strong></p><blockquote><p>readFileToString(File file)：读取文件内容，并返回一个String；</p><p>writeStringToFile(File file，String content)：将内容content写入到file中；</p><p>copyFile(File srcFile, File destFile): 文件复制</p><p>copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制</p></blockquote><p>多是一些静态方法，直接用类名就可调用</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><strong>几个小概念</strong></p><blockquote><p>进程: 正在运行的程序 叫做进程</p><p>线程:    进程中的一个小任务</p><p>一个进程中通常是由多个线程在执行任务</p><p>main方法所在线程 我们称为主线程</p></blockquote><h5 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h5><p>Thread类:就是我们说的线程类</p><p>构造:</p><p>public Thread();//创建一个默认名字的线程对象</p><p>public Thread(String name);//创建一个指定名字的线程对象</p><p>创建新的线程的方法一:</p><blockquote><p>1.定义子类 继承 Thread</p><p>2.在子类中重写run方法(就是执行任务的方法,在run方法中写<strong>任务代码</strong>即可)</p><p>3.创建子类对象(就是创建一个线程对象)</p><p>4.开启这个线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.创建子类线程对象</span></span><br><span class="line">MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//设置守护线程</span></span><br><span class="line">mt.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//4.开启线程,JVM自动会告诉CPU去执行线程任务代码</span></span><br><span class="line">mt.start();</span><br></pre></td></tr></table></figure><p>开启线程的第二种方式:</p><blockquote><p>1.定义实现类 实现Runnable接口</p><p>2.实现类要重写run方法(就是写任务代码的方法)</p><p>3.创建实现类对象</p><p>4.创建Thread对象,并把刚刚的实现类对象 作为参数传递</p><p>5.启动这个Thread对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line"><span class="comment">//4.创建Thread对象,并把刚刚的实现类对象 作为参数传递</span></span><br><span class="line">Thread td = <span class="keyword">new</span> Thread(mr);</span><br><span class="line"><span class="comment">//5.开启线程</span></span><br><span class="line">td.start();</span><br></pre></td></tr></table></figure><p>内存图</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase26.bmp" alt></p><p>创建两个线程对象</p><blockquote><p>我们发现:</p><p>a.线程默认是有名字,名字Thread-n,n从0开始 依次递增的</p><p>b.我们可以修改线程的名字,但是一般不改</p><p>setName(String name);</p><p>c我们可以获取线程的名字,通过线程对象的getName方法获取</p><p>d.获取线程名字的最常用的方法</p><p>Thread.currentThread().getName();</p></blockquote><p>两种创建方式比较</p><p>从耦合性分析:</p><blockquote><p>第一种方式:线程和任务是紧紧联系在一起的,耦合性高</p><p>第二种方式:线程是线程,任务是任务,他们之间没有必然联系,给一个线程传递哪个任务那么该线程就执行哪个任务</p><p>所以说开发中,我们用第二种方式</p></blockquote><p>从代码的扩展性:</p><blockquote><p>第一种方式 由于是继承Thread,那么子线程类就不能继承别的类</p><p>第二种方式 由于是实现了接口,同时可以继承别的类</p><p>所以说开发中,我们用第二种方式</p></blockquote><h5 id="用匿名内部类创建对象"><a href="#用匿名内部类创建对象" class="headerlink" title="用匿名内部类创建对象"></a>用匿名内部类创建对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匿名内部类:</span></span><br><span class="line"><span class="comment"> * 快速创建一个类的子类对象,或者一个接口的实现类对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 格式:</span></span><br><span class="line"><span class="comment"> * new 父类()&#123;</span></span><br><span class="line"><span class="comment"> * 重写方法();</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> * new 接口()&#123;</span></span><br><span class="line"><span class="comment"> * 实现方法()</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> * 使用匿名内部类 创建线程对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.第一种方式创建线程对象:继承方式</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"线程"</span>+getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="comment">//2.第二种方式创建线程对象:实现方式</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h5 id="案例：卖票"><a href="#案例：卖票" class="headerlink" title="案例：卖票"></a>案例：卖票</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 案例:电影院卖票</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 假设 上演"忍者神龟" 100张票</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 有三个柜台在卖票,同时开卖,并且卖的都是这100张票</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 三个柜台就是三个线程,他们同时执行同一个买票任务,同时操作一个共享数据100张票</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicketsDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//1.创建卖票任务对象</span></span><br><span class="line">TicketsRunnable tr = <span class="keyword">new</span> TicketsRunnable();</span><br><span class="line"><span class="comment">//2.创建 3个线程 去执行买票任务</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(tr,<span class="string">"窗口1"</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(tr,<span class="string">"窗口2"</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(tr,<span class="string">"窗口3"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketsRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//任务代码 就是卖票 100张</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;Thread.sleep(<span class="number">120</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+count);</span><br><span class="line"></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解决线程安全问题方式一:</span></span><br><span class="line"><span class="comment"> *    给代码加上同步锁</span></span><br><span class="line"><span class="comment"> *    格式:</span></span><br><span class="line"><span class="comment"> *    synchronized(锁对象)&#123;</span></span><br><span class="line"><span class="comment"> *    代码</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *    锁对象可以是任意对象</span></span><br><span class="line"><span class="comment"> *  先运行到那块的会拿到锁对象，然后执行几次后会将锁对象放回，让其他线程执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketsRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//任务代码 就是卖票 100张</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+count);</span><br><span class="line"></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解决线程安全问题方式二:</span></span><br><span class="line"><span class="comment"> *    同步方法</span></span><br><span class="line"><span class="comment"> *    格式:</span></span><br><span class="line"><span class="comment"> *    public synchronized void 方法名()&#123;</span></span><br><span class="line"><span class="comment"> *    需要运行的代码</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> *    注意:同步代码块和同步方法的原理是一样,都是具有锁对象,哪一个线程进来执行,那么该线程就持有这个锁对象</span></span><br><span class="line"><span class="comment"> *    这里同步方法使用的锁对象 叫做this对象</span></span><br><span class="line"><span class="comment"> *    如果同步方法是静态方法,那么他的锁对象是 当前类.class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketsRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//任务代码 就是卖票 100张</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">sale();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+count);</span><br><span class="line"></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解决线程安全问题方式三:</span></span><br><span class="line"><span class="comment"> * Lock接口方式</span></span><br><span class="line"><span class="comment"> * 我们实际用的是他的一个实现类:ReentrantLock</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在Lock接口中有两个方法:</span></span><br><span class="line"><span class="comment"> * lock();//获取锁</span></span><br><span class="line"><span class="comment"> * unlock();//释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketsRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">//创建一个Lock接口的实现类对象</span></span><br><span class="line">Lock l = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//任务代码 就是卖票 100张</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">l.lock();</span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"第"</span>+count);</span><br><span class="line"></span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">l.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程状态图"><a href="#线程状态图" class="headerlink" title="线程状态图"></a>线程状态图</h5><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase27.bmp" alt></p><h4 id="socket-网络编程"><a href="#socket-网络编程" class="headerlink" title="socket-网络编程"></a>socket-网络编程</h4><h5 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h5><p>网络通信协议:</p><blockquote><p>网络:由多台计算机,以及外部设备 连接起来一个系统 我们就称为网络</p><p>通信协议: 就像交通规则,规定网络上传输的数据的格式,大小,速度等等</p></blockquote><p>在我们现在的网络中都有哪些通信协议:</p><blockquote><p>TCP/IP协议</p><p>UDP协议</p><p>其他协议</p></blockquote><p>IP地址和端口号的介绍</p><blockquote><p>IP地址: 网络每一台计算的唯一标识</p><p>1Byte=8Bit</p><p>IP地址 每一个段 0-255 </p><p>端口号:</p><p>是每一个计算机中的”门”,一共有0-65535号门</p></blockquote><p>总结:我们向别的计算机发信息的时候</p><blockquote><p>确定 IP地址:为了找到那台计算机</p><p>确定 端口号: 为了确定发送到对方计算机中的哪个应用程序</p></blockquote><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase28.bmp" alt></p><h5 id="InetAddress-代表IP地址类"><a href="#InetAddress-代表IP地址类" class="headerlink" title="InetAddress:代表IP地址类"></a>InetAddress:代表IP地址类</h5><blockquote><p>public static InetAddress getLocalHost();//获取你的计算机的IP地址对象</p><p>public String getHostName();//仅获取主机名</p><p>public String getHostAddress();//仅获取IP地址</p><p>public static InetAddress getByName(“其他主机的名字或者IP”);//远程主机的IP地址对象</p></blockquote><h5 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h5><p>UDP:用户数据报协议</p><blockquote><p>特点:面向无连接,数据是不安全,不完整    有无接收端均可</p><p>优点:效率高</p><p>比如:发短信,供屏软件,QQ视频</p></blockquote><p>TCP:传输控制协议</p><blockquote><p>特点:面向有连接,数据是安全,完整性    没有接收端会直接报错</p><p>比如:打电话,上网</p><p>TCP协议建立连接 有三个步骤 我们称为”三次握手”</p></blockquote><p><img src alt></p><h5 id="UDP使用"><a href="#UDP使用" class="headerlink" title="UDP使用"></a>UDP使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用UDP进行数据通信,需要用到两个类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据的发送接收器:DatagramSocket</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据包类:DatagramPacket</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSender</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//1.创建DatagramSocket对象</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.创建DatagramPacket对象</span></span><br><span class="line"><span class="comment">//存储 发送的数据,对方的IP,端口号</span></span><br><span class="line">System.out.println(<span class="string">"请输入您要发送的数据:"</span>);</span><br><span class="line">String sendMsg = sc.nextLine();</span><br><span class="line"><span class="keyword">byte</span>[] bs = sendMsg.getBytes();</span><br><span class="line"><span class="comment">//IP地址:127.0.0.1  代表本机,本地回环地址</span></span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bs,bs.length,InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">12345</span>);</span><br><span class="line"><span class="comment">//3.发送</span></span><br><span class="line">ds.send(dp);</span><br><span class="line">System.out.println(<span class="string">"发送数据成功!!!"</span>);<span class="comment">//192.168.146.72</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line"><span class="comment">//ds.close();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//1.创建DatagramSocket对象,</span></span><br><span class="line"><span class="comment">//强调:接收端必须指定一个端口号</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.直接创建一个DatagramPacket对象</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bs, bs.length);</span><br><span class="line"><span class="comment">//3.接收</span></span><br><span class="line">System.out.println(<span class="string">"等待发送端发送数据...."</span>);</span><br><span class="line">ds.receive(dp);<span class="comment">//这个方法具有等待功能,等待发送端发送过来的数据</span></span><br><span class="line">System.out.println(<span class="string">"接收数据成功!!"</span>);</span><br><span class="line"><span class="comment">//获取发送端的地址</span></span><br><span class="line">InetAddress sendAddress = dp.getAddress();</span><br><span class="line">System.out.println(<span class="string">"发送端是:"</span>+sendAddress.getHostAddress());</span><br><span class="line"><span class="comment">//获取真正的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line"><span class="comment">//获取发送端 发来了多少字节</span></span><br><span class="line"><span class="keyword">int</span> len = dp.getLength();</span><br><span class="line"><span class="comment">//打印数据</span></span><br><span class="line">String receiveMsg = <span class="keyword">new</span> String(data, <span class="number">0</span>, len);</span><br><span class="line">System.out.println(<span class="string">"发送端说:"</span>+receiveMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line"><span class="comment">//ds.close();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TCP使用"><a href="#TCP使用" class="headerlink" title="TCP使用"></a>TCP使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">进行简单数据交互</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP客户端:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.创建Socket对象,传入服务器的IP和端口</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.通过Socket对象获取输出流,调用write方法写数据到服务器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.通过socket对象获取输入流,调用read方法读取服务器反馈的信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.关闭(Socket对象)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * TCP服务端:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.创建ServerSocket对象,传入一个端口,端口必须和客户端的一样</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.先获取哪一个客户端连接的服务器,通过accept()方法获取</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.通过Socket对象获取输入流,调用read方法读取客户端发来的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.通过socket对象获取输出流,调用write方法向客户端反馈数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5.关闭(ServerSocket,Socket)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yingpeng</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line"><span class="comment">//2.获取到 哪一个 客户端连接的我</span></span><br><span class="line">System.out.println(<span class="string">"等待客户端连接..."</span>);</span><br><span class="line">Socket client = server.accept();<span class="comment">//此方法也具有等待功能,等待某一个客户端连接</span></span><br><span class="line"><span class="comment">//打印一些和客户端有关信息</span></span><br><span class="line">String ip = client.getInetAddress().getHostAddress();</span><br><span class="line">System.out.println(<span class="string">"小样,抓到你了:"</span>+ip);</span><br><span class="line"><span class="comment">//3.获取输入流,实际上是客户端写数据时的输出流</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="comment">//4.读取数据</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(bs);</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line">System.out.println(<span class="string">"客户端说:"</span>+<span class="keyword">new</span> String(bs,<span class="number">0</span>,len));</span><br><span class="line"><span class="comment">//5.要向客户端 回写数据,告诉客户端您的信息我已经收到了</span></span><br><span class="line">OutputStream out = client.getOutputStream();</span><br><span class="line">out.write(<span class="string">"您的消息已经收到..."</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">"给客户端反馈的信息发送成功!!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭资源</span></span><br><span class="line">server.close();</span><br><span class="line">client.close();</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">// 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个构造方法干了很多事情:</span></span><br><span class="line"><span class="comment"> * a.自动去连接服务器</span></span><br><span class="line"><span class="comment"> * b.自动进行三次握手,建立连接</span></span><br><span class="line"><span class="comment"> * c.自动为连接中创建两个流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 2.从客户端对象中获取 输出流:getOutputStream()</span></span><br><span class="line"><span class="comment">//OutputStream out = client.getOutputStream();</span></span><br><span class="line"> <span class="comment">// 3.调用输出流的Write方法写数据到服务器即可</span></span><br><span class="line"><span class="comment">//out.write("How are you".getBytes());</span></span><br><span class="line">client.getOutputStream().write(<span class="string">"How are you"</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">"给服务器发送数据成功!!"</span>);</span><br><span class="line"><span class="comment">//4.读取服务器 发送过来的反馈信息</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(bs);</span><br><span class="line">System.out.println(<span class="string">"服务器响应:"</span>+<span class="keyword">new</span> String(bs,<span class="number">0</span>,len));</span><br><span class="line"> <span class="comment">//  关闭资源</span></span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase29.bmp" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上传文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象,连接服务器</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line">System.out.println(<span class="string">"连接服务器成功.."</span>);</span><br><span class="line"><span class="comment">//2.获取输出流,把数据写向服务器</span></span><br><span class="line">OutputStream out = client.getOutputStream();</span><br><span class="line"><span class="comment">//3.创建文件的输入流,读取本地的文件数据</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\yingpeng\\Desktop\\pictures\\3.png"</span>);</span><br><span class="line"><span class="comment">//4.循环,读取本地文件,写到服务器</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(bs))!=-<span class="number">1</span>)&#123;</span><br><span class="line">out.write(bs, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭输出流</span></span><br><span class="line">client.shutdownOutput();</span><br><span class="line"><span class="comment">//5.获取服务器反馈的信息</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] bs1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len1 = in.read(bs1);</span><br><span class="line">System.out.println(<span class="string">"服务器说:"</span>+<span class="keyword">new</span> String(bs1,<span class="number">0</span>,len1));</span><br><span class="line"><span class="comment">//6关闭</span></span><br><span class="line">client.close();</span><br><span class="line">out.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端服务器一直开启，通过多次执行客户端来多文件上传</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//1.创建ServerSocket对象,绑定一个端口</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.获取哪一个客户端连接的服务器</span></span><br><span class="line">System.out.println(<span class="string">"等待客户端连接..."</span>);</span><br><span class="line"><span class="keyword">final</span> Socket client = server.accept();</span><br><span class="line"><span class="comment">//开启一个线程,和clinet进行交互</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"小样:"</span>+client.getInetAddress().getHostAddress());</span><br><span class="line"><span class="comment">//3.获取输入流,读取客户端发来数据</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="comment">//4.创建文件的输出流,把数据写到文件中</span></span><br><span class="line">String picName = <span class="string">"H:\\upload\\"</span>+System.currentTimeMillis()+<span class="string">".png"</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(picName);</span><br><span class="line"><span class="comment">//5.循环 从输入流读取客户端数据, 写入到文件中</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=in.read(bs))!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(bs, <span class="number">0</span>, len);</span><br><span class="line">&#125;<span class="comment">//1小时</span></span><br><span class="line">System.out.println(<span class="string">"客户端的文件已经保存完毕,可以查看了"</span>+picName);</span><br><span class="line"><span class="comment">//6.告知客户端,文件真的真的真的上传成功</span></span><br><span class="line">OutputStream out = client.getOutputStream();</span><br><span class="line">out.write(<span class="string">"您的文件真的真的真的上传成功"</span>.getBytes());</span><br><span class="line">client.close();</span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.关闭</span></span><br><span class="line"><span class="comment">//server.close();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个bug</strong></p><p>客户端传输完文件需主动调用client.shutdownoutputstream来关闭输出流，不然服务器会不知道是执行完了还是网络延迟</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase30.bmp" alt></p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>一个应用程序已写好，后期出现的接口子类无法直接在该应用中new一个对象，该怎么办？</p><p>子类不确定，可以通过提供配置文件形式将不确定的信息存储在配置文件中即可。该程序只要之前写好读取配置文件的信息即可。</p><p>如果存储了指定的子类名，就根据具体名称找该类并进行加载和对象的创建，这些动作都是在定义软件时写好的</p><p>没有类之前就将创建对象的动作写好了，这就是动态的获取指定的类，并使用类中的功能——反射技术</p><h5 id="字节码文件对应的类"><a href="#字节码文件对应的类" class="headerlink" title="字节码文件对应的类"></a>字节码文件对应的类</h5><p>class Class    描述字节码文件的类</p><p>Field field    将字段封装成对象类型</p><p>Constructor cons    将构造函数封装成了对象类型</p><p>Method method    将类中的成员都封装成了对象</p><p>getField()</p><p>getMethod()</p><p>getConstrctor()</p><h5 id="获取字节码文件对象"><a href="#获取字节码文件对象" class="headerlink" title="获取字节码文件对象"></a>获取字节码文件对象</h5><p>要想获取字节码文件中的成员，首先要获取字节码文件对象</p><p><strong>法一</strong></p><p>通过object类中的getClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> Person();</span><br><span class="line">Class clszz1=p1.getClass();</span><br></pre></td></tr></table></figure><p>虽然通用，但必须有指定类，并对该类进行实例化才能调用getClass方法</p><p><strong>法二</strong></p><p>调用任意一个数据类型的一个静态成员class</p><p>不用实例化类，但还是需要指定的类</p><p><strong>法三</strong></p><p>使用class类中的forName方法，通过给定类名来获取相应的字节码文件对象</p><p>最常用，只需从配置文件中解析到类名即可</p><p>调用newInstanse()方法来实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"cn.itcast.domain.Person"</span>;<span class="comment">//一般从配置文件解析获取</span></span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Object obj = clazz.newInstanse();</span><br><span class="line"><span class="comment">//1.通过给定类名称加载对应字节码文件，并封装成字节码文件对象</span></span><br><span class="line"><span class="comment">//2.通过new创建Person对象</span></span><br><span class="line"><span class="comment">//3.调用构造方法初始化</span></span><br><span class="line"><span class="comment">//通常被反射的类会提供无参构造，若没有会报instantiationException</span></span><br><span class="line"><span class="comment">//如果提供了，但是权限不够会报illegalAccessException</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//1.加载Person类，并将类封装成字节码对象</span></span><br><span class="line"><span class="comment">//2.通过new创建Person对象</span></span><br><span class="line"><span class="comment">//3.调用构造方法初始化</span></span><br><span class="line"></span><br><span class="line">String className = <span class="string">"cn.itcast.domain.Person"</span>;</span><br><span class="line">Class clazz = Class.forName(className);</span><br><span class="line">Constructor cons = clazz.getConstructor(String.class,<span class="keyword">int</span>.class);<span class="comment">//获取指定的构造器</span></span><br><span class="line">Object obj = cons.newInstance(<span class="string">"wangwu"</span>,<span class="number">23</span>);<span class="comment">//有了构造器对象后，通过其来初始化对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段需要先获取到class对象</span></span><br><span class="line">Field field = clazz.getField(字段名);<span class="comment">//公共字段可以这样获取</span></span><br><span class="line">Field field = clazz.getDeclaredField(字段名);<span class="comment">//获取以声明字段多数方法都有对应的declare</span></span><br><span class="line">field.set(obj,<span class="number">30</span>)<span class="comment">//需要获取到字段和字节码对象，只可修改公共字段</span></span><br><span class="line">field.setAccessible();<span class="comment">//暴力访问，去除该字段访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法，需要先获取到class对象</span></span><br><span class="line">Method method = clazz.getMethod(方法名,<span class="keyword">null</span>);<span class="comment">//第二个表示无参</span></span><br><span class="line">method.invoke(<span class="keyword">null</span>,<span class="keyword">null</span>);<span class="comment">//第一个为字节码对象，后面表示无参</span></span><br><span class="line"></span><br><span class="line">Method method = clazz.getMethod(方法名,String.class,<span class="keyword">int</span>.class);<span class="comment">//第二个表示无参</span></span><br><span class="line">method.invoke(obj,<span class="string">"wangwu"</span>,<span class="number">33</span>);</span><br></pre></td></tr></table></figure><h3 id="java设计思想"><a href="#java设计思想" class="headerlink" title="java设计思想"></a>java设计思想</h3><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>前人把解决问题的方案总结出一个套路</p><h5 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h5><p>静态代理设计模式</p><p>设计个接口，限制代理需要做哪些事，用接口来接收不同代理</p><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase11.JPG" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.demo10_代理设计模式;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 代理类:经销商</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPerson</span> <span class="keyword">implements</span> <span class="title">ComputerInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ComputerInterface lianxiang;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyCompany</span><span class="params">(ComputerInterface lianxiang)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lianxiang = lianxiang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">buyComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"鼠标,键盘,电脑包,u盘,操作系统,3000$ + "</span>+lianxiang.buyComputer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"需要运费1000块"</span>);</span><br><span class="line">lianxiang.repair();</span><br><span class="line">System.out.println(<span class="string">"再给500块保管费"</span>);</span><br><span class="line">System.out.println(<span class="string">"再给100块运费"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理设计模式</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>向上抽取原则</li></ul><p><img src="/.com//java%E8%BF%9B%E9%98%B6/javase2.JPG" alt></p><h2 id="Java数据结构和算法"><a href="#Java数据结构和算法" class="headerlink" title="Java数据结构和算法"></a>Java数据结构和算法</h2><p>先看几个经典算法面试题</p><ul><li>用最快速度判断str2是否为str1子串    暴力破解（逐字匹配）/kmp算法《部分匹配表》</li><li>汉诺塔问题    递归，分治算法</li><li>八皇后问题    回溯算法</li><li>马踏棋盘    图的深度优化算法（DFS），贪心算法（优化）</li></ul><p>算法是程序的灵魂，大厂对算法要求越来越高</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数据类型和运算符&quot;&gt;&lt;a href=&quot;#数据类型和运算符&quot; class=&quot;headerlink&quot; title=&quot;数据类型和运算符&quot;&gt;&lt;/a&gt;数据类型和运算符&lt;/h4&gt;&lt;h5 id=&quot;基本数据类型（四类八种）&quot;&gt;&lt;a href=&quot;#基本数据类型（四类八种）&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型（四类八种）&quot;&gt;&lt;/a&gt;基本数据类型（四类八种）&lt;/h5&gt;&lt;p&gt;byte(1)  boolean(1)  short(2)  char(2)unicode字符集  int()4  float(4)  long(8)  double(8)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;限制double小数点数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DecimalFormat df = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DecimalFormat(&lt;span class=&quot;string&quot;&gt;&quot;0.00&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df.format(total);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;string与基本类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包装类的parse和tostring方法&lt;/p&gt;
&lt;h5 id=&quot;引用数据类型&quot;&gt;&lt;a href=&quot;#引用数据类型&quot; class=&quot;headerlink&quot; title=&quot;引用数据类型&quot;&gt;&lt;/a&gt;引用数据类型&lt;/h5&gt;&lt;p&gt;string，数组，集合ArrayList，Scanner，Random，自定义类型&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>xmind使用</title>
    <link href="http://yoursite.com/2019/08/13/xmind%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/08/13/xmind使用/</id>
    <published>2019-08-13T12:43:43.000Z</published>
    <updated>2020-02-18T01:58:42.727Z</updated>
    
    <content type="html"><![CDATA[<h4 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h4><p>使用的较简单的免费版，本意只是为了简单的做一些总结<br>之所以选择xmind:zen而不是xmind 8是因为感觉xmind:zen相对来说更小，启动速度更快，并且感觉更加代表了未来的发展方向，xmind 8有些笨重了<br><a href="https://www.xmind.cn" target="_blank" rel="noopener">官网</a></p><h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><p><strong>编辑主题文字：</strong>选中主题“双击鼠标”或者按【空格键<strong>】</strong></p><p><strong>添加同级主题：</strong>快捷键<strong>【</strong>enter/return<strong>】</strong></p><p><strong>添加子主题：</strong>可快捷键【tab】</p><p><strong>删除：</strong>选中主题按【delete/backspace】</p><a id="more"></a><p><strong>添加外框：</strong>选中要框选的主题按工具栏的【外框】进行添加</p><p><strong>添加概要：</strong>选中主题按工具栏的【概要】进行添加</p><p><strong>添加笔记：</strong> ctrl+shift+n(note)</p><p><strong>撤销:</strong> Ctrl+z</p><p><strong>恢复:</strong> Ctrl+y</p><p>emmm,帮助-&gt;快捷键助手，基本列出了常用快捷键，还可以自定义快捷键</p><p>自己直接上手也很easy，就不一一总结了</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>整体使用还是比较符合我的预期的，启动快，简约，操作方便，虽然免费版导出格式受限，并且还有水印，但这个对我基本没什么影响</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;软件下载&quot;&gt;&lt;a href=&quot;#软件下载&quot; class=&quot;headerlink&quot; title=&quot;软件下载&quot;&gt;&lt;/a&gt;软件下载&lt;/h4&gt;&lt;p&gt;使用的较简单的免费版，本意只是为了简单的做一些总结&lt;br&gt;之所以选择xmind:zen而不是xmind 8是因为感觉xmind:zen相对来说更小，启动速度更快，并且感觉更加代表了未来的发展方向，xmind 8有些笨重了&lt;br&gt;&lt;a href=&quot;https://www.xmind.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用技巧&quot;&gt;&lt;a href=&quot;#使用技巧&quot; class=&quot;headerlink&quot; title=&quot;使用技巧&quot;&gt;&lt;/a&gt;使用技巧&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;编辑主题文字：&lt;/strong&gt;选中主题“双击鼠标”或者按【空格键&lt;strong&gt;】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加同级主题：&lt;/strong&gt;快捷键&lt;strong&gt;【&lt;/strong&gt;enter/return&lt;strong&gt;】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加子主题：&lt;/strong&gt;可快捷键【tab】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除：&lt;/strong&gt;选中主题按【delete/backspace】&lt;/p&gt;
    
    </summary>
    
    
      <category term="思维导图" scheme="http://yoursite.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
      <category term="软件使用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>看过的一些编程书及评价</title>
    <link href="http://yoursite.com/2019/07/28/%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8F%8A%E8%AF%84%E4%BB%B7/"/>
    <id>http://yoursite.com/2019/07/28/看过的一些编程书及评价/</id>
    <published>2019-07-28T14:10:10.000Z</published>
    <updated>2020-01-30T03:30:39.513Z</updated>
    
    <content type="html"><![CDATA[<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><hr><h4 id="汇编语言基础教程-James-T-Streib"><a href="#汇编语言基础教程-James-T-Streib" class="headerlink" title="汇编语言基础教程         James T.Streib"></a>汇编语言基础教程         James T.Streib</h4><p>整体讲解不够深入，用了很多高级汇编指令，与最初想了解底层如何实现的初衷相违背，并且很多话说的不清楚，很绕。整体学到了一些东西，算是入门了，但整体感觉不好，不推荐。</p><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><hr><h4 id="跟阿铭学linux（第三版）"><a href="#跟阿铭学linux（第三版）" class="headerlink" title="跟阿铭学linux（第三版）"></a>跟阿铭学linux（第三版）</h4><p>学linux最初的各种命令是看的网课。那几个明明运用及理解都不难的命令，反反复复讲了好长时间，白白浪费了不少时间。我感觉看书来学习linux的各种命令更高效，这本书整体节奏不错，难度感觉略高一点，但认着看，感觉看的很舒服，收货很多。勉强算适合小白吧，我感觉还是有一些对新手不怎么友好的点。</p><p>（这本书学习笔记参见）</p><a id="more"></a><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;汇编&quot;&gt;&lt;a href=&quot;#汇编&quot; class=&quot;headerlink&quot; title=&quot;汇编&quot;&gt;&lt;/a&gt;汇编&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;汇编语言基础教程-James-T-Streib&quot;&gt;&lt;a href=&quot;#汇编语言基础教程-James-T-Streib&quot; class=&quot;headerlink&quot; title=&quot;汇编语言基础教程         James T.Streib&quot;&gt;&lt;/a&gt;汇编语言基础教程         James T.Streib&lt;/h4&gt;&lt;p&gt;整体讲解不够深入，用了很多高级汇编指令，与最初想了解底层如何实现的初衷相违背，并且很多话说的不清楚，很绕。整体学到了一些东西，算是入门了，但整体感觉不好，不推荐。&lt;/p&gt;
&lt;h3 id=&quot;运维&quot;&gt;&lt;a href=&quot;#运维&quot; class=&quot;headerlink&quot; title=&quot;运维&quot;&gt;&lt;/a&gt;运维&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;跟阿铭学linux（第三版）&quot;&gt;&lt;a href=&quot;#跟阿铭学linux（第三版）&quot; class=&quot;headerlink&quot; title=&quot;跟阿铭学linux（第三版）&quot;&gt;&lt;/a&gt;跟阿铭学linux（第三版）&lt;/h4&gt;&lt;p&gt;学linux最初的各种命令是看的网课。那几个明明运用及理解都不难的命令，反反复复讲了好长时间，白白浪费了不少时间。我感觉看书来学习linux的各种命令更高效，这本书整体节奏不错，难度感觉略高一点，但认着看，感觉看的很舒服，收货很多。勉强算适合小白吧，我感觉还是有一些对新手不怎么友好的点。&lt;/p&gt;
&lt;p&gt;（这本书学习笔记参见）&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
