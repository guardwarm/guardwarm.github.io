<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2019%2F09%2F04%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git版本控制系统 记录版本信息（记录每一次的修改） 方便团队相互之间协作，共同开发 常用版本控制系统 svn/cvs：集中式版本控制系统 git：分布式版本控制系统 Git安装这个网上很常见，自行参考网上教程 使用GitHub目的：托管项目代码工作区 -&gt; 暂存区 -&gt; 历史区 1.Git的全局配置123456第一次安装完成git后，要在全局环境下配置基本信息：我是谁？$ git config -l 查看配置信息$ git config --global -l 查看全局配置信息配置全局信息，用户名和邮箱$ git config --global user.name 'xxx'$ git config --global user.email 'xxx@xx.xx' 2.创建仓库完成版本控制1234567891011121314创建本地git仓库$ git init会生成一个隐藏文件夹“.git”（这个文件夹很重要，暂存区和历史区以及一些其他数据都在里面存着）在本地编写完成代码后（在工作区），把一些文件提交到暂存区$ git add xxx 把某一个文件或者文件夹提交到暂存区$ git add . || git add A 把当前仓库中所有最新修改的文件都提交到暂存区$ git status 查看当前文件的状态（红色代表工作区，绿色代表暂存区，看不见东西代表所有东西都已提交到历史区）把暂存区内容提交到历史区$ git commit -m'描述信息'查看历史版本信息（历史记录）$ git log$ git reflog 包含回滚的信息 GitHub一个网站（开源的代码管理平台），用户注册号，可以在自己账户下创建仓库，用来管理项目的源代码（源代码基于git传到仓库中） 我们所熟知的插件，类库，框架等都在这个平台上有托管，我们可以下载观看和研究源码等 settings用户设置 profile 修改自己的基本信息 account 作用修改用户名 security 可以改自己的密码 emails 私有仓库作为内部团队协作管理的项目 …… new repository -&gt; 填写信息，公私有都免费 -&gt; create repository public 公共开源 private 私有，作为内部团队项目 settings -&gt; 删除仓库 ​ -&gt; collaborators 设置协助开发人员，需对方同意邀请 code可以查看历史版本和分支信息 3.把本地仓库信息提交到远程仓库123456789101112131415161718192021查看本地仓库和哪些远程仓库保持连接$ git remote -v让本地仓库和远程仓库创建一个连接 origin是随便起的一个名字，但一般都用这个$ git remote add origin [仓库地址]解除关联信息$ git remote rm origin提交之前最好先拉取$ git pull origin master将本地代码提交到远程仓库（第一次需要输入用户名和密码）$ git push origin master将远程仓库代码拉取到本地$ git clone [远程仓库git地址] [别名，默认为仓库名，也可以起一个作为拉取后的文件夹名]/* *真实项目开发流程： * 1.组长或者负责人先创建中央仓库 * 2.小组成员基于$ git clone 把远程仓库及默认的内容克隆到本地（解决了三个事情：初始化一个 本地仓库“git init”，和对应的远程仓库也保持了关联“git remote add”，把远程仓库默认内人拉取到本地 “git pull” * 3.每个组员写自己的程序后，基于“git add/git commit”把自己修改的内容存放到历史区，然后通过 “git pull/git push”把本地信息和远程仓库信息保持同步即可（可能涉及冲突处理） */ NPMnode package manger:NODE模块管理工具，根据NPM我们可快速安装、卸载所需要的资源文件 区NODE官网：下载NODE重启支持版，安装NODE后，NPM也跟着安装了 基于npm是从npmjs.com平台下下载安装 123//在终端中检测安装是否成功，出现版本号即成功了node -vnpm -v 12345678910111213$ npm install xxx 把模块安装在当前项目中（node_modules）$ npm install xxx -g 把模块安装在全局环境中$ npm i xxx@1.0.0 安装指定版本号的模块$ npm view xx version &gt; xxx.version.json 查看某个模块的版本信息（输出到指定json文件中）$ npm init -y 初始化当前项目的配置依赖清单$ npm i xxx -save 把模块保存在清单生产依赖中$ npm i xxx --save-dev 把模块保存在清单开发依赖中$ npm install 跑环境，按照清单安装所需模块$ npm root -g 查看全局安装模块的目录$ npm -uninstall xxx$ npm -uninstall xxx -g 卸载安装过的模块]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java]]></title>
    <url>%2F2019%2F08%2F16%2Fjava%2F</url>
    <content type="text"><![CDATA[[TOC] java基础入门及环境搭建下载JDK进入Oracle官网，下载相应版本，最近下载好像都得注册个账号 下完按到所需目录，一般默认，一直下一步即可，完了设置一下环境变量 此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;编辑path，把bin目录路径加入 classpath也可以设置 在cmd中，输入java -version检查是否安装成功 javac 文件路径（编译，生成。class文件） java 文件名，不加后缀，运行 IDE选择 目前比较流行的是eclipse和IDEA，我更喜欢IDEA，熟练了快捷键和各种模板之后会用得很舒服 语言特点通过编译成统一的字节码，不同平台下载对应JVM来实现跨平台 完全面向对象，简单，高性能，分布式，多线程，健壮 JDK（用于开发）-&gt;JRE（运行环境）-&gt;JVM(依次包含) java SE 标准版，定位于个人计算机用户 java EE 企业版，定位于服务器端领域 java ME 微型版，定位于消费电子产品的应用 越高级语言越容易入门，但要精通还需沉下心来 数据类型和运算符注释单行，多行，文档注释 标识符的命名规则虽然不同语言之间会有细微区别，但为了便于编写，感觉大多数语言都推荐采用比较大众的规范 不可以是java关键字，并且大小写敏感 类名 大驼峰命名法 方法和变量 小驼峰命名法 常量 大写 数据类型向上隐士转换，向下需要显示加括号强转 基本数据类型（四类八种）byte(1) boolean(1) short(2) char(2)unicode字符集 int()4 float(4) long(8) double(8) 引用数据类型string，数组，集合ArrayList，Scanner，Random，自定义类型 包的声明和访问包的本质就是文件夹，在包名中以.来区分上下级文件关系 作用：分类管理文件 包的声明：package 包名 指示某个类在哪个包下 包的声明必须和类的实际位置保持一致 包的导入：用来告诉编译器我们要用的类在哪个包下 import 包名.类名 不导包时需采用全限定类名：包名.类名（所有用到类名的地方都需这样写） 四种访问权限修饰符 面向对象面向对象是一种编程思想，是相当于面向过程的 面向过程：遇到问题，亲力亲为一步一步解决 核心理念：谁的功能谁负责 面向对象：遇到一个问题，找具有解决这个问题能力的对象，调用它的方法 面向对象三大特性：封装（安全性），继承（拓展性），多态（） 类的格式 1234567public class 类名&#123; //构造方法 //成员类名 //成员方法&#125;//一个标准的类 封装：隐藏细节，对外暴露公共防蚊1方式 构造：无参必须有，全参最好有//类名作为方法参数或返回值时需要传入或返回的应该是该类的对象 继承继承是两个类之间的关系，子类继承父类 this关键字区分局部变量和成员变量同名的情况 this的本质：实际上是个对象 谁调用的方法，this指的就是谁 匿名对象：（可用可不用） 没有名字的对象 只创建对象，但不用变量接收 在一些用来传参后续不调用时使用 特点：匿名对象也是一个对象，具有对象所有功能 ​ 每次调用都是一个新的对象，所一每个对象只能使用一次 123this.xxx //调用该对象属性this.aaa() //调用该对象方法//高级使用：用来调用本类的其他构造 通过输入不同参数来调用不同构造 super关键字区分子类和父类成员同名的情况，但默认优先调用子类 1234super.xxx //调用父类属性super.aaa() //调用父类方法super(); //调用父类构造方法，通过输入不同参数来调用不同构造，默认调用无参构造//无论调用子类那个构造，都会先调用父类构造，符合单一职责原则，一个类只需负责给本类变量初始化 继承12345678910111213public class 子类 extends 父类&#123; &#125;//继承必须合理 人是人他妈生的，妖是妖他妈生的//继承中的成员抽取了子类中的共性内容//子类会自动继承父类中所有成员，但private不可访问//创建子类对象时会先创建其父类对象//继承后成员变量不同时，没有任何问题，相同时优先访问子类//继承后成员方法不同时，没有任何问题，相同时(子类重写了父类方法时)优先访问子类，但可以通过super.方法名访问//只能单继承，但可以多层继承（直接父类唯一，但可以有多个间接父类）//多继承的话调用方法时会产生不确定性，同名父类成员不知道该掉哪个 继承大大提高代码重用性 方法的重载：在同一个类中，方法名相同，但参数列表不同（参数类型，参数顺序，参数个数任一不同） 方法的重写（覆盖，覆写override）：子类中出现了和父类一模一样的方法 重写原因：当子类发现继承过来的方法不适用时需要重写自己的方法 重写要求：该方法子类权限需大于等于父类权限（一般都是相同权限） public protected default private private方法不可重写 方法名，参数列表，返回值类型必须一模一样 多态一个对象的多种状态 java中的前提：必须有字符类关系，必须有方法的重写 抽象类和接口抽象类：以前一个类中包含抽象方法即为抽象类，现在只要由关键字abstract修饰即为抽象类 抽象类不可以实例化，天生就是作为父类的 抽象方法：只有声明而没有实现 向上抽取时会出现一种特殊情况，方法功能声明相同，但方法主体不同，这时只抽取方法声明，所得即为抽象方法 必须用关键字abstract修饰 不能调用，为了强制子类去重写 类名作为返回值或参数时，传递和返回的应是该类对象 抽象类作为返回值或参数时，传递和返回的应是该类的子类的对象 链式编程：当返回值为调用这个方法的对象时，便可以链式的调用下去 小练习 12//案例：武警开坦克打飞机//名词提取：武警 坦克 飞机 再分析每个类对应属性和方法 接口类：一堆具有共同属性和成员方法的对象的集合 接口：方法的集合，只能定义抽象方法 天生作为父接口 12345678910111213//class 类//abstract class 抽象类//interface 接口//enum 枚举public interface 接口名&#123; //不能定义普通成员变量，只能定义抽象方法 //可以定义常量 public static final 变量名 即使不加修饰，编译器也会自动添加&#125;//开发中常用模式：一个类继承一个抽象类，实现多个接口public class A extends AbstractClass B implements 接口A，接口B&#123; &#125; 类与类之间是单继承，一个子类只能有一个直接父类 接口与接口之间支持多继承也支持多层继承 类与接口之间不叫继承（extends）而是实现（implements） 可以多实现 比较抽象类和接口 相同点：都不能实例化，都是作为父类/父接口，子类继承/实现都不行重写抽象方法 不同点：抽象类中不全是抽象方法，可以有普通成员变量，修饰的关键字不同 弥补了java的单继承 思想上的区别：抽象类中必须定义整个体系的共性内容 ​ 接口中定义整个继承体系之外额外的扩展功能（谁想有这些功能就来是实现下这个接口） 优先使用接口 需要定义子类行为又要为子类提供共性功能时才用抽象类 多态父类类型 变量名 = new 子类类型(); 父类类型变量指向了子类对象 注意事项：多态使用变量是，编译和运行都看父类 调用成员方法，编译看父类，运行看子类 多态的弊端：只能调用子父类共有的方法，不能调用子类特有的（因为编译时看父类，特有的编译过不了） 好处：提高灵活性，父类可以接收任何一个子类对象 传哪个子类运行哪个子类的方法 1234//弊端解决方案//向下转型：强制类型转换 double转int，父类转之类 把向下和强转关联记忆吧//向上转型:隐式类型转换 子类转父类（多态） 向下转换会面临不知道该转成哪个子类的困扰，易出现类型转换异常//向下转型弊端解决：instanceof 格式：boolean b = 父类对象名 instanceof 子类对象名 内部类 成员内部类：定义类中方法外 在其他类中创建对象 外部类名.内部类名 对象名 = new 外部类名().new 内部类(); 局部内部类：定义方法中 在其他类中无法使用，只能局部使用 匿名内部类一种特殊的语法，用于快速创建抽象类的对象 12345678910111213141516//创建抽闲类对象//创建子类继承抽象类 重写抽象方法 new子类对象//用匿名内部类可以一步完成new 抽象类名()&#123; //重写方法&#125;;new 抽象类名()&#123; //重写方法&#125;.调用属性/方法;//最常用抽象类名 对象名 = new 抽象类名()&#123; //重写方法&#125;;//只重写抽象方法而不写独有的方法，因为没有名字，即使写了也无法向下强转为子类调用 静态代码块12345678public class 类名&#123; static&#123; //当我们使用到这个类的时候（实例化或使用静态成员等等），JVM会自动执行静态代码块中的内容 //仅在第一次使用到这个类的时候会执行一次，第二次就不会了 //优先级高于main和构造方法 //用于初始化类，比如MySQL加载驱动等 &#125;&#125; 访问修饰符static 静态的用于修饰类中的成员 被static修饰的成员访问时无需实例化再调用，可以直接通过类名访问（推荐） 当一个对象不独属于某个成员，而是所有成员共享事应加static修饰 静态没有多态性，静态属于类，而多态属于对象 多态调用静态成员时没有多态性（访问的是父类而非子类） 静态优先于对象存在 final 最终的可以修饰类，成员变量，成员方法，局部变量（基本类型，引用类型） 通过最终来理解这些性质 final修饰类——最终类：不能被继承，但可以有父类（太监类） final修饰成员变量：该变量必需在被实例化前赋值，且只能赋值一次 final修饰成员方法：该方法不能被子类重写 final修饰的基本类型局部变量只能赋值一次 final修饰的引用类型局部变量只能赋值一次，但其所指向的对象的内容可以随意改变 object类是类层次的根类，所有类都直接或间接继承 12345//两个重要方法boolean equals(Object obj); //obj中定义的是根据地址计算出的hashcode //string类中重写了，改为比较字符串内容,我们自己定义类也一般会重写String toString(Object obj) //返回该对象的字符串表示 默认包名.类名@hashcode(地址) //system.out 打印对象会默认调用tostring 我们一般会重写这个方法 异常java代码编译或执行过程中出现的一些问题 异常的继承体系 Throwable：可以抛出去的东西 Exception：异常（普通问题） 编译时异常：Exception及其子类（RuntimeException除外） 运行时异常：RuntimeException及其子类 Errow：错误（严重的问题） 异常处理方式异常处理：异常处理指的是一种可能性，只有当出现了异常时才会执行异常处理代码，否则正常执行 异常处理方式 不处理 throw：动词，真正的抛出一个异常 throws：形容词，用来形容一个方法，表示该方法可能抛出的异常 要求调用者去处理它 public void 方法名（参数）throws 可能抛出的异常类型{ } 捕获处理 try(){ ​ 可能出现异常的代码 }catch(对应类型的异常对象){ ​ //catch可以有多个 ​ //处理异常 }finally{ ​ //写上必须要执行的代码，比如释放资源等 } 一次捕获多次处理: 一个try 多个catch (多个catch中 必须是异常子类在前,父类在后) 多次捕获多次处理: 多个try,每个try多应一个catch 一次捕获一次处理(最常用的):一个try一个catch(catch中异常类必须所有可能出现异常的父类) 注意事项：子类异常必须从属于父类异常 技巧: 如何区分一个异常类 到底是编译时还是运行时异常 1.编译时异常 在编译的时候会报错的 (需要我们去处理) 2.运行时异常 在编译的时候不会报错 只要定义一个方法,在方法中抛出一个异常对象,如果编译报错那么就是编译时异常 如果编译成功,那么就是运行时异常 请你说出十个运行时异常: 1.RuntimeException 2.ClassCastException:类型转换异常 (向下转型的时候) 3.ArrayIndexOutOfBoundsException:数组下标越界 4.StringIndexOutOfBoundsException:字符串下标越界 5.NullPointerException:空指针异常 自定义异常类： 1.创建一个类,这个类必须用Exception结尾 2.必须继承 Exception 或者 RumtimeException 3.自定义的异常 至少有两个构造 a.空参数构造 b.带有String类型参数的构造 12345678910package com.itheima.demo09_自定义异常的练习;public class NoSuchAgeException extends Exception&#123; //无参构造 public NoSuchAgeException()&#123;&#125; //带有String的构造 内部调用super(s)，将传入的string交给父类 public NoSuchAgeException(String s)&#123; super(s); &#125;&#125; Date类Date类:日期类 多数方法都过时了，不常用 标准时间1970年1月1日0时0分0秒 构造: public Date();//代表当前系统时间的Date对象 public Date(long time);//代表距离标准时间 time毫秒值的Date对象 成员方法: public String toString();//Date 重写Object类的toString方法 public long getTime();//获取当前Date对象的毫米值 与public Date(long time)互逆 DateFormat:日期格式化类,是一个抽象类 具体的子类:SimpleDateFormat 构造: public SimpleDateFormat(String pattern);//以指定的模式创建格式化对象 123&gt; SimpleDateFormat sdf = new SimpleDateFormat(yyyy年MM月dd日HH时mm分ss秒);&gt; &gt; 成员方法: public String format(Date d);//把date对象按照指定的模式 转成字符串 public Date parse(String s);//把字符串转成Date对象,如果字符串有问题,就会抛出ParseException Calendar:日历类获取Calendar对象 public static Calendar getInstance();//返回的是抽象类Calendar的某一个子类 成员方法: public int get(int field);//获取指定字段的值 public void add(int field,int amount);//给指定的字段增加值 public void set(int field,int value);//修改指定字段的值 public Date getTime();//把Calendar对象转成Date 对象 getTime().getTime() 相当于调用date的方法来获取毫秒值 System:系统类该类无法思力华，被私有化了 public static void exit(0);//结束JVM public static void gc();//通知垃圾回收器过来收垃圾，只是通知，不一定会来 public static getProperty(String key);//根据键 获取值 public static long currentTimeMillis();//获取当前系统的毫秒值 Math:数学类都是些静态方法，直接调用就好 求最大值 max 求最小值 min 求绝对值 abs 求随机数 random 返回一个[0,1)之间的数，通过简单计算得到自己想要的范围 求四舍五入 ceil(向上取整) floor(向下取整) pow(求次幂) 基类数据类型包装类八种基本类对应的包装类型 byte boolean short char int float double long Byte Boolean Short Character Interger Float Double Long 作用 在集合中只允许存储包装类型，不可以存基本类型 实现字符串的转换 public static int parseInt(String s); 将字符串转为int，其它基本类型类比即可 自动拆箱装箱 装箱：基本类型-&gt;包装类型 拆箱：包装类型-&gt;基本类型 正则表达式所有编程语言都支持，用来匹配字符串的 boolean b = 普通字符串 匹配 正则表达式 public boolean matches(String regex); boolean b = “普通字符串”.matches(“正则表达式”); public String[] split(String regex); 切割字符串,返回切割后的字符串数组 书写技巧：一位一位的匹配 通配符 正则表达式中 “.”代表任意字符 在DOS中 “*”代表任意内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * QQ号码需要满足的规则: * 1.必须是0-9的数字 * 2.开头必须1-9中的一个数字 * 3.位数必须 5-12位 */public static void qq()&#123; String qq = "12355a63564"; boolean b = qq.matches("[1-9][0-9]&#123;4,11&#125;"); System.out.println(b);&#125;/* * 举例：校验手机号码 * 1：要求为11位0-9的数字 * 2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。 */public static void phone()&#123; String phone = "18600363521"; boolean b = phone.matches("1[34578][0-9]&#123;9&#125;"); System.out.println(b);&#125;/* * * 案例:切割电话 */public static void split01()&#123; String phone = "2345--4564----6546-----1345"; //切割phone 把号码切割出来 //+号 在正则表达式中有特殊意义,表示连续的多个相同的字符 String[] phones = phone.split("-+"); for (int i = 0; i &lt; phones.length; i++) &#123; System.out.println(phones[i]); &#125;&#125;/* * 案例:切割ip */public static void split02()&#123; String ip = "192...168....123......110"; //"."号 在正则表达式中 表示 任意字符 //转译字符 //\t //\n String[] ips = ip.split("\\.+");//在正则表达式中 "\\" 代表一个"\" System.out.println(ips.length); for (int i = 0; i &lt; ips.length; i++) &#123; System.out.println(ips[i]); &#125;&#125; String中的方法（4532）判断方法1234boolean equals(String str);boolean equalsIngoreCase(String str);boolean startsWith(String str);boolean endsWith(String str); 获取方法12345int length(String str);char charAt(int index);String substring(int startIndex);String substring(int startIndex,int endIndex); //左闭右开int indexof(String subStr); //少用 转换方法123String toLowerCase()；String toUpperCase()；char[] toCharArray()； 其它方法12String trim(); //去掉两端空格String[] split(String str); //一某一个字符串来分割字符串 流_读写文件（输入输出是相对程序而言的） 文件路径 绝对路径：以盘符开头 相对路径：相对当前目录而言 输出流：数据从java程序到文件中 123456//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)write(int ch); //可以写ascll码值write(char[] ch);write(char[] ch,int startIndex,int len);write(String s);write(String s,int startIndex,int len); 输入流：数据从文件到java程序 123//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)int read(); //读取一个字符int read(char[] chs); //读取一个字符数组，返回值表示读取到的字符个数 集合集合框架: List–&gt; ArrayList,LinkedList,Vector Set –&gt; HashSet,LinkedHashSet,TreeSet Collection接口中的公共方法:子类不是都有下标，所有Collection无下标，故而无法进行改查操作 增: add(E e); 删: remove(Object obj); 改: 无 查: 无 其他: int size();//长度 boolean contains(Object obj); void clear();//清空 Object[] toArray(); //集合转换成数组 在ArrayList中 有一个方法 addAll(Collection c);//把集合c里面的每一个元素添加到ArrayList中 迭代器在Collection根解扣子中定义一种公共的遍历方式:迭代器遍历 Iterator&lt;泛型和集合的一样&gt; it = 集合对象.iterator(); 底层类似链表 迭代器对象 有两个方法: hasNext();//判断有没有下一个 next();//取出下一个 以上两个方法必须配合使用 补充 Concurrent(并发)Modification(修改)Exception java规定,如果一个集合使用迭代器遍历,那么在遍历的过程中 不允许修改集合的长度(增加或者删除) 123456789101112131415//1.创建一个集合对象,使用多态Collection&lt;String&gt; names = new ArrayList&lt;String&gt;();//2.添加names.add("郭德纲");names.add("刘德华");names.add("柳岩");names.add("范伟");names.add("范伟1");//3.获取names集合的迭代器对象Iterator&lt;String&gt; it = names.iterator();//4.标准代码while(it.hasNext())&#123;//反复判断有没有下一个元素 String s = it.next();//如果有取出下一个元素 System.out.println(s);&#125; 增强for循环增强for循环比普通的for循环增强在哪? 增强在语法上更加简单 格式: for(数据类型 变量名:数组/集合){ syso(变量名); } 注意: 当你使用增强for循环遍历集合的时候 底层采用的是迭代器 总结: 当你使用增强for循环遍历集合的时候,不能修改集合的长度 泛型泛泛的类型,不确定的类型，类型参数化 格式: ,&lt;K,V&gt; 好处 避免了强制类型转换 将运行时的ClassCsatException变为了编译错误 泛型通配符 ?:代表任意类型 &lt;? extends Animal&gt; : 表示一种泛型,这种泛型必须是Animal 或者Animal的子类 &lt;? super Animal&gt;:表示一种泛型,这种泛型必须是Animal 或者Animal的父类 泛型可以用在类上，方法上，接口上 泛型用在类上: 泛型类 格式:public class 类名 当你创建该类的对象的时候,就可以确定 泛型用在方法上:泛型方法 格式:public 返回值类型 方法名(T t); 当你调用方法,传递参数的时候确定 泛型用在接口上:泛型接口 格式:public interface 接口名 1.实现类实现接口的时候,直接确定 2.实现类实现接口的时候,不确定泛型,而是直接把泛型继承下来,当这个实现类创建对象的时候确定 斗地主案例案例分析 代码实现12 反射定义一个应用程序已写好，后期出现的接口子类无法直接在该应用中new一个对象，该怎么办？ 子类不确定，可以通过提供配置文件形式将不确定的信息存储在配置文件中即可。该程序只要之前写好读取配置文件的信息即可。 如果存储了指定的子类名，就根据具体名称找该类并进行加载和对象的创建，这些动作都是在定义软件时写好的 没有类之前就将创建对象的动作写好了，这就是动态的获取指定的类，并使用类中的功能——反射技术 字节码文件对应的类class Class 描述字节码文件的类 Field field 将字段封装成对象类型 Constructor cons 将构造函数封装成了对象类型 Method method 将类中的成员都封装成了对象 getField() getMethod() getConstrctor() 获取字节码文件对象要想获取字节码文件中的成员，首先要获取字节码文件对象 法一 通过object类中的getClass方法 12Person p1=new Person();Class clszz1=p1.getClass(); 虽然通用，但必须有指定类，并对该类进行实例化才能调用getClass方法 法二 调用任意一个数据类型的一个静态成员class 不用实例化类，但还是需要指定的类 法三 使用class类中的forName方法，通过给定类名来获取相应的字节码文件对象 最常用，只需从配置文件中解析到类名即可 调用newInstanse()方法来实例化 123456789101112131415161718192021222324252627282930String className = "cn.itcast.domain.Person";//一般从配置文件解析获取Class clazz = Class.forName(className);Object obj = clazz.newInstanse();//1.通过给定类名称加载对应字节码文件，并封装成字节码文件对象//2.通过new创建Person对象//3.调用构造方法初始化//通常被反射的类会提供无参构造，若没有会报instantiationException//如果提供了，但是权限不够会报illegalAccessExceptionPerson p = new Person();//1.加载Person类，并将类封装成字节码对象//2.通过new创建Person对象//3.调用构造方法初始化String className = "cn.itcast.domain.Person";Class clazz = Class.forName(className);Constructor cons = clazz.getConstructor(String.class,int.class);//获取指定的构造器Object obj = cons.newInstance("wangwu",23);//有了构造器对象后，通过其来初始化对象//获取字段 需要先获取到class对象Field field = clazz.getField(字段名); //公共字段可以这样获取Field field = clazz.getDeclaredField(字段名); //获取以声明字段 多数方法都有对应的declarefield.set(obj,30) //需要获取到字段和字节码对象，只可修改公共字段field.setAccessible(); //暴力访问，去除该字段访问权限//获取方法，需要先获取到class对象Method method = clazz.getMethod(方法名,null); //第二个表示无参method.invoke(null,null); //第一个为字节码对象，后面表示无参Method method = clazz.getMethod(方法名,String.class,int.class); //第二个表示无参method.invoke(obj,"wangwu",33); java设计思想设计模式前人把解决问题的方案总结出一个套路 代理设计模式静态代理设计模式 设计个接口，限制代理需要做哪些事，用接口来接收不同代理 1234567891011121314151617181920212223242526package com.itheima.demo10_代理设计模式;/* * 代理类:经销商 */public class ProxyPerson implements ComputerInterface&#123; private ComputerInterface lianxiang; public ProxyCompany(ComputerInterface lianxiang) &#123; this.lianxiang = lianxiang; &#125; @Override public String buyComputer() &#123; // TODO Auto-generated method stub return "鼠标,键盘,电脑包,u盘,操作系统,3000$ + "+lianxiang.buyComputer(); &#125; @Override public void repair() &#123; // TODO Auto-generated method stub System.out.println("需要运费1000块"); lianxiang.repair(); System.out.println("再给500块保管费"); System.out.println("再给100块运费"); &#125; 动态代理设计模式 设计原则 向上抽取原则 Java数据结构和算法先看几个经典算法面试题 用最快速度判断str2是否为str1子串 暴力破解（逐字匹配）/kmp算法《部分匹配表》 汉诺塔问题 递归，分治算法 八皇后问题 回溯算法 马踏棋盘 图的深度优化算法（DFS），贪心算法（优化） 算法是程序的灵魂，大厂对算法要求越来越高 数据结构MySQL软件安装去MySQL官网下社区版，根据网上教程配置属性 还下了SQLyog，可以图形化界面写mysql（注册码百度一下很好找） 数据库（DB）和数据库管理系统（DBMS）数据库：存储数据的仓库，本质是一个文件管理系统 数据库管理系统：是一个软件，用来管理文件 我们常说的数据库，实际上是数据库管理系统，一般习惯称为数据库 一般不直接操作DB，而是通过DBMS来操作DB 表（java中一个类）行：一条记录 类的一个对象 列：一个字段 java中一个属性 常见数据库MySQL：开源免费，小型的数据库，已经被Oracle收购，开始收费（6.x之后） Oracle：收费的大型数据库，收购了SUN,MySQL DB2：IBM的数据库，常用在银行，效率差，安全性高 SQLSever：Microsoft的，常用于c#，.net SyBase：已经淡出历史舞台，提供了一个专业的数据建模工具——PowerDesigner SQLite：嵌入式的小型数据库，用于手机端 MySQL开启和关闭 法一：此电脑-&gt;管理-&gt;服务-&gt;找到MySQL即可 法二：以管理员权限打开command net start mysql net stop mysql mysql -u root -p(直接跟密码或回车然后会提示输入密码) 法三：用SQLyog SQL语句 DDL：数据库定义语言 defination 主要是对数据库数据库表进行创建删除等维护操作 create 创建 drop 删除 alter 修改 show 查看 DCL：数据库操纵/控制语言 control 控制数据库访问权限 DML：数据库操作语言 manager 主要是对表中数据进行增删改 insert 增加 delete 删除 update 修改 DQL：数据库查询语言 query 主要是对表中数据进行查询 select 查询 from 从 where 条件 SQL通用语法 SQL语句可以单行或多行书写，以分号结尾 可使用空格和缩进来增强可读性 语句不区分大小写，关键字建议使用大写 /**/ 块注释 # 单行注释 常用数据类型（还有很多，但不常用） int 整形 double 浮点型 varchar 字符串型 date 日期型 yyyy-mm-dd，没有时分秒 DDL操作数据库​ 增 ​ create database 数据库名 采用默认编码，安装时选的 ​ create database 数据库名 charset utf8 ​ 删 ​ drop database 数据库名 ​ 改 ​ 修改数据库名字很麻烦 ​ use 数据库名 修改正在使用的数据库 ​ 查 ​ select database() 查询正在使用的数据库 ​ show database 查询所有数据库 ​ show create database 数据库名 查询某个数据库详细信息 操作数据库表​ 增 ​ create table 表名（ ​ 字段名1 数据类型1（长度） [约束]， ​ 字段名2 数据类型2（长度） [约束] ​ 字段名2 数据类型2（长度） [约束] ​ ）； ​ 删 ​ drop table 表名 ​ 查 ​ desc 表名 查看一个表的详细信息 description ​ show tables 查看所有的表 ​ 改 ​ rename table 表名 to 新表名 改名字 操作数据库表中的列​ 增 ​ alter table 表名 add 列名 类型（长度） [约束] ​ 删 ​ alter table 表名 drop 列名 ​ 查（同查看表的信息） ​ desc 表名 查看一个表的详细信息 ​ 改 可以修改列的名字，类型，约束等等 ​ alter table 表名 change 旧列名 新列名 类型(长度) 约束 修改列名,实际上类型和约束也可以一起改了 ​ alter table 表名 modify 列名 类型（长度） 约束 修改类型和约束 ​ alter table 表名 character set 字符集 一般不修改 DML增 insert into 表名 (列名1，列名2) values (value1，value2) 插入一条记录 列名可以选择一列或几列，前后必须一一对应 除了int，double，其它数据必须用””或’’引起来，推荐使用单引号 如果要插入的记录所有字段都有，则(列名1，列名2)可省略 删 delete from 表名 删除所有记录 delete from 表名 where 条件 改 update 表名 set 字段名=值 把该字段内所有的值都改了 update 表名 set 字段名=值 where 条件 DQL基本查询select [distinct] *|列名1，列名2 from 表名 查询表中所有行数据 distinct 去重查询 字段名+10 查询结果是表达式 运算查询 字段名+10 as 新名字 别名查询 条件查询 1234567891011121314151617181920212223where price &lt;&gt; 60;where not (price=60);where price &gt;= 400 and price &lt;= 600;where price between 400 and 600;where price in (400,600); 价格是400和600的where price &gt;1000 or price &lt; 300;where pname like &apos;%霸%&apos; 名字中含&apos;霸&apos;的商品where pname like &apos;_霸%&apos; 名字中第二个字为&apos;霸&apos;的商品where pname is null; 没有名字的，不可以用pname=nullwhere price &gt;2000 and category_id in (&apos;c002&apos;,&apos;c003&apos;);where (price &gt;2000 and category_id=&apos;c002&apos;) or(price &gt;2000 and category_id=&apos;c003&apos;); 排序查询对查询结果进行排序，关键字order by 格式：查询语句 order by 字段名 [ASC|DESC] ASC 升序，从小到大，默认 DESC 降序，从大到小 聚合查询以前的查询都是横向记录查询，该查询是纵向个数查询 查询特点：查询到的是单一值 聚合函数：求记录数的聚合函数 格式：聚合函数（字段名） ​ count函数会自动忽略空值 ​ max：求最大值 ​ min：求最小值 ​ avg：求平均值 ​ sum：求和 分组查询把查询到的结果分成几个组，先分组再查询，具体查询到的结果数，取决于分成几个组 若分组后还有条件需要判断，用having关键字 where写在基本查询语句后，且后面不可以写聚合函数 having写在分组查询后，且后面可以写聚合函数 格式：查询语句 group by 字段 select count() from product group by categroy_id having count(\)&gt;1 只显示个数大于1的商品分类，注意条件用having 完整查询过程 分页查询只查询记录的一部分 格式：limit 数值一（开始下标，从0开始计数），数值二（需要查出的记录数） 查询公式：假设每次查n条 第m页 limit (m-1)*n,n 多表查询交叉查询 格式：select * from 表一，表二 总字段=表一字段+表二字段 总记录数=表一记录数*表二记录数 但交叉查询无实际意义，实际上是一个矩阵（坐标）的笛卡尔，是另外两个查询的基础 内连接查询 inner join 隐式内连接查询：不写关键字inner join select * from 表一，表二 where 表一.主键=表二.外键 显式内连接查询：写关键字inner join select * from 表一 inner join 表二 on 表一.主键=表二.外键 外连接查询 outer join 左外连接：left outer join select * from 表一 left outer join 表二 on 表一.主键=表二.外键 左外连接，以左表为主，左表中数据都会有 右外连接：right outer join select * from 表一 right outer join 表二 on 表一.主键=表二.外键 右外连接，以右表为主，右表中数据都会有 子查询一个查询的结果，做另一个查询的一部分 12SELECT * FROM products WHERE category_id IN (SELECT cid FROM category WHERE cname IN('化妆品'，'家电'))； SQL备份和恢复在SQLyog中，右击数据库进行导入和导出 三个知识点两个约束主键约束(primary key):只能有一个，值必须唯一且不能为空 自动增长约束（auto_increment):初始值唯一，若被设置为一个值后，下一个值从这个的基础上增加 删除表所有数据的两种方式 delete from 表名 所有记录被删除，但自增值不会重置 truncate table 表名 删除所有记录，并重置自增值 底层是先摧毁表，再重建 乱码问题 在DOS中查看utf8编码的数据库数据时会出现乱码问题，因为DOS默认的是gbk 解决方法 临时方案：set names gbk 临时的确告诉数据库我们用gbk来查询 永久方案：修改my.ini的配置文件，不建议 数据完整性添加数据完整性==添加表约束 实体完整性：对数据行的约束，比如主键约束，唯一约束 域完整性：对数据列的约束 引用完整性：外键约束（多表关系） 各种约束主键约束：primary key 保证该字段唯一并且不为空 123456789101112131415161718-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE，-- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;//创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid)//删除主键约束ALTER TABLE books DROP PRIMARY KEY; -- 因为只能有一个主键，所以无需加字段名 唯一约束：unique 保证该字段唯一，可以为null 123456789101112131415161718192021-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT UNIQUE, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT unique_bid UNIQUE(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid);-- 删除主键约束ALTER TABLE books DROP UNIQUE(约束名); -- /如果添加唯一约束时没起名字，默认是字段名 自动增长约束：auto_increment 把该字段的值交给数据库去维护，默认每次加一（这个字段必须是建，多为主键） 1234567891011121314151617181920-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY AUTO_INCREMENT, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY bid INT AUTO_CREMENT-- /字段名 类型 约束-- 删除主键约束ALTER TABLE books MODIFY bid INT; 非空约束：not null 被约束字段不可为空值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) NOT NULL, bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 默认约束：default 给字段添加一个默认值，如果添加记录时没赋值的话用默认值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) DEFAULT 'JAVA 入门', bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 多表操作双向看，两边都是一个记录对另一边多个记录，这是多对多，否则为一对多 一对多：两张表即可 多对多：需要一张中间表 12345678910111213141516171819-- 多对多建表，一张学生表，一张课程表，一张中间表，至少两个字段-- 创建三张表CREATE TABLE student&#123; sid INT PRIMARY KEY AUTO_INCREMENT, sname VARCHAR(20), sage INT&#125;CREATE TABLE course&#123; cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(20)&#125;CREATE TABLE student_course_item&#123; student_id INT&#125;-- 添加外键约束 核心ALTER TABLE student_course_item ADD CONSTRAINT item_student_fk FOREIGN KEY(student_id) REFENRENCE student (sid);ALTER TABLE student_course_item ADD CONSTRAINT item_course_fk FOREIGN KEY(course_id) REFENRENCE course (cid); 特例：有时候两张表内记录一对一，但字段过多，也会分成两张表]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xmind使用]]></title>
    <url>%2F2019%2F08%2F13%2Fxmind%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 软件下载使用的较简单的免费版，本意只是为了简单的做一些总结之所以选择xmind:zen而不是xmind 8是因为感觉xmind:zen相对来说更小，启动速度更快，并且感觉更加代表了未来的发展方向，xmind 8有些笨重了官网 使用技巧编辑主题文字：选中主题“双击鼠标”或者按【空格键】 添加同级主题：快捷键【enter/return】 添加子主题：可快捷键【tab】 删除：选中主题按【delete/backspace】 添加外框：选中要框选的主题按工具栏的【外框】进行添加 添加概要：选中主题按工具栏的【概要】进行添加 添加笔记： ctrl+shift+n(note) 撤销: Ctrl+z 恢复: Ctrl+y emmm,帮助-&gt;快捷键助手，基本列出了常用快捷键，还可以自定义快捷键 自己直接上手也很easy，就不一一总结了 小结整体使用还是比较符合我的预期的，启动快，简约，操作方便，虽然免费版导出格式受限，并且还有水印，但这个对我基本没什么影响]]></content>
      <tags>
        <tag>思维导图</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java开发工具之intelliJ IDEA]]></title>
    <url>%2F2019%2F07%2F30%2Fjava%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BintelliJ-IDEA%2F</url>
    <content type="text"><![CDATA[[TOC] 简介Java开发主流工具是Eclipse（IBM开发）和intellij IDEA（jetbrains）。目前intellij IDEA明显使用人数增加。 主要优势强大的整合能力，比如git，Maven，Spring等 提示功能的快速，便捷，范围广 好用的快捷键和代码模板 精确搜索 下载下载地址 安装目录 第一个目录存的是配置信息，比如字体，快捷键设置，插件 第二个存的是索引，缓存等（刚启动时会自动生成索引，这段时间最好安静等待，不然可能会报一些莫名其妙的错） 如果出了什么问题，可以把第二个目录干掉，一般重启一下就好了 程序主体安装在自己安装时选择的目录下 创建项目 自己导入一下SDK，其余看需求勾选，只是java的话下一步就好 起个名字，选个存储路径就结束了 创建一个moudle-&gt;package-&gt;再在内部创建java类 删除Module：右击，F4，减掉，再右击，就可以找到delete 右上角文件夹图标，点击可以查看项目属性 调试行号旁边单击可以添加断点，右击断点可以改为条件断点 单步，跳出之类的与大多数IDE一致 取消自动更新 安装插件可以直接在设置中查找插件 Plugins 生成javadoctool -&gt; generate javadoc 选择要生成的文件，位置 locate zh_CN other command line arguments: -encoding UTF-8 -charset UTF-8 切换主题具体自行百度 常用设置setting -&gt; editor -&gt; General -&gt;Ctrl+鼠标滚轮改变字体大小/显示快速文档提示，可更改悬停时间/auto import自动导包（展开General）/显示方法间分隔符（apperance）/忽略大小写（code completion）/取消单行显示标签（editor tabs） font修改字体大小及样式 editor内可以单独修改编辑器和控制台样式 language default -&gt; comments 修改注释颜色 editor -&gt; code style -&gt; file and code template -&gt; include -&gt; file header(编写头部信息) editor -&gt; encoding -&gt; 可以将编码格式都改为utf-8（右下角显示了当前文件编码格式） （reload 改变当前文件显示方式 convert 彻底转变） build -&gt; compiler(设置自动编译) file -&gt; power save module(省电模式，关闭代码提示等功能) 右击别的文件标签可以设置显示方式，同时打开多个文件 快捷键setting -&gt;keymap -&gt; 在搜索框中输入功能，会提示对应快捷键/点击搜索图标，可以输入快捷键，提示对应功能 run Ctrl+f5、shift+f10 提示补全 Ctrl+Alt+空格 单行注释 Ctrl+/ 多行注释 Ctrl+shift+/ 向下复制一行 Ctrl+d 删除选中行 Ctrl+y 向上移动一行 Ctrl+shift+向上箭头 向下移动一行 Ctrl+shift+向下箭头 向下开始新的一行 Ctrl+enter 向上开始新的一行 Ctrl+shift+enter 查看源码 按住Ctrl，点击要查看的/还有一种暂时没找见快捷键 查看继承关系 光标位于想查看元素上，ctrl+h 万能解错/生成返回值 alt+enter 返回到前一个编辑的页面 alt+right 进入到下一个编辑的页面 alt+left 格式化代码 Ctrl+alt+l 提示方法参数类型 Ctrl+p 复制，剪切，粘贴，全选与Windows一致 撤销 Ctrl+z 反撤销 ctrl+shift+z 选中数行，整体后移 tab 选中数行，整体前移 shift+tab 查看类的结构 ctrl+o 重构：修改变量名和方法名 shift+f6 大小写转化 Ctrl+shift+u 生成构造函数 alt+fn+insert 查看文档说明 Ctrl+q 收起所有方法 Ctrl+shift+减号 打开所有方法 Ctrl+shift+等号 打开代码所在硬盘文件夹 Ctrl+shift+x（我在设置中自己设置的） 生成try—catch等 alt+ctrl 查看方法在那些地方被调用过 Ctrl+h]]></content>
      <tags>
        <tag>开发工具</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看过的一些编程书及评价]]></title>
    <url>%2F2019%2F07%2F28%2F%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8F%8A%E8%AF%84%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[汇编 汇编语言基础教程 James T.Streib整体讲解不够深入，用了很多高级汇编指令，与最初想了解底层如何实现的初衷相违背，并且很多话说的不清楚，很绕。整体学到了一些东西，算是入门了，但整体感觉不好，不推荐。 运维 跟阿铭学linux（第三版）学linux最初的各种命令是看的网课。那几个明明运用及理解都不难的命令，反反复复讲了好长时间，白白浪费了不少时间。我感觉看书来学习linux的各种命令更高效，这本书整体节奏不错，难度感觉略高一点，但认着看，感觉看的很舒服，收货很多。勉强算适合小白吧，我感觉还是有一些对新手不怎么友好的点。 （这本书学习笔记参见）]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux之centos学习笔记]]></title>
    <url>%2F2019%2F07%2F28%2Flinux%E4%B9%8Bcentos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 常用命令 文件和目录管理绝对路径与相对路径：区别在于是否从根目录开始，本地绝对路径更稳定，服务器端用相对路径 cd cd 路径 . 当前目录 .. 上级目录 什么都不加默认跳转到当前用户根目录下只能跳转到目录，不可以跳转到文件，会报错 mkdir -m 指定文件权限，不常用-p 创建一串级联目录，已存在时不报错 ls -l 详细信息-d 查看指定目录属性-h 人性化显示大小 ll=ls -l rmdir 不常用，仅用于删除目录 -p 级联删除，如果目录非空时报错 rm -r 删除目录时必须加-f 强制删除，不再询问是否删除 PATH变量 一串用：分隔的路径，执行命令时会默认从PATH中找修改: PATH=$PATH:新路径 cp 【选项】 【源文件】 【目标文件】 -r 复制目录时加-i 安全选项，覆盖时会询问，默认alise cp=“cp -i” mv 【选项】 【源文件或目录】 【目标文件或目录】 目标文件是目录，若存在，则将源文件或目录移动到目标目录下；若不存在，则将原目录重命名为给定文件名目标文件是文件，若存在，则询问是否覆盖，若不存在，则将源文件重命名为给定的目标文件 cat -n 显示行号-A 显示所有内容，包括特殊字符 tac 与命令tac一样，倒叙查看 more 文件内容较多时使用 Ctrl+D 向上翻屏Ctrl+F 向下翻屏，同空格空格 向下翻屏q 退出/字符串 从当前行向下查找字符串，按n定位下一个？字符串 从当前行向上查找字符串，按n定位下一个（可以使用通配符） less 作用同more，但命令更多 j 向上移动一行k 向上移动 head 默认显示文件前十行 -n 1/-n1/-1 显示指定行数，三种方式皆可 tail 同head，倒叙查看 文件属性 第一列第一位 d 目录 - 普通文件 l 链接文件 b 块设备 c 串行端口设备文件 s 套接字文件，socket 后九位 每三位为一组，分别为user，group，others权限 最后一位 使用了SElinux context为点 设置了acl属性为+号 第二列 该文件占用的节点（inode），有几种访问方式 第三列 所有者 第四列 所属组 第五列 该文件大小 第六七八列 分别为月日及时间 第九列 文件名 chgrp 不常用更改文件所属组chgrp 【组名】 【文件名】-R 级联更改子目录名或文件名 chown更改文件所有者chown 【-R】 账户名：组名 文件名-R 仅用于目录，作用是级联更改 chmod更改用户权限，目录默认为755，文件默认为644chmod 750 文件或目录名chmod u=rwx，og=rw 文件或目录名 u，g，o，a（all）chmod a-x 文件或目录名 umask修改文件默认权限umask xxx xxx=默认值-所需默认值（文件默认为666，目录默认为777）特例：666-333=444（333代表去了可写和可执行权限，但本来就没有可执行） chattr修改文件特殊属性chattr 【+-=】【Asaci】 【文件或目录名】 分别是增加，减少和设定存疑：=还不清楚-A 文件或目录的atime将不可修改-s 将数据同步写入磁盘-a 只能追加不能删除，非root不可设定该属性（常用）-c 自动压缩文件，读取时自动解压-i 文件不能删除，重命名，设定链接，以及写入数据（常用） lsattr 文件或目录名该命令用于读取文件或者目录的特殊权限-a 列出所有文件，包括隐藏文件-R 连同子目录数据列出 set uid，set gid，sticky bit权限其实共四位，第一位由这三个决定，分别为4,2,1，具体表现在第三位，若为小写则原本有x，大写则无，例如rwsrwsrwt为7777set uid 针对二进制可执行文件，使文件在执行阶段拥有该文件所有者权限 passwd命令set gid 作用在二进制文件上时，同上，作用在目录上时，任何用户在此目录下创建的文件都具有和该目录所属组相同的组sticky bit 设置该权限后，就算用户拥有写权限，也只可以添加而不可删除文件 /tmp/ 在linux下搜索文件which查找可执行文件绝对路径which vi whereis通过预先生成的文件列表库查找whereis 【-bms】 【文件名称】-b 只查找二级制文件-m 只查找帮助文件-s 只查找源代码文件 locate 不常用类似于whereis，包含所搜索关键词的目录和文件都会列出，所以不适合精确搜索 find 重要find 【路径】 【参数】-atime +n/-n 访问或执行时间大于或小于n天-ctime +n/-n 写入、更改inode属性的时间大于或小于n天-mtime +n/-n 写入时间大于或小于n天 用得最多]]></content>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出现过的小问题]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[[TOC] 与git相关​ fatal: Not a git repository (or any of the parent directories): .git ​ git init ​ 生成子项目 ​ git submodule add 项目路径 文件路径 与hexo相关常用命令 ​ 清楚缓存 hexo clean ​ 本地检测 hexo s (-p 4001 指定端口，默认4000) （–debug检测） ​ 生成静态文件 hexo g（-w 监视文件变动） ​ 部署 hexo d ​ (hexo clean &amp;&amp; hexo g -d) 与Markdown相关 感觉没有光标移动很不舒服，暂时没找到解决办法 默认开启了拼写检查，很多编程的英文下面都是红线，很难受 文件 -&gt; 偏好设置，下拉就可以找到钱拼写检查 不喜欢默认主题的可以在偏好设置中获取主题 选择自己喜欢的点击download，会给出css源码（有时也会直接给一个压缩文件），自己ctrl A,ctrl C存为一个css文件，导入主题文件夹即可 （从偏好设置中打开主题文件夹，导入即可） 与intellij IDEA相关]]></content>
      <tags>
        <tag>编程</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学英语路上的点点滴滴.md]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AD%A6%E8%8B%B1%E8%AF%AD%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[短句scissors,paper,stone 剪刀石头布 iron my clothes 熨衣服 I started off for a interview 我动身去参加面试 She needs to move out,find her first job,meet the love of her life,maybe even get married]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编基础]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[[TOC] 基础知识 直接在硬件工作，与机器语言一一对应 机器语言 01010000 本质：电平脉冲（早期通过穿孔卡片是实现） push ax 难以阅读且易错 汇编语言主体是汇编指令，相当于机器指令的助记符 程序–&gt; 汇编指令 –&gt; 编译器–&gt; 机器码 –&gt; 计算机 汇编语言包括 汇编指令（机器码的助记符）核心 伪指令（由编译器执行） 其他符号（由编译器执行） CPU：控制计算机运作并进行运算 核心部件 内存：存储数据，不常用的置于磁盘中 寄存器参考资料 小甲鱼零基础汇编 汇编语言基础教程]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
