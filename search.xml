<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发]]></title>
    <url>%2F2020%2F07%2F09%2FJava%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[labuladong的算法小抄]]></title>
    <url>%2F2020%2F07%2F03%2Flabuladong%E7%9A%84%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%84%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[技术之外]]></title>
    <url>%2F2020%2F05%2F16%2F%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%2F</url>
    <content type="text"><![CDATA[学习方法 不受重视时如何破局]]></content>
      <tags>
        <tag>为人</tag>
        <tag>方法论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想(一)]]></title>
    <url>%2F2020%2F05%2F08%2FJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[绪论Java设计目标：为程序员减少复杂性 真实世界在很大程度上基于群体语言习惯而形成 不应该仅将Java看作特性的集合（某些特性孤立状态下毫无意义），只有在考虑到设计，而不仅仅是编码时，才能完整运用Java各部分 对象导论计算机革命起源于机器，因此编程语言的产生也始于对机器的模仿 但计算机并非只是机器那么简单，计算机说头脑延伸的工具，还是一种不同类型的表达媒体 OOP（Object-oriented Programming）便是以计算机作为表达媒体趋势中的组成部分 抽象过程所有编程语言都支持抽象，甚至于解决问题的复杂性直接取决于抽象的类型和质量 类型：所抽象的是什么 汇编是对机器底层的轻微抽象 BASIC、C等命令式语言是对汇编的抽象 但这些抽象解决问题时仍要基于计算机的结构，而不是基于所要解决问题的结构来考虑 程序员必须建立机器模型（解空间）与实际待解问题模型（问题模型）的关联 LISP、APL考虑某些问题的特定视图，但只在特定领域高效 面向对象实质：程序可以添加适合于特定问题的新类型（class） 即根据问题来描述问题，而不是根据解决问题的计算机来描述 每个对象一个特定的微型计算机（有着特定的状态和操作） Smalltalk第一个成功的面向对象语言 五大特性 特性 解释 万物皆对象 将对象视为奇特的变量可存储数据，还可执行操作可以抽取待求解问题的任何概念化构件表示为对象 程序是对象的集合，通过发送消息告知彼此要做的 消息类似于对某个特定对象方法的调用请求 每个对象都有自己的由其它对象所构成的存储 对象之间可以组合在程序中构建复杂的体系，并将其复杂性隐藏在对象的简单些背后 每个对象都有其类型 每个对象都是某个类的实例类之间最重要的区别就是可接收的消息类型 某一特定类型的所有对象都可接收同样的消息 是继承和多态的基础这种可替代性是OOP中最强有力的概念之一 每个对象都有一个接口所有的对象都是唯一的，但同时也是具有相同的特性和行为的所有对象所归属的类的一部分 class 在程序执行期间具有不同状态而其它方面都相似的对象会被分组到对象的类中 每个对象都属于定义了特性和行为的某个特定的类 程序员通过定义适应当前问题的类来解决问题 面向对象挑战：构建问题空间元素（业务）和解空间元素（class和内置类型）的一一映射 接口：对某一特定对象可以发出的请求 每个对象都提供服务将对象想象为服务提供者，程序向用户提供服务 一切都是对象]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F04%2F29%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fleetcode%2F</url>
    <content type="text"><![CDATA[综述刷题建议 面试建议 尽可能多沟通，结合询问到的要求获得更好的实现 准备范围 小Tips 数组_排序88.合并两个有序数组 类比归并排序的合并——三指针 1234567891011121314public void merge(int[] nums1, int m, int[] nums2, int n) &#123; if(n == 0) return; int curIndex = nums1.length - 1; int nums1Index = m - 1; int nums2Index = n - 1; // 以nums2为主，它遍历完则合并结束 while(nums2Index &gt;= 0) &#123; if(nums1Index &gt;= 0 &amp;&amp;nums1[nums1Index] &gt; nums2[nums2Index]) &#123; nums1[curIndex--] = nums1[nums1Index--]; &#125;else &#123; nums1[curIndex--] = nums2[nums2Index--]; &#125; &#125;&#125; 75.颜色分类 12345678910111213141516171819public void sortColors(int[] nums) &#123; int lIndex = 0; int curIndex = 0; int rIndex = nums.length - 1; while(curIndex &lt;= rIndex) &#123; if(nums[curIndex] == 1) &#123; curIndex++; &#125;else if(nums[curIndex] == 0) &#123; swap(nums,curIndex++,lIndex++); &#125;else&#123; swap(nums, curIndex,rIndex--); &#125; &#125;&#125;public void swap(int[] nums, int index1, int index2) &#123; int tmp = nums[index1]; nums[index1] = nums[index2]; nums[index2] = tmp;&#125; 部分排序 1234567891011121314151617181920212223242526272829303132 public int[] subSort(int[] nums) &#123; if (nums.length == 0) return new int[] &#123; -1, -1 &#125;; // 从左扫描到右寻找逆序对（正序：逐渐变大） int max = nums[0]; // 用来记录最右的那个逆序对位置 int r = -1; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= max) &#123; max = nums[i]; &#125; else &#123; r = i; &#125;&#125; // 提前结束 if (r == -1) return new int[] &#123; -1, -1 &#125;; // 从右扫描到左寻找逆序对（正序：逐渐变小） int min = nums[nums.length - 1]; // 用来记录最左的那个逆序对位置 int l = -1; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; if (nums[i] &lt;= min) &#123; min = nums[i]; &#125; else &#123; l = i; &#125;&#125; return new int[] &#123; l, r &#125;; &#125; 164.最大间距 977.有序数组的平方 双指针 12345678910111213141516171819202122232425262728293031323334public int[] sortedSquares(int[] A) &#123; if(A == null || A.length == 0) return A; int i; int cur = 0; int[] newA = new int[A.length]; for(i = 0; i &lt; A.length; ++i) &#123; if(A[i] &gt;= 0) &#123; break; &#125; &#125; int l = i - 1; int r = i; while(l &gt;= 0 &amp;&amp; r &lt; A.length) &#123; int lVal = l &lt; 0 ? 0 : A[l]; int rVal = r &gt;= A.length ? 0 : A[r]; if(rVal * rVal &gt; lVal * lVal) &#123; newA[cur++] = lVal * lVal; l--; &#125;else &#123; newA[cur++] = rVal * rVal; r++; &#125; &#125; // 算是一个小优化 while(l &gt;= 0) &#123; newA[cur++] = A[l] * A[l]; l--; &#125; while(r &lt; A.length) &#123; newA[cur++] = A[r] * A[r]; r++; &#125; return newA;&#125; 16.最接近的三数之和暴力枚举n3 1234567891011121314151617public int threeSumClosest(int[] nums, int target) &#123; int len = nums.length; int min = nums[0] + nums[1] + nums[2]; for(int i = 0; i &lt; len - 2; ++i) &#123; for(int j = i+1; j &lt; len;++j) &#123; for(int k = j+1;k &lt; len;++k) &#123; int sum = nums[i] + nums[j] +nums[k]; if(Math.abs(target - sum) &lt; Math.abs(target - min)) &#123; min = sum; System.out.println(min+"----"+nums[i] + nums[j] +nums[k]); &#125; &#125; &#125; &#125; return min; &#125; 排序和双指针 123456789101112131415161718192021222324public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int len = nums.length; int ans = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; len - 2; i++) &#123; int strat = i + 1; int end = len - 1; while (strat &lt; end) &#123; int sum = nums[i] + nums[strat] + nums[end]; if (Math.abs(target - sum) &lt; Math.abs(target - ans)) &#123; ans = sum; &#125; // 利用排序和这个比较减少一些不必要的选择 if (sum &gt; target) &#123; end--; &#125;else if (sum &lt; target) &#123; strat++; &#125;else &#123; return sum; &#125; &#125; &#125; return ans;&#125; 1343. 大小为 K 且平均值大于等于阈值的子数组数目链接 注意 子数组必须连续 所求的是&gt;= 解法 暴力：O(nk) 遍历所有可能的子数组，并对其求和 模仿滑动窗口 实际上就是个长度为k的窗口不断滑动 12345678910111213141516171819202122public int numOfSubarrays(int[] arr, int k, int threshold) &#123; int lastIndex = arr.length - k; int r = k; int sum = 0; int result = 0; for(int i = 0;i &lt; k;++i) &#123; sum += arr[i]; &#125; adder = sum - k * threshold; if(adder &gt;= 0) &#123; result++; &#125; int adder; for(int i = 0;i &lt; lastIndex;++i) &#123; adder = adder + arr[r] - arr[i]; if(adder &gt;= 0) &#123; result++; &#125; r++; &#125; return result;&#125; 1. 两数之和链接 利用哈希表保存已遍历元素，用空间换时间 12345678910111213public class _1_两数之和 &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null) return null; // 用来存放之前扫描过的元素 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; Integer idx = map.get(target - nums[i]); if (idx != null) return new int[]&#123;idx, i&#125;; map.put(nums[i], i); &#125; return null; &#125;&#125; 209. 长度最小的子数组链接 题解-Java 双重循环暴力求解 1234567891011121314public int minSubArrayLen(int s, int[] nums) &#123; int minLen = Integer.MAX_VALUE; for (int i = 0;i &lt; nums.length;++i) &#123; int sum = 0; for (int j = i; j &lt; nums.length; j++) &#123; sum += nums[j]; if (sum &gt;= s) &#123; minLen = Math.min(minLen, j - i + 1); break; &#125; &#125; &#125; return minLen == Integer.MAX_VALUE ? 0 : minLen;&#125; 滑动窗口 123456789101112131415public int minSubArrayLen(int s, int[] nums) &#123; // [head, ...，tail) 相当于这样的队列 int head = 0, tail = 0, sum = 0, min = Integer.MAX_VALUE; // 这样的滑动窗口本质还是基于以每个元素开头计算短子数组的优化 while (tail &lt; nums.length) &#123; // 小于s时不断往队尾添加 sum += nums[tail++]; // 一旦超过就开始逐个移除对头元素 while (sum &gt;= s) &#123; min = Math.min(min, tail - head); sum -= nums[head++]; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min;&#125; 先累加得到递增序列再利用二分查找 123456789101112131415161718192021public int minSubArrayLen(int s, int[] nums) &#123; int length = nums.length; int min = Integer.MAX_VALUE; int[] sums = new int[length + 1]; // 获得累加数组 for (int i = 1; i &lt;= length; i++) &#123; sums[i] = sums[i - 1] + nums[i - 1]; &#125; for (int i = 0; i &lt;= length; i++) &#123; int target = s + sums[i]; int index = Arrays.binarySearch(sums, target); if (index &lt; 0) // 没找到时会返回一个负数，该负数取反之后就是查找的值应该在数组中的位置（可以自己看下源码） index = ~index; if (index &lt;= length) &#123; min = Math.min(min, index - i); &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125; 直接就用一个固定窗口 12345678910111213141516171819202122232425public int minSubArrayLen(int s, int[] nums) &#123; int lo = 1, hi = nums.length, min = 0; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt; 1; if (windowExist(mid, nums, s)) &#123; hi = mid - 1;//找到就缩小窗口的大小 min = mid;//如果找到就记录下来 &#125; else lo = mid + 1;//没找到就扩大窗口的大小 &#125; return min;&#125;//size窗口的大小private boolean windowExist(int size, int[] nums, int s) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (i &gt;= size) sum -= nums[i - size]; sum += nums[i]; if (sum &gt;= s) return true; &#125; return false;&#125; 链表 203.移除链表元素 1234567891011121314151617public ListNode removeElements(ListNode head, int val) &#123; if (head == null) return null; // 新链表的头结点 ListNode dummyHead = new ListNode(0); // 新链表的尾结点（相当于prev） ListNode newTail = dummyHead; // （head相当于cur） while (head != null) &#123; if (head.val != val) &#123; newTail.next = head; newTail = head; &#125; head = head.next; &#125; newTail.next = null; return newHead.next;&#125; 2.两数相加 1234567891011121314151617181920212223242526272829303132333435public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; ListNode dummyHead = new ListNode(0); ListNode last = dummyHead; // 进位值 int carry = 0; while (l1 != null || l2 != null) &#123; int v1 = 0; if (l1 != null) &#123; v1 = l1.val; l1 = l1.next; &#125; int v2 = 0; if (l2 != null) &#123; v2 = l2.val; l2 = l2.next; &#125; int sum = v1 + v2 + carry; // 设置进位值 carry = sum / 10; // sum的个位数作为新节点的值 last.next = new ListNode(sum % 10); last = last.next; &#125; // 检查最后的进位 if (carry &gt; 0) &#123; // carry == 1 last.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 160.相交链表 123456789101112public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) return null; ListNode curA = headA, curB = headB; while (curA != curB) &#123; curA = (curA == null) ? headB : curA.next; curB = (curB == null) ? headA : curB.next; // 这段代码在两个链表不相交的时候会死循环 // curA = (curA.next == null) ? headB : curA.next; // curB = (curB.next == null) ? headA : curB.next; &#125; return curA;&#125; 86.分隔链表 用两个链表分别串起两部分，然后再合并 1234567891011121314151617181920212223242526public ListNode partition(ListNode head, int x) &#123; if (head == null) return null; ListNode lHead = new ListNode(0); ListNode lTail = lHead; ListNode rHead = new ListNode(0); ListNode rTail = rHead; while (head != null) &#123; if (head.val &lt; x) &#123; // 放在lTail后面 lTail.next = head; lTail = head; &#125; else &#123; // 放在rTail后面 rTail.next = head; rTail = head; &#125; head = head.next; &#125; /* * 因为可能出现这样的情况: * 原链表倒数第N个节点A的值是&gt;=x的，A后面所有节点的值都是&lt;x的 * 然后rTail.next最终其实就是A.next */ rTail.next = null; // 将rHead.next拼接在lTail后面 lTail.next = rHead.next; return lHead.next;&#125; 234.回文链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 public boolean isPalindrome(ListNode head) &#123; if (head == null || head.next == null) return true; if (head.next.next == null) return head.val == head.next.val; // 找到中间节点 ListNode mid = middleNode(head); // 翻转右半部分（中间节点的右边部分） ListNode rHead = reverseList(mid); ListNode lHead = head; ListNode rOldHead = rHead; // 从lHead、rHead出发，判断是否为回文链表 boolean result = true; while (rHead != null) &#123; if (lHead.val != rHead.val) &#123; result = false; // 此处break而不是return是为了后面再次翻转一定会执行 break; &#125; rHead = rHead.next; lHead = lHead.next; &#125; // 恢复右半部分（对右半部分再次翻转） reverseList(rOldHead); return result; &#125; /** * 找到中间节点（右半部分链表头结点的前一个节点） * 比如 1&gt;2&gt;3&gt;2&gt;1中的3是中间节点 * 比如 1&gt;2&gt;2&gt;1中左边第一个2是中间节点 * @param head * @return */private ListNode middleNode(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; // 奇数个节点时，slow再往后一个后半部分的开始节点 if (fast != null) slow = slow.next; return slow;&#125;/** * 翻转链表 * @param head 原链表的头结点 * 比如原链表：1&gt;2&gt;3&gt;4&gt;null，翻转之后是：4&gt;3&gt;2&gt;1&gt;null * @return 翻转之后链表的头结点（返回4） */private ListNode reverseList(ListNode head) &#123; ListNode newHead = null; while (head != null) &#123; ListNode tmp = head.next; head.next = newHead; newHead = head; head = tmp; &#125; return newHead;&#125; 138.复制带随机指针的链表 708.循环有序链表插入 25.K个一组翻转链表 栈和队列155.最小栈 利用两个栈来实现 1234567891011121314151617181920212223242526272829303132/* 用来存放正常数据 */private Stack&lt;Integer&gt; stack;/* 用来存放最小数据 */private Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if (minStack.isEmpty()) &#123; minStack.push(x); &#125; else &#123; minStack.push(Math.min(x, minStack.peek())); &#125; &#125; public void pop() &#123; stack.pop(); minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125; 利用链表节点来模拟 1234567891011121314151617181920212223242526272829303132333435public class MinStack &#123; private Node head; /** initialize your data structure here. */ public MinStack() &#123; head = new Node(0, Integer.MAX_VALUE, null); &#125; public void push(int x) &#123; head = new Node(x, Math.min(x, head.min), head); &#125; public void pop() &#123; head = head.next; &#125; public int top() &#123; return head.val; &#125; public int getMin() &#123; return head.min; &#125; private static class Node &#123; public int val; public int min; public Node next; public Node(int val, int min, Node next) &#123; this.val = val; this.min = min; this.next = next; &#125; &#125;&#125; 239.滑动窗口最大值 利用双端队列解决 12345678910111213141516171819202122232425262728293031323334353637 public int[] maxSlidingWindow_deque(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &lt; 1) return new int[0]; if (k == 1) return nums; int[] maxes = new int[nums.length - k + 1]; // peek: 取值（偷偷瞥一眼） // poll: 删除（削） // offer: 添加（入队） Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); for (int ri = 0; ri &lt; nums.length; ri++) &#123; // 只要nums[队尾] &lt;= nums[i]，就删除队尾 while (!deque.isEmpty() &amp;&amp; nums[ri] &gt;= nums[deque.peekLast()]) &#123; // deque.pollLast(); deque.removeLast(); &#125; // 将i加到队尾 // deque.offerLast(ri); deque.addLast(ri); // 检查窗口的索引是否合法 int li = ri - k + 1; if (li &lt; 0) continue; // 检查队头的合法性 if (deque.peekFirst() &lt; li) &#123; // 队头不合法（失效，不在滑动窗口索引范围内） // deque.pollFirst(); deque.removeFirst(); &#125; // 设置窗口的最大值 maxes[li] = nums[deque.peekFirst()];&#125; return maxes; &#125; 利用两个指针来模拟双端队列 123456789101112131415161718192021222324252627282930 public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length == 0 || k &lt; 1) return new int[0]; if (k == 1) return nums; int[] maxes = new int[nums.length - k + 1]; // 当前滑动窗口的最大值索引 int maxIdx = 0; // 求出前k个元素的最大值索引 for (int i = 1; i &lt; k; i++) &#123; if (nums[i] &gt; nums[maxIdx]) maxIdx = i;&#125; // li是滑动窗口的最左索引 for (int li = 0; li &lt; maxes.length; li++) &#123; // ri是滑动窗口的最右索引 int ri = li + k - 1; if (maxIdx &lt; li) &#123; // 最大值的索引不在滑动窗口的合理范围内 // 求出[li, ri]范围内最大值的索引 maxIdx = li; for (int i = li + 1; i &lt;= ri; i++) &#123; if (nums[i] &gt; nums[maxIdx]) maxIdx = i; &#125; &#125; else if (nums[ri] &gt;= nums[maxIdx]) &#123; // 最大值的索引在滑动窗口的合理范围内 maxIdx = ri; &#125; maxes[li] = nums[maxIdx];&#125; return maxes; &#125; 654.最大二叉树 基于前序遍历，但每次具体遍历的节点需临时再那个范围内找最值 12345678910111213141516171819202122 public TreeNode constructMaximumBinaryTree(int[] nums) &#123; if (nums == null) return null; return findRoot(nums, 0, nums.length); &#125; /** * 找出[l, r)范围的根节点 */ private TreeNode findRoot(int[] nums, int l, int r) &#123; if (l == r) return null; // 找出[l, r)范围内最大值的索引 int maxIdx = l; for (int i = l + 1; i &lt; r; i++) &#123; if (nums[i] &gt; nums[maxIdx]) maxIdx = i;&#125; TreeNode root = new TreeNode(nums[maxIdx]); root.left = findRoot(nums, l, maxIdx); root.right = findRoot(nums, maxIdx + 1, r); return root; &#125; 题目变种——找到每个元素的父节点 利用栈来找 1234567891011121314151617181920212223242526272829303132333435363738394041424344 public int[] parentIndexes(int[] nums) &#123; if (nums == null || nums.length == 0) return null; /* * 1.扫描一遍所有的元素 * 2.保持栈从栈底到栈顶是单调递减的 */ int[] lis = new int[nums.length]; int[] ris = new int[nums.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 初始化 for (int i = 0; i &lt; nums.length; i++) &#123; ris[i] = -1; lis[i] = -1;&#125; for (int i = 0; i &lt; nums.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peek()]) &#123; ris[stack.pop()] = i; &#125; if (!stack.isEmpty()) &#123; lis[i] = stack.peek(); &#125; stack.push(i);&#125; int[] pis = new int[nums.length]; for (int i = 0; i &lt; pis.length; i++) &#123; if (lis[i] == -1 &amp;&amp; ris[i] == -1) &#123; // i位置的是根节点 pis[i] = -1; continue; &#125; if (lis[i] == -1) &#123; pis[i] = ris[i]; &#125; else if (ris[i] == -1) &#123; pis[i] = lis[i]; &#125; else if (nums[lis[i]] &lt; nums[ris[i]]) &#123; pis[i] = lis[i]; &#125; else &#123; pis[i] = ris[i]; &#125;&#125; return pis; &#125; 739.每日温度 用栈来找 1234567891011121314 public int[] dailyTemperatures2(int[] T) &#123; if (T == null || T.length == 0) return null; int[] result = new int[T.length]; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; T.length; i++) &#123; // 这里应该要写大于，不要写大于等于 while (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123; result[stack.peek()] = i - stack.peek(); stack.pop(); &#125; stack.push(i);&#125; return result; &#125; 倒推法 12345678910111213141516171819202122 public int[] dailyTemperatures1(int[] T) &#123; if (T == null || T.length == 0) return null; int[] values = new int[T.length]; for (int i = T.length - 2; i &gt;= 0; i--) &#123; int j = i + 1; while (true) &#123; if (T[i] &lt; T[j]) &#123; values[i] = j - i; break; &#125; else if (values[j] == 0) &#123; values[i] = 0; break; &#125; else if (T[i] == T[j]) &#123; values[i] = values[j] + j - i; break; &#125; else &#123; j = j + values[j]; &#125; &#125;&#125; return values; &#125; 42.接雨水 字符串字符串轮转 572.另一个树的子树 DFS暴力匹配 将树序列化 后序遍历的的话值（val+！），空节点（#！） 前序遍历可能存在如下问题，所以需在最开始加个！ 1234567891011121314151617181920212223242526272829public boolean isSubtree(TreeNode s, TreeNode t) &#123; if (s == null || t == null) return false; return preSerialize(s).contains(postSerialize(t));&#125;/** * 利用前序遍历的方式进行序列化 * @param root 树的根节点 * @return */private String preSerialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder("!"); preSerialize(root, sb); return sb.toString();&#125;private void preSerialize(TreeNode node, StringBuilder sb) &#123; sb.append(node.val).append("!"); if (node.left == null) &#123; sb.append("#!"); &#125; else &#123; postSerialize(node.left, sb); &#125; if (node.right == null) &#123; sb.append("#!"); &#125; else &#123; postSerialize(node.right, sb); &#125;&#125; 树哈希（尽可能降低哈希冲突） 242.有效的字母异位词 两个字符串长度一致且构成他们的字符完全一致 12345678910111213141516 public boolean isAnagram(String s, String t) &#123; if (s == null || t == null) return false; char[] schars = s.toCharArray(); char[] tchars = t.toCharArray(); if (schars.length != tchars.length) return false; int[] counts = new int[26]; for (int i = 0; i &lt; schars.length; i++) &#123; counts[schars[i] - 'a']++;&#125; // 长度一样，有判断了没有减到负一的情况，肯定是全减到0了 for (int i = 0; i &lt; tchars.length; i++) &#123; if (--counts[tchars[i] - 'a'] &lt; 0) return false;&#125; return true; &#125; 151.翻转字符串里的单词 先遍历一遍去除多余空格 再将整个字符串翻转 再将里面的每个单词以空格为界进行翻转 3.无重复字符的最长子串 滑动窗口 动态规划47.礼物的最大价值 状态：哪行、哪列 状态转移方程：左侧或上册中的最大值+当前位置价值 base case：第一行和第一列只能直走，是固定的 121.买卖股票的最佳时机 72.编辑距离 5.最长回文子串 只是将O(n)级别的判断是否为回文串降为了O(1)，但仍然考虑了O(n^2)个子串 由于依赖于左下元素：所有遍历方向为从左到右，从下到上 二叉树 二叉树算法设计的总路线：把当前节点要做的事做好，其他的交给递归框架，不用当前节点操心。 如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。 在二叉树框架之上，扩展出一套 BST 遍历框架： 12345678void BST(TreeNode root, int target) &#123; if (root.val == target) // 找到目标，做点什么 if (root.val &lt; target) BST(root.right, target); if (root.val &gt; target) BST(root.left, target);&#125; 掌握了 BST 的基本操作 236.最近公共祖先 99.恢复二叉搜索树 Morris遍历 333.最大BST子树 高频题1.两数之和解法一：O(n^2) 每遍历到一个数，在遍历其前面所有数，看是否有符合的 解法二：O(n) 利用哈希表存储已遍历元素——用空间换时间 1234567891011public int[] twoSum(int[] nums, int target) &#123; if (nums == null) return null; // 用来存放之前扫描过的元素 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; Integer idx = map.get(target - nums[i]); if (idx != null) return new int[]&#123;idx, i&#125;; map.put(nums[i], i); &#125; return null;&#125; 15.三数之和12345678910111213141516171819202122232425262728293031323334public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if (nums == null) return null; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (nums.length &lt; 3) return res; // 排序 Arrays.sort(nums); // i用来扫描三元组的第一个元素 int lastIdx = nums.length - 3; int lastR = nums.length - 1; for (int i = 0; i &lt;= lastIdx; i++) &#123; // 去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int l = i + 1, r = lastR, remain = -nums[i]; while (l &lt; r) &#123; int sumLr = nums[l] + nums[r]; if (sumLr == remain) &#123; // 找到了符合条件的三元组 res.add(Arrays.asList(nums[i], nums[l], nums[r])); // 跳过相同的值（去重） while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; // 往中间逼近 l++; r--; &#125; else if (sumLr &lt; remain) &#123; l++; &#125; else &#123; // sumLr &gt; remain r--; &#125; &#125; &#125; return res;&#125; 线性表约瑟夫环用循环链表解决 1234567891011121314151617181920212223public void reset() &#123; current = first.next;&#125;public void next() &#123; if (current == null) &#123; return; &#125; if (current.next != first) &#123; current = current.next; &#125;else &#123; current = current.next.next; &#125;&#125;public E remove() &#123; Node&lt;E&gt; rmNode = current; if (size == 1) &#123; current = null; &#125;else &#123; next(); &#125; return remove(rmNode.element); 使用 12345678910 cirList = new CircleLinkedList&lt;&gt;(); for (int i = 1; i &lt;= 8; i++) &#123; cirList.add(i); &#125;cirList.reset(); while (!cirList.isEmpty()) &#123; cirList.next(); cirList.next(); System.out.println(cirList.remove()); &#125; 树二叉树翻转二叉树链接 本质为遍历所有节点，对每个节点交换其左右节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); invertTree(root.right); return root;&#125;public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; invertTree(root.left); invertTree(root.right); TreeNode tmp = root.left; root.left = root.right; root.right = tmp; return root;&#125;public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; invertTree(root.left); TreeNode tmp = root.left; root.left = root.right; root.right = tmp; invertTree(root.left); return root;&#125;public TreeNode invertTree(TreeNode root) &#123; if (root == null) return root; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; TreeNode node = queue.poll(); TreeNode tmp = node.left; node.left = node.right; node.right = tmp; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return root;&#125; 其它前缀，中缀，后缀表达式 集合 斐波那契数列力扣链接 1234567891011121314151617181920212223242526272829303132333435363738public class Main &#123; /* 后面的数等于前两数之和 * 0 1 1 2 3 5 8 13 .... */ // 每回调一次分成两个，复杂度约为O(2^n) public static int fib1(int n) &#123; if (n &lt;= 1) return n; return fib1(n - 1) + fib1(n - 2); &#125; // O(n) public static int fib2(int n) &#123; if (n &lt;= 1) return n; int first = 0; int second = 1; for (int i = 0; i &lt; n - 1; i++) &#123; int sum = first + second; first = second; second = sum; &#125; return second; &#125; // 和fib2基本一致 public static int fib3(int n) &#123; if (n &lt;= 1) return n; int first = 0; int second = 1; while (n-- &gt; 1) &#123; // 这里可读性更低，但效率高 second += first; first = second - first; &#125; return second; &#125;&#125;]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>习题</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2020%2F04%2F29%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述解决特定问题的一系列执行步骤 使用不同算法，解决同一个问题，效率相差可能很大 排序概述按排序结果分为升序和降序 各派系算法的基类，抽取一些基本功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt; implements Comparable&lt;Sort&lt;T&gt;&gt;&#123; protected T[] array; private int cmpCount; private int swapCount; private long time; private final DecimalFormat dmf = new DecimalFormat("#.00"); public void sort(T[] array) &#123; if (array == null || array.length &lt; 2) &#123; return; &#125; this.array = array; long begin = System.currentTimeMillis(); sort(); time = System.currentTimeMillis() - begin; &#125; @Override public int compareTo(Sort&lt;T&gt; o) &#123; int result = (int) (time - o.time); if (result != 0) &#123; return result; &#125; result = cmpCount - o.cmpCount; if (result != 0) &#123; return result; &#125; return swapCount - o.swapCount; &#125; protected abstract void sort(); /** * 根据索引取值，进行比较 * @param i1 索引i1 * @param i2 索引i2 * @return array[i1] 和 array[i2]的差值 */ protected int cmp(int i1, int i2) &#123; ++cmpCount; return array[i1].compareTo(array[i2]); &#125; protected int cmp(T t1, T t2) &#123; ++cmpCount; return t1.compareTo(t2); &#125; protected void swap(int i1, int i2) &#123; ++swapCount; T temp = array[i1]; array[i1] = array[i2]; array[i2] = temp; &#125; private String numberFormat(int number) &#123; if (number &lt; 1_0000) &#123; return "" + number; &#125; if (number &lt; 1_0000_0000) &#123; return dmf.format(number / 1_0000) + "万"; &#125; return dmf.format(number / 1_0000_0000) + "亿"; &#125; private boolean isStable() &#123; if (this instanceof RadixSort) return true; if (this instanceof CountingSort) return true; if (this instanceof ShellSort) return false; if (this instanceof SelectSort) return false; Student[] students = new Student[20]; for (int i = 0; i &lt; 20; i++) &#123; students[i] = new Student(i *10, 10); &#125; for (int i = 1; i &lt; students.length; i++) &#123; if (students[i].score - students[i-1].score != 10) &#123; return false; &#125; &#125; return true; &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append("【").append(getClass().getSimpleName()).append("】").append("\n") .append("稳定性：").append(isStable()).append("\t") .append("耗时：").append(time/1000.0).append("s(").append(time).append("ms)").append("\t") .append("比较：").append(numberFormat(cmpCount)).append("\t") .append("交换：").append(numberFormat(swapCount)).append("\n") .append("--------------------------------------"); return sb.toString(); &#125;&#125; 冒泡排序概述 ​ 稳定的原地排序算法 123456789101112public class BubbleSort1&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; for (int end = array.length - 1; end &gt; 0; --end) &#123; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); &#125; &#125; &#125; &#125;&#125; 优化 如果序列已完全有序（即遍历一次而没有发生交换），可以提前终止 1234567891011121314151617181920public class BubbleSort2&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; // 是否已经有序 boolean sorted; for (int end = array.length - 1; end &gt; 0; --end) &#123; sorted = true; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sorted = false; &#125; &#125; if (sorted) &#123; break; &#125; &#125; &#125;&#125; 如果序列尾部已经局部有序，可以记录最后一次交换位置，减少比较次数 123456789101112131415161718192021package com.guardwarm.alogorithm.sort.cmp;import com.guardwarm.alogorithm.sort.Sort;public class BubbleSort3&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; for (int end = array.length - 1; end &gt; 0; end--) &#123; // 初值为1是为了在完全有序时使用 int sortedIndex = 1; for (int begin = 1; begin &lt;= end; begin++) &#123; if (cmp(begin, begin - 1) &lt; 0) &#123; swap(begin, begin - 1); sortedIndex = begin; &#125; &#125; // 正好到sortedIndex - 1为乱序，所以end--仍有用 end = sortedIndex; &#125; &#125;&#125; 最坏、平均时间复杂度为O（n2） 最好时间复杂度为O（n） 即完全有序的情况下，只遍历一次 空间复杂度为O（1） 选择排序概述 12345678910111213for (int end = array.length - 1; end &gt; 0; end--) &#123; // 感觉可以将初值设为end int max = 0; for (int begin = 1; begin &lt;= end; begin++) &#123; // &lt;=仅能保证选最大数的过程的稳定性 // 但设计最大数和后面元素交换，所以稳定性无法保证 if (cmp(max, begin) &lt; 0) &#123; max = begin; &#125; &#125; // 可以改为在max不等于end是再交换，但会多一次比较 swap(max, end);&#125; 优化使用堆来选择最大值，实际就是堆排序 堆排序 123456789101112131415161718192021222324252627282930313233343536373839404142public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; private int heapSize; @Override protected void sort() &#123; heapSize = array.length; // 自下而上的下滤来生成（大顶）堆 for (int i = (heapSize &gt;&gt; 1) - 1; i &gt;= 0; --i) &#123; siftDown(i); &#125; // 不断交换堆顶和堆尾，实现升序排序 while (heapSize &gt; 1) &#123; swap(0, --heapSize); siftDown(0); &#125; &#125; private void siftDown(int index) &#123; // 先将index处的值保存下来 T element = array[index]; // 到half-1为非叶子节点 int half = heapSize &gt;&gt; 1; while (index &lt; half) &#123; // 默认指向左子节点 int childIndex = (index &lt;&lt; 1) + 1; T child = array[childIndex]; int rightIndex = childIndex + 1; // 此处必须是heapsize，而不能是array.length if (rightIndex &lt; heapSize &amp;&amp; cmp(rightIndex, childIndex) &gt; 0) &#123; child = array[childIndex = rightIndex]; &#125; // 这里必须是用element比，用索引的话index在不断变化，即使备份，index处的值也被覆盖了 if (cmp(element, child) &gt;= 0) &#123; break; &#125; array[index] = child; index = childIndex; &#125; array[index] = element; &#125;&#125; 插入排序概述 123456789101112public class InsertSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; while (cur &gt; 0 &amp;&amp; cmp(cur, cur-1) &lt; 0) &#123; swap(cur, cur-1); --cur; &#125; &#125; &#125;&#125; 优化 直到找到插入位置再交换 123456789101112131415public class InsertSort2&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; for (int begin = 1; begin &lt; array.length; begin++) &#123; int cur = begin; T element = array[begin]; // 但凡涉及这种取出元素来减少比较的，都要注意用元素比 while (cur &gt; 0 &amp;&amp; cmp(element, array[cur - 1]) &lt; 0) &#123; array[cur] = array[cur - 1]; --cur; &#125; array[cur] = element; &#125; &#125;&#125; 利用二分查找来优化 只是将比较次数优化到logn，涉及移动元素仍是n 123456789101112131415161718192021222324252627282930313233public class InsertSort3&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; for (int begin = 1; begin &lt; array.length; begin++) &#123; insert(begin, search(begin)); &#125; &#125; private void insert(int source, int dest) &#123; T element = array[source]; System.arraycopy(array, dest, array, dest + 1, source - dest); array[dest] = element; &#125; private int search(int index) &#123; int begin = 0; int end = index; T element= array[index]; while (begin &lt; end) &#123; // 这样有溢出的风险，可以改为下面的写法 // int mid = (begin + end) &gt;&gt; 1; // 两个正数相加除2可以这样规避溢出 int mid = begin + (end - begin) &gt;&gt; 1; if (cmp(element, array[mid]) &lt; 0) &#123; end = mid; &#125;else &#123; begin = mid +1; &#125; &#125; return begin; &#125;&#125; 补充二分查找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.guardwarm.utils;public class BinarySearch &#123; /** * 在有序数组中找出对应元素的索引 * @param array 数组 * @param v 待查找元素 * @return 元素对应索引 */ public static int indexOf(int[] array, int v) &#123; if (array == null || array.length == 0) &#123; return -1; &#125; int begin = 0; int end = array.length; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (v &gt; array[mid]) &#123; begin = mid + 1; &#125;else if (v &lt; array[mid]) &#123; end = mid; &#125;else &#123; return mid; &#125; &#125; return -1; &#125; /** * 在有序数组中找出对应元素待插入位置，且要保持稳定性 * @param array 数组 * @param v 待查找元素 * @return 插入的索引 */ public static int search(int[] array, int v) &#123; if (array == null || array.length == 0) &#123; return -1; &#125; int begin = 0; int end = array.length; while (begin &lt; end) &#123; int mid = (begin + end) &gt;&gt; 1; if (v &lt; array[mid]) &#123; end = mid; &#125;else &#123; // 等于也让begin往前移，以此来保证稳定性 begin = mid+1; &#125; &#125; return -1; &#125;&#125; 归并排序 常见递推式对应复杂度 123456789101112131415161718192021222324252627282930313233343536373839public class MergeSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; private T[] leftArray; @Override protected void sort() &#123; leftArray = (T[]) new Comparable[array.length &gt;&gt; 1]; sort(0, array.length); &#125; private void sort(int begin, int end) &#123; if (end - begin &lt; 2) &#123; return; &#125; int mid = (begin + end) &gt;&gt; 1; sort(begin, mid); sort(mid, end); merge(begin, mid, end); &#125; private void merge(int begin, int mid, int end) &#123; int li = 0, le = mid - begin; int ri = mid, re = end; int ai = begin; // 先将左边的一半保存下来 for (int i = 0; i &lt; le; i++) &#123; leftArray[i] = array[begin + i]; &#125; // 只要左边不结束就遍历 while (li &lt; le) &#123; // 右边结束后，直接遍历左边 if (ri &lt; re &amp;&amp; cmp(leftArray[li], array[ri]) &gt; 0) &#123; array[ai++] = array[ri++]; &#125;else &#123; array[ai++] = leftArray[li++]; &#125; &#125; &#125;&#125; 快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class QuickSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; sort(0, array.length); &#125; private void sort(int begin, int end) &#123; if (end - begin &lt; 2) &#123; return; &#125; int mid = pivotIndex(begin, end); sort(begin, mid); // pivot占一个位置，所以要mid+1 sort(mid + 1, end); &#125; private int pivotIndex(int begin, int end) &#123; swap(begin, begin + (int) (Math.random() * (end - begin))); T pivot = array[begin]; // 让end指向最后一个元素，便于后续操作 --end; // 等于是交换是为了使pivot左右两侧更均匀（可以自己试下元素全相同的情况） while (begin &lt; end) &#123; // 从右往左遍历 while (begin &lt; end) &#123; if (cmp(pivot, array[end]) &lt; 0) &#123; end--; &#125;else &#123; array[begin++] = array[end]; break; &#125; &#125; // 从左往右遍历 while (begin &lt; end) &#123; if (cmp(pivot, array[begin]) &gt; 0) &#123; begin++; &#125;else &#123; array[end--] = array[begin]; break; &#125; &#125; &#125; array[begin] = pivot; return begin; &#125;&#125; 希尔排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ShellSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; &#123; @Override protected void sort() &#123; List&lt;Integer&gt; stepSequence = sedgewickStepSequence(); for (Integer step : stepSequence) &#123; sort(step); &#125; &#125; private void sort(int step) &#123; for (int col = 0; col &lt; step; col++) &#123; for (int begin = col + step; begin &lt; array.length; begin += step) &#123; int cur = begin;// T element = array[begin]; while (cur &gt; col &amp;&amp; cmp(cur, cur - step) &lt; 0) &#123;// array[cur] = array[cur - step]; swap(cur, cur - step); cur -= step; &#125;// array[cur] = element; &#125; &#125; &#125; private List&lt;Integer&gt; shellStepSequence() &#123; List&lt;Integer&gt; stepSequence = new ArrayList&lt;&gt;(); int step = array.length; while ((step &gt;&gt;= 1) &gt; 0) &#123; stepSequence.add(step); &#125; return stepSequence; &#125; private List&lt;Integer&gt; sedgewickStepSequence() &#123; List&lt;Integer&gt; stepSequence = new LinkedList&lt;&gt;(); int k = 0, step = 0; while (true) &#123; if (k % 2 == 0) &#123; int pow = (int) Math.pow(2, k &gt;&gt; 1); step = 1 + 9 * (pow * pow - pow); &#125; else &#123; int pow1 = (int) Math.pow(2, (k - 1) &gt;&gt; 1); int pow2 = (int) Math.pow(2, (k + 1) &gt;&gt; 1); step = 1 + 8 * pow1 * pow2 - 6 * pow2; &#125; if (step &gt;= array.length) break; // 正序生成，倒序插入，便于后序使用 stepSequence.add(0, step); k++; &#125; return stepSequence; &#125;&#125; 计数排序 123456789101112131415161718192021222324252627282930313233343536public class CountingSort extends Sort&lt;Integer&gt; &#123; @Override protected void sort() &#123; int max = array[0]; int min = array[0]; for (Integer a : array) &#123; min = Math.min(min, a); max = Math.max(max, a); &#125; int[] counts = new int[max - min + 1]; for (Integer a : array) &#123; counts[a - min]++; &#125; // 累加次数,简化后续找索引的操作 for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i -1]; &#125; int[] newArray = new int[array.length]; // 倒序遍历是为了保证稳定性（正序存，倒序取） for (int i = array.length -1; i &gt;= 0; --i) &#123; newArray[--counts[array[i] - min]] = array[i]; &#125; for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125; // 原遍历方式// // 根据整数的出现次数，对整数进行排序// int index = 0;// for (int i = 0; i &lt; counts.length; i++) &#123;// while (counts[i]-- &gt; 0) &#123;// array[index++] = i;// &#125;// &#125; &#125;&#125; 基数排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RadixSort extends Sort&lt;Integer&gt; &#123; @Override protected void sort() &#123; // 找出最大值 int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; // 个位数: array[i] / 1 % 10 = 3 // 十位数：array[i] / 10 % 10 = 9 // 百位数：array[i] / 100 % 10 = 5 // 千位数：array[i] / 1000 % 10 = ... for (int divider = 1; divider &lt;= max; divider *= 10) &#123; countingSort(divider); &#125; &#125; protected void countingSort(int divider) &#123; // 开辟内存空间，存储次数 int[] counts = new int[10]; // 统计每个整数出现的次数 for (int i = 0; i &lt; array.length; i++) &#123; counts[array[i] / divider % 10]++; &#125; // 累加次数 for (int i = 1; i &lt; counts.length; i++) &#123; counts[i] += counts[i - 1]; &#125; // 从后往前遍历元素，将它放到有序数组中的合适位置 int[] newArray = new int[array.length]; for (int i = array.length - 1; i &gt;= 0; i--) &#123; newArray[--counts[array[i] / divider % 10]] = array[i]; &#125; // 将有序数组赋值到array for (int i = 0; i &lt; newArray.length; i++) &#123; array[i] = newArray[i]; &#125; &#125;&#125; 桶排序 并查集需求分析 概述 存储数据 接口设计 初始化 Quick Find Quick Union Quick Union优化 基于size优化元素少的树嫁接到元素多的树 基于rank优化矮的树嫁接到高的树 路径压缩 路径分裂 路径减半 小结 存储自定义类型 图基本概念 实现方案 邻接矩阵 邻接表 接口设计一下为基于邻接表的实现 遍历 广度优先搜索 123456789101112131415161718192021222324252627public void bfs(V begin, VertexVisitor&lt;V&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) &#123; return; &#125; // 已选择（遍历）的点，不一定已经消费，但已在消费队列中 HashSet&lt;Vertex&lt;V, E&gt;&gt; visitedVertex = new HashSet&lt;&gt;(); Queue&lt;Vertex&lt;V,E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(beginVertex); visitedVertex.add(beginVertex); while (!queue.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = queue.poll(); if (visitor.visit(vertex.value)) &#123; return; &#125; for (Edge&lt;V, E&gt; outEdge : vertex.outEdges) &#123; if (visitedVertex.contains(outEdge.to)) &#123; continue; &#125; queue.offer(outEdge.to); visitedVertex.add(outEdge.to); &#125; &#125;&#125; 深度优先搜索 递归实现 非递归实现 12345678910111213141516171819202122232425262728293031323334@Overridepublic void dfs(V begin, VertexVisitor&lt;V&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) &#123; return; &#125; // 类似于消费队列，保存将要遍历和已遍历的点 HashSet&lt;Vertex&lt;V, E&gt;&gt; visitedVertex = new HashSet&lt;&gt;(); Stack&lt;Vertex&lt;V,E&gt;&gt; stack = new Stack&lt;&gt;(); stack.push(beginVertex); if (visitor.visit(beginVertex.value)) &#123; return; &#125; visitedVertex.add(beginVertex); while (!stack.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = stack.pop(); // 类似于回溯 for (Edge&lt;V, E&gt; outEdge : vertex.outEdges) &#123; if (visitedVertex.contains(outEdge.to)) &#123; continue; &#125; stack.push(vertex); stack.push(outEdge.to); visitedVertex.add(outEdge.to); if (visitor.visit(outEdge.to.value)) &#123; return; &#125; break; &#125; &#125;&#125; AOV网 拓扑排序 12345678910111213141516171819202122232425262728293031323334353637public List&lt;V&gt; topologicalSort() &#123; // 拓扑排序的顺序 List&lt;V&gt; list = new ArrayList&lt;&gt;(); // 可以完成的点（入度为0） Queue&lt;Vertex&lt;V,E&gt;&gt; queue = new LinkedList&lt;&gt;(); // 各点及其入度的映射 HashMap&lt;Vertex&lt;V, E&gt;, Integer&gt; ins = new HashMap&lt;&gt;(); vertices.forEach((v, vertex) -&gt; &#123; int inSize = vertex.inEdges.size(); if (inSize == 0) &#123; // 入度为0，可以遍历 queue.offer(vertex); &#125;else &#123; ins.put(vertex, inSize); &#125; &#125;); // 基于层序遍历 while (!queue.isEmpty()) &#123; Vertex&lt;V, E&gt; vertex = queue.poll(); list.add(vertex.value); for (Edge&lt;V, E&gt; outEdge : vertex.outEdges) &#123; Integer inTo = ins.get(outEdge.to) - 1; if(inTo == 0) &#123; queue.offer(outEdge.to); &#125;else &#123; ins.put(outEdge.to, inTo); &#125; &#125; &#125; // 不是所有的AOV网都可以拓扑排序 // 证明没有拓扑排序 if (list.size() &lt; vertices.size()) &#123; return null; &#125;else &#123; return list; &#125;&#125; AOE网参见 最小生成树 prim 12345678910111213141516171819202122232425private Set&lt;EdgeInfo&lt;V, E&gt;&gt; prim() &#123; Iterator&lt;Vertex&lt;V, E&gt;&gt; iterator = vertices.values().iterator(); if (!iterator.hasNext()) &#123; return null; &#125; Vertex&lt;V, E&gt; vertex = iterator.next(); HashSet&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new HashSet&lt;&gt;(); HashSet&lt;Vertex&lt;V,E&gt;&gt; addedVertex = new HashSet&lt;&gt;(); addedVertex.add(vertex); MinHeap&lt;Edge&lt;V, E&gt;&gt; minEdgeHeap = new MinHeap&lt;&gt;(vertex.outEdges, edgeComparator); while (!minEdgeHeap.isEmpty() &amp;&amp; addedVertex.size() &lt; vertices.size()) &#123; Edge&lt;V, E&gt; edge = minEdgeHeap.remove(); if (addedVertex.contains(edge.to)) &#123; continue; &#125; addedVertex.add(edge.to); edgeInfos.add(edge.info()); minEdgeHeap.addAll(edge.to.outEdges); &#125; // 有些图本身不是连通的，可能没有最小生成树 if (addedVertex.size() &lt; vertices.size()) &#123; return null; &#125; return edgeInfos;&#125; Kruskal 1234567891011121314151617181920212223private Set&lt;EdgeInfo&lt;V,E&gt;&gt; kruskal() &#123; // 最小生成树边数为节点数减一 int edgeSize = vertices.size() - 1; MinHeap&lt;Edge&lt;V, E&gt;&gt; edgeMinHeap = new MinHeap&lt;&gt;(edges, edgeComparator); HashSet&lt;EdgeInfo&lt;V, E&gt;&gt; edgeInfos = new HashSet&lt;&gt;(); UnionFind&lt;Vertex&lt;V, E&gt;&gt; vertexUnionFind = new UnionFind&lt;&gt;(); // 初始化 vertices.forEach((v,vertex) -&gt; vertexUnionFind.makeSet(vertex)); while (!edgeMinHeap.isEmpty() &amp;&amp; edgeInfos.size() &lt; edgeSize) &#123; Edge&lt;V, E&gt; edge = edgeMinHeap.remove(); if (vertexUnionFind.isSame(edge.from, edge.to)) &#123; continue; &#125; vertexUnionFind.union(edge.from, edge.to); edgeInfos.add(edge.info()); &#125; // 可以根据边数/点数判断一下是否为最小生成树，因为之前的while循环有两个退出条件 if (edgeInfos.size() == edgeSize) &#123; return edgeInfos; &#125; return null;&#125; 最短路径 单源最短路径Dijkstra 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private Map&lt;V, PathInfo&lt;V,E&gt;&gt; dijkstra(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) &#123; return null; &#125; HashMap&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = new HashMap&lt;&gt;(); HashMap&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V,E&gt;&gt; paths = new HashMap&lt;&gt;(); // 初始化 到自身距离为0 paths.put(beginVertex, new PathInfo&lt;&gt;(weightManager.zero())); while (!paths.isEmpty()) &#123; Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = getMinPath(paths); Vertex&lt;V, E&gt; minVertex = minEntry.getKey(); selectedPaths.put(minVertex.value, minEntry.getValue()); paths.remove(minVertex); for (Edge&lt;V, E&gt; outEdge : minVertex.outEdges) &#123; if (selectedPaths.containsKey(outEdge.to.value)) &#123; continue; &#125; relaxForDijkstra(minEntry.getValue(), outEdge, paths); &#125; &#125; selectedPaths.remove(begin); return selectedPaths;&#125;/** * 松弛操作 * @param fromPath edge的from的最短路径信息 * @param edge 需要进行松弛的边 * @param paths 存放着其它点（还未离开桌面）的最短路径信息 */private void relaxForDijkstra(PathInfo&lt;V, E&gt; fromPath, Edge&lt;V, E&gt; edge, HashMap&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123; PathInfo&lt;V, E&gt; oldPath = paths.get(edge.to); E newWeight = weightManager.add(fromPath.weight, edge.weight); // 原先到达该点距离比新到达该点距离更近 if (oldPath != null &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt; 0) &#123; return; &#125; if (oldPath == null) &#123; oldPath = new PathInfo&lt;&gt;(); paths.put(edge.to, oldPath); &#125;else &#123; oldPath.edgeInfos.clear(); &#125; oldPath.weight = newWeight; oldPath.edgeInfos.addAll(fromPath.edgeInfos); oldPath.edgeInfos.add(edge.info());&#125;/** * 从paths中选一个最短路径（可以用最小堆来进一步优化） * @param paths 待选集合 * @return 最短路径 */private Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; getMinPath(HashMap&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; paths) &#123; Iterator&lt;Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt;&gt; iterator = paths.entrySet().iterator(); if (!iterator.hasNext()) &#123; return null; &#125; Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; minEntry = iterator.next(); while (iterator.hasNext()) &#123; Entry&lt;Vertex&lt;V, E&gt;, PathInfo&lt;V, E&gt;&gt; entry = iterator.next(); if (weightManager.compare(minEntry.getValue().weight, entry.getValue().weight) &gt; 0) &#123; minEntry = entry; &#125; &#125; return minEntry;&#125; Bellman-Ford 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 复杂度略高于dijkstra但在有负权边时可以使用，并且可判断负权环 */private Map&lt;V, PathInfo&lt;V,E&gt;&gt; bellmanFord(V begin) &#123; Vertex&lt;V, E&gt; beginVertex = vertices.get(begin); if (beginVertex == null) &#123; return null; &#125; HashMap&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths = new HashMap&lt;&gt;(); selectedPaths.put(begin, new PathInfo&lt;&gt;(weightManager.zero())); int count = vertices.size() - 1; for (int i = 0; i &lt; count; i++) &#123; for (Edge&lt;V, E&gt; edge : edges) &#123; PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value); // 若前一个节点的最短路径还未求出，无法进行松弛操作 if (fromPath == null) &#123; continue; &#125; relax(edge, fromPath, selectedPaths); &#125; &#125; // 判断是否有负权环，有负权环的话每整个松弛一次都会有新的最短距离 for (Edge&lt;V, E&gt; edge : edges) &#123; PathInfo&lt;V, E&gt; fromPath = selectedPaths.get(edge.from.value); if (fromPath == null) &#123; continue; &#125; if (relax(edge, fromPath, selectedPaths)) &#123; System.out.println("有负权环"); return null; &#125; &#125; selectedPaths.remove(begin); return selectedPaths;&#125;private boolean relax(Edge&lt;V, E&gt; edge, PathInfo&lt;V, E&gt; fromPath, HashMap&lt;V, PathInfo&lt;V, E&gt;&gt; selectedPaths) &#123; E newWeight = weightManager.add(fromPath.weight, edge.weight); PathInfo&lt;V, E&gt; oldPath = selectedPaths.get(edge.to.value); if (oldPath != null &amp;&amp; weightManager.compare(newWeight, oldPath.weight) &gt; 0) &#123; return false; &#125; if (oldPath == null) &#123; oldPath = new PathInfo&lt;&gt;(); selectedPaths.put(edge.to.value, oldPath); &#125;else &#123; oldPath.edgeInfos.clear(); &#125; oldPath.weight = newWeight; oldPath.edgeInfos.addAll(fromPath.edgeInfos); oldPath.edgeInfos.add(edge.info()); return true;&#125; 多源最短路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; shortestPath() &#123; HashMap&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; paths = new HashMap&lt;&gt;(); // 初始化 for (Edge&lt;V, E&gt; edge : edges) &#123; Map&lt;V, PathInfo&lt;V, E&gt;&gt; map = paths.get(edge.from.value); if (map == null) &#123; map = new HashMap&lt;&gt;(); paths.put(edge.from.value, map); &#125; PathInfo&lt;V, E&gt; pathInfo = new PathInfo&lt;&gt;(edge.weight); pathInfo.edgeInfos.add(edge.info()); map.put(edge.to.value, pathInfo); &#125; vertices.forEach((v2, vertex2) -&gt; &#123; vertices.forEach((v1, vertex1) -&gt; &#123; vertices.forEach((v3,vertex3) -&gt; &#123; PathInfo&lt;V, E&gt; path12 = getPathInfo(paths, v1, v2); if (path12 == null) &#123; return; &#125; PathInfo&lt;V, E&gt; path23 = getPathInfo(paths, v2, v3); if (path23 == null) &#123; return; &#125; PathInfo&lt;V, E&gt; path13 = getPathInfo(paths, v1, v3); E newWeight = weightManager.add(path12.weight, path23.weight); if (path13 != null &amp;&amp; weightManager.compare(newWeight, path13.weight) &gt; 0) &#123; return; &#125; if (path13 == null) &#123; path13 = new PathInfo&lt;&gt;(); // paths.get(v1)可能为空，这里应该有问题 paths.get(v1).put(v3, path13); &#125;else &#123; path13.edgeInfos.clear(); &#125; path13.weight = newWeight; path13.edgeInfos.addAll(path12.edgeInfos); path13.edgeInfos.addAll(path23.edgeInfos); &#125;); &#125;); &#125;); return paths;&#125;private PathInfo&lt;V,E&gt; getPathInfo(Map&lt;V, Map&lt;V, PathInfo&lt;V, E&gt;&gt;&gt; map, V from, V to) &#123; Map&lt;V, PathInfo&lt;V, E&gt;&gt; vMap = map.get(from); return vMap == null ? null : vMap.get(to);&#125; 递归概述 调用过程 示例 基本思想 使用套路 斐波那契数列 第一版 第二版 第三版 第四版 第五版 第六版 上楼梯 汉诺塔 递归转非递归 万能方法但没什么意义 用变量保存栈帧内容 尾调用 思路类似于带着几个变量去做循环 在循环过程中不断缩小问题规模 自底向上迭代，额外参数个数取决于需要保存的变量数 最明显的区别是之前会栈溢出的情况现在可以正常执行 尾调用优化参考博文 示例 回溯概述 八皇后问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.guardwarm.alogorithm.backtrack;public class Queen &#123; /** * 数组索引是行号，数组元素是列号 */ int[] queens; /** * 符合条件的摆法数 */ int way; public void placeQueens(int n) &#123; if (n &lt; 1) return; queens = new int[n]; place(0); System.out.println(n+"皇后共有"+way+"种摆法"); &#125; private void place(int row) &#123; // 递归基 if (row == queens.length) &#123; way++; show(); return; &#125; for (int col = 0; col &lt; queens.length; col++) &#123; if (isValid(row, col)) &#123; queens[row] = col; // 回溯 place(row + 1); &#125; &#125; &#125; private void show() &#123; for (int row = 0; row &lt; queens.length; row++) &#123; for (int col = 0; col &lt; queens.length; col++) &#123; if (col == queens[row]) &#123; System.out.print("1 "); &#125;else &#123; System.out.print("0 "); &#125; &#125; System.out.println(); &#125; System.out.println("-----------------"); &#125; private boolean isValid(int row, int col) &#123; // 逐行遍历，故无需考虑同一行 for (int i = 0; i &lt; row; i++) &#123; // 位于同一列返回false if (queens[i] == col) &#123; return false; &#125; // 位于同一对角线 if (row - i == Math.abs(col - queens[i])) &#123; return false; &#125; &#125; return true; &#125;&#125; 优化简化剪枝判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.guardwarm.alogorithm.backtrack;/** * 通过增加三个boolean数组，降低判断有效性的时间复杂度 */@SuppressWarnings("unused")public class Queen2 &#123; int[] queens; /** * 某一列是否有皇后 */ boolean[] cols; /** * 某一斜线是否有皇后（左上-&gt;右下） */ boolean[] leftTop; /** * 某一斜线是否有皇后（右上-&gt;左下） */ boolean[] rightTop; int way; void placeQueens(int n) &#123; if (n &lt; 1) &#123; return; &#125; queens = new int[n]; cols = new boolean[n]; leftTop = new boolean[2*n + 1]; rightTop = new boolean[2*n + 1]; place(0); System.out.println(n+"皇后共有"+way+"种摆法"); &#125; private void place(int row) &#123; if (row == cols.length) &#123; way++; show(); return; &#125; for (int col = 0; col &lt; cols.length; col++) &#123; // 剪枝 if (cols[col]) &#123; continue; &#125; int ltIndex = row + col; if (leftTop[ltIndex]) &#123; continue; &#125; int rtIndex = row - col + cols.length; if (rightTop[rtIndex]) &#123; continue; &#125; queens[row] = col; cols[col] = true; leftTop[ltIndex] = true; rightTop[rtIndex] = true; place(row + 1); // 回溯回来需置空，不然会影响下次剪枝 cols[col] = false; leftTop[ltIndex] = false; rightTop[rtIndex] = false; &#125; &#125; private void show() &#123; for (int row = 0; row &lt; queens.length; row++) &#123; for (int col = 0; col &lt; queens.length; col++) &#123; if (queens[row] == col) &#123; System.out.print("1 "); &#125;else &#123; System.out.print("0 "); &#125; &#125; System.out.println(); &#125; System.out.println("-----------------"); &#125;&#125; 用位运算压缩 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.guardwarm.alogorithm.backtrack;/** * 利用位运算来进一步降低空间复杂度 * 但这种不适合n皇后，会有一定数量限制 */public class Queen3 &#123; int[] queens; /** * 某一列是否有皇后 */ byte cols; /** * 某一斜线是否有皇后（左上-&gt;右下） */ short leftTop; /** * 某一斜线是否有皇后（右上-&gt;左下） */ short rightTop; int way; public void place8Queens() &#123; queens = new int[8]; place(0); System.out.println("8皇后一共有"+way+"种摆法"); &#125; private void place(int row) &#123; if (row == 8) &#123; way++; show(); return; &#125; for (int col = 0; col &lt; 8; col++) &#123; int cv = 1 &lt;&lt; col; if ((cols &amp; cv) != 0) &#123; continue; &#125; int lv = 1 &lt;&lt; (row - col + 7); if ((leftTop &amp; lv) != 0) &#123; continue; &#125; int rv = 1 &lt;&lt; (row + col); if ((rightTop &amp; rv) != 0) &#123; continue; &#125; queens[row] = col; cols |= cv; leftTop |= lv; rightTop |= rv; place(row + 1); cols &amp;= ~cv; leftTop &amp;= ~lv; rightTop &amp;= ~rv; &#125; &#125; private void show() &#123; for (int row = 0; row &lt; queens.length; row++) &#123; for (int col = 0; col &lt; queens.length; col++) &#123; if (queens[row] == col) &#123; System.out.print("1 "); &#125;else &#123; System.out.print("0 "); &#125; &#125; System.out.println(); &#125; System.out.println("-----------------"); &#125;&#125; 贪心 最优装载问题 零钱兑换只用贪心仅能在某些数值得到最优解 12345678910111213141516171819202122public class CoinChange &#123; public static void main(String[] args) &#123; new CoinChange().coinChange(new Integer[] &#123;25, 20, 5, 1&#125;, 41); &#125; public void coinChange(Integer[] faces, int money) &#123; Arrays.sort(faces, (f1, f2) -&gt; &#123; return f2 - f1; &#125;); int i = 0, coins = 0; while (i &lt;faces.length) &#123; if (money &lt; faces[i]) &#123; i++; continue; &#125; System.out.println(faces[i]); money -= faces[i]; ++coins; &#125; System.out.println("coin count: "+coins); System.out.println("--------"); &#125;&#125; 0-1背包问题 1234567891011121314151617181920212223242526public class Knapsack &#123; public void select(String title, Comparator&lt;Article&gt; cmp) &#123; Article[] articles = new Article[] &#123; new Article(35, 10), new Article(30, 40), new Article(60, 30), new Article(50, 50), new Article(40, 35), new Article(10, 40), new Article(25, 30) &#125;; Arrays.sort(articles, cmp); int capacity = 150, weight = 0, value = 0; List&lt;Article&gt; selectedArticles = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; articles.length &amp;&amp; weight &lt; capacity; i++) &#123; int newWeight = weight + articles[i].getWeight(); if (newWeight &lt;= capacity) &#123; weight = newWeight; value += articles[i].getValue(); selectedArticles.add(articles[i]); &#125; &#125; System.out.println("["+title+"]"); System.out.println("All value: "+value); for (Article selectedArticle : selectedArticles) &#123; System.out.println(selectedArticle); &#125; &#125;&#125; 分治 最大连续子序列和 暴力遍历 分治 大数乘法 动态规划概述 常规步骤 前提条件 示例找零钱 暴力递归 记忆化搜索 递推 输出找零钱的具体方案 通用实现 最大连续子序列和 实现 优化 最长上升子序列 LIS 实现 基于二分搜索的实现 最长公共子序列 LCS 递归实现 递归的缺陷 非递归实现 最长公共子串 实现 一维数组实现 0-1背包 一维数组实现 要求恰好装满 布隆过滤器背景 概述 原理 实现 Google Guava实现 代码简化了hash函数的生成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class BloomFilter&lt;T&gt; &#123; /** * 需要多少个bit存储数据 */ private final int bitSize; /** * 用long数组来保存bits */ private final long[] bits; /** * 需要的hash函数数 */ private final int hashSize; /** * @param n 数据规模 * @param p 容错率 */ public BloomFilter(int n, double p) &#123; if (n &lt;= 0 || p &lt;= 0 || p &gt;= 1) &#123; throw new IllegalArgumentException("wrong n or p"); &#125; double ln2 = Math.log(2); bitSize = (int) (- (n * Math.log(p)) / (ln2 * ln2)); hashSize = (int) (bitSize * ln2 / n); // 以此来避免向上取整 bits = new long[(bitSize + Long.SIZE - 1) / Long.SIZE]; &#125; public boolean put(T value) &#123; nullCheck(value); // 利用value生成hashcode值，但这个只是很简单的生成 // 正常为了分布均匀这个生成是比较复杂的 int hash1 = value.hashCode(); int hash2 = value.hashCode() &gt;&gt;&gt; 16; boolean result = false; for (int i = 0; i &lt; hashSize; i++) &#123; // 第i个hash函数 int combinedHash = hash1 + (i * hash2); if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; int index = combinedHash % bitSize; // 设置的index处本身就是1 if (set(index)) result = true; &#125; return result; &#125; public boolean contains(T value) &#123; nullCheck(value); int hash1 = value.hashCode(); int hash2 = hash1 &gt;&gt;&gt; 16; for (int i = 0; i &lt; hashSize; i++) &#123; int combinedHash = hash1 + (i * hash2); if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; int index = combinedHash % bitSize; // 没有值则返回false if (!get(index)) return false; &#125; return true; &#125; private boolean set(int index) &#123; // 提前将原值备份,以便于确认是否本身就已经是1 long value = bits[index / Long.SIZE]; int bitValue = 1 &lt;&lt; (index % Long.SIZE); bits[index / Long.SIZE] = value | bitValue; return (bitValue &amp; value) == 0; &#125; private boolean get(int index) &#123; long value = bits[index / Long.SIZE]; // Long.SIZE为2的幂次，故可以优化为&amp;运算 return (value &amp; (1 &lt;&lt; (index &amp; (Long.SIZE - 1)))) != 0;// return (value &amp; (1 &lt;&lt; (index % Long.SIZE))) != 0; &#125; private void nullCheck(T value) &#123; if (value == null) &#123; throw new IllegalArgumentException("Value must not be null"); &#125; &#125;&#125; 跳表背景 概述 搜索 增删 复杂度分析 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class SkipList&lt;K, V&gt; &#123; /** * 最高层数 */ private static final int MAX_LEVEL = 32; /** * 再往上加一层的概率 */ private static final double P = 0.25; /** * 当前跳表元素个数 */ private int size; /** * 比较器 */ private final Comparator&lt;K&gt; comparator; /** * 有效层数（当前最高层数） */ private int level; /** * 虚拟头节点 */ private Node&lt;K, V&gt; first; public SkipList() &#123; this(null); &#125; public SkipList(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; first = new Node&lt;&gt;(null, null, MAX_LEVEL); &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public V get(K key) &#123; keyCheck(key); Node&lt;K, V&gt; node = first; // 找到则返回，下个元素仍小于待查找key则向后，否则降层 for (int i = level -1; i&gt;= 0;--i) &#123; int cmp = -1; while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; if (cmp == 0) &#123; return node.nexts[i].value; &#125; &#125; return null; &#125; public V put(K key, V value) &#123; keyCheck(key); Node&lt;K, V&gt; node = first; // 每次向下走的节点都是带添加节点的前驱节点 Node&lt;K, V&gt;[] prevs = new Node[level]; for (int i = level -1; i &gt;= 0; --i) &#123; int cmp = -1; while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; if (cmp == 0) &#123; V oldValue = node.nexts[i].value; node.nexts[i].value = value; return oldValue; &#125; prevs[i] = node; &#125; // 节点高度随机生成 int newLevel = randomLevel(); Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, newLevel); // 更改前驱节点指向，若超出原先最大高度，需修改first部分指向 for (int i = 0; i &lt; newLevel; i++) &#123; if (i &gt;= level) &#123; first.nexts[i] = newNode; &#125;else &#123; newNode.nexts[i] = prevs[i].nexts[i]; prevs[i].nexts[i] = newNode; &#125; &#125; ++size; level = Math.max(level, newLevel); return null; &#125; public V remove(K key) &#123; keyCheck(key); Node&lt;K, V&gt; node = first; Node&lt;K, V&gt;[] prevs = new Node[level]; boolean isExists = false; for (int i = level -1; i&gt;= 0;--i) &#123; int cmp = -1; while (node.nexts[i] != null &amp;&amp; (cmp = compare(key, node.nexts[i].key)) &gt; 0) &#123; node = node.nexts[i]; &#125; // 下一个节点的key与待删除节点的key相同，照样往下走，无需特殊处理 if (cmp == 0) &#123; isExists = true; &#125; prevs[i] = node; &#125; if (!isExists) &#123; return null; &#125; Node&lt;K, V&gt; removeNode = node.nexts[0]; size--; // 更新前驱节点 注意高度为待删除节点高度 for (int i = 0; i &lt; removeNode.nexts.length; i++) &#123; prevs[i].nexts[i] = removeNode.nexts[i]; &#125; // 更新跳表层数（若删除的为最高的，正常应该更新为次高的，但不清楚次高为多高） int newLevel = level; while (--newLevel &gt; 0 &amp;&amp; first.nexts[newLevel] == null) &#123; level = newLevel; &#125; return removeNode.value; &#125; private static class Node&lt;K, V&gt; &#123; K key; V value; Node&lt;K, V&gt;[] nexts; public Node(K key, V value, int level) &#123; this.key = key; this.value = value; nexts = new Node[level]; &#125; @Override public String toString() &#123; return key + ":" + value + "_" + nexts.length; &#125; &#125; private int randomLevel() &#123; int level = 1; while (Math.random() &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123; level++; &#125; return level; &#125; private void keyCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must be not null"); &#125; &#125; private int compare(K k1, K k2) &#123; return comparator != null ? comparator.compare(k1, k2) : ((Comparable) k1).compareTo(k2); &#125; @Override public String toString() &#123; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("一共").append(level).append("层").append("\n"); Node&lt;K, V&gt; node; for (int i = level - 1; i &gt;= 0; i--) &#123; node = first; while (node.nexts[i] != null) &#123; stringBuilder.append(node.nexts[i]); stringBuilder.append(" "); node = node.nexts[i]; &#125; stringBuilder.append("\n"); &#125; return stringBuilder.toString(); &#125;&#125; B+树概述 基知硬盘分类 机械硬盘 操作系统读取硬盘数据 磁盘完成IO操作时间 MySQL索引为什么用B+树 对比B树 B*树 串串匹配算法背景 概述 蛮力（一）概述 实现优化 蛮力（二）概述 性能分析 KMP算法对比 next表构建原理从后往前该字符串最近的一次出现 实现 优化 执行流程 复杂度分析 代码123456789101112131415161718192021222324252627282930313233343536373839private boolean contains(String text, String pattern) &#123; int plen = pattern.length(); int tlen = text.length(); if (tlen == 0 || plen == 0 || tlen &lt; plen) return false; int[] next = next(pattern); int pi = 0, ti = 0; int tmax = tlen - plen; while (pi &lt; plen &amp;&amp; ti - pi &lt;= tmax) &#123; if (pi &lt; 0 || text.charAt(ti) == pattern.charAt(pi)) &#123; ti++; pi++; &#125; else &#123; pi = next[pi]; &#125; &#125; return pi == plen;&#125;private int[] next(String pattern) &#123; int len = pattern.length(); int[] next = new int[len]; int i = 0; int n = next[i] = -1; int imax = len - 1; while (i &lt; imax) &#123; if (n &lt; 0 || pattern.charAt(i) == pattern.charAt(n)) &#123; i++; n++; if (pattern.charAt(i) == pattern.charAt(n)) &#123; next[i] = next[n]; &#125; else &#123; next[i] = n; &#125; &#125; else &#123; n = next[n]; &#125; &#125; return next;&#125; BM算法 RK算法 Sunday算法 前缀树（Trie）概述 接口设计 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package com.guardwarm.trie;import java.util.HashMap;public class Trie&lt;V&gt; &#123; private int size; Node&lt;V&gt; root; private static class Node&lt;V&gt; &#123; Node&lt;V&gt; parent; HashMap&lt;Character, Node&lt;V&gt;&gt; children; Character character; V value; boolean isWord; public Node(Node&lt;V&gt; parent) &#123; this.parent = parent; &#125; &#125; private void keyCheck(String key) &#123; if (key == null || key.length() == 0) &#123; throw new IllegalArgumentException("Key must not be empty"); &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; root = null; size = 0; &#125; public V get(String key) &#123; Node&lt;V&gt; node = node(key); return (node != null &amp;&amp; node.isWord) ? node.value : null; &#125; public boolean contains(String key) &#123; Node&lt;V&gt; node = node(key); return node != null &amp;&amp; node.isWord; &#125; public boolean startsWith(String prefix) &#123; return node(prefix) != null; &#125; public V add(String key, V value) &#123; keyCheck(key); if (root == null) &#123; root = new Node&lt;&gt;(null); &#125; Node&lt;V&gt; node = root; for (char c : key.toCharArray()) &#123; boolean emptyChildren = node.children == null; Node&lt;V&gt; childNode = emptyChildren ? null : node.children.get(c); if (childNode == null) &#123; childNode = new Node&lt;&gt;(node); childNode.character = c; node.children = emptyChildren ? new HashMap&lt;Character, Node&lt;V&gt;&gt;() : node.children; node.children.put(c, childNode); &#125; node = childNode; &#125; if (node.isWord) &#123; V oldValue = node.value; node.value = value; return oldValue; &#125; node.value = value; node.isWord = true; size++; return null; &#125; public V remove(String key) &#123; keyCheck(key); Node&lt;V&gt; node = node(key); if (node == null || !node.isWord) &#123; return null; &#125; size--; V oldValue = node.value; if (node.children != null &amp;&amp; !node.children.isEmpty()) &#123; node.value = null; node.isWord = false; return oldValue; &#125; Node&lt;V&gt; parent = null; while ((parent = node.parent) != null) &#123; parent.children.remove(node.character); if (parent.isWord || !parent.children.isEmpty()) &#123; break; &#125; node = parent; &#125; return oldValue; &#125; private Node&lt;V&gt; node(String key) &#123; keyCheck(key); Node&lt;V&gt; node = root; for (char c : key.toCharArray()) &#123; if (node == null || node.children == null || node.children.isEmpty()) &#123; return null; &#125; node = node.children.get(c); &#125; return node; &#125;&#125; 小结 AC自动机参见]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2020%2F04%2F29%2F%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[复杂度大O表示法 一般用大O表示法来描述复杂度，它表示的是数据规模 n 对应的复杂度 忽略常数、系数、低阶 数据规模受多个变量影响时，这些变量都得保留 注意：大O表示法仅仅是一种粗略的分析模型，能帮助我们短时间内了解一个算法的执行效率，估算一种增长趋势 对数阶一般省略底数，统称为 logn（根据对数换底底数可以通过抽个系数来任意改变） O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(n^n) 示例1234567891011121314151617 // log5(n) // O(logn) while ((n = n / 5) &gt; 0) &#123; System.out.println("test");public static void test7(int n) &#123; // i += i等价于 i = i * 2 // 1 + 2*log2(n) + log2(n) * (1 + 3n) // 1 + 3*log2(n) + 2 * nlog2(n) // O(nlogn) for (int i = 1; i &lt; n; i += i) &#123; // 1 + 3n for (int j = 0; j &lt; n; j++) &#123; System.out.println("test"); &#125; &#125;&#125; 分类 最好情况复杂度 最坏情况复杂度 平均复杂度——累加之后求平均 数组随机访问为O(1)，链表插入和删除那一刻是O(1) 均摊复杂度 多次较低复杂度后，出现一次较高复杂度 空间复杂度 线性表 具有 n 个同类型元素的有限序列（ n ≥ 0 ） 首节点、尾节点 前驱、后继 接口设计 List接口对外提供的接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.guardwarm;public interface List&lt;E&gt; &#123; int ELEMENT_NOT_FOUND = -1; /** * 清除所有元素 */ void clear(); /** * 元素的数量 * @return 元素个数 */ int size(); /** * 是否为空 * @return 是否为空 */ boolean isEmpty(); /** * 是否包含某个元素 * @param element 待查找元素 * @return 是否找到 */ boolean contains(E element); /** * 添加元素到尾部 * @param element 待添加元素 */ void add(E element); /** * 获取index位置的元素 * @param index 元素索引 * @return 该索引处元素 */ E get(int index); /** * 设置index位置的元素 * @param index 元素索引 * @param element 元素 * @return 原来的元素ֵ */ E set(int index, E element); /** * 在index位置插入一个元素 * @param index 元素索引 * @param element 元素 */ void add(int index, E element); /** * 删除index位置的元素 * @param index 元素索引 * @return 该索引处原来的元素 */ E remove(int index); /** * 查看元素的索引 * @param element 元素索引 * @return 第一个该元素对应索引 */ int indexOf(E element);&#125; AbstractList对一些共同方法进行实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.guardwarm;/** * @author wh */@SuppressWarnings("unused")public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; &#123; /** * 元素的数量 */ protected int size; /** * 元素的数量 * @return 元素个数 */ @Override public int size() &#123; return size; &#125; /** * 是否为空 * @return 是否为空 */ @Override public boolean isEmpty() &#123; return size == 0; &#125; /** * 是否包含某个元素 * @param element 待检查元素 * @return 是否包含 */ @Override public boolean contains(E element) &#123; return indexOf(element) != ELEMENT_NOT_FOUND; &#125; /** * 添加元素到尾部 * @param element 待添加元素 */ @Override public void add(E element) &#123; add(size, element); &#125; protected void outOfBounds(int index) &#123; throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size); &#125; /** * 检查操作的索引是否越界 * @param index 待操作索引 */ protected void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; outOfBounds(index); &#125; &#125; /** * add方法可操作size处索引，需单独检验 * @param index 待操作索引 */ protected void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; outOfBounds(index); &#125; &#125;&#125; 动态数组概述数组是一种顺序存储的线性表，所有元素的内存地址是连续的 在很多编程语言中，有个致命问题，无法修改容量 为了满足使用需求，需要实现动态扩容 图解 add(E element) add(int index, E element) remove(int index, E element) 打印数组 泛型 提升数组通用性，但泛型只能接收对象 扩容 内存管理 null值处理 判断相等 用equles方法代替==，这样通过重写equles方法可以自定义比较方法 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.guardwarm;/** * @author asus */@SuppressWarnings("unused")public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private E[] elements; /** * 无参构造，默认初始容量10 */ public ArrayList() &#123; this(DEFAULT_CAPACITY); &#125; /** * 当传入参数小于默认容量时，初始化为默认容量 * * @param capacity 初始化容量 */ public ArrayList(int capacity) &#123; capacity = Math.max(capacity, DEFAULT_CAPACITY); //noinspection unchecked elements = (E[]) new Object[capacity]; &#125; /** * 检查是否需要扩容，每次扩容1.5倍 */ private void checkCapacity() &#123; int oldCapacity = elements.length; if (oldCapacity == this.size) &#123; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); @SuppressWarnings("unchecked") E[] newElements = (E[]) new Object[newCapacity]; System.arraycopy(elements, 0, newElements, 0, this.size); System.out.println(oldCapacity + "扩容为：" + newCapacity); elements = newElements; &#125; &#125; @Override public int size() &#123; return size; &#125; /** * 数组是否为空 * @return 为空返回true */ @Override public boolean isEmpty() &#123; return size == 0; &#125; /** * 是否包含该元素 * * @param element 待查找元素 * @return 是否包含 */ @Override public boolean contains(E element) &#123; return indexOf(element) != ELEMENT_NOT_FOUND; &#125; /** * 默认插在数组末尾 * * @param element 待插入的元素 */ @Override public void add(E element) &#123; add(size, element); &#125; @Override public void add(int index, E element) &#123; rangeCheckForAdd(index); checkCapacity(); if (size != 0) &#123; System.arraycopy(elements, index, elements, index + 1, size - index); &#125; elements[index] = element; size++; &#125; /** * 获取指定索引处的元素 * * @param index 操作的索引 * @return 获取的元素 */ @Override public E get(int index) &#123; rangeCheck(index); return elements[index]; &#125; @Override public E set(int index, E element) &#123; rangeCheck(index); E old = elements[index]; elements[index] = element; return old; &#125; @Override public E remove(int index) &#123; rangeCheck(index); E old = elements[index]; System.arraycopy(elements, index + 1, elements, index, size - index - 1); elements[--size] = null; return old; &#125; /** * 是否包含指定的元素 * * @param element 待查找的元素 * @return 待查找元素对应的索引，未找到时返回-1 */ @Override public int indexOf(E element) &#123; for (int i = 0; i &lt; size; i++) &#123; if (elements[i].equals(element)) &#123; return i; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; /** * 清空该数组 * 并没有新建一个空数组，为了提高内存利用率，避免重复申请 * 在数组元素不多时只是将其清空并且将size清零 * 各个元素置为null是为了释放掉对应内存空间 */ @Override public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[i] = null; &#125; size = 0; &#125; /** * 将数组按指定规则转为字符串 * * @return 该数组的字符串形式 */ @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append("size = ").append(size).append(" "); sb.append("[ "); for (int i = 0; i &lt; size; i++) &#123; if (i != 0) &#123; sb.append(", "); &#125; sb.append(elements[i]); &#125; sb.append(" ]"); return sb.toString(); &#125;&#125; 优化缩容删除元素后看是否需要缩容以节省空间 123456789101112131415private void trim() &#123; // 30 int oldCapacity = elements.length; // 15 int newCapacity = oldCapacity &gt;&gt; 1; if (size &gt; (newCapacity) || oldCapacity &lt;= DEFAULT_CAPACITY) return; // 剩余空间还很多 E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[i]; &#125; elements = newElements; System.out.println(oldCapacity + "缩容为" + newCapacity);&#125; 循环数组 链表概述 图解 clear() add(int index, E element) 获取指定索引的node 添加和删除元素时注意考虑临界值 size，size-1，first 单向链表实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.guardwarm;/** * @author wh */@SuppressWarnings("unused")public class LinkedList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; private Node&lt;E&gt; first; private static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125; &#125; private Node&lt;E&gt; node(int index) &#123; rangeCheck(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; return node; &#125; @Override public void clear() &#123; size = 0; first = null; &#125; @Override public E get(int index) &#123; return node(index).element; &#125; @Override public E set(int index, E element) &#123; Node&lt;E&gt; node = node(index); E old = node.element; node.element = element; return old; &#125; @Override public void add(int index, E element) &#123; rangeCheckForAdd(index); if (index == 0) &#123; first = new Node&lt;&gt;(element, first.next); &#125;else &#123; Node&lt;E&gt; prev = node(index - 1); prev.next = new Node&lt;&gt;(element, prev.next); &#125; size++; &#125; @Override public E remove(int index) &#123; rangeCheck(index); Node removeNode = first; if (index == 0) &#123; first = first.next; &#125; else &#123; Node&lt;E&gt; prev = node(index - 1); removeNode = prev.next; node.next = node.next.next; &#125; size--; return removeNode.element; &#125; @Override public int indexOf(E element) &#123; Node&lt;E&gt; node = first; if (element == null) &#123; for (int i = 0; i &lt; size; i++) &#123; if (node.element == null) &#123; return i; &#125; node = node.next; &#125; &#125;else &#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node.element)) &#123; return i; &#125; node = node.next; &#125; &#125; return ELEMENT_NOT_FOUND; &#125;&#125; 双向链表实现实现 只有一个元素时 node方法 根据索引考略从头遍历还是从尾遍历 add方法 可以对头插和尾插特殊处理 亦可加个虚拟头节点和尾节点来一般化 remove方法 和add方法类似，头尾需要特别处理 与单向链表比较 与动态数组比较 用虚拟头节点和尾节点来减少临界判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.guardwarm.demo2;/** * @author wh */public class NonSingleLinkedList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; Node&lt;E&gt; first; Node&lt;E&gt; last; public NonSingleLinkedList() &#123; first = new Node&lt;&gt;(null, null, null); last = new Node&lt;&gt;(null, null, null); &#125; private static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; prev; Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; prev, Node&lt;E&gt; next) &#123; this.element = element; this.prev = prev; this.next = next; &#125; &#125; @Override public void clear() &#123; first.next = null; last.next = null; size = 0; &#125; @Override public E get(int index) &#123; return node(index).element; &#125; @Override public E set(int index, E element) &#123; Node&lt;E&gt; node = node(index); E old = node.element; node.element = element; return old; &#125; @Override public void add(int index, E element) &#123; rangeCheckForAdd(index); // 这些判断也可以封装到node方法内 但第一个节点还是需要单独处理 Node&lt;E&gt; prev = index == 0 ? first : node(index - 1); Node&lt;E&gt; next = index == size ? last : prev.next; prev.next = new Node&lt;&gt;(element, prev, next); next.prev = prev.next; size ++; &#125; @Override public E remove(int index) &#123; rangeCheck(index); Node&lt;E&gt; prev = index == 0 ? first : node(index - 1); Node&lt;E&gt; next = index == size - 1 ? last : prev.next.next; E old = prev.next.element; prev.next = next; next.prev = prev; return old; &#125; @Override public int indexOf(E element) &#123; Node&lt;E&gt; node = first.next; if (element == null) &#123; for (int i = 0; i &lt; size; i++) &#123; if (node.element == null) &#123; return i; &#125; node = node.next; &#125; &#125;else &#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node.element)) &#123; return i; &#125; node = node.next; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; private Node&lt;E&gt; node(int index) &#123; rangeCheck(index); Node&lt;E&gt; node; if (index &gt; (size &gt;&gt; 1)) &#123; node = last.prev; for (int i = 0; i &lt; size - index - 1; i++) &#123; node = node.prev; &#125; &#125;else &#123; node = first.next; for (int i = 0; i &lt; index; i++) &#123; node = node.next; &#125; &#125; return node; &#125;&#125; 单向循环链表 单节点时 add方法 对头插特殊处理 remove方法 对头部和单节点时需要特殊处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.guardwarm.demo2;/** * @author wh * @param &lt;E&gt; 泛型参数 */public class CircleLinkedList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; Node&lt;E&gt; first; public CircleLinkedList() &#123; first = new Node&lt;&gt;(null, null); &#125; private static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; next; public Node(E element, Node&lt;E&gt; next) &#123; this.element = element; this.next = next; &#125; &#125; @Override public void clear() &#123; first = null; size = 0; &#125; @Override public E get(int index) &#123; return node(index).element; &#125; @Override public E set(int index, E element) &#123; Node&lt;E&gt; node = node(index); E old = node.element; node.element = element; return old; &#125; @Override public void add(int index, E element) &#123; Node&lt;E&gt; node; if (size == 0) &#123; first.next = new Node&lt;&gt;(element, first); &#125; else &#123; node = node(index - 1); node.next = new Node&lt;&gt;(element, node.next); &#125; size++; &#125; @Override public E remove(int index) &#123; Node&lt;E&gt; prev = node(index - 1); E old = prev.next.element; if (size == 1) &#123; prev.next = null; &#125;else &#123; prev.next = prev.next.next; &#125; size--; return old; &#125; @Override public int indexOf(E element) &#123; if (element == null) &#123; for (int i = 0; i &lt; size; i++) &#123; if (node(i).element == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; size; i++) &#123; if (element.equals(node(i).element)) &#123; return i; &#125; &#125; &#125; return ELEMENT_NOT_FOUND; &#125; private Node&lt;E&gt; node(int index) &#123; Node&lt;E&gt; node; if (index == -1) &#123; node = first; &#125;else &#123; node = first.next; &#125; for (int i = 0; i &lt; index; i++) &#123; if (node.next == first) &#123; node = node.next.next; &#125; else &#123; node = node.next; &#125; &#125; return node; &#125;&#125; 双向循环链表 单节点时 add方法 头插和第一个节点特殊处理 remove方法 仅剩单节点时特殊处理 静态链表 优化虚拟头节点 感悟 虚拟头节点不是必须的，但加上的话会简化很多复杂的临界条件，在越复杂的链表中优势越明显 相当于多了两个固定的伪头和伪尾 链表本质就是一个个内存块通过地址串连起来 只要保存好地址值就可以按任意想要的规则重新连接 用虚拟头节点可以把上述四种类型的核心区别都封装到node方法内 其余方法完全可以实现复用 栈概述是一种操作受限的线性表 可以通过与动态数组或者链表组合来快速实现 亦或者基于数组和Node自己实现 接口设计 实现1234567891011121314151617181920212223242526272829303132333435package com.guardwarm;import com.guardwarm.list.ArrayList;import com.guardwarm.list.List;public class Stack&lt;E&gt; &#123; // 通过组合比继承更合理，这样只提供需要的接口 private List&lt;E&gt; list = new ArrayList&lt;&gt;(); public void clear() &#123; list.clear(); &#125; public int size() &#123; return list.size(); &#125; public boolean isEmpty() &#123; return list.isEmpty(); &#125; public void push(E element) &#123; list.add(element); &#125; public E pop() &#123; return list.remove(list.size() - 1); &#125; public E top() &#123; return list.get(list.size() - 1); &#125;&#125; 应用浏览器的前进后退 队列概述 接口设计 普通实现123456789101112131415161718192021222324package com.guardwarm.demo2;public class Queue&lt;E&gt; &#123; // 通过组合双向链表来实现功能 List&lt;E&gt; list = new NonSingleLinkedList&lt;&gt;(); public int size() &#123; return list.size(); &#125; public boolean isEmpty() &#123; return list.isEmpty(); &#125; public void clear() &#123; list.clear(); &#125; public void enQueue(E element) &#123; list.add(list.size(), element); &#125; public E deQueue() &#123; return list.remove(0); &#125; public E front() &#123; return list.get(0); &#125;&#125; 用栈实现 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.guardwarm.demo;import com.guardwarm.demo2.Stack;/** * @author wh */public class QueueStack&lt;E&gt; &#123; private Stack&lt;E&gt; inStack = new Stack&lt;&gt;(); private Stack&lt;E&gt; outStack = new Stack&lt;&gt;(); public int size() &#123; return inStack.size() + outStack.size(); &#125; public boolean isEmpty() &#123; return inStack.isEmpty() &amp;&amp; outStack.isEmpty(); &#125; public void enQueue(E element) &#123; inStack.push(element); &#125; public E deQueue() &#123; checkOutStack(); return outStack.pop(); &#125; public E front() &#123; checkOutStack(); return outStack.peek(); &#125; private void checkOutStack() &#123; if (outStack.isEmpty()) &#123; if (inStack.isEmpty()) &#123; throw new IndexOutOfBoundsException(); &#125;else &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125; &#125; &#125;&#125; 双端队列和普通队列很像，不补充具体代码了 循环队列基于数组实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.guardwarm.demo2;/** * @author asus */@SuppressWarnings("unused")public class CircleQueue&lt;E&gt; &#123; private int size; private E[] elements; private static final int DEFAULT_CAPACITY = 10; private int front; public CircleQueue() &#123; this(DEFAULT_CAPACITY); &#125; public CircleQueue(int capacity) &#123; front = 0; capacity = Math.max(capacity, DEFAULT_CAPACITY); elements = (E[]) new Object[capacity]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[index(i)] = null; &#125; size = 0; front = 0; &#125; private void ensureCapacity() &#123; if (size == elements.length) &#123; int newCapacity = size + (size &gt;&gt; 1); E[] newElements = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElements[i] = elements[index(i)]; &#125; elements = newElements; front = 0; &#125; &#125; public E front() &#123; return elements[front]; &#125; public void enQueue(E element) &#123; ensureCapacity(); elements[index(size)] = element; // 前面操作会用到front，所以front要最后修改 front = index(-1); size++; &#125; public E deQueue() &#123; E old = elements[front]; elements[front] = null; size --; front = index(1); return old; &#125; private int index(int index) &#123; index += front; if (index &lt; 0) &#123; return index + elements.length; &#125; // %效率低，由于index一定&gt;0 且 &lt;2length，故可如下优化 return index - (index &gt;= elements.length ? elements.length : 0); &#125;&#125; 循环双端队列和数组优化很像，不过是少了在中间添加和删除 无需增加成员保存rear指，rear可以通过front+size-1来获取 优化%运算符优化 哈希表原型 概述 哈希冲突 JDK1.8的解决方案 哈希函数 哈希值生成 选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：31 * i == (i &lt;&lt; 5) - i，现代的 Java 虚拟机可以自动的完成这个优化。正如 Goodrich 和 Tamassia 指出的那样，如果你对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个，所以在上面几个常数中，常数 31 被 Java 实现所选用也就不足为奇了。 装填因子 TreeMap Vs HashMap 实现1234567891011121314151617181920package com.guardwarm.map;@SuppressWarnings("unused")public interface Map&lt;K, V&gt; &#123; int size(); boolean isEmpty(); void clear(); boolean containsKey(K key); boolean containsValue(V value); V get(K key); V put(K key, V value); V remove(K key); void traversal(Visit&lt;K, V&gt; visit); abstract class Visit&lt;K, V&gt; &#123; boolean stop; public abstract boolean visit(K key, V value); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655package com.guardwarm.map;import com.guardwarm.printer.BinaryTreeInfo;import com.guardwarm.printer.BinaryTrees;import java.util.Arrays;import java.util.LinkedList;import java.util.Objects;import java.util.Queue;@SuppressWarnings("unused")public class HashMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private int size; private static final boolean RED = false; private static final boolean BLACK = true; private Node&lt;K, V&gt;[] table; private static final int DEFAULT_CAPACITY = 1 &lt;&lt; 4; private static final float DEFAULT_LOAD_FACTOR = 0.75f; public HashMap() &#123; this(DEFAULT_CAPACITY); &#125; public HashMap(int capacity) &#123; capacity = Math.max(capacity, DEFAULT_CAPACITY); table = new Node[capacity]; &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public void clear() &#123; if (size == 0) &#123; return; &#125; // 将数组内的引用清空 Arrays.fill(table, null); size = 0; &#125; @Override public V get(K key) &#123; Node&lt;K, V&gt; node = node(key); return node != null ? node.value : null; &#125; @Override public V put(K key, V value) &#123; resize(); int index = index(key); Node&lt;K, V&gt; root = table[index]; if (root == null) &#123; root = createNode(key, value, null); table[index] = root; size++; fixAfterPut(root); return null; &#125; Node&lt;K, V&gt; parent = root; Node&lt;K, V&gt; node = root; int cmp = 0; K k2; int h2; Node&lt;K, V&gt; result = null; int h1 = hash(key); boolean searched = false; do &#123; parent = node; k2 = node.key; h2 = node.hash; if (h1 &gt; h2) &#123; cmp = 1; &#125;else if (h1 &lt; h2) &#123; cmp = -1; &#125;else if (Objects.equals(key, k2)) &#123; cmp = 0; &#125;else if (key != null &amp;&amp; k2 != null &amp;&amp; key.getClass() == k2.getClass() &amp;&amp; key instanceof Comparable &amp;&amp; (cmp = ((Comparable)key).compareTo(k2)) != 0) &#123; &#125;else if (searched) &#123; cmp = System.identityHashCode(key) - System.identityHashCode(k2); &#125;else &#123; if ((node.left != null &amp;&amp; (result = node(node.left, key)) != null) || (node.right != null &amp;&amp; (result = node(node.right, key)) != null)) &#123; node = result; cmp = 0; &#125;else &#123; searched = true; cmp = System.identityHashCode(key) - System.identityHashCode(k2); &#125; &#125; if (cmp &gt; 0) &#123; node = node.right; &#125;else if (cmp &lt; 0) &#123; node = node.left; &#125;else &#123; V oldValue = node.value; node.key = key; node.value = value; node.hash = h1; return oldValue; &#125; &#125;while (node != null); Node&lt;K, V&gt; newNode = createNode(key, value, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125;else &#123; parent.left = newNode; &#125; size++; fixAfterPut(newNode); return null; &#125; @Override public V remove(K key) &#123; return remove(node(key)); &#125; protected V remove(Node&lt;K, V&gt; node) &#123; if (node == null) &#123; return null; &#125; size--; Node&lt;K, V&gt; willNode = node; V oldValue = node.value; if (node.hasTwoChild()) &#123; Node&lt;K, V&gt; success = successor(node); node.key = success.key; node.value = success.value; node.hash = success.hash; node = success; &#125; // node度必为0或1 但度为1时左右节点都有可能 Node&lt;K, V&gt; replacement = node.left != null ? node.left : node.right; int index = index(node); if (replacement != null) &#123; replacement.parent = node.parent; if (node.parent == null) &#123; table[index] = replacement; &#125; else if (node.isLeftChild()) &#123; node.parent.left = replacement; &#125; else &#123; node.parent.right = replacement; &#125; fixAfterRemove(replacement); &#125; else if (node.parent == null) &#123; // 度为0且是根节点 table[index] = null; &#125; else &#123; // 度为0且不是根节点 if (node.isLeftChild()) &#123; node.parent.left = null; &#125; else &#123; node.parent.right = null; &#125; fixAfterRemove(node); &#125; afterRemove(willNode, node); return oldValue; &#125; @Override public boolean containsKey(K key) &#123; return node(key) != null; &#125; @Override public boolean containsValue(V value) &#123; if (size == 0) &#123; return false; &#125; Queue&lt;Node&lt;K, V&gt;&gt; queue = new LinkedList&lt;&gt;(); for (Node&lt;K, V&gt; kvNode : table) &#123; if (kvNode == null) &#123; continue; &#125; queue.offer(kvNode); while (!queue.isEmpty()) &#123; Node&lt;K, V&gt; node = queue.poll(); if (Objects.equals(value, node.value)) &#123; return true; &#125; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; &#125; return false; &#125; /** * 对哈希表进行扩容 * 本质：遍历所有节点，将其移动到新表 */ private void resize() &#123; if (size / table.length &lt;= DEFAULT_LOAD_FACTOR) &#123; return; &#125; Node&lt;K, V&gt;[] oldTable = table; table = new Node[oldTable.length &lt;&lt; 1]; Queue&lt;Node&lt;K,V&gt;&gt; queue = new LinkedList&lt;&gt;(); Node&lt;K,V&gt; tempNode; for (Node&lt;K, V&gt; node : oldTable) &#123; if (node == null) &#123; continue; &#125; queue.offer(node); while (!queue.isEmpty()) &#123; tempNode = queue.poll(); if (tempNode.left != null) &#123; queue.offer(tempNode.left); &#125; if (tempNode.right != null) &#123; queue.offer(tempNode.right); &#125; // 先将左右节点入队再移动节点 moveNode(tempNode); &#125; &#125; &#125; private void moveNode(Node&lt;K, V&gt; newNode) &#123; // 将节点的k，v之外的属性重置 newNode.parent = null; newNode.left = null; newNode.right = null; newNode.color = RED; int index = index(newNode); Node&lt;K, V&gt; root = table[index]; if (root == null) &#123; root = newNode; table[index] = root; fixAfterPut(root); return; &#125; Node&lt;K, V&gt; parent = root; Node&lt;K, V&gt; node = root; int cmp = 0; K k1 = newNode.key; int h1 = newNode.hash; do &#123; parent = node; K k2 = node.key; int h2 = node.hash; if (h1 &gt; h2) &#123; cmp = 1; &#125;else if (h1 &lt; h2) &#123; cmp = -1; // 这是在移动，所以原数据中不可能存在相等覆盖的情况 &#125;else if (k1 != null &amp;&amp; k2 != null &amp;&amp; k1.getClass() == k2.getClass() &amp;&amp; k1 instanceof Comparable &amp;&amp; (cmp = ((Comparable)k1).compareTo(k2)) != 0) &#123; &#125;else &#123; cmp = System.identityHashCode(k1) - System.identityHashCode(k2); &#125; if (cmp &gt; 0) &#123; node = node.right; &#125;else &#123; // 从上面走下来不可能出现==0的情况 node = node.left; &#125; &#125;while (node != null); newNode.parent = parent; if (cmp &gt; 0) &#123; parent.right = newNode; &#125;else &#123; parent.left = newNode; &#125; fixAfterPut(newNode); &#125; protected Node&lt;K, V&gt; createNode(K key, V value, Node&lt;K, V&gt; parent) &#123; return new Node&lt;&gt;(key, value, parent); &#125; protected void afterRemove(Node&lt;K, V&gt; willNode, Node&lt;K, V&gt; removeNode) &#123;&#125; /** * 根据key获取其在桶中位置 * @param key 存储的键 * @return 桶中的位置索引 */ private int index(K key) &#123; return hash(key) &amp; (table.length - 1); &#125; private int hash(K key) &#123; if (key == null) &#123; return 0; &#125; int hash = key.hashCode(); return hash ^ (hash &gt;&gt;&gt; 16); &#125; private int index(Node&lt;K, V&gt; node) &#123; return (node.hash &amp; (table.length - 1)); &#125; private Node&lt;K, V&gt; node(K key) &#123; Node&lt;K, V&gt; root = table[index(key)]; return root == null ? null : node(root, key); &#125; private Node&lt;K,V&gt; node(Node&lt;K, V&gt; node, K key) &#123; int h1 = hash(key); Node&lt;K, V&gt; result = null; int cmp; K k2; int h2; // 存放时按一定规则存放，取出时再按这个规则查找，可以极大提高效率 while (node != null) &#123; k2 = node.key; h2 = node.hash; if (h1 &gt; h2) &#123; node = node.right; &#125;else if (h1 &lt; h2) &#123; node = node.left; &#125;else if (Objects.equals(key, k2))&#123; return node; &#125;else if (key != null &amp;&amp; k2 != null &amp;&amp; key.getClass() == k2.getClass() &amp;&amp; key instanceof Comparable &amp;&amp; (cmp = ((Comparable) key).compareTo(k2)) != 0) &#123; node = cmp &gt; 0 ? node.right : node.left; &#125;else if (node.right != null &amp;&amp; (result = node(node.right, key)) != null) &#123; return result; &#125;else &#123; node = node.left; &#125; &#125; return null; &#125; protected Node&lt;K, V&gt; successor(Node&lt;K, V&gt; node) &#123; if (node == null) &#123; return null; &#125; node = node.right; if (node != null) &#123; while (node.left != null) &#123; node = node.left; &#125; return node; &#125; else &#123; while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; return node.parent; &#125; &#125; private void rotateRight(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.left; Node&lt;K, V&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; private void rotateLeft(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.right; Node&lt;K, V&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; private void afterRotate(Node&lt;K, V&gt; grand, Node&lt;K, V&gt; parent, Node&lt;K, V&gt; child) &#123; parent.parent = grand.parent; if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125; else if (grand.isLeftChild()) &#123; grand.parent.left = parent; &#125; else &#123; // table[index(grand)]等价于这棵树的根节点 table[index(grand)] = parent; &#125; if (child != null) &#123; child.parent = grand; &#125; grand.parent = parent; &#125; protected void fixAfterPut(Node&lt;K, V&gt; node) &#123; Node&lt;K, V&gt; parent = node.parent; if (parent == null) &#123; // 即使不断上溢到根节点，根节点也还是原来那个根节点 // 只需染色，无需更改root指向 black(node); return; &#125; if (isBlack(parent)) &#123; return; &#125; Node&lt;K, V&gt; uncle = parent.sibling(); Node&lt;K, V&gt; grand = parent.parent; if (isRed(uncle)) &#123; black(parent); black(uncle); fixAfterPut(red(grand)); return; &#125; if (parent.isLeftChild()) &#123; if (node.isLeftChild()) &#123; black(parent); &#125; else &#123; black(node); rotateLeft(parent); &#125; rotateRight(red(grand)); &#125; else &#123; if (node.isRightChild()) &#123; black(parent); &#125; else &#123; black(node); rotateRight(parent); &#125; rotateLeft(red(grand)); &#125; &#125; private void fixAfterRemove(Node&lt;K, V&gt; node) &#123; if (isRed(node)) &#123; black(node); return; &#125; Node&lt;K, V&gt; parent = node.parent; // 删除的是根节点 if (parent == null) &#123; return; &#125; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;K, V&gt; sibling = left ? parent.right : parent.left; // 被删除的节点在左边，兄弟节点在右边 if (left) &#123; // 兄弟节点是红色 if (isRed(sibling)) &#123; black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; // 除非是一连串的黑色节点，这个才会反复调用 // 显然是不可能的 fixAfterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; sibling.color = colorOf(parent); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 // 兄弟节点是红色 if (isRed(sibling)) &#123; black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; fixAfterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; sibling.color = colorOf(parent); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125; @Override public void traversal(Visit&lt;K, V&gt; visitor) &#123; if (size == 0 || visitor == null) &#123; return; &#125; Queue&lt;Node&lt;K, V&gt;&gt; queue = new LinkedList&lt;&gt;(); for (Node&lt;K, V&gt; kvNode : table) &#123; if (kvNode == null) &#123; continue; &#125; queue.offer(kvNode); while (!queue.isEmpty()) &#123; Node&lt;K, V&gt; node = queue.poll(); if (visitor.visit(node.key, node.value)) &#123; return; &#125; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; &#125; &#125; private Node&lt;K, V&gt; red(Node&lt;K, V&gt; node) &#123; if (node != null) &#123; node.color = RED; &#125; return node; &#125; private Node&lt;K, V&gt; black(Node&lt;K, V&gt; node) &#123; if (node != null) &#123; node.color = BLACK; &#125; return node; &#125; private boolean colorOf(Node&lt;K, V&gt; node) &#123; return node == null ? BLACK : node.color; &#125; private boolean isBlack(Node&lt;K, V&gt; node) &#123; return colorOf(node) == BLACK; &#125; private boolean isRed(Node&lt;K, V&gt; node) &#123; return colorOf(node) == RED; &#125; public void print() &#123; if (size == 0) return; for (int i = 0; i &lt; table.length; i++) &#123; final Node&lt;K, V&gt; root = table[i]; System.out.println("【index = " + i + "】"); BinaryTrees.println(new BinaryTreeInfo() &#123; @Override public Object string(Object node) &#123; return node; &#125; @Override public Object root() &#123; return root; &#125; @Override public Object right(Object node) &#123; return ((Node&lt;K, V&gt;)node).right; &#125; @Override public Object left(Object node) &#123; return ((Node&lt;K, V&gt;)node).left; &#125; &#125;); System.out.println("---------------------------------------------------"); &#125; &#125; protected static class Node&lt;K, V&gt; &#123; // 在节点内保存会浪费空间，但可以节省重复计算hashcode的时间 int hash; K key; V value; boolean color = RED; Node&lt;K, V&gt; parent; Node&lt;K, V&gt; left; Node&lt;K, V&gt; right; public Node(K key, V value, Node&lt;K, V&gt; parent) &#123; int hash = key == null ? 0 : key.hashCode(); this.hash = hash ^ (hash &gt;&gt;&gt; 16); this.key = key; this.value = value; this.parent = parent; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; public boolean hasTwoChild() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public Node&lt;K, V&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125; @Override public String toString() &#123; return "Node_" + key + "_" + value; &#125; &#125;&#125; LinkedHashMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.guardwarm.map;import java.util.Objects;@SuppressWarnings("unused")public class LinkedHashMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; &#123; private LinkedNode&lt;K, V&gt; first; private LinkedNode&lt;K, V&gt; last; @Override public void clear() &#123; first = null; last = null; super.clear(); &#125; @Override public boolean containsValue(V value) &#123; LinkedNode&lt;K, V&gt; node = first; while (node != null) &#123; if (Objects.equals(value, node.value)) &#123; return true; &#125; node = node.next; &#125; return false; &#125; @Override protected void afterRemove(Node&lt;K, V&gt; willNode, Node&lt;K, V&gt; removeNode) &#123; if (willNode == null || removeNode == null) &#123; return; &#125; LinkedNode&lt;K, V&gt; node1 = (LinkedNode&lt;K, V&gt;) willNode; LinkedNode&lt;K, V&gt; node2 = (LinkedNode&lt;K, V&gt;) removeNode; // 如果删除的是有两个子节点的节点，发生了后继和原节点替换 // 此时需将两节点交换，不然删除后会改变原链表顺序 if (node1 != node2) &#123; LinkedNode&lt;K, V&gt; temp = node1.prev; node1.prev = node2.prev; node2.prev = temp; if (node1.prev == null) &#123; first = node1; &#125; else &#123; node1.prev.next = node1; &#125; if (node2.prev == null) &#123; first = node2; &#125; else &#123; node2.prev.next = node2; &#125; temp = node1.next; node1.next = node2.next; node2.next = temp; if (node1.next == null) &#123; last = node1; &#125; else &#123; node1.next.prev = node1; &#125; if (node2.next == null) &#123; last = node2; &#125; else &#123; node1.next.prev = node2; &#125; &#125; LinkedNode&lt;K, V&gt; prev = node2.prev; LinkedNode&lt;K, V&gt; next = node2.next; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; &#125; &#125; @Override public void traversal(Visit&lt;K, V&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; LinkedNode&lt;K, V&gt; node = first; while (node != null) &#123; if (visitor.visit(node.key, node.value)) &#123; return; &#125; node = node.next; &#125; &#125; @Override protected Node&lt;K, V&gt; createNode(K key, V value, Node&lt;K, V&gt; parent) &#123; LinkedNode&lt;K, V&gt; node = new LinkedNode&lt;&gt;(key, value, parent); if (first == null) &#123; first = last = node; &#125; else &#123; last.next = node; node.prev = last; last = node; &#125; return node; &#125; private static class LinkedNode&lt;K, V&gt; extends Node&lt;K, V&gt; &#123; LinkedNode&lt;K, V&gt; prev; LinkedNode&lt;K, V&gt; next; public LinkedNode(K key, V value, Node&lt;K, V&gt; parent) &#123; super(key, value, parent); &#125; &#125;&#125; %优化若哈希表长度为2的n次，则可以用&amp;代替 没有限制的话可以用如下最优素数 小细节put时的多次比较是为了按一定规律存放，这样可以大幅提升查找效率instanceof 一个类与另一个类相等或为其子类时都会返回true直接getclass比较，需要两个类完全相同才会返回true 树概述 二叉树概述 真二叉树所有节点的度要么为0，要么为2 满二叉树最后一层节点的度为0，其它节点的度都为2 完全二叉树 国外教程的定义 试题 接口设计 遍历前序遍历 迭代 法一 1234567891011121314151617Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();Node&lt;E&gt; node = root;while (true) &#123; if (node != null) &#123; if (visitor.visit(node.element)) &#123; return; &#125; if (node.right != null) &#123; stack.push(node.right); &#125; node = node.left; &#125;else if (stack.isEmpty()) &#123; return; &#125;else &#123; node = stack.pop(); &#125;&#125; 法二 1234567891011121314Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();stack.push(root);while (!stack.isEmpty()) &#123; Node&lt;E&gt; node = stack.pop(); if (visitor.visit(node.element)) &#123; return; &#125; if (node.right != null) &#123; stack.push(node.right); &#125; if (node.left != null) &#123; stack.push(node.left); &#125;&#125; 递归 123456if (node == null || visitor.stop) &#123; return;&#125;visitor.stop = visitor.visit(node.element);preorder(node.left, visitor);preorder(node.right, visitor); 中序遍历 迭代 12345678910111213141516Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();Node&lt;E&gt; node = root;while (true) &#123; if (node != null) &#123; stack.push(node); node = node.left; &#125;else if (stack.isEmpty()) &#123; return; &#125;else &#123; node = stack.pop(); if (visitor.visit(node.element)) &#123; return; &#125; node = node.right; &#125;&#125; 递归 123456789if (node == null || visitor.stop) &#123; return;&#125;inorder(node.left, visitor);if (visitor.stop) &#123; return;&#125;visitor.stop = visitor.visit(node.element);inorder(node.right, visitor); 后序遍历 迭代 1234567891011121314151617181920Node&lt;E&gt; prev = null;Stack&lt;Node&lt;E&gt;&gt; stack = new Stack&lt;&gt;();stack.push(root);while (!stack.isEmpty()) &#123; // 偷窥栈顶元素符合访问条件则访问，不符合则左右入栈 Node&lt;E&gt; top = stack.peek(); // 栈顶元素为叶子节点或者是之前弹出节点的父节点 if (top.isLeaf() || (prev != null &amp;&amp; prev.parent == top)) &#123; prev = stack.pop(); // 访问节点 if (visitor.visit(prev.element)) return; &#125; else &#123; if (top.right != null) &#123; stack.push(top.right); &#125; if (top.left != null) &#123; stack.push(top.left); &#125; &#125;&#125; 递归 123456789if (node == null || visitor.stop) &#123; return;&#125;postorder(node.left, visitor);postorder(node.right, visitor);if (visitor.stop) &#123; return;&#125;visitor.stop = visitor.visit(node.element); 层序遍历 设计遍历接口 初版 终版 应用 根据遍历结果重构二叉树 利用前序遍历树状打印 计算二叉树高度 递归 迭代 判断是否为完全二叉树 表达式树 前驱节点 后继节点 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343package com.guardwarm.treestruct;import com.guardwarm.printer.BinaryTreeInfo;import java.util.LinkedList;import java.util.Queue;public class BinaryTree&lt;E&gt; implements BinaryTreeInfo &#123; protected int size; protected Node&lt;E&gt; root; protected static class Node&lt;E&gt; &#123; E element; Node&lt;E&gt; parent; Node&lt;E&gt; left; Node&lt;E&gt; right; public Node(E element, Node&lt;E&gt; parent) &#123; this.element = element; this.parent = parent; &#125; public boolean isLeft() &#123; return this == parent.left; &#125; public boolean isRight() &#123; return this == parent.right; &#125; public boolean hasTwoChild() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; @Override public String toString() &#123; return "Node&#123;" + "element=" + element + '&#125;'; &#125; &#125; public static abstract class AbstractVisitor&lt;E&gt; &#123; /** * 为true时表示停止遍历 */ boolean stop; /** * 对元素经行什么处理 * * @param element 遍历到的元素 * @return 是否结束遍历 true则结束 */ public abstract boolean visit(E element); &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void preorder() &#123; preorder(root); &#125; private void preorder(Node&lt;E&gt; node) &#123; if (node == null) &#123; return; &#125; System.out.print(node.element); preorder(node.left); preorder(node.right); &#125; public void preorder(AbstractVisitor&lt;E&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; preorder(root, visitor); &#125; private void preorder(Node&lt;E&gt; node, AbstractVisitor&lt;E&gt; visitor) &#123; if (node == null || visitor.stop) &#123; return; &#125; visitor.stop = visitor.visit(node.element); preorder(node.left, visitor); preorder(node.right, visitor); &#125; public void inorder() &#123; inorder(root); &#125; private void inorder(Node&lt;E&gt; node) &#123; if (node == null) &#123; return; &#125; inorder(node.left); System.out.print(node.element); inorder(node.right); &#125; public void inorder(AbstractVisitor&lt;E&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; inorder(root, visitor); &#125; private void inorder(Node&lt;E&gt; node, AbstractVisitor&lt;E&gt; visitor) &#123; if (node == null || visitor.stop) &#123; return; &#125; inorder(node.left, visitor); if (visitor.stop) &#123; return; &#125; visitor.stop = visitor.visit(node.element); inorder(node.right, visitor); &#125; public void postorder() &#123; postorder(root); &#125; private void postorder(Node&lt;E&gt; node) &#123; if (node == null) &#123; return; &#125; postorder(node.left); postorder(node.right); System.out.print(node.element); &#125; public void postorder(AbstractVisitor&lt;E&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; postorder(root, visitor); &#125; private void postorder(Node&lt;E&gt; node, AbstractVisitor&lt;E&gt; visitor) &#123; if (node == null || visitor.stop) &#123; return; &#125; postorder(node.left, visitor); postorder(node.right, visitor); if (visitor.stop) &#123; return; &#125; visitor.stop = visitor.visit(node.element); &#125; public void levelOrder() &#123; if (root == null) &#123; return; &#125; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); Node&lt;E&gt; node; while (!queue.isEmpty()) &#123; node = queue.poll(); System.out.println(node); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; &#125; public void levelOrder(AbstractVisitor&lt;E&gt; visitor) &#123; if (root == null || visitor == null) &#123; return; &#125; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); Node&lt;E&gt; node; queue.offer(root); while (!queue.isEmpty()) &#123; node = queue.poll(); visitor.stop = visitor.visit(node.element); if (visitor.stop) &#123; break; &#125; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; &#125; public int height() &#123; if (root == null) &#123; return 0; &#125; Node&lt;E&gt; node = root; int height = 0; int levelCount = 1; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; node = queue.poll(); levelCount--; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; if (levelCount == 0) &#123; levelCount = queue.size(); height++; &#125; &#125; return height; &#125; private int height(Node&lt;E&gt; node) &#123; if (node == null) &#123; return 0; &#125; return 1 + Math.max(height(node.left), height((node.right))); &#125; protected Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123; if (node == null) &#123; return node; &#125; node = node.left; if (node != null) &#123; while (node.right != null) &#123; node = node.right; &#125; return node; &#125; else &#123; while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.parent == null // node == node.parent.right return node.parent; &#125; &#125; protected Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123; if (node == null) &#123; return null; &#125; node = node.right; if (node != null) &#123; while (node.left != null) &#123; node = node.left; &#125; return node; &#125; else &#123; while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; return node.parent; &#125; &#125; public void clear() &#123; root = null; size = 0; &#125; /** * 利用层序遍历访问所有节点 * 左右都不为空 无需处理，入队即可 * 左为空，右不为空 返回false * 左不为空，右为空 之后都是叶子节点 * 左右皆为空 之后必须全是叶子节点 * @return */ public boolean isCompleteBinaryTree() &#123; if (root == null) &#123; return false; &#125; Node&lt;E&gt; node; Queue&lt;Node&lt;E&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); boolean leaf = false; while (!queue.isEmpty()) &#123; node = queue.poll(); if (leaf &amp;&amp; !node.isLeaf()) &#123; return false; &#125; if (node.left != null) &#123; queue.offer(node.left); &#125;else if (node.right != null)&#123; return false; &#125; if (node.right != null) &#123; queue.offer(node.right); &#125;else &#123; // 处理左右为空和左不空有空 leaf = true; &#125; &#125; return true; &#125; @Override public Object root() &#123; return root; &#125; @Override public Object left(Object node) &#123; return ((BinarySearchTree.Node&lt;E&gt;) node).left; &#125; @Override public Object right(Object node) &#123; return ((BinarySearchTree.Node&lt;E&gt;) node).right; &#125; @Override public Object string(Object node) &#123; BinarySearchTree.Node&lt;E&gt; myNode = (BinarySearchTree.Node&lt;E&gt;) node; StringBuilder sb = new StringBuilder(); sb.append(myNode.element); sb.append("_"); if (myNode != root) &#123; sb.append(myNode.parent.element.toString()); &#125; else &#123; sb.append("null"); &#125; return sb; &#125;&#125; 二叉搜索树背景 概述 接口设计 实现添加方法 元素比较 打印二叉树 根据元素获取节点 删除 叶子节点 度为1的节点 度为二的节点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.guardwarm.treestruct;import com.guardwarm.printer.BinaryTreeInfo;import java.util.Comparator;import java.util.LinkedList;import java.util.Queue;/** * @author wh */@SuppressWarnings("unused")public class BinarySearchTree&lt;E&gt; extends BinaryTree &#123; private final Comparator&lt;E&gt; comparator; public BinarySearchTree() &#123; this(null); &#125; public BinarySearchTree(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator; &#125; public void add(E element) &#123; elementNotNullCheck(element); if (size == 0) &#123; root = new Node&lt;&gt;(element, null); size++; return; &#125; Node&lt;E&gt; node = root; Node&lt;E&gt; parent = root; int cmp = 0; while (node != null) &#123; parent = node; cmp = compare(element, node.element); if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp == 0) &#123; node.element = element; return; &#125; else &#123; node = node.left; &#125; &#125; if (cmp &gt; 0) &#123; parent.right = new Node&lt;&gt;(element, parent); &#125; else &#123; parent.left = new Node&lt;&gt;(element, parent); &#125; size++; &#125; private void elementNotNullCheck(E element) &#123; if (null == element) &#123; throw new IllegalArgumentException("element must not be null"); &#125; &#125; public boolean contains(E element) &#123; return node(element) != null; &#125; public void remove(E element) &#123; remove(node(element)); &#125; private void remove(Node&lt;E&gt; node) &#123; if (node == null) &#123; return; &#125; size--; if (node.hasTwoChild()) &#123; Node&lt;E&gt; success = successor(node); node.element = success.element; node = success; &#125; // node度必为0或1 但度为1时左右节点都有可能 Node&lt;E&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; replacement.parent = node.parent; if (node.parent == null) &#123; root = replacement; &#125; else if (node == node.parent.left) &#123; node.parent.left = replacement; &#125; else &#123; node.parent.right = replacement; &#125; &#125; else if (node.parent == null) &#123; root = null; &#125; else &#123; if (node == node.parent.left) &#123; node.parent.left = null; &#125;else &#123; node.parent.right = null; &#125; &#125; &#125; private Node&lt;E&gt; node(E element) &#123; elementNotNullCheck(element); Node&lt;E&gt; node = root; int cmp; while (node != null) &#123; cmp = compare(node.element, element); if (cmp == 0) &#123; break; &#125; else if (cmp &gt; 0) &#123; node = node.left; &#125; else &#123; node = node.right; &#125; &#125; return node; &#125; private int compare(E e1, E e2) &#123; if (comparator != null) &#123; return comparator.compare(e1, e2); &#125; return ((Comparable) e1).compareTo(e2); &#125; @Override public String toString() &#123; StringBuilder sb = new StringBuilder(); toString(root, sb, ""); return sb.toString(); &#125; private void toString(Node&lt;E&gt; node, StringBuilder sb, String prefix) &#123; if (node == null) &#123; return; &#125; sb.append(prefix).append(node.element).append("\n"); toString(node.left, sb, prefix + "L---"); toString(node.right, sb, prefix + "R---"); &#125;&#125; 平衡二叉搜索树复杂度分析 平衡 改进二叉搜索 常见平衡二叉搜索树 AVL树概述 对比 接口设计 添加导致的失衡 法一对如下四种情况分别进行左右旋 核心实在擦欧总grand，parent，和parent较低的一个子树 法二对法一的四种情况统一处理 删除导致的失衡 小结 示例 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.guardwarm.treestruct;import java.util.Comparator;/** * @author asus */@SuppressWarnings("unused")public class AvlTree&lt;E&gt; extends BinarySearchTree&lt;E&gt; &#123; public AvlTree() &#123; this(null); &#125; public AvlTree(Comparator&lt;E&gt; comparator) &#123; super(comparator); &#125; @Override protected void afterAdd(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalance(node)) &#123; updateHeight(node); &#125;else &#123; reBalance(node); break; &#125; &#125; &#125; @Override protected void afterRemove(Node&lt;E&gt; node) &#123; while ((node = node.parent) != null) &#123; if (isBalance(node)) &#123; updateHeight(node); &#125;else &#123; reBalance(node); &#125; &#125; &#125; private void reBalance(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = ((AvlNode&lt;E&gt;)grand).tallerChild(); Node&lt;E&gt; node = ((AvlNode&lt;E&gt;)parent).tallerChild(); if (parent.isLeftChild()) &#123; if (node == parent.left)&#123; rotateRight(grand); &#125;else &#123; rotateLeft(parent); rotateRight(grand); &#125; &#125;else &#123; if (node == parent.left) &#123; rotateRight(parent); &#125; rotateLeft(grand); &#125; &#125; private void rotateRight(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; private void rotateLeft(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; private void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) &#123; parent.parent = grand.parent; if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125;else if (grand.isLeftChild())&#123; grand.parent.left = parent; &#125;else &#123; root = parent; &#125; if (child != null) &#123; child.parent = grand; &#125; grand.parent = parent; // 由于更新内部没有使用递归，所以使用的时候需先更新子树 updateHeight(grand); updateHeight(parent); &#125; private void updateHeight(Node&lt;E&gt; node) &#123; ((AvlNode&lt;E&gt;)node).updateHeight(); &#125; private boolean isBalance(Node&lt;E&gt; node) &#123; return Math.abs(((AvlNode&lt;E&gt;)node).balanceFactor()) &lt;= 1; &#125; private static class AvlNode&lt;E&gt; extends Node&lt;E&gt; &#123; int height = 1; public AvlNode(E element, Node&lt;E&gt; parent) &#123; super(element, parent); &#125; public int balanceFactor() &#123; int leftHeight = left == null ? 0 : ((AvlNode&lt;E&gt;) left).height; int rightHeight = right == null ? 0 : ((AvlNode&lt;E&gt;) right).height; return leftHeight - rightHeight; &#125; public void updateHeight() &#123; int leftHeight = left == null ? 0 : ((AvlNode&lt;E&gt;) left).height; int rightHeight = right == null ? 0 : ((AvlNode&lt;E&gt;) right).height; height = 1 + Math.max(leftHeight, rightHeight); &#125; public Node&lt;E&gt; tallerChild() &#123; int leftHeight = left == null ? 0 : ((AvlNode&lt;E&gt;) left).height; int rightHeight = right == null ? 0 : ((AvlNode&lt;E&gt;) right).height; if (leftHeight &gt; rightHeight) &#123; return left; &#125; else if (leftHeight &lt; rightHeight) &#123; return right; &#125; else &#123; return this == parent.left ? left : right; &#125; &#125; @Override public String toString() &#123; String parentString = "null"; if (parent != null) &#123; parentString = parent.element.toString(); &#125; return element + "_p(" + parentString + ")_h(" + height + ")"+balanceFactor(); &#125; &#125; @Override protected Node&lt;E&gt; createNewNode(E element, Node&lt;E&gt; parent) &#123; return new AvlNode&lt;&gt;(element, parent); &#125;&#125; B树概述 增删查 四阶B树 红黑树概述 辅助函数 添加节点概述 恢复平衡根据uncle是否为RED判断是否会发生上溢 未发生上溢 发生上溢 发生上溢后只需染色，将上溢节点当作新添加节点 所以可能会执行logn级别的染色，但只会执行O（1）级别旋转（在新节点未发生上溢时执行） 删除节点概述 删除红色节点 删除黑色节点 度为1的黑色节点 叶子节点 平衡 平均时间复杂度 与AVL树比较 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.guardwarm.treestruct;import java.util.Comparator;public class BalanceBinarySearchTree&lt;E&gt; extends BinarySearchTree&lt;E&gt; &#123; public BalanceBinarySearchTree() &#123; this(null); &#125; public BalanceBinarySearchTree(Comparator&lt;E&gt; comparator) &#123; super(comparator); &#125; protected void rotateRight(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = grand.left; Node&lt;E&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; protected void rotateLeft(Node&lt;E&gt; grand) &#123; Node&lt;E&gt; parent = grand.right; Node&lt;E&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; protected void afterRotate(Node&lt;E&gt; grand, Node&lt;E&gt; parent, Node&lt;E&gt; child) &#123; parent.parent = grand.parent; if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125;else if (grand.isLeftChild())&#123; grand.parent.left = parent; &#125;else &#123; root = parent; &#125; if (child != null) &#123; child.parent = grand; &#125; grand.parent = parent; &#125; protected void rotate( Node&lt;E&gt; r, // 子树的根节点 Node&lt;E&gt; b, Node&lt;E&gt; c, Node&lt;E&gt; d, Node&lt;E&gt; e, Node&lt;E&gt; f) &#123; // 让d成为这棵子树的根节点 d.parent = r.parent; if (r.isLeftChild()) &#123; r.parent.left = d; &#125; else if (r.isRightChild()) &#123; r.parent.right = d; &#125; else &#123; root = d; &#125; //b-c b.right = c; if (c != null) &#123; c.parent = b; &#125; // e-f f.left = e; if (e != null) &#123; e.parent = f; &#125; // b-d-f d.left = b; d.right = f; b.parent = d; f.parent = d; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package com.guardwarm.treestruct;import java.util.Comparator;@SuppressWarnings("unused")public class RBTree&lt;E&gt; extends BalanceBinarySearchTree&lt;E&gt; &#123; private static final boolean RED = false; private static final boolean BLACK = true; public RBTree() &#123; this(null); &#125; public RBTree(Comparator&lt;E&gt; comparator) &#123; super(comparator); &#125; private static class RBNode&lt;E&gt; extends Node&lt;E&gt; &#123; boolean color = RED; public RBNode(E element, Node&lt;E&gt; parent) &#123; super(element, parent); &#125; @Override public String toString() &#123; String str = color == RED ? "R_" : ""; return str + element.toString(); &#125; &#125; @Override protected Node&lt;E&gt; createNewNode(E element, Node&lt;E&gt; parent) &#123; return new RBNode&lt;&gt;(element, parent); &#125; private boolean isRed(Node&lt;E&gt; node) &#123; return colorOf(node) == RED; &#125; private boolean isBlack(Node&lt;E&gt; node) &#123; return colorOf(node) == BLACK; &#125; private boolean colorOf(Node&lt;E&gt; node) &#123; return node == null ? BLACK : ((RBNode&lt;E&gt;)node).color; &#125; private Node&lt;E&gt; color(Node&lt;E&gt; node, boolean color) &#123; if (node == null) &#123; return null; &#125; ((RBNode&lt;E&gt;)node).color = color; return node; &#125; private Node&lt;E&gt; red(Node&lt;E&gt; node) &#123; return color(node, RED); &#125; private Node&lt;E&gt; black(Node&lt;E&gt; node) &#123; return color(node, BLACK); &#125; @Override protected void afterAdd(Node&lt;E&gt; node) &#123; Node&lt;E&gt; parent = node.parent; if (parent == null) &#123; // 即使不断上溢到根节点，根节点也还是原来那个根节点 // 只需染色，无需更改root指向 black(node); return; &#125; if (isBlack(parent)) &#123; return; &#125; Node&lt;E&gt; uncle = parent.sibling(); Node&lt;E&gt; grand = parent.parent; if (isRed(uncle)) &#123; black(parent); black(uncle); afterAdd(red(grand)); return; &#125; if (parent.isLeftChild()) &#123; if (node.isLeftChild()) &#123; black(parent); &#125;else &#123; black(node); rotateLeft(parent); &#125; rotateRight(red(grand)); &#125;else &#123; if (node.isRightChild()) &#123; black(parent); &#125;else &#123; black(node); rotateRight(parent); &#125; rotateLeft(red(grand)); &#125; &#125; @Override protected void afterRemove(Node&lt;E&gt; node) &#123; Node&lt;E&gt; parent = node.parent; // 删除的是根节点 if (parent == null) return; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;E&gt; sibling = left ? parent.right : parent.left; if (left) &#123; // 被删除的节点在左边，兄弟节点在右边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; // 除非是一连串的黑色节点，这个才会反复调用 // 显然是不可能的 afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; color(sibling, colorOf(parent)); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 if (isRed(sibling)) &#123; // 兄弟节点是红色 black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; color(sibling, colorOf(parent)); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125;&#125; 集合 TreeSet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.guardwarm.set;import com.guardwarm.treestruct.BinaryTree;import com.guardwarm.treestruct.RBTree;import java.util.Comparator;public class TreeSet&lt;E&gt; implements Set&lt;E&gt;&#123; private final RBTree&lt;E&gt; rbTree; public TreeSet() &#123; rbTree = new RBTree&lt;&gt;(); &#125; public TreeSet(Comparator&lt;E&gt; comparator) &#123; rbTree = new RBTree&lt;&gt;(comparator); &#125; public int size() &#123; return rbTree.size(); &#125; public boolean isEmpty() &#123; return rbTree.isEmpty(); &#125; @Override public void clear() &#123; rbTree.clear(); &#125; @Override public boolean contains(E element) &#123; return rbTree.contains(element); &#125; @Override public void add(E element) &#123; rbTree.add(element); &#125; @Override public void remove(E element) &#123; rbTree.remove(element); &#125; @Override public void traversal(final Visitor&lt;E&gt; visitor) &#123; rbTree.inorder(new BinaryTree.AbstractVisitor&lt;E&gt;() &#123; @Override public boolean visit(E element) &#123; return visitor.visit(element); &#125; &#125;); &#125;&#125; ListSet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.guardwarm.set;import java.util.LinkedList;public class ListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private int size; private LinkedList&lt;E&gt; list; public ListSet() &#123; list = new LinkedList&lt;&gt;(); &#125; @Override public int size() &#123; return list.size(); &#125; @Override public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public void clear() &#123; list.clear(); &#125; @Override public boolean contains(E element) &#123; return list.contains(element); &#125; @Override public void add(E element) &#123; int index = list.indexOf(element); if (index != -1) &#123; list.set(index, element); &#125; else &#123; list.add(element); &#125; &#125; @Override public void remove(E element) &#123; list.remove(element); &#125; @Override public void traversal(Visitor&lt;E&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; for (E e : list) &#123; visitor.visit(e); &#125; &#125;&#125; 基于TreeMap实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mj.set;import com.mj.map.Map;import com.mj.map.TreeMap;public class TreeSet&lt;E&gt; implements Set&lt;E&gt; &#123; Map&lt;E, Object&gt; map = new TreeMap&lt;&gt;(); @Override public int size() &#123; return map.size(); &#125; @Override public boolean isEmpty() &#123; return map.isEmpty(); &#125; @Override public void clear() &#123; map.clear(); &#125; @Override public boolean contains(E element) &#123; return map.containsKey(element); &#125; @Override public void add(E element) &#123; map.put(element, null); &#125; @Override public void remove(E element) &#123; map.remove(element); &#125; @Override public void traversal(Visitor&lt;E&gt; visitor) &#123; map.traversal(new Map.Visitor&lt;E, Object&gt;() &#123; public boolean visit(E key, Object value) &#123; return visitor.visit(key); &#125; &#125;); &#125;&#125; 映射概述 接口设计 TreeMap分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459package com.guardwarm.map;import java.util.Comparator;import java.util.LinkedList;import java.util.Queue;/** * @author wh * @param &lt;K&gt; 键类型 * @param &lt;V&gt; 值类型 */@SuppressWarnings("unused")public class TreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private int size; private static final boolean RED = false; private static final boolean BLACK = true; private final Comparator&lt;K&gt; comparator; private Node&lt;K, V&gt; root; public TreeMap(Comparator&lt;K&gt; comparator) &#123; this.comparator = comparator; &#125; public TreeMap() &#123; this(null); &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public void clear() &#123; root = null; size = 0; &#125; @Override public boolean containsKey(K key) &#123; return node(key) != null; &#125; @Override public boolean containsValue(V value) &#123; if (root == null) &#123; return false; &#125; Queue&lt;Node&lt;K, V&gt;&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); Node&lt;K, V&gt; node; while (!queue.isEmpty()) &#123; node = queue.poll(); if (valEquals(value, node.value)) &#123; return true; &#125; if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; return false; &#125; private boolean valEquals(V v1, V v2) &#123; return v1 == null ? v2 == null : v1.equals(v2); &#125; @Override public V get(K key) &#123; Node&lt;K, V&gt; node = node(key); return node != null ? node.value : null; &#125; @Override public V put(K key, V value) &#123; keyNotNullCheck(key); if (size == 0) &#123; root = new Node&lt;&gt;(key, value, null); size++; afterPut(root); return null; &#125; Node&lt;K, V&gt; node = root; Node&lt;K, V&gt; parent = root; int cmp = 0; while (node != null) &#123; parent = node; cmp = compare(key, node.key); if (cmp &gt; 0) &#123; node = node.right; &#125; else if (cmp == 0) &#123; node.key = key; V oldValue = node.value; node.value = value; return oldValue; &#125; else &#123; node = node.left; &#125; &#125; Node&lt;K, V&gt; newNode = new Node&lt;&gt;(key, value, parent); if (cmp &gt; 0) &#123; parent.right = newNode; &#125; else &#123; parent.left = newNode; &#125; size++; afterPut(newNode); return null; &#125; @Override public V remove(K key) &#123; return remove(node(key)); &#125; private V remove(Node&lt;K,V&gt; node) &#123; if (node == null) &#123; return null; &#125; size--; V oldValue = node.value; if (node.hasTwoChild()) &#123; Node&lt;K, V&gt; success = successor(node); node.key = success.key; node.value = success.value; node = success; &#125; // node度必为0或1 但度为1时左右节点都有可能 Node&lt;K, V&gt; replacement = node.left != null ? node.left : node.right; if (replacement != null) &#123; replacement.parent = node.parent; if (node.parent == null) &#123; root = replacement; &#125; else if (node.isLeftChild()) &#123; node.parent.left = replacement; &#125; else &#123; node.parent.right = replacement; &#125; afterRemove(replacement); &#125; else if (node.parent == null) &#123; // 度为0且是根节点 root = null; &#125; else &#123; // 度为0且不是根节点 if (node.isLeftChild()) &#123; node.parent.left = null; &#125;else &#123; node.parent.right = null; &#125; afterRemove(node); &#125; return oldValue; &#125; private void afterRemove(Node&lt;K, V&gt; node) &#123; Node&lt;K, V&gt; parent = node.parent; // 删除的是根节点 if (parent == null) &#123; return; &#125; // 删除的是黑色叶子节点【下溢】 // 判断被删除的node是左还是右 boolean left = parent.left == null || node.isLeftChild(); Node&lt;K, V&gt; sibling = left ? parent.right : parent.left; // 被删除的节点在左边，兄弟节点在右边 if (left) &#123; // 兄弟节点是红色 if (isRed(sibling)) &#123; black(sibling); red(parent); rotateLeft(parent); // 更换兄弟 sibling = parent.right; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; // 除非是一连串的黑色节点，这个才会反复调用 // 显然是不可能的 afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.right)) &#123; rotateRight(sibling); sibling = parent.right; &#125; sibling.color = colorOf(parent); black(sibling.right); black(parent); rotateLeft(parent); &#125; &#125; else &#123; // 被删除的节点在右边，兄弟节点在左边 // 兄弟节点是红色 if (isRed(sibling)) &#123; black(sibling); red(parent); rotateRight(parent); // 更换兄弟 sibling = parent.left; &#125; // 兄弟节点必然是黑色 if (isBlack(sibling.left) &amp;&amp; isBlack(sibling.right)) &#123; // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并 boolean parentBlack = isBlack(parent); black(parent); red(sibling); if (parentBlack) &#123; afterRemove(parent); &#125; &#125; else &#123; // 兄弟节点至少有1个红色子节点，向兄弟节点借元素 // 兄弟节点的左边是黑色，兄弟要先旋转 if (isBlack(sibling.left)) &#123; rotateLeft(sibling); sibling = parent.left; &#125; sibling.color = colorOf(parent); black(sibling.left); black(parent); rotateRight(parent); &#125; &#125; &#125; @Override public void traversal(Visit&lt;K, V&gt; visitor) &#123; if (visitor == null) &#123; return; &#125; traversal(root, visitor); &#125; private void traversal(Node&lt;K,V&gt; node, Visit&lt;K,V&gt; visitor) &#123; if (node == null || visitor.stop) &#123; return; &#125; traversal(node.left, visitor); if (visitor.stop) &#123; return; &#125; visitor.visit(node.key, node.value); traversal(node.right, visitor); &#125; private Node&lt;K, V&gt; node(K key) &#123; Node&lt;K, V&gt; node = root; int cmp; while (node != null) &#123; cmp = compare(key, node.key); if (cmp &gt; 0) &#123; node = node.right; &#125;else if (cmp &lt; 0) &#123; node = node.left; &#125;else &#123; return node; &#125; &#125; return null; &#125; protected void afterPut(Node&lt;K, V&gt; node) &#123; Node&lt;K, V&gt; parent = node.parent; if (parent == null) &#123; // 即使不断上溢到根节点，根节点也还是原来那个根节点 // 只需染色，无需更改root指向 black(node); return; &#125; if (isBlack(parent)) &#123; return; &#125; Node&lt;K, V&gt; uncle = parent.sibling(); Node&lt;K, V&gt; grand = parent.parent; if (isRed(uncle)) &#123; black(parent); black(uncle); afterPut(red(grand)); return; &#125; if (parent.isLeftChild()) &#123; if (node.isLeftChild()) &#123; black(parent); &#125;else &#123; black(node); rotateLeft(parent); &#125; rotateRight(red(grand)); &#125;else &#123; if (node.isRightChild()) &#123; black(parent); &#125;else &#123; black(node); rotateRight(parent); &#125; rotateLeft(red(grand)); &#125; &#125; protected Node&lt;K, V&gt; predecessor(Node&lt;K, V&gt; node) &#123; if (node == null) &#123; return null; &#125; node = node.left; if (node != null) &#123; while (node.right != null) &#123; node = node.right; &#125; return node; &#125; else &#123; while (node.parent != null &amp;&amp; node == node.parent.left) &#123; node = node.parent; &#125; // node.parent == null // node == node.parent.right return node.parent; &#125; &#125; protected Node&lt;K, V&gt; successor(Node&lt;K, V&gt; node) &#123; if (node == null) &#123; return null; &#125; node = node.right; if (node != null) &#123; while (node.left != null) &#123; node = node.left; &#125; return node; &#125; else &#123; while (node.parent != null &amp;&amp; node == node.parent.right) &#123; node = node.parent; &#125; return node.parent; &#125; &#125; private void rotateRight(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.left; Node&lt;K, V&gt; child = parent.right; grand.left = child; parent.right = grand; afterRotate(grand, parent, child); &#125; private void rotateLeft(Node&lt;K, V&gt; grand) &#123; Node&lt;K, V&gt; parent = grand.right; Node&lt;K, V&gt; child = parent.left; grand.right = child; parent.left = grand; afterRotate(grand, parent, child); &#125; private void afterRotate(Node&lt;K,V&gt; grand, Node&lt;K,V&gt; parent, Node&lt;K,V&gt; child) &#123; parent.parent = grand.parent; if (grand.isRightChild()) &#123; grand.parent.right = parent; &#125;else if (grand.isLeftChild())&#123; grand.parent.left = parent; &#125;else &#123; root = parent; &#125; if (child != null) &#123; child.parent = grand; &#125; grand.parent = parent; &#125; private Node&lt;K, V&gt; red(Node&lt;K, V&gt; node) &#123; node.color = RED; return node; &#125; private Node&lt;K, V&gt; black(Node&lt;K, V&gt; node) &#123; node.color = BLACK; return node; &#125; private boolean colorOf(Node&lt;K, V&gt; node) &#123; return node == null ? BLACK : node.color; &#125; private boolean isBlack(Node&lt;K, V&gt; node) &#123; return colorOf(node) == BLACK; &#125; private boolean isRed(Node&lt;K, V&gt; node) &#123; return colorOf(node) == RED; &#125; private int compare(K k1, K k2) &#123; if (comparator != null) &#123; return comparator.compare(k1, k2); &#125; //noinspection unchecked return ((Comparable&lt;K&gt;)k1).compareTo(k2); &#125; private void keyNotNullCheck(K key) &#123; if (key == null) &#123; throw new IllegalArgumentException("key must not be null"); &#125; &#125; private static class Node&lt;K, V&gt; &#123; K key; V value; boolean color = RED; Node&lt;K, V&gt; parent; Node&lt;K, V&gt; left; Node&lt;K, V&gt; right; public Node(K key, V value, Node&lt;K, V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; public boolean isLeftChild() &#123; return parent != null &amp;&amp; this == parent.left; &#125; public boolean isRightChild() &#123; return parent != null &amp;&amp; this == parent.right; &#125; public boolean hasTwoChild() &#123; return left != null &amp;&amp; right != null; &#125; public boolean isLeaf() &#123; return left == null &amp;&amp; right == null; &#125; public Node&lt;K, V&gt; sibling() &#123; if (isLeftChild()) &#123; return parent.right; &#125; if (isRightChild()) &#123; return parent.left; &#125; return null; &#125; &#125;&#125; 二叉堆背景 概述 接口设计 获取最大值 添加 优化 删除 replace 批量建堆自上而下的上滤 自下而上的下滤 效率对比 实现aaa 1234567891011package com.guardwarm.heap;public interface Heap&lt;E&gt; &#123; int size(); boolean isEmpty(); void clear(); void add(E element); E get(); E remove(); E replace(E element);&#125; 1234567891011121314151617181920212223242526272829303132package com.guardwarm.heap;import java.util.Comparator;public abstract class AbstractHeap&lt;E&gt; implements Heap&lt;E&gt; &#123; protected int size; protected Comparator&lt;E&gt; comparator; public AbstractHeap() &#123; this(null); &#125; public AbstractHeap(Comparator&lt;E&gt; comparator) &#123; this.comparator = comparator; &#125; @Override public int size() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @SuppressWarnings("unchecked") protected int compare(E e1, E e2) &#123; return comparator != null ? comparator.compare(e1, e2) : ((Comparable&lt;E&gt;)e1).compareTo(e2); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179package com.guardwarm.heap;import com.guardwarm.printer.BinaryTreeInfo;import java.util.Comparator;/** * 二叉堆（最大堆） * @param &lt;E&gt; 存放的数据类型 * @author wh */@SuppressWarnings(&#123;"unused", "unchecked"&#125;)public class BinaryHeap&lt;E&gt; extends AbstractHeap&lt;E&gt; implements BinaryTreeInfo &#123; E[] elements; private static final int DEFAULT_CAPACITY = 10; public BinaryHeap() &#123; this(null, null); &#125; public BinaryHeap(E[] elements) &#123; this(elements, null); &#125; public BinaryHeap(Comparator&lt;E&gt; comparator) &#123; this(null, comparator); &#125; public BinaryHeap(E[] elements, Comparator&lt;E&gt; comparator) &#123; super(comparator); if (elements == null || elements.length == 0) &#123; this.elements = (E[]) new Object[DEFAULT_CAPACITY]; &#125;else &#123; size = elements.length; int capacity = Math.max(DEFAULT_CAPACITY, size); this.elements = (E[]) new Object[capacity]; System.arraycopy(elements, 0, this.elements, 0, size); heapify(); &#125; &#125; private void heapify() &#123; for (int i = (size &gt;&gt; 1); i &gt;= 0; i--) &#123; siftDown(i); &#125;// for (int i = 0; i &lt; size; i++) &#123;// siftUp(i);// &#125; &#125; @Override public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elements[i] = null; &#125; size = 0; &#125; @Override public void add(E element) &#123; elementNotCheck(element); ensureCapacity(); elements[size++] = element; siftUp(size - 1); &#125; @Override public E get() &#123; emptyCheck(); return elements[0]; &#125; @Override public E remove() &#123; emptyCheck(); E oldValue = elements[0]; elements[0] = elements[--size]; elements[size] = null; siftDown(0); return oldValue; &#125; @Override public E replace(E element) &#123; elementNotCheck(element); E oldValue = null; if (size == 0) &#123; elements[size++] = element; &#125;else &#123; oldValue = elements[0]; elements[0] = element; siftDown(0); &#125; return oldValue; &#125; private void ensureCapacity() &#123; if (size == elements.length) &#123; // +优先级高于&gt;&gt; int newCapacity = size + (size &gt;&gt; 1); E[] newEles = (E[]) new Object[newCapacity]; System.arraycopy(elements, 0, newEles, 0, size); elements = newEles; &#125; &#125; private void emptyCheck() &#123; if (size == 0) &#123; throw new IndexOutOfBoundsException("Heap is empty"); &#125; &#125; private void elementNotCheck(E element) &#123; if (element == null) &#123; throw new IllegalArgumentException("element must not be null"); &#125; &#125; private void siftUp(int index) &#123; E e = elements[index]; int parentIndex; E parent; while (index &gt; 0) &#123; parentIndex = (index - 1) &gt;&gt; 1; parent = elements[parentIndex]; if (compare(parent, e) &gt;= 0) &#123; break; &#125; elements[index] = parent; index = parentIndex; &#125; elements[index] = e; &#125; private void siftDown(int index) &#123; E e = elements[index]; int leftIndex; int rightIndex; int half = size &gt;&gt; 1; E eLeft; while (index &lt; half) &#123; leftIndex = 2 * index + 1; rightIndex = leftIndex + 1; eLeft = elements[leftIndex]; if (rightIndex &lt; size &amp;&amp; compare(eLeft, elements[rightIndex]) &lt; 0) &#123; eLeft = elements[leftIndex = rightIndex]; &#125; if (compare(eLeft, e) &lt;= 0) &#123; break; &#125; elements[index] = eLeft; index = leftIndex; &#125; elements[index] = e; &#125; @Override public Object root() &#123; return 0; &#125; @Override public Object left(Object node) &#123; int index = ((int)node &lt;&lt; 1) + 1; return index &lt; size ? index : null; &#125; @Override public Object right(Object node) &#123; int index = ((int)node &lt;&lt; 1) + 2; return index &lt; size ? index : null; &#125; @Override public Object string(Object node) &#123; return elements[(int)node]; &#125;&#125; 小顶堆默认实现为大顶堆 只需更改比较函数，将较小的数作为较大的数即可 TOP K 问题 优先级队列概述 实现 123456789101112131415161718192021222324252627282930313233343536373839package com.guardwarm.heap;import java.util.Comparator;public class PriorityQueue&lt;E&gt; &#123; private BinaryHeap&lt;E&gt; heap; public PriorityQueue(Comparator&lt;E&gt; comparator) &#123; heap = new BinaryHeap&lt;&gt;(comparator); &#125; public PriorityQueue() &#123; this(null); &#125; public int size() &#123; return heap.size(); &#125; public boolean isEmpty() &#123; return heap.isEmpty(); &#125; public void clear() &#123; heap.clear(); &#125; public E front() &#123; return heap.get(); &#125; public E deQueue() &#123; return heap.remove(); &#125; public void inQueue(E element) &#123; heap.add(element); &#125;&#125; 作业 哈夫曼树背景 概述 总结]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2020%2F04%2F26%2Fmkw%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理]]></title>
    <url>%2F2020%2F04%2F26%2Fmkw%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2020%2F04%2F26%2Fmkw%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[概述定义计算机网络是由一些通用的可编程的硬件互连而成，通过这些硬件，可以传输不同类型的数据，并且可以支持广泛且日益增长的应用 不是软件概念，还包含硬件 不仅仅是信息传输，还包含应用支持 分类作用范围 使用者 公用网络 专用网络 发展简史互联网 中国互联网 计网的层次结构层次结构设计的基本原则 各层之间相互独立 各层具备足够的灵活性 各层完全解耦 OSI七层模型想成为统一标准，但由于制定时间过长，且缺乏实际经验，部分层之间有些功能重复，而没有占据到市场 TCP/IP四层模型 网络拓扑网络拓扑(Network Topology)结构是指用传输介质互连各种设备的物理布局。指构成网络的成员间特定的物理的即真实的、或者逻辑的即虚拟的排列方式。如果两个网络的连接结构相同我们就说它们的网络拓扑相同，尽管它们各自内部的物理接线、节点间距离可能会有不同。 边缘部分 核心部分 实际网络 C/S模式 P2P模式 性能指标 速率 时延 发送时延 传输时延 排队时延 数据包在网络设备中等待被处理的时间 处理时延 数据到达设备或目标机器被处理所花费的时间 往返时间RTT 数据报文在端到端通信中来回一次的时间 用ping命令来查看 网络接口层物理层作用 连接不同的物理设备 还有红外线，无线，激光等 传输比特流 物理特性 机械特性，电气特性，功能特性，过程特性 信道定义 往一个方向传送信息的媒体 一个通信电路包含一个接收信道和一个发送信道 分类 单工信道 只能往一个方向通信，没有反方向反馈的信道 有线电视，无线电收音机等 半双工信道 双方都可以发送和接收，但不能同时发送或接收 全双工信道（主流） 双方可以同时发送或接收 分用-复用技术提高信道利用率 数据链路层封装成帧 “帧”是数据链路层数据的基本单位 发送端在网络层的一段数据前后添加特定标记形成“帧” 接收端根据前后特定标记识别出“帧” 透明传输即使控制字符在帧数据中，也要当作不存在去处理 差错监测 奇偶校验码 循环冗余校验码 根据传输或保存的数据而产生固定位数的校验码的方法 CRC的纠错能力与位串阶数r有关 数据链路层仅进行数据的检测，不进行纠正 最大传输单元MTUMaximum Transmission Unit 数据帧的最大长度 数据帧过大过小都会影响传输效率，以太网MTU一般为1500字节 路径MTU MAC地址 以太网协议数据链路层使用广泛的局域网技术，可以完成相邻设备的数据帧传输 只能在相邻设备间通过MAC地址表传输数据，跨设备传输需要网络层协议 网络层数据路由——决定数据在网络中的路径 IP协议虚拟互连网络 IP协议使得复杂的实际网络变为一个虚拟的互连网络 IP协议使得网络层可以屏蔽底层细节而专注网络层的数据转发 IP协议解决了在虚拟网络中数据报传输路径的问题 IP地址 IP协议首部 字段 作用 4位版本 指的是IP协议的版本——IPv4/IPv6 4位首部位长度 表示IP首部长度，单位是32字节，即IP首部最大长度为60字节 8位服务类型（TOS） 16位总长度 IP数据报总长度，最大为65535（MTU） 16位标识 3位标志 是否可以分片 13位片偏移 当前数据帧保存的第几个偏移数据 8位TTL IP数据报文在网络中的寿命，每经过一个设备，TTL-1，TTL为0时，丢弃报文 8位协议 IP数据所携带的数据具体是什么协议的 16位首部校验和 校验数据在传输过程中是否出错 32位源IP地址 32位目标IP地址 子网划分IP地址的分类 特殊主机号 主机号全0表示当前网络段，不可分配为待定主机 主机号全1表示广播地址 特殊的网络号 划分子网按类分配IP会造成较大浪费，划分子网来进一步精确的分配IP 无分类编址CIDR 、 NAT技术Network Address Translation 网络地址转换 早期对于IP地址规划不合理，造成了很大浪费，导致IP不够用 用于多个主机通过一个公有IP访问互联网 减缓了IP地址消耗，但是增加了网络通信的复杂度 ICMP协议Internet Control Message Protocol 国际控制报文协议 报告错误信息或者异常情况 报文格式 应用 ping 结合ICMP的请求报文实现 traceroute 结合TTL实现 ARP协议Address Resolution Protocol 地址解析协议 ARP缓存表由于IP多为动态分配，所以这个缓存会定时更新 arp -a 在命令行中查看本机缓存 没有缓存时，将广播此IP信息，从回应数据中获取MAC地址，并将其缓存 报文格式 RARP协议Reverse Address Resolution Protocol 逆地址解析协议 现在不常用了 报文格式 路由路由表简介 转发流程 数据帧每一跳的MAC地址都在变化 IP数据报每一跳的IP始终不变 自治系统Autonomous System 一个自治系统（AS）是处于一个管理机构下的网络设备群 AS内部网络自行管理，对外提供一个或多个出入口 协议分类 AS内部路由协议——內部网关协议（RIP、OSPF） AS外部路由协议——外部网关协议（BGP） 路由算法要求 算法是正确的，完整的 算法在计算上应尽可能的简单 算法可以适应网络中的变化 算法是稳定，公平的 距离矢量（DV）算法 每个节点维护Di,Si Di描述的是当前节点到别的节点的距离 Si描述的是前期节点到别的节点的下一个节点 每个节点与相邻节点交换Di,Si 每个节点根据交换的信息更新自己的节点信息 Dijkstra算法迪杰斯特拉 Dijkstra算法是著名的图论算法 解决有权图从一个节点到其它节点的最短路径算法 以起始点为中心，向外层层拓展 …… 协议RIP协议 概述 具体过程 问题 ​ 实现简单，开销小 ​ 但限制了网络规模（但本身作为内网协议还行），主要是错误数据传递慢 链路状态(LS)协议 像内网所有路由器都发送消息 消息描述该路由器与相邻路由器的链路状态 距离 时延 带宽 …… 比RIP的跳数精确很多 只有链路状态发生变化时，才更新信息 只是一套规则 OSPF协议对LS协议的具体实现 BGP协议Border Gateway Protocol 边际网关协议 运行在AS间的一种协议 互联网规模很大 不同AS的内网协议可能不同 AS间还需考虑一些网络特性外的因素（政治，安全…） BGP协议需要综合考虑各种因素后，找到一条较好的路由 传输层进程通信 UDPUser Datagram Protocol 用户数据报协议 对应用层数据不进行合并或拆分 特点 无连接协议 不保证可靠交付数据 面向报文传输，对应用层数据不进行处理 没有拥塞控制 首部开销很小（8字节） TCPTransmission Control Protocol 传输控制协议 面向连接 一个连接有两端(点对点通信) 提供可靠的传输服务 提供全双工的通信 面向字节流的协议 协议首部 字段 作用 16位源端口 源进程 16位目的端口 目的进程 序号 一个字节一个序号，数据报首字节序号 确认号 期望收到的首字节序号确认号为N，表示N-1的数据都已收到 4位数据偏移 单位是32位字，数据偏离首部的字节数由此得出首部最多为60字节 保留字段 还未使用的字段 6位TCP标记 16位窗口 表明允许对方发送的数据量 校验和 紧急指针 紧急数据（URG=1），指定紧急数据在报文的位置 TCP选项 最多40字节，数据缺失时定位或支持未来的拓展 可靠传输基于连续ARQ协议 滑动窗口以字节为单位 若后面字节已收到，但前面字节未收到，可以通过选择重传来提高传输效率 指定需要重传的字节 每个字节都有唯一的32位序号 保存在TCP选项中，TCP选项最多可以存10个序号，即五段 流量控制由于接收速率有限，让发送方发送数据别太快 通过滑动窗口实现流量控制 坚持定时器 当接收方收到窗口为0的消息时启动，每隔一段时间发送一个窗口探测报文 拥塞控制流量控制是点对点的，即两台机器间 拥塞控制需要考虑整个网络，全局性的考虑 三次握手 为什么需要第三次握手 避免已失效的连接请求报文传递到对方，引起错误 三次握手的话发送方对于迟到的确认不做处理，从而避免重复建立连接 四次挥手 等待计时器 停止等待协议每发送一个消息，都设置一个超时定时器，保证可靠传输 发送消息在路上丢失 接收消息在路上丢失 接收消息由于拥塞等很久才到 这个协议很简单，但对信道利用效率不高 连续ARQ协议Automatic Repeat reQuest 自动重传请求 套接字及套接字编程建议网络传输数据时使用本地的话域套接字，共享内存等更高效]]></content>
      <categories>
        <category>imooc</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效编程]]></title>
    <url>%2F2020%2F04%2F19%2Fmkw%2F%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程背景 面向对象过分强调“必须通过对象的形式来做事情” ​ 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情. 函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。 ​ 将行为参数化，来直接处理数据，而不是必须先有对象，再有行为 Lambda概述 java8引入函数式编程风格 将行为参数化传递 凡可推导的皆可省略 使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。 使用Lambda必须具有上下文推断 标准格式 一些参数 一个箭头 一段代码 1(参数类型 参数名称) -&gt; &#123; 代码语句 &#125; 格式说明： 小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。 -&gt;是新引入的语法格式，代表指向动作。 大括号内的语法与传统方法体要求基本一致。 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号 用途 作为参数来替代匿名函数，但二者原理不同 作为返回值，用对应接口来接收 示例12345678910public class Demo06Comparator &#123; private static Comparator&lt;String&gt; newComparator() &#123; return (a, b) ‐&gt; b.length() ‐ a.length(); &#125; public static void main(String[] args) &#123; String[] array = &#123; "abc", "ab", "abcd" &#125;; Arrays.sort(array, new Comparator()); &#125;&#125; 123456789public class Demo04Runnable &#123; private static void startThread(Runnable task) &#123; new Thread(task).start(); &#125; public static void main(String[] args) &#123; startThread(() ‐&gt; System.out.println("线程任务执行！")); &#125;&#125; 函数式接口概述 接口中只有一个抽象方法 使用@FunctionalInterface来校验 函数式接口的抽象方法签名：函数描述符 内置接口 常用的 更多接口自行去java.util.function 包下查阅 示例12345678910111213141516171819public void test_Supplier() &#123; // 使用Supplier接口实现方法,只有一个get方法，无参数，返回一个值 Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() &#123; @Override public Integer get() &#123; //返回一个随机值 return new Random().nextInt(); &#125; &#125;; System.out.println(supplier.get()); // 使用lambda表达式， supplier = () -&gt; new Random().nextInt(); System.out.println(supplier.get()); // 使用方法引用 Supplier&lt;Double&gt; supplier2 = Math::random; System.out.println(supplier2.get());&#125; Consumer接口的andThen方法 12345678910111213141516171819// 源码default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;;&#125;// 举例import java.util.function.Consumer; public class Demo10ConsumerAndThen &#123; private static void consumeString(Consumer&lt;String&gt; one, Consumer&lt;String&gt; two) &#123; one.andThen(two).accept("Hello"); &#125; public static void main(String[] args) &#123; consumeString( s ‐&gt; System.out.println(s.toUpperCase()), s ‐&gt; System.out.println(s.toLowerCase())); &#125;&#125; Predicate的and，or，negate方法 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.List;import java.util.function.Predicate; public class DemoPredicate &#123; public static void main(String[] args) &#123; String[] array = &#123; "迪丽热巴,女", "古力娜扎,女", "马尔扎哈,男", "赵丽颖,女" &#125;; List&lt;String&gt; list = filter(array, s ‐&gt; "女".equals(s.split(",")[1]), s ‐&gt; s.split(",")[0].length() == 4); System.out.println(list); &#125; private static List&lt;String&gt; filter(String[] array, Predicate&lt;String&gt; one, Predicate&lt;String&gt; two) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String info : array) &#123; if (one.and(two).test(info)) &#123; list.add(info); &#125; &#125; return list; &#125;&#125; 方法引用概述调用特定方法的lambda表达式的快捷写法 即重复使用现有方法定义，并像lambda表达式一样传递 格式：目标引用::方法名 示例 流编程概述从支持数据处理操作的源生成的元素序列 JDK1.8引入新成员，已声明式方式处理集合数据 将基础操作连接起来，完成复杂的数据流水线操作 提供透明的并行处理 流与集合区别 时间(流)与空间(集合) 可以构建一个无限大的流，但不能创建一个无限大的集合 只能遍历一次 内部迭代(流)与外部迭代(集合) 构建1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /** * 由数值直接构建流 */ @Test public void streamFromValue() &#123; Stream stream = Stream.of(1, 2, 3, 4, 5); stream.forEach(System.out::println); &#125; /** * 通过数组构建流 */ @Test public void streamFromArray() &#123; int[] numbers = &#123;1, 2, 3, 4, 5&#125;; IntStream stream = Arrays.stream(numbers); stream.forEach(System.out::println); &#125; /** * 通过集合元素构建流 */ @Test public void streamFromCollection() &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream1 = list.stream(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); Stream&lt;String&gt; stream2 = set.stream(); Vector&lt;String&gt; vector = new Vector&lt;&gt;(); Stream&lt;String&gt; stream3 = vector.stream(); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;String&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream(); &#125; /** * 通过文件生成流 * @throws IOException */ @Test public void streamFromFile() throws IOException &#123; // TODO 此处替换为本地文件的地址全路径 String filePath = ""; Stream&lt;String&gt; stream = Files.lines( Paths.get(filePath)); stream.forEach(System.out::println); &#125; /** * 通过函数生成流（无限流） * 一般会用limit截取一部分 */ @Test public void streamFromFunction() &#123;// Stream stream = Stream.iterate(0, n -&gt; n + 2); Stream stream = Stream.generate(Math::random); stream.limit(100) .forEach(System.out::println); &#125; 常用操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * flatMap使用：将一个对象转换成流 */ @Test public void flatMapTest() &#123; list.stream() // flatMap .flatMap(sku -&gt; Arrays.stream( sku.getSkuName().split(""))) .forEach(item -&gt; System.out.println(JSON.toJSONString(item, true))); &#125;/** * peek使用：对流中元素进行遍历操作，与forEach类似，但不会销毁流元素 */ /** * sort使用：对流中元素进行排序，可选则自然排序或指定排序规则。有状态操作 */ @Test public void sortTest() &#123; list.stream() .peek(sku -&gt; System.out.println(sku.getSkuName())) //sort .sorted(Comparator.comparing(Sku::getTotalPrice)) .forEach(System.out::println); &#125; /** * distinct使用：对流元素进行去重。有状态操作 */ @Test public void distinctTest() &#123; list.stream() .map(sku -&gt; sku.getSkuCategory()) // distinct .distinct() &#125; /** * allMatch使用：终端操作，短路操作。所有元素匹配，返回true */ @Test public void allMatchTest() &#123; boolean match = list.stream() .peek(sku -&gt; System.out.println(sku.getSkuName())) // allMatch .allMatch(sku -&gt; sku.getTotalPrice() &gt; 100); System.out.println(match); &#125;/** * 找到第一个 */ @Test public void findFirstTest() &#123; Optional&lt;Sku&gt; optional = list.stream() .peek(sku -&gt; System.out.println(sku.getSkuName())) // findFirst .findFirst(); System.out.println( JSON.toJSONString(optional.get(), true)); &#125; /** * 找任意一个 串行时等价于findFirst()，并行时找到的未必是第一个 */ @Test public void findAnyTest() &#123; Optional&lt;Sku&gt; optional = list.stream() .peek(sku -&gt; System.out.println(sku.getSkuName())) // findAny .findAny(); System.out.println( JSON.toJSONString(optional.get(), true)); &#125; /** * max使用： */ @Test public void maxTest() &#123; OptionalDouble optionalDouble = list.stream() // 获取总价 .mapToDouble(Sku::getTotalPrice) .max(); System.out.println(optionalDouble.getAsDouble()); &#125; /** * count使用 */ @Test public void countTest() &#123; long count = list.stream() .count(); System.out.println(count); &#125; 收集器概述 将流中元素累积成一个结果 作用于终端操作collect()上 Collector 规定的接口 Collectors 工具类，Collector接口的具体实现 功能 将流元素归约和汇总为一个值 将流元素分组 将流元素分区 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 集合收集器 */ @Test public void toList() &#123; List&lt;Sku&gt; list = CartService.getCartSkuList(); List&lt;Sku&gt; result = list.stream() .filter(sku -&gt; sku.getTotalPrice() &gt; 100) .collect(Collectors.toList()); System.out.println( JSON.toJSONString(result, true)); &#125; /** * 分组 */ @Test public void group() &#123; List&lt;Sku&gt; list = CartService.getCartSkuList(); // Map&lt;分组条件，结果集合&gt; Map&lt;Object, List&lt;Sku&gt;&gt; group = list.stream() .collect( Collectors.groupingBy( sku -&gt; sku.getSkuCategory())); System.out.println( JSON.toJSONString(group, true)); &#125; /** * 分区 相当于分组的一种特殊情况 */ @Test public void partition() &#123; List&lt;Sku&gt; list = CartService.getCartSkuList(); Map&lt;Boolean, List&lt;Sku&gt;&gt; partition = list.stream() .collect(Collectors.partitioningBy( sku -&gt; sku.getTotalPrice() &gt; 100)); System.out.println( JSON.toJSONString(partition, true)); &#125; 效果对比传统foreach1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void oldCartHandle() &#123; List&lt;Sku&gt; cartSkuList = CartService.getCartSkuList(); /** * 1 打印所有商品 */ for (Sku sku: cartSkuList) &#123; System.out.println(JSON.toJSONString(sku, true)); &#125; /** * 2 图书类过滤掉 */ List&lt;Sku&gt; notBooksSkuList = new ArrayList&lt;Sku&gt;(); for (Sku sku: cartSkuList) &#123; if (!SkuCategoryEnum.BOOKS.equals(sku.getSkuCategory())) &#123; notBooksSkuList.add(sku); &#125; &#125; /** * 排序 */ notBooksSkuList.sort(new Comparator&lt;Sku&gt;() &#123; @Override public int compare(Sku sku1, Sku sku2) &#123; if (sku1.getTotalPrice() &gt; sku2.getTotalPrice()) &#123; return -1; &#125; else if (sku1.getTotalPrice() &lt; sku2.getTotalPrice()) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; &#125;); /** * TOP2 */ List&lt;Sku&gt; top2SkuList = new ArrayList&lt;Sku&gt;(); for (int i = 0; i &lt; 2; i++) &#123; top2SkuList.add(notBooksSkuList.get(i)); &#125; /** * 4 求两件商品的总价 */ Double money = 0.0; for (Sku sku: top2SkuList) &#123; // money = money + sku.getTotalPrice(); money += sku.getTotalPrice(); &#125; /** * 获取两件商品的名称 */ List&lt;String&gt; resultSkuNameList = new ArrayList&lt;String&gt;(); for (Sku sku: top2SkuList) &#123; resultSkuNameList.add(sku.getSkuName()); &#125; /** * 打印输入结果 */ System.out.println( JSON.toJSONString(resultSkuNameList, true)); System.out.println("商品总价：" + money); &#125; Stream+Lambda1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void newCartHandle() &#123; AtomicReference&lt;Double&gt; money = new AtomicReference&lt;&gt;(Double.valueOf(0.0)); List&lt;String&gt; resultSkuNameList = CartService.getCartSkuList() .stream() /** * 1 打印商品信息 */ .peek(sku -&gt; System.out.println( JSON.toJSONString(sku, true))) /** * 2 过滤掉所有图书类商品 */ .filter(sku -&gt; !SkuCategoryEnum.BOOKS.equals( sku.getSkuCategory())) /** * 排序 */ .sorted(Comparator. comparing(Sku::getTotalPrice).reversed()) /** * TOP2 */ .limit(2) /** * 累加商品总金额 */ .peek(sku -&gt; money.set(money.get() + sku.getTotalPrice())) /** * 获取商品名称 */ .map(sku -&gt; sku.getSkuName()) /** * 收集结果 */ .collect(Collectors.toList()); /** * 打印输入结果 */ System.out.println( JSON.toJSONString(resultSkuNameList, true)); System.out.println("商品总价：" + money.get()); &#125; 资源关闭效果对比传统方式123456789101112131415// 关闭流资源if (targetFileOutputStream != null) &#123; try &#123; targetFileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;if (originalFileInputStream != null) &#123; try &#123; originalFileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; JDK7新特性try - with - resource 是一种语法糖，底层还是通过逐一关闭来实现 多资源自动关闭，但需要实现AutoCloseable接口 并且通过异常追加来避免异常屏蔽 1234567891011121314151617181920212223// 先定义输入/输出路径String originalUrl = "lib/NewFileCopyTest.java";String targetUrl = "targetTest/new.txt";// 初始化输入/输出流对象try ( FileInputStream originalFileInputStream = new FileInputStream(originalUrl); FileOutputStream targetFileOutputStream = new FileOutputStream(targetUrl);) &#123; int content; // 迭代，拷贝数据 while ((content = originalFileInputStream.read()) != -1) &#123; targetFileOutputStream.write(content); &#125;&#125; catch (FileNotFoundException e) &#123; e.printStackTrace();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 背景垃圾回收特点 只负责回收堆内存资源 无法精确控制回收时间 垃圾回收之前会先调用finalize来确认是否是垃圾 需手动释放的资源 文件/流 套接字 数据库连接 不释放的后果 长时间资源无效占用 系统无法正常运行 超过最大限制后，系统将无资源可用 资源关闭顺序 先开后关 从外到内 底层资源单独声明 特例 资源对象被return时由调用方关闭 socket获取的输入输出流无需关闭 ByteArrayInputStream等无需关闭 Optional受Guava启发，JDK1.8新加特性，用于避免空值 创建12345678// 创建空的Optional对象Optional.empty();// 使用非null值创建Optional对象Optional.of("zhangxiaoxi");// 使用任意值创建Optional对象Optional optional = Optional.ofNullable("zhangxiaoxi"); 常用方法12345678910111213141516171819202122/** * 判断是否引用缺失的方法(不建议直接使用) */optional.isPresent();/** * 当optional引用存在时执行 * 类似的方法：map filter flatMap */optional.ifPresent(System.out::println);/** * 当optional引用缺失时执行 */optional.orElse("引用缺失");optional.orElseGet(() -&gt; &#123; // 自定义引用缺失时的返回值，可扩展性更高 return "自定义引用缺失";&#125;);optional.orElseThrow(() -&gt; &#123; throw new RuntimeException("引用缺失异常");&#125;); 结合Stream12345// 非空会执行map，为空则执行orElseGet为其赋值Optional.ofNullable(list) .map(List::stream) .orElseGet(Stream::empty) .forEach(System.out::println); Guava概述Guava is a set of core Java libraries from Google that includes new collection types (such as multimap and multiset), immutable collections, a graph library, and utilities for concurrency, I/O, hashing, caching, primitives, strings, and more! It is widely used on most Java projects within Google, and widely used by many other companies as well. github仓库 Maven依赖123456&lt;!-- Guava 引入 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;28.0-jre&lt;/version&gt;&lt;/dependency&gt; 不可变集合合理使用不可变集合是一种很好的防御性编程技巧 安全 不存在竞态条件 节省时间和空间 可以做为常量来使用 JDK提供的 笨重而且累赘 不安全 低效 123456List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(1);list.add(2);List&lt;Integer&gt; newList = Collections.unmodifiableList(list); Guava的12345678910111213141516171819List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();list.add(1);list.add(2);/** * 构造不可变集合对象三种方式 */// 通过已经存在的集合创建ImmutableSet.copyOf(list);// 通过初始值，直接创建不可变集合ImmutableSet immutableSet = ImmutableSet.of(1, 2, 3);// 以builder方式创建ImmutableSet.builder() .add(1) .addAll(Sets.newHashSet(2, 3)) .add(4) .build(); 新集合类型Guava对原生集合类型进行了补充 Multiset 两面性没有元素顺序限制的ArrayList add：添加单个给定元素 iterator：返回所有元素（包括重复元素） size：返回所有元素的总个数（包括重复元素） 键为元素，值为计数的Map count：返回给定元素的计数 entrySet：和Map的entrySet类似 elementSet：返回所有不重复元素的Set，和Map的keySet类似 与Map区别 元素计数只能是正数 multiset.size返回集合大小（包含重复元素） multiset.iterator会迭代重复元素 multiset支持直接设置元素的计数 没有的元素，multiset.count为0 具体实现 HashMultiset TreeMultiset LinkedHashMultiset ConcurrentHashMultiset ImmutableMultiset 示例12345678910111213141516171819202122232425private static final String text = "《南陵别儿童入京》" + "白酒新熟山中归，黄鸡啄黍秋正肥。" + "呼童烹鸡酌白酒，儿女嬉笑牵人衣。" + "高歌取醉欲自慰，起舞落日争光辉。" + "游说万乘苦不早，著鞭跨马涉远道。" + "会稽愚妇轻买臣，余亦辞家西入秦。" + "仰天大笑出门去，我辈岂是蓬蒿人。"; @Test public void handle() &#123; // multiset创建 Multiset&lt;Character&gt; multiset = HashMultiset.create(); // string 转换成 char 数组 char[] chars = text.toCharArray(); // 遍历数组，添加到multiset中 Chars.asList(chars) .stream() .forEach(charItem -&gt; &#123; multiset.add(charItem); &#125;); System.out.println("size : " + multiset.size()); System.out.println("count : " + multiset.count('人')); &#125; 集合工具类Sets 并集 交集 差集 相对差集 拆分子集 计算笛卡尔积 12345678910111213141516171819202122232425262728293031323334353637383940private static final Set set1 = Sets.newHashSet(1, 2);private static final Set set2 = Sets.newHashSet(4);// 并集@Testpublic void union() &#123; Set&lt;Integer&gt; set = Sets.union(set1, set2);&#125;// 交集@Testpublic void intersection() &#123; Set&lt;Integer&gt; set = Sets.intersection(set1, set2);&#125;// 差集：如果元素属于A而且不属于B@Testpublic void difference() &#123; Set&lt;Integer&gt; set = Sets.difference(set1, set2); // 相对差集：属于A而且不属于B 或者 属于B而且不属于A 等价于两个差集的并集 set = Sets.symmetricDifference(set1, set2);&#125;// 获取该集合所有子集@Testpublic void powerSet() &#123; Set&lt;Set&lt;Integer&gt;&gt; powerSet = Sets.powerSet(set1);&#125;// 计算两个集合笛卡尔积@Testpublic void cartesianProduct() &#123; Set&lt;List&lt;Integer&gt;&gt; product = Sets.cartesianProduct(set1, set2);&#125; Lists 分割 反转 12345678910111213141516171819/** * 拆分成指定长度的子集合 */@Testpublic void partition() &#123; List&lt;Integer&gt; list = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7); List&lt;List&lt;Integer&gt;&gt; partition = Lists.partition(list, 3);&#125;// 反转@Testpublic void reverse() &#123; List&lt;Integer&gt; list = Lists.newLinkedList(); list.add(1); List&lt;Integer&gt; newList = Lists.reverse(list);&#125; IO工具类概述 对字节流/字符流提供的工具方法 对流的封装，需手动关闭 ByteStreams 提供对InputStream/OutputStream的操作 CharStreams 提供对Reader/Writer的操作 对源（Source）与汇（Sink）的抽象 无需手动关闭 Source ByteSource CharSource Sink ByteSink CharSink 示例123456789101112131415161718192021import com.google.common.base.Charsets;import com.google.common.io.CharSink;import com.google.common.io.CharSource;import com.google.common.io.Files; @Test public void copyFile() throws IOException &#123; /** * 创建对应的Source和Sink */ CharSource charSource = Files.asCharSource( new File("SourceText.txt"), Charsets.UTF_8); CharSink charSink = Files.asCharSink( new File("TargetText.txt"), Charsets.UTF_8); /** * 拷贝 */ charSource.copyTo(charSink); &#125; 线程池概述事先创建若干线程放在一个容器中，使用时从容器中获取，用完不再销毁而是放回容器，从而减少创建和销毁线程对象的开销 优点 降低资源消耗 提高响应速度 提高线程的可管理性 简答设计 初始创建多少线程？ 没有可用线程了怎么办？ 缓冲数组要多长？ 缓冲数组满了怎么办？ 线程池参数 处理流程 阻塞队列有界队列12345678910111213public void arrayBlockingQueue() throws InterruptedException &#123; /** * 基于数组的有界阻塞队列，队列容量为10 */ ArrayBlockingQueue queue = new ArrayBlockingQueue&lt;Integer&gt;(10); // 循环向队列添加元素 for (int i = 0; i &lt; 20; i++) &#123; queue.put(i); System.out.println("向队列中添加值：" + i); &#125; &#125; 无界队列123456789101112131415@Test public void linkedBlockingQueue() throws InterruptedException &#123; /** * 基于链表的有界/无界阻塞队列，队列容量为10 * 不输入容量时默认为Interger.MAX_VALUE，相当于无界队列 */ LinkedBlockingQueue queue = new LinkedBlockingQueue&lt;Integer&gt;(); // 循环向队列添加元素 for (int i = 0; i &lt; 20; i++) &#123; queue.put(i); System.out.println("向队列中添加值：" + i); &#125; &#125; 同步移交队列本身不存储任务，类似于缓存，直到任务被取走才会向下执行 12345678910111213141516171819202122232425262728293031public void test() throws InterruptedException &#123; /** * 同步移交阻塞队列 */ SynchronousQueue queue = new SynchronousQueue&lt;Integer&gt;(); // 插入值 new Thread(() -&gt; &#123; try &#123; // 任务不被取走，会阻塞在这 queue.put(1); System.out.println("插入成功"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); // 删除值 /* new Thread(() -&gt; &#123; try &#123; queue.take(); System.out.println("删除成功"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); */ Thread.sleep(1000L * 60);&#125; 饱和策略AbortPolicy终止策略（默认）抛出异常 DiscardPolicy抛弃策略 DiscardOldestPolicy抛弃旧任务策略 CallerRunsPolicy调用者运行策略调用方直接执行run方法，run方法耗费多久，调用方就被阻塞多久 常用线程池newCachedThreadPool newFixedThreadPool newSingleThreadExecutor 线程池状态 向线程池提交任务submit1234567891011121314151617181920public void submitTest() throws ExecutionException, InterruptedException &#123; // 创建线程池 ExecutorService threadPool = Executors.newCachedThreadPool(); /** * 利用submit方法提交任务，接收任务的返回结果 */ Future&lt;Integer&gt; future = threadPool.submit(() -&gt; &#123; Thread.sleep(1000L * 10); return 2 * 5; &#125;); /** * 阻塞方法，直到任务有返回值后，才向下执行 */ Integer num = future.get(); System.out.println("执行结果：" + num);&#125; execute123456789101112131415161718192021public void executeTest() throws InterruptedException &#123; // 创建线程池 ExecutorService threadPool = Executors.newCachedThreadPool(); /** * 利用execute方法提交任务，没有返回结果 * 并且Runnable接口不允许抛出异常，必须自行捕获 */ threadPool.execute(() -&gt; &#123; try &#123; Thread.sleep(1000L * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Integer num = 2 * 5; System.out.println("执行结果：" + num); &#125;); Thread.sleep(1000L * 1000);&#125; Lombok概述是一个Java库，在编译时期为我们自动生成一些代码 需在IDE中安装Lombok插件 注解的解析时机 运行时解析 编译时解析&lt;–Lombok Annotation Processing Tool（注解处理器） Pluggable Annotation Processing API（JSR269插入式注解处理器） 原理 Maven依赖1234567&lt;!-- Lombok 章节引入Jar包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 常用注解@Data常用方法 @Getter @Setter @ToString @EqualsAndHashCode 构造方法 @AllArgsConstructor @RequiredArgsConstructor @NoArgsConstructor 其它 @NonNull 自动生成空值校验 @Cleanup 自动调用变量的close方法释放资源 @Builder 自动生成构造者模式 @SneakyThrows 自动生成try/catch捕捉异常 @Slf4j 自动为类添加日志支持 @Synchronized 自动生成同步锁 优缺点 优点 通过注解自动生成样板代码，提高开发效率 代码简介，只关注相关属性 新增属性后，无需可以修改相关方法 缺点 降低了源代码的可读性和完整性 加大对问题排查的难度 需要IDE的相关插件的支持 示例@Getter12345678910@Getter( lazy = true)private final String field1 = "zhangxiaoxi";@Getter( value = AccessLevel.PRIVATE, onMethod_=&#123;@NotNull&#125;)private String field2; @Setter12345678@Setterprivate String field1;@Setter( value = AccessLevel.PRIVATE, onParam_=&#123;@NotNull&#125;)private String field2; @ToString1234567891011/** * 生成toString方法 * if优先级高于exclude */@ToString( includeFieldNames = false,// exclude = &#123;"field1"&#125;,// of = &#123;"field1"&#125;, doNotUseGetters = false)public class ToStringTest &#123; @EqualsAndHashCode1234567/** * 生成Equals方法和HashCode方法 */@EqualsAndHashCode( exclude = &#123;"field1"&#125;)public class EqualsAndHashCodeTest &#123; @Data12345/** * 大而全的注解：包含@Getter，@Setter，@ToString，@EqualsAndHashCode */@Datapublic class DataTest &#123; 构造方法12345/** * @AllArgsConstructor 全参 * @NoArgsConstructor 无参 * @RequiredArgsConstructor 自动为必须初始化的字段生成构造方法,eg：final字段，NonNull修饰的字段 */ NonNull生成非空检查 123public NonNullTest(@NonNull String field) &#123; System.out.println(field);&#125; @Cleanup123456789101112/** * 生成资源关闭代码 */public class CleanupTest &#123; public void copyFile(String in, String out) throws Exception &#123; @Cleanup FileInputStream fileInputStream = new FileInputStream(in); @Cleanup FileOutputStream fileOutputStream = new FileOutputStream(out); 验证框架Maven依赖123456789101112131415161718192021&lt;!-- Validation 相关依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.16.Final&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.6&lt;/version&gt;&lt;/dependency&gt; 验证模型 JCP和JSR Hibernate Validator是对Bean Validator的具体实现 Spring Validation 常用注解 内置简单注解对属性进行校验 空值验证 范围验证 其他验证 级联验证 分组验证 组序列 待验证实体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 待验证对象实体类 * 用户信息类 */@Datapublic class UserInfo &#123; // 登录场景 用于分组验证 public interface LoginGroup &#123;&#125; // 注册场景 用于分组验证 public interface RegisterGroup &#123;&#125; // 组排序场景 多个分组时，按序验证，一般优先校验一些简单的 @GroupSequence(&#123; LoginGroup.class, RegisterGroup.class, Default.class 默认分组 &#125;) public interface Group &#123;&#125; @NotNull(message = "用户ID不能为空", groups = LoginGroup.class) private String userId; /** * NotEmpty 不会自动去掉前后空格 */ @NotEmpty(message = "用户名称不能为空") private String userName; /** * NotBlank 自动去掉字符串前后空格后验证是否为空 */ @NotBlank(message = "用户密码不能为空") @Length(min = 6, max = 20, message = "密码长度不能少于6位，多于20位") private String passWord; @NotNull(message = "邮箱不能为空", groups = RegisterGroup.class) @Email(message = "邮箱必须为有效邮箱") private String email; /** * 这是一个自定义注解 */ @Phone(message = "手机号不是158后头随便") private String phone; @Min(value = 18, message = "年龄不能小于18岁") @Max(value = 60, message = "年龄不能大于60岁") private Integer age; @Past(message = "生日不能为未来或当前时间点") private Date birthday; @Size(min = 1, message = "不能少于1个好友") private List&lt;@Valid UserInfo&gt; friends;&#125; 验证类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class ValidationTest &#123; // 验证器对象 private Validator validator; // 待验证对象 private UserInfo userInfo; // 验证普通字段的结果集合 private Set&lt;ConstraintViolation&lt;UserInfo&gt;&gt; set; // 验证返回值等时的结果集合 private Set&lt;ConstraintViolation&lt;UserInfoService&gt;&gt; otherSet; /** * 初始化验证器以及待验证对象 */ @Before public void init() &#123; // 初始化验证器 validator = Validation.buildDefaultValidatorFactory() .getValidator(); // 初始化待验证对象 - 用户信息 userInfo = new UserInfo();// userInfo.setUserId("zhangxiaoxi"); userInfo.setPassWord("zhangxiaoxi");// userInfo.setEmail("zhangxiaoxi@sina.cn"); userInfo.setAge(30); Calendar calendar = Calendar.getInstance(); calendar.set(2012, 1, 1); userInfo.setBirthday(calendar.getTime()); UserInfo friend = new UserInfo();// friend.setUserId("wangxiaoxi"); friend.setUserName("王小喜"); friend.setPassWord("wangxiaoxi");// friend.setEmail("wangxiaoxi@sina.cn"); friend.setPhone("15811111111"); userInfo.setFriends(new ArrayList()&#123;&#123;add(friend);&#125;&#125;); &#125; /** * 打印结果集 */ @After public void print() &#123; set.forEach(item -&gt; &#123; // 输出验证错误信息 System.out.println(item.getMessage()); &#125;); &#125; @Test public void nullValidation() &#123; // 使用验证器对对象进行验证 set = validator.validate(userInfo); &#125; /** * 级联验证测试方法 */ @Test public void graphValidation() &#123; set = validator.validate(userInfo); &#125; /** * 分组验证测试方法 */ @Test public void groupValidation() &#123; set = validator.validate(userInfo, UserInfo.RegisterGroup.class, UserInfo.LoginGroup.class); &#125; /** * 组序列 */ @Test public void groupSequenceValidation() &#123; set = validator.validate(userInfo, UserInfo.Group.class); &#125; /** * 对方法输入参数进行约束注解校验 */ @Test public void paramValidation() throws NoSuchMethodException &#123; // 获取校验执行器 ExecutableValidator executableValidator = validator.forExecutables(); // 待验证对象 UserInfoService service = new UserInfoService(); // 待验证方法 Method method = service.getClass() .getMethod("setUserInfo", UserInfo.class); // 方法输入参数 Object[] paramObjects = new Object[]&#123;new UserInfo()&#125;; // 对方法的输入参数进行校验 otherSet = executableValidator.validateParameters( service, method, paramObjects); &#125; /** * 对方法返回值进行约束校验 */ @Test public void returnValueValidation() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; // 获取校验执行器 ExecutableValidator executableValidator = validator.forExecutables(); // 构造要验证的方法对象 UserInfoService service = new UserInfoService(); Method method = service.getClass() .getMethod("getUserInfo"); // 调用方法得到返回值 Object returnValue = method.invoke(service); // 校验方法返回值是否符合约束 otherSet = executableValidator.validateReturnValue( service, method, returnValue); &#125; /** * 对构造函数输入参数进行校验 */ @Test public void constructorValidation() throws NoSuchMethodException &#123; // 获取验证执行器 ExecutableValidator executableValidator = validator.forExecutables(); // 获取构造函数 Constructor constructor = UserInfoService.class .getConstructor(UserInfo.class); Object[] paramObjects = new Object[]&#123;new UserInfo()&#125;; // 校验构造函数 otherSet = executableValidator .validateConstructorParameters( constructor, paramObjects); &#125;&#125; 内置复杂注解 校验参数 校验返回值 校验构造方法 待验证实体1234567891011121314151617181920212223242526272829303132333435package com.imooc.zhangxiaoxi.validation;import javax.validation.Valid;/** * 用户信息服务类 */public class UserInfoService &#123; /** * UserInfo 作为输入参数 * @param userInfo */ public void setUserInfo(@Valid UserInfo userInfo) &#123;&#125; /** * UserInfo 作为输出参数 * @return */ public @Valid UserInfo getUserInfo() &#123; return new UserInfo(); &#125; /** * 默认构造函数 */ public UserInfoService() &#123;&#125; /** * 接收UserInfo作为参数的构造函数 * @param userInfo */ public UserInfoService(@Valid UserInfo userInfo) &#123;&#125;&#125; 验证类见前面 自定义注解 约束注解的定义 约束验证规则（约束验证器） 约束注解的声明 在需要验证字段处添加 约束验证流程 调用验证器对象 注解类123456789101112131415161718192021222324252627package com.imooc.zhangxiaoxi.validation;import javax.validation.Constraint;import javax.validation.Payload;import java.lang.annotation.*;/** * 自定义手机号约束注解 */@Documented// 注解的作用目标@Target(&#123;ElementType.FIELD&#125;)// 注解的保留策略@Retention(RetentionPolicy.RUNTIME)// 不同之处：与约束注解关联的验证器@Constraint(validatedBy = PhoneValidator.class)public @interface Phone &#123; // 约束注解验证时的输出信息 String message() default "手机号校验错误"; // 约束注解在验证时所属的组别 Class&lt;?&gt;[] groups() default &#123;&#125;; // 约束注解的有效负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 验证器12345678910111213141516171819202122public class PhoneValidator implements ConstraintValidator&lt;Phone, String&gt; &#123; /** * 自定义校验逻辑方法 * @param value * @param context * @return */ @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; // 手机号验证规则：158后头随便 String check = "158\\d&#123;8&#125;"; Pattern regex = Pattern.compile(check); // 空值处理 String phone = Optional.ofNullable(value).orElse(""); Matcher matcher = regex.matcher(phone); return matcher.matches(); &#125;&#125; 具体使用同内置注解 Postman概述 简单使用多套环境变量满足不同环境的测试 测试集对一组测试进行管理，并对一些通用配置，可直接在测试集上设置 多人协作 检查工具静态代码分析 主流静态分析CheckStyle FindBugs PMD IDEA插件 SonarQube概述 功能 工作原理 maven集成]]></content>
      <categories>
        <category>imooc</category>
      </categories>
      <tags>
        <tag>开发效率</tag>
        <tag>第三方工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos]]></title>
    <url>%2F2020%2F04%2F18%2Fheima57%2Fcentos%2F</url>
    <content type="text"><![CDATA[概述操作系统 linux选择特点：安全，免费稳定，可靠，多平台 发行版选择：生命周期，软件包更新 远程连接SecureCRT XShellftp方式FlashFXPlinux配置ftp lrzszyum install lrzsz 有些慢 CRT中设置上传和下载文件夹 rz 上传 sz 文件名 sftpCRT中内置的，用alt+p打开 下载 上传 传到电脑文档目录下 目录结构 分区及目录挂载这样挂掉只需处理那一部分即可 常用命令辅助 帮助 help 命令 --help man man 命令 开关机 shotdown -h now 关机 showdown -r now 重启 reboot 重启 重定向 &gt; ifconfig &gt; a.txt 覆盖 &gt;&gt; ifconfig &gt;&gt; a.txt 追加 系统进程 ps -ef 动态查看当前系统 kill -9 进程号 强制杀死进程 管道 将两个命令连接起来 左侧的输出作为右侧的输入 网络主机名 hostname 查看当前主机名 hostname ××× 临时修改主机名，重启后失效 vim /etc/sysconfig/network 修改配置文件，永久生效 修改ip ifconfig 查看当前网络状态 ifconfig eth0 ip 临时修改 vim /etc/sysconfig/network-scripts/ifcfg-eth0 永久修改 域名映射/etc/hosts 相当于windows下的hosts文件 网络服务 网络服务 systemctl network start/restart/stop/status 开启/重启/停止/状态 systemctl –status-all 查看系统中所有后台服务 netstat -nltp 网络进程的端口监听情况 防火墙 systemctl start/restart/stop firewalld.service 开启/重启/关闭防火墙 chkconfig iptables off 禁止防火墙自启 firewall-cmd –state 防火墙状态 端口 firewall-cmd –zone=public –add-port=5672/tcp –permanent 永久在全局开放5672端口 firewall-cmd –zone=public –remove-port=5672/tcp –permanent 永久在全局关闭5672端口 firewall-cmd –reload 重启防火墙，使修改生效 firewall-cmd –zone=public –list-ports 查看所有开放的端口 文件和目录管理绝对路径与相对路径：区别在于是否从根目录开始，本地绝对路径更稳定，服务器端用相对路径 cdcd 路径 . 当前目录 .. 上级目录 什么都不加默认跳转到当前用户根目录下 只能跳转到目录，不可以跳转到文件，会报错 使用tab来补全目录 pwd打印当前目录 clear清屏 touch创建文件 mkdir-m 指定文件权限，不常用-p 创建一串级联目录，已存在时不报错 ls ls 查看当前目录下文件 -a 所有，包括隐藏文件 -l 详细信息( ll = ls -l ) -d 查看指定目录属性 -h 人性化显示大小 -a 所有，包括隐藏文件 -l 详细信息-d 查看指定目录属性-h 人性化显示大小 ll=ls -l rmdir不常用，仅用于删除空目录 -p 级联删除，如果目录非空时报错 rm-r 删除目录时必须加-f 强制删除，不再询问是否删除 cp cp cp 【选项】 【源文件】 【目标文件】 -r 复制目录时加 -i 安全选项，覆盖时会询问，默认alise cp=“cp -i” mv在同级目录下可以实现重命名 mv mv 【选项】 【源文件或目录】 【目标文件或目录】 目标文件是目录 若存在，则将源文件或目录移动到目标目录下 若不存在，则将原目录重命名为给定文件名 目标文件是文件 若存在，则询问是否覆盖 若不存在，则将源文件重命名为给定的目标文件 tar -c 创建一个新tar文件 -x 解开tar文件 -z 调用gzip压缩 -v 显示压缩过程 -f 指定文件名 -t 查看压缩文件内容 使用示例 tar -cvf a.tar ./anaconda-ks.cfg 打成一个tar包 tar -zcvf a.tar.gz ./anaconda-ks.cfg 打包并压缩，后缀名常用tar.gz tar -zxvf b.tar.gz -C ./cc 加-C ./cc来指定解压目录，不然解压到当前目录 PATH变量一串用：分隔的路径，执行命令时会默认从PATH中找修改: PATH=$PATH:新路径 查看文件cat cat 查看少量信息 -n 显示行号 -A 显示所有内容，包括特殊字符 tac与命令tac一样，倒叙查看 more more 文件内容较多时使用 Ctrl+D 向上翻屏 Ctrl+F 向下翻屏，同空格 空格 向下翻屏 q/ctrl+c 退出 /字符串 从当前行向下查找字符串，按n定位下一个 ?字符串 从当前行向上查找字符串，按n定位下一个（可以使用通配符） less less 对more的争强 Ctrl+D 向上翻屏 Ctrl+F 向下翻屏，同空格 空格 向下翻屏 q/ctrl+c 退出 /字符串 从当前行向下查找字符串，按n定位下一个 ?字符串 从当前行向上查找字符串，按n定位下一个（可以使用通配符） J/↑ 向上移动 k/↓ 向下移动 head head 默认显示文件前十行 -n 1/-n1/-1 显示指定行数，三种方式皆可 -n 1/-n1/-1 显示指定行数，三种方式皆可 tail tail 倒叙查看 -n 1/-n1/-1 显示指定行数，三种方式皆可 -f 动态查看，常用于监视日志文件 -f 动态查看 查找which查找可执行文件绝对路径which vi whereis通过预先生成的文件列表库查找whereis 【-bms】 【文件名称】-b 只查找二级制文件-m 只查找帮助文件-s 只查找源代码文件 locate不常用类似于whereis，包含所搜索关键词的目录和文件都会列出，所以不适合精确搜索 find find 路径 参数 文件名 在指定目录下寻找文件 find / -name “ana*” 在根目录下按名字查找以ana开头的文件 find / -user itcast 用户为itcast -atime +n/-n 访问或执行时间大于或小于n天 -ctime +n/-n 写入、更改inode属性的时间大于或小于n天 -mtime +n/-n 写入时间大于或小于n天 用得最多 grep grep 在文件中查找字符串 grep lang catalina.log --color 在catalina.log中查找lang。并高亮显示 -An -Bm 包含向上n行，向下m行 用户管理 群组管理 角色设置-R递归修改目录下的所有文件 权限设置 压缩 12// 单文件用deflation压缩的包才可以用gzip解压，unzip则方便的多 -d用于指定解压目录unzip 20131030.zip -d /home/2/ 文件属性 第一列第一位d 目录 - 普通文件 l 链接文件 b 块设备 c 串行端口设备文件 s 套接字文件，socket 后九位 每三位为一组，分别为user，group，others权限 最后一位 使用了SElinux context为点 设置了acl属性为+号 第二列该文件占用的节点（inode），有几种访问方式 第三列所有者 第四列所属组 第五列该文件大小 第六七八列分别为月日及时间 第九列文件名 chgrp 不常用更改文件所属组chgrp 【组名】 【文件名】-R 级联更改子目录名或文件名 chown更改文件所有者chown 【-R】 账户名：组名 文件名-R 仅用于目录，作用是级联更改 chmod更改用户权限，目录默认为755，文件默认为644chmod 750 文件或目录名chmod u=rwx，og=rw 文件或目录名 u，g，o，a（all）chmod a-x 文件或目录名 umask修改文件默认权限umask xxx xxx=默认值-所需默认值（文件默认为666，目录默认为777）特例：666-333=444（333代表去了可写和可执行权限，但本来就没有可执行） chattr修改文件特殊属性chattr 【+-=】【Asaci】 【文件或目录名】 分别是增加，减少和设定存疑：=还不清楚-A 文件或目录的atime将不可修改-s 将数据同步写入磁盘-a 只能追加不能删除，非root不可设定该属性（常用）-c 自动压缩文件，读取时自动解压-i 文件不能删除，重命名，设定链接，以及写入数据（常用） lsattr 文件或目录名该命令用于读取文件或者目录的特殊权限-a 列出所有文件，包括隐藏文件-R 连同子目录数据列出 set uid，set gid，sticky bit权限其实共四位，第一位由这三个决定，分别为4,2,1，具体表现在第三位，若为小写则原本有x，大写则无，例如rwsrwsrwt为7777set uid 针对二进制可执行文件，使文件在执行阶段拥有该文件所有者权限 passwd命令set gid 作用在二进制文件上时，同上，作用在目录上时，任何用户在此目录下创建的文件都具有和该目录所属组相同的组sticky bit 设置该权限后，就算用户拥有写权限，也只可以添加而不可删除文件 /tmp/ vim 菜鸟教程-Vim 命令模式h j k l左 下 上 右 dd 剪切当前行yy 复制p 下一行黏贴 P 上一行黏贴 a在光标后插入 A在当行末插入i在光标前插入 I在当行首插入o在当前行之下插入 O在上一行插入 最末行模式:set nu 显示行号:w 保存:wq 保存并退出:q! 不保存退出 软件安装安装方式 二进制发布包 软件已经针对具体平台编译打包发布，只要解压，修改配置即可 不通用 RPM包 软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装 没法自动安装依赖 红帽系列 Yum在线安装 软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题 需要联网 红帽系列 可以配置yum源来提高速度 源码编译安装 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署 略麻烦 安装JDK判断服务器位数 一般在/usr/local目录下安装 卸载原jdk 解压压缩包 配置环境变量 vim /etc/profile 1234567#set java environmentJAVA_HOME=/opt/jdk1.8.0_241CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATH# 导入这俩变量export JAVA_HOME CLASSPATH PATH source /etc/profile 重新加载 安装MySQL步骤：百度找最新的吧 记得完了开放3306端口，不然别处无法访问 centos7防火墙开放端口 如果购买的云服务器还需修改安全组 tomcat安装下载压缩文件，解压到指定文件夹 记得开放端口 远程试下ip:8080是否可以访问 项目部署]]></content>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2020%2F04%2F17%2Fheima57%2Fnginx%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2020%2F04%2F04%2Fheima57%2FRedis%2F</url>
    <content type="text"><![CDATA[概述​ Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求 ​ 将数据存储在内存中，也可以持久化到硬盘 NOSQL概述​ NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 ​ 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动 态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。 NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战 优缺点优点： 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流产品 键值(Key-Value)存储数据库 ​ 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB​ 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。​ 数据模型： 一系列键值对​ 优势： 快速查询​ 劣势： 存储的数据缺少结构化 列存储数据库 ​ 相关产品：Cassandra, HBase, Riak​ 典型应用：分布式的文件系统​ 数据模型：以列簇式存储，将同一列数据存在一起​ 优势：查找速度快，可扩展性强，更容易进行分布式扩展​ 劣势：功能相对局限 文档型数据库 ​ 相关产品：CouchDB、MongoDB​ 典型应用：Web应用（与Key-Value类似，Value是结构化的）​ 数据模型： 一系列键值对​ 优势：数据结构要求不严格​ 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 ​ 相关数据库：Neo4J、InfoGrid、Infinite Graph​ 典型应用：社交网络​ 数据模型：图结构​ 优势：利用图结构相关算法。​ 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 支持的数据类型redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedset 应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 安装与启动安装官网 1234$ wget http://download.redis.io/releases/redis-5.0.8.tar.gz$ tar xzf redis-5.0.8.tar.gz$ cd redis-5.0.8$ make 启动./src/redis-server redis.conf 启动服务器端 ./src/redis-cli -p 6379 启动客户端 ./src/redis-cli shutdown 关闭服务器 或者netstat -tulpn 先获取端口号再kill掉 auth 密码 连接之后经行认证 redis.conf常用配置 开发时为了远程连接，可以如下修改 还得开放相应端口 命令通用命令type key ： 获取键对应的value的类型 string最大512mb,但建议单个不超过100kb hash存储结构化数据 list最大长度为2的32次方-1 添加： lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边 获取： lrange key start end ：范围获取 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 set 存储：sadd key value 获取：smembers key:获取set集合中所有元素 删除：srem key value:删除set集合中的某个元素 交集：sinter set1 set2 并集：sunion set1 set2 差集：sdiff set1 set2 sortedset每个值关联一个score，通过score来排序 存储：zadd key score value 获取： zrange key start end [withscores] zrangebyscore key score1 score2 获取分数在这个区间内的元素 删除：zrem key value 持久化机制RDB默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.conf文件 123456# after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定配置文件名称 redis-server redis.conf AOF日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.conf文件 appendonly no（关闭aof） –&gt; appendonly yes （开启aof） 123# appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化 重新启动redis服务器，并指定配置文件名称 redis-server redis.conf Jedis使用 导入jar包 123456//1. 获取连接Jedis jedis = new Jedis(&quot;localhost&quot;,6379);//2. 操作 和redis命令一致jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);//3. 关闭连接jedis.close(); 连接池工具类 加载配置文件，配置连接池的参数 提供获取连接的方法 123456789101112131415161718192021222324252627public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port"))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; jedis.properties 1234host=127.0.0.1port=6379maxTotal=50maxIdle=10]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA]]></title>
    <url>%2F2020%2F03%2F30%2F%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%2FIDEA%2F</url>
    <content type="text"><![CDATA[概述 强大的整合能力，比如git，Maven，Spring等 提示功能的快速，便捷，范围广 好用的快捷键和代码模板 精确搜索 目录结构 .idea IDEA自己用的 src 源码 out 生成的class文件 管理结构项目&gt;模块&gt;包&gt;java文件 下载与安装下载地址 安装目录 第一个目录存的是配置信息，比如字体，快捷键设置，插件 第二个存的是索引，缓存等（刚启动时会自动生成索引，这段时间最好安静等待，不然可能会报一些莫名其妙的错） 如果出了什么问题，可以把第二个目录干掉，一般重启一下就好了 程序主体安装在自己安装时选择的目录下 Debug追踪 按键 效果 shift+F9 开始调试 F7 进入方法 ctrl+shift+F8 查看所有断点 shift+F8 跳出方法 F8 逐行执行 F9 跳到下一断点 Ctrl+F2 停止调试 循环中的断点在跳到下一断点时，相当于循环内就有多个断点 行号旁边单击可以添加断点，右击断点可以改为条件断点 源码阅读codesheep链接 常用设置取消自动更新 安装插件可以直接在设置中查找插件 Plugins 热门插件自行百度 生成javadoctool -&gt; generate javadoc 选择要生成的文件，位置 locate zh_CN other command line arguments: -encoding UTF-8 -charset UTF-8 文件双开右击别的文件标签可以设置显示方式，同时打开多个文件 快捷键窗口快捷键 代码快捷键 alt+shift再用鼠标点击，做到多光标 代码定位Ctrl+g 跳转到指定行 jar包中标签只能加在文件第一行 小结 命令 作用· 双击shift 查询一切 setting -&gt;keymap 设置快捷键 shift+f10 运行 Ctrl+Alt+空格 提示补全 Ctrl+/ 单行注释 Ctrl+shift+/ 多行注释 Ctrl+d 向下复制一行 Ctrl+y 删除选中行 Ctrl+shift+↑/↓ 移动选中行 Ctrl+enter 向下开始新的一行 Ctrl+shift+enter 向上开始新的一行 Ctrl 查看源码 alt+enter 万能解错 alt+←/→ 返回到前/后一个编辑的页面 ctrl+h 查看继承关系 Ctrl+alt+L 格式化代码 Ctrl+p 提示方法参数 Ctrl+z 撤销 ctrl+shift+z 反撤销 tab 选中数行，整体后移 shift+tab 选中数行，整体前移 ctrl+o 查看类的结构 shift+f6 重命名 Ctrl+shift+u 大小写转化 alt+fn+insert 生成构造函数 Ctrl+q 查看文档说明 Ctrl+shift+减号 收起所有方法 Ctrl+shift+等号 打开所有方法 Ctrl+shift+x(自己设置的) 打开代码所在硬盘文件夹 alt+ctrl+T 生成try—catch等 ctrl+空格 代码提示 live template内置 命令 效果 syso 输出 psvm 生成main函数 fori (eg:5.fori) 生成for函数 forr 生成逆序的for函数 iter 增强for循环 自定义 先加个组，然后再添加代码并配置用于那些文件 版本管理IDEA本身有local history，无需团队协作时，可以通过其很方便的实现版本管理 常用插件Java Stream Debugger Key promoter X进行操作后自动提示快捷键 Lombok代码注解插件 Free Mybatis PluginMybatis插件 Maven Helper解决maven依赖冲突 JunitGenerator2.0自动生成test方法 GsonFormat根据json数据生成实体类 在generator中调用 Pojo to JSON根据实体类生成JSON字符串 右键实体类类名来生成 GenerateSerialVersionUID自动生成序列化ID，右键功能菜单中调用 打包jar包 war包web项目只有在debug模式下才可以实现热部署]]></content>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端进阶]]></title>
    <url>%2F2020%2F03%2F26%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[JQuery概述JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 去官网下载即可，通过引入js文件的方式来使用 核心是选择器，然后对选择元素进行操作 JQuery对象JQuery对象在操作时更加方便，但JQuery对象和js对象方法不通用的. 当同样操作一个数组时，js对象需要遍历逐个操作，JQuery可直接对选择中的数组进行操作，会自动对其中所有元素操作 jq – &gt; js : jq对象[索引] 或者 jq对象.get(索引) js – &gt; jq : $(js对象) 选择器基本选择器 层叠选择器 属性选择器 属性名称选择器 语法： $(&quot;A[属性名]&quot;) 包含指定属性的选择器 属性选择器 语法： $(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(&quot;A[属性名=&#39;值&#39;][]...&quot;) 包含多个属性条件的选择器 位置选择器 非元素选择器 语法： :not(selector) 不包括指定内容的元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 操作元素属性 123456781. attr(): 获取/设置元素的属性2. removeAttr():删除属性3. prop():获取/设置元素的属性4. removeProp():删除属性* attr和prop区别？ 1. 如果操作的是元素的固有属性，则建议使用prop 2. 如果操作的是元素自定义的属性，则建议使用attr 元素的CSS样式 12345671. addClass():添加class属性值2. removeClass():删除class属性值3. toggleClass():切换class属性 * toggleClass(&quot;one&quot;): * 判断如果元素对象上存在class=&quot;one&quot;，则将属性值one删除掉。 如果元素对象上不存在class=&quot;one&quot;，则添加4. css(): 元素内容不传入参数为获取，传入为设置 CRUD1. append():父元素将子元素追加到末尾 * 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 2. prepend():父元素将子元素追加到开头 * 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 3. appendTo(): * 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 4. prependTo()： * 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 5. after():添加元素到元素后边 * 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 6. before():添加元素到元素前边 * 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 7. insertAfter() * 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 8. insertBefore() * 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 9. remove():移除元素 * 对象.remove():将对象删除掉 10. empty():清空元素的所有后代元素。 * 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 11. clone():克隆调用对象遍历1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象)事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;常用事件 示例12345678910111213141516171819202122232425262728293031&lt;script type="text/javascript"&gt; //onload是指在页面所有资源加载完成后执行 window.onload = function()&#123; //alert(1); &#125; //ready()则是在页面dom被浏览器解释完成后执行 $(document).ready(function()&#123; alert("页面准备就绪"); &#125;) //简化形式 $(function()&#123; $("p.myclass").on("click" , function()&#123; //$(this)是指当前事件产生的对象 $(this).css("background-color" , "yellow"); &#125;); $("span.myclass").click(function()&#123; $(this).css("background-color" , "lightgreen"); &#125;) $("input[name='uname']").keypress(function(event)&#123; // 看下该事件对象有哪些属性 console.log(event); if(event.keyCode == 32)&#123; $(this).css("color" , "red"); &#125; &#125;) &#125;)&lt;/script&gt; 动画三种动画方式，传入参数个数任意 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]])插件相当于全局函数 $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) 12345678910111213141516171819202122232425262728293031323334//1.定义jqeury的对象插件$.fn.extend(&#123; //定义了一个check()方法。所有的jq对象都可以调用该方法 check:function () &#123; //让复选框选中 //this:调用该方法的jq对象 this.prop("checked",true); &#125;, uncheck:function () &#123; //让复选框不选中 this.prop("checked",false); &#125; &#125;);$(function () &#123; // 获取按钮 //$("#btn-check").check(); //复选框对象.check(); $("#btn-check").click(function () &#123; //获取复选框对象 $("input[type='checkbox']").check(); &#125;); $("#btn-uncheck").click(function () &#123; //获取复选框对象 $("input[type='checkbox']").uncheck(); &#125;);&#125;); $.extend(object) 增强JQeury对象自身的功能 $/jQuery 123456789101112131415161718$.extend(&#123; max:function (a,b) &#123; //返回两数中的较大值 return a &gt;= b ? a:b; &#125;, min:function (a,b) &#123; //返回两数中的较小值 return a &lt;= b ? a:b; &#125; &#125;); //调用全局方法 var max = $.max(4,3); //alert(max); var min = $.min(1,2); BootStrap概述一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 好处： 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 响应式布局。 同一套页面可以兼容不同分辨率的设备。 快速入门 下载Bootstrap 在项目中将这三个文件夹复制 创建html页面，引入必要的资源文件 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- 加载 Bootstrap 的所有 css 插件 --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局 同一套页面可以兼容不同分辨率的设备。 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子 步骤： 定义容器。相当于之前的table、 容器分类： container：两边留白 container-fluid：每一种设备都是100%宽度 定义行。相当于之前的tr 样式：row 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目 设备代号： xs：超小屏幕 手机 (&lt;768px)：col-xs-12 sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 注意： 一行中如果格子数目超过12，则超出部分自动换行。 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 123456789101112131415161718192021222324252627&lt;body&gt; &lt;!--1.定义容器--&gt; &lt;div class="container"&gt; &lt;!--2.定义行--&gt; &lt;div class="row"&gt; &lt;!--3.定义元素 在大显示器一行12个格子 在pad上一行6个格子 --&gt; &lt;!--&lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-lg-1 col-sm-2 inner"&gt;栅格&lt;/div&gt;--&gt; &lt;div class="col-md-4 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-md-4 inner"&gt;栅格&lt;/div&gt; &lt;div class="col-md-4 inner"&gt;栅格&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 常用插件123456789101112131415161718191. 全局CSS样式： * 按钮：class="btn btn-default" * 图片： * class="img-responsive"：图片在任意尺寸都占100%，响应式布局 * 图片形状 * &lt;img src="..." alt="..." class="img-rounded"&gt;：方形 * &lt;img src="..." alt="..." class="img-circle"&gt; ： 圆形 * &lt;img src="..." alt="..." class="img-thumbnail"&gt; ：相框 * 表格 * table * table-bordered * table-hover * 表单 * 给表单项添加：class="form-control" 2. 组件： * 导航条 * 分页条3. 插件： * 轮播图 案例栅格化布局，大小很方便控制，很像用表格来布局，通过div和row来实现一些简单的嵌套 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;style&gt; .paddtop&#123; padding-top: 10px; &#125; .search-btn&#123; float: left; border:1px solid #ffc900; width: 90px; height: 35px; background-color:#ffc900 ; text-align: center; line-height: 35px; margin-top: 15px; &#125; .search-input&#123; float: left; border:2px solid #ffc900; width: 400px; height: 35px; padding-left: 5px; margin-top: 15px; &#125; .jx&#123; border-bottom: 2px solid #ffc900; padding: 5px; &#125; .company&#123; height: 40px; background-color: #ffc900; text-align: center; line-height:40px ; font-size: 8px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1.页眉部分--&gt; &lt;header class="container-fluid"&gt; &lt;div class="row"&gt; &lt;img src="img/top_banner.jpg" class="img-responsive"&gt; &lt;/div&gt; &lt;div class="row paddtop"&gt; &lt;div class="col-md-3"&gt; &lt;img src="img/logo.jpg" class="img-responsive"&gt; &lt;/div&gt; &lt;div class="col-md-5"&gt; &lt;input class="search-input" placeholder="请输入线路名称"&gt; &lt;a class="search-btn" href="#"&gt;搜索&lt;/a&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;img src="img/hotel_tel.png" class="img-responsive"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--导航栏--&gt; &lt;div class="row"&gt; &lt;nav class="navbar navbar-default"&gt; &lt;div class="container-fluid"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class="navbar-header"&gt; &lt;!-- 定义汉堡按钮 --&gt; &lt;button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"&gt; &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#"&gt;Link &lt;span class="sr-only"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;!--轮播图--&gt; &lt;div class="row"&gt; &lt;div id="carousel-example-generic" class="carousel slide" data-ride="carousel"&gt; &lt;!-- Indicators --&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="2"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class="carousel-inner" role="listbox"&gt; &lt;div class="item active"&gt; &lt;img src="img/banner_1.jpg" alt="..."&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="img/banner_2.jpg" alt="..."&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="img/banner_3.jpg" alt="..."&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class="left carousel-control" href="#carousel-example-generic" role="button" data-slide="prev"&gt; &lt;span class="glyphicon glyphicon-chevron-left" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class="right carousel-control" href="#carousel-example-generic" role="button" data-slide="next"&gt; &lt;span class="glyphicon glyphicon-chevron-right" aria-hidden="true"&gt;&lt;/span&gt; &lt;span class="sr-only"&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;!-- 2.主体部分--&gt; &lt;div class="container"&gt; &lt;div class="row jx"&gt; &lt;img src="img/icon_5.jpg"&gt; &lt;span&gt;黑马精选&lt;/span&gt; &lt;/div&gt; &lt;div class="row paddtop"&gt; &lt;div class="col-md-3"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-3"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-3"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-3"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row jx"&gt; &lt;img src="img/icon_6.jpg"&gt; &lt;span&gt;国内游&lt;/span&gt; &lt;/div&gt; &lt;div class="row paddtop"&gt; &lt;div class="col-md-4"&gt; &lt;img src="img/guonei_1.jpg"&gt; &lt;/div&gt; &lt;div class="col-md-8"&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-4"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="col-md-4"&gt; &lt;div class="thumbnail"&gt; &lt;img src="img/jiangxuan_3.jpg" alt=""&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color="red"&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3.页脚部分--&gt; &lt;footer class="container-fluid"&gt; &lt;div class="row"&gt; &lt;img src="img/footer_service.png" class="img-responsive"&gt; &lt;/div&gt; &lt;div class="row company"&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882 &lt;/div&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具类]]></title>
    <url>%2F2020%2F03%2F21%2F%E5%B7%A5%E5%85%B7%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[BeanUtils简化数据封装，用于封装JavaBean JavaBean：标准的Java类 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username 方法： setProperty() getProperty() populate(Object obj , Map map):将map集合的键值对信息封装到对应的JavaBean对象中 Logback123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!--输出格式--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 日志输出级别(优先级高到低): error: 错误 - 系统的故障日志 warn: 警告 - 存在风险或使用不当的日志 info: 一般性消息 debug: 程序内部用于调试信息 trace: 程序运行的跟踪信息 --&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="console"/&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%B7%A5%E5%85%B7%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 设计模式是基于场景的解决方案 是前辈经验的总结，使代码更易理解，更易维护，更可靠 UML 统一建模语言——Unified Modeling Language 非专利的第三代建模和规约语言 用于说明、可视化、构建和编写一个正在开发的面向对象的、软件密集系统的制品的开放方法 展现了一系列最佳工程实践 分类14种图示 结构式图形：强调系统式的建模 行为式图形：强调系统模型中触发的事件 交互式图形：属于行为式图形的子集，强调系统模型中的资料流程 UML类图 Class Diagram：用于表示类、接口、实例等之间相互静态的关系 tips： 箭头方向：子类指向父类 只有子类才能明确知道自己继承了谁，父类是不清楚这些的 空心三角箭头：继承或实现 实现–继承：is a关系，真真实实的父类，用实线 虚线–实现：接口是一个虚无的概念，用虚线 关联或依赖 实线–关联：关联是平级的，无整体与部分的关系，如朋友关系，通常是一个类中有另一个对象作为属性 虚线–依赖：通常是一个类中有另一个对象作为参数、返回值等 菱形 空心菱形——聚合：整体与部分的关系，但比较弱，部分不依赖整体的存在而存在，二者有着独立的生命周期 has a 实心菱形——组合：整体与部分的关系比较强，部分的生命周期依赖与整体的存在，二者生命周期相同 contains a UML时序图 七大原则开闭原则 一个软件实体（类、函数、模块等）应对扩展开放，对修改关闭 用抽象构建框架，用实现扩展细节 提高软件系统的可复用性及可维护性 依赖倒置原则 高层不应该依赖低层模块，二者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖抽象 针对接口编程，不要针对实现编程（类比IOC） 抽象要比实现稳定的多 减少类间耦合，提高系统稳定性 单一职责原则 单个接口或类不应该有多个职责，应该尽可能的划分职责，通过组合的方式，完成更为复杂的业务 降低类的复杂度，减少变更时的风险 也可以加个参数表示不同职责来减少拆分 接口隔离原则 用多个专门的接口，而不要使用一个总接口，客户端不应该依赖他不需要的接口 一个类对一个类的依赖应建立在最小的接口上 一个接口不要包含过多的职责，应合理划分，跟单一职责原则相辅相成 一定要把握适度原则 迪米特法则 最少知道原则，一个对象尽量让其它对象保持最少的了解 尽量降低类与类之间耦合，该封装的都封装起来 典型场景：我点外卖，我只关心外卖员，不关系具体的店。我的类中只依赖外卖员，不会依赖具体的店。是不是静态代理。 里氏替换原则在引用父类的地方，都可以替换为其子类。从而可以实现子类间的动态切换。换句话说就是要有面向接口的编程思维。结合“开闭原则”，完美 合成复用原则多用组合，少用继承 创建型模式单例模式保证一个类仅有一个实例，并提供一个全局访问点 使用场景 想确保任何情况下都仅有一个实例 对系统内资源要求统一读写，如读写配置文件信息 当多个实例存在可能引起逻辑错误，如号码生成器 优缺点优点 在内存中只有唯一对象，节省内存空间 设置全局访问点，严格控制访问 避免对对象资源的多重占用 缺点 没有接口，扩展困难 若实例化后长期不使用，会被垃圾回收，造成对象状态丢失 重点 私有构造器 线程安全 延迟加载 序列化和反序列化安全 反射 实现参考 补充序列化和反序列化enum本来就是安全的，其它情况下需要多实现如下方法 底层实际上有创建了对象，但由于实现了这个方法，最后又舍弃了创建的那个对象，而序列化了原对象 反射攻击 可以在构造函数中加以判断，但如果反射发生在单例创建之前的话就没有用了（饿汉式不存在这个问题，反射加载类的过程中单例就初始化好了，所以这样可以防住） 懒汉式是没办法抵御反射攻击的，因为反射可以任意修改成员变量 最佳实践effective java 中推荐的是用枚举实现 容器单例 根据具体业务判断，存在线程安全问题 ThreadLocal线程单例各线程唯一，而不是全局唯一 简单工厂这个不属于23种设计模式 由一个工厂对象决定创建出哪一种产品类的实例 使用场景 工厂类负责创建的对象比较少 应用层只需知道传入的参数，不关心具体的创建细节（逻辑） 优缺点优点 只需传入正确参数即可 缺点 工厂类职责过重 增加新产品时需要修改工厂类的判断逻辑，不符合开闭原则 实例参考 工厂方法定义一个创建对象的接口但让实现这个接口的类来决定实例化哪个类——让类的实例化推迟到子类中进行 使用场景 创建对象需要大量重复代码 应用层不依赖于产品实例 一个类通过其子类来指定创建哪个对象 优缺点优点 用户只需要关心所需产品对应工厂 加入新产品符合开闭原则，提高可扩展性 缺点 类的个数容易过多 增加了系统的抽象性和理解难度 实例 抽象工厂 创建一系列相关或相互依赖对象的接口 无需指定他们具体的类 使用场景 优缺点优点 无需关心创建细节 将一个系列的产品族统一到一起创建 缺点 规定了所有可能被创建的产品集合，扩展新产品困难，需要修改抽象工厂接口 增加了系统的抽象性和理解难度 实例 建造者 将一个复杂对象的构建和他的表示分离，使得同样的构建过程可以创建不同的表示 用户只需指定建造类型即可，无需了解建造细节 使用场景 一个对象有很多非常复杂的内部结构（很多属性） 想把复杂对象的创建和使用分离 优缺点优点 封装性好，创建和使用分离 扩展性好、构建类之间独立、一定程度上解耦 缺点 产生多余的Builder对象 产生内部发生变化，建造者都要修改 实例 原型模式使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象 使用场景 类初始化消耗较多的资环 new一个对象过程繁琐（数据准备，访问权限等） 优缺点优点 简化创建过程 比直接new更高效 缺点 必须配备克隆方法 深浅拷贝要运用得到 实现 坑结合单例模式时，单例的克隆要如下实现 结构型模式代理模式 概念： 真实对象：被代理的对象 代理对象： 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 实现方式： 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类 实现步骤： 代理对象和真实对象实现相同的接口 代理对象 = Proxy.newProxyInstance(); 使用代理对象调用方法。 增强方法 增强方式：* 增强参数列表 * 增强返回值类型 * 增强方法体执行逻辑]]></content>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java进阶2]]></title>
    <url>%2F2020%2F02%2F28%2Fheima57%2Fjava%E8%BF%9B%E9%98%B62%2F</url>
    <content type="text"><![CDATA[多线程简介并发与并行 并发：指两个或多个事件在同一个时间段内发生。 并行：指两个或多个事件在同一时刻发生（同时发生）。 并发指的是在一段时间内宏观上有多个程序同时运行 注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。 同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行， 当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。 线程与进程一个程序运行后至少有一个进程，一个进程中可以包含多个线程 我们可以打开任务管理器查看当前任务的进程： 线程调度: 分时调度 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 设置线程的优先级 抢占式调度详解 大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序 实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时 刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够**提高程序运行效率，让CPU的使用率更高。**创建创建线程类构造方法： public Thread() :分配一个新的线程对象。public Thread(String name)public Thread(Runnable target)public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName() :获取当前线程名称。public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。public void run() :此线程要执行的任务在此处定义代码。public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 public void join():等待调用join方法的线程结束后才能执行 法一通过继承Thread类来创建并启动多线程的步骤如下： 1234567891011121314151617181920212223242526272829public class MyThread extends Thread &#123; //定义指定线程名称的构造方法 public MyThread(String name) &#123; //调用父类的String参数的构造方法，指定线程的名称 super(name); &#125; /** * 重写run方法，完成该线程执行的逻辑 */ @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("小强"+i); &#125; &#125;&#125;public class Demo01 &#123; public static void main(String[] args) &#123; //创建自定义线程对象 MyThread mt = new MyThread("新的线程！"); //开启新线程 mt.start(); //在主方法中执行for循环 for (int i = 0; i &lt; 10; i++) &#123; System.out.println("旺财"+i); &#125; &#125;&#125; 法二12345678public class MyRunnable implements Runnable&#123;@Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; &#125;&#125; 123456789101112public class Demo &#123; public static void main(String[] args) &#123; //创建自定义类对象 线程任务对象 MyRunnable mr = new MyRunnable(); //创建线程对象 Thread t = new Thread(mr, "小强"); t.start(); for (int i = 0; i &lt; 20; i++) &#123; System.out.println("旺财 " + i); &#125; &#125;&#125; 通过实现Runnable接口，使得该类有了多线程类的特征。 Thread类实际上也是实现了Runnable接口的类。 所有的多线程代码都是通过运行Thread的start()方法来运行的。因此不管怎么创建的，最终还是通过Thread的对象的API来控制线程的 二者区别实现Runnable接口的优势 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 扩充在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程 每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 优化匿名内部类方式实现线程的创建 12345678 Runnable r = new Runnable()&#123; public void run()&#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println("张宇:"+i); &#125; &#125;&#125;; new Thread(r).start(); 线程优先级 线程安全概念线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的； 若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步Java中提供了同步机制(synchronized)来解决线程安全问题 生成一个唯一的锁对象，抢到锁对象的线程可以执行同步方法，其余线程被阻塞，直到锁对象被释放 同步代码块可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123; private int ticket = 100; Object lock = new Object(); /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; synchronized (lock) &#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+"正在卖:"+ticket‐‐); &#125; &#125; &#125; &#125;&#125; 同步方法使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 对于非static方法,同步锁就是this。 对于static方法,我们使用当前方法所在类的字节码对象(类名.class) 1234567891011121314151617181920212223242526272829303132333435public class Ticket implements Runnable&#123; private int ticket = 100; /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; sellTicket(); &#125; &#125; /* * 锁对象 是 谁调用这个方法 就是谁 * 隐含 锁对象 就是 this * */ public synchronized void sellTicket()&#123; if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+"正在卖:"+ticket‐‐); &#125; &#125;&#125; 锁机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象 12public void lock() :加同步锁。public void unlock() :释放同步锁。 123456789101112131415161718192021222324252627282930public class Ticket implements Runnable&#123; private int ticket = 100; Lock lock = new ReentrantLock(); /* * 执行卖票操作 */ @Override public void run() &#123; //每个窗口卖票的操作 //窗口 永远开启 while(true)&#123; lock.lock(); if(ticket&gt;0)&#123;//有票 可以卖 //出票操作 //使用sleep模拟一下出票时间 try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto‐generated catch block e.printStackTrace(); &#125; //获取当前线程对象的名字 String name = Thread.currentThread().getName(); System.out.println(name+"正在卖:"+ticket‐‐); &#125; lock.unlock(); &#125; &#125;&#125; 线程状态常见状态概念 Timed Waiting（计时等待）Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。 在写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句 其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待) 实现一个计数器，计数到100，在每个数字之间暂停1秒，每隔10个数字输出一个字符串 12345678910111213141516171819 public class MyThread extends Thread &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if ((i) % 10 == 0) &#123; System.out.println("‐‐‐‐‐‐‐" + i); &#125; System.out.print(i); try &#123; Thread.sleep(1000); System.out.print("线程睡眠1秒！\n"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; new MyThread().start(); &#125;&#125; tips： 进入 TIMED_WAITING 状态的一种常见情形是调用 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。 为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠 sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。 小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就立刻执行。 BLOCKED（锁阻塞） Waiting（无限等待）等待唤醒 1234567891011121314151617181920212223242526272829303132333435363738394041424344 public class WaitingTest &#123; public static Object obj = new Object(); public static void main(String[] args) &#123; // 演示waiting new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; try &#123; System.out.println( Thread.currentThread().getName() +"=== 获取到锁对象，调用wait方法，进入waiting状态，释放锁对象"); obj.wait(); //无限等待 //obj.wait(5000); //计时等待, 5秒 时间到，自动醒来 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println( Thread.currentThread().getName + "=== 从waiting状态醒来，获取到锁对象，继续执行了"); &#125; &#125; &#125; &#125;,"等待线程").start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; //每隔3秒 唤醒一次 try &#123; System.out.println(Thread.currentThread().getName) Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj)&#123; System.out.println( Thread.currentThread().getName"‐‐‐‐‐ 获取到锁对象,调用notify方法，释放锁对象"); obj.notify(); &#125; &#125;// &#125; &#125;,"唤醒线程").start(); &#125;&#125; 通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方 法 或 Object.notifyAll()方法 其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系， 多个线程会争取锁，同时相互之间又存在协作关系 当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了 Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那 么就会将无限等待的A线程唤醒。如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 小结 等待唤醒机制线程间通信概念：多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同 多个thread类传入同一个runnable接口，且该runnable接口中有唯一锁对象，通过该对象来实现线程间通信 比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。 如何保证线程间通信有效利用资源： 多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 即我们需要 通过一定的手段使各个线程能有效的利用资源。而这种手段即—— 等待唤醒机制。 等待唤醒机制什么是等待唤醒机制 这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），但这并不是故事的全部，线程间也会有协作机制。 就是在一个线程进行了规定操作后，就进入等待状态， 等待其他线程执行完他们的指定代码过后 再将其唤醒;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。 wait/notify 就是线程间的一种协作机制。 等待唤醒中的方法 等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下： wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态 即是 WAITING。它还要等别的线程执行一个特别的动作，也即是“通知”在这个对象上等待的线程从wait set 中释放出 来，重新进入到调度队列（ready queue）中 notify：则选取锁通知对象的 wait set 中的一个线程释放 notifyAll：则释放锁通知对象的 wait set 上的全部线程。 注意： 哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁，成功后才能在当初调用 wait 方法之后的地方恢复执行。 总结： 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态； 否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态 调用wait和notify方法需要注意的细节 wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait 方法后的线程。 wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。 生产者与消费者问题等待唤醒机制其实就是经典的“生产者与消费者”的问题。 就拿生产包子消费包子来说等待唤醒机制如何有效利用资源： 123456789/*包子铺线程生产包子，吃货线程消费包子。当包子没有时，吃货线程等待，包子铺线程生产包子，并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。*/ 代码演示： 包子资源类： 12345public class BaoZi &#123; String pier ; String xianer ; boolean flag = false ;//包子资源 是否存在 包子资源状态&#125; 吃货线程类： 12345678910111213141516171819202122232425public class ChiHuo extends Thread&#123; private BaoZi bz; public ChiHuo(String name,BaoZi bz)&#123; super(name); this.bz = bz; &#125; @Override public void run() &#123; while(true)&#123; synchronized (bz)&#123; if(bz.flag == false)&#123;//没包子 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("吃货正在吃"+bz.pier+bz.xianer+"包子"); bz.flag = false; bz.notify(); &#125; &#125; &#125;&#125; 包子铺线程类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BaoZiPu extends Thread &#123; private BaoZi bz; public BaoZiPu(String name,BaoZi bz)&#123; super(name); this.bz = bz; &#125; @Override public void run() &#123; int count = 0; //造包子 while(true)&#123; //同步 synchronized (bz)&#123; if(bz.flag == true)&#123;//包子资源 存在 try &#123; bz.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 没有包子 造包子 System.out.println("包子铺开始做包子"); if(count%2 == 0)&#123; // 冰皮 五仁 bz.pier = "冰皮"; bz.xianer = "五仁"; &#125;else&#123; // 薄皮 牛肉大葱 bz.pier = "薄皮"; bz.xianer = "牛肉大葱"; &#125; count++; bz.flag=true; System.out.println("包子造好了："+bz.pier+bz.xianer); System.out.println("吃货来吃吧"); //唤醒等待线程 （吃货） bz.notify(); &#125; &#125; &#125;&#125; 测试类： 123456789101112public class Demo &#123; public static void main(String[] args) &#123; //等待唤醒案例 BaoZi bz = new BaoZi(); ChiHuo ch = new ChiHuo("吃货",bz); BaoZiPu bzp = new BaoZiPu("包子铺",bz); ch.start(); bzp.start(); &#125;&#125; 线程池线程池思想概述在Java中可以通过线程池来使得线程可以复用 概念 线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作 合理利用线程池的好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而导致 服务器瘫痪(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机) 使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个 执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此 在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors 工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是 池中的线程个数可以指定最大数量) 获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码： 12345678910111213public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println("我要一个教练"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("教练来了： " + Thread.currentThread().getName()); System.out.println("教我游泳,交完后，教练回到了游泳池"); &#125;&#125; 线程池测试类： 12345678910111213141516171819202122public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(2);//包含2个线程对象 // 创建Runnable实例对象 MyRunnable r = new MyRunnable(); //自己创建线程对象的方式 // Thread t = new Thread(r); // t.start(); ---&gt; 调用MyRunnable中的run() // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 // 将使用完的线程又归还到了线程池中 // 关闭线程池 //service.shutdown(); &#125;&#125; 文件File类概述java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 构造方法 public File(String pathname) public File(String parent, String child) public File(File parent, String child) tips： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 判断功能的方法 public boolean exists() public boolean isDirectory() public boolean isFile() 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 小贴士： ​ 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 递归概述 递归：指在当前方法内调用自己的这种现象。 递归的分类: 直接递归称为方法自身调用自己。 间接递归为A方法调用B方法，B方法调用C方法，C方法调用A方法。 注意事项： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。 构造方法禁止递归 核心：找到f(n)和f(n-1)的关系 递归求阶乘 阶乘：所有小于及等于该数的正整数的积。 1n的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 分析：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。 123推理得出：n! = n * (n-1)! f(n) = n*f(n-1) 出口：n=1时，返回1 代码实现： 12345678910111213public class DiGuiDemo &#123; public static int jc(int n) &#123; // 1的阶乘为1 if (n == 1) &#123; return 1; &#125; /* n不为1时,方法返回 n! = n*(n-1)! 递归调用getValue方法 */ return n * getValue(n - 1); &#125;&#125; 递归打印多级目录分析：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们要使用递归实现。 代码实现： 12345678910111213141516171819202122232425262728293031public class DiGuiDemo2 &#123; public static void main(String[] args) &#123; // 创建File对象 File dir = new File("D:\\aaa"); // 调用打印目录方法 printDir(dir); &#125; public static void printDir(File dir) &#123; // 获取子文件和目录 File[] files = dir.listFiles(); // 循环打印 /* 判断: 当是文件时,打印绝对路径. 当是目录时,继续调用打印目录的方法,形成递归调用. */ for (File file : files) &#123; // 判断 if (file.isFile()) &#123; // 是文件,输出文件绝对路径 System.out.println("文件名:"+ file.getAbsolutePath()); &#125; else &#123; // 是目录,输出目录绝对路径 System.out.println("目录:"+file.getAbsolutePath()); // 继续遍历,调用printDir,形成递归 printDir(file); &#125; &#125; &#125;&#125; 综合案例文件搜索搜索D:\aaa 目录中的.java 文件。 分析： 目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。 遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。 代码实现： 1234567891011121314151617181920212223242526public class DiGuiDemo3 &#123; public static void main(String[] args) &#123; // 创建File对象 File dir = new File("D:\\aaa"); // 调用打印目录方法 printDir(dir); &#125; public static void printDir(File dir) &#123; // 获取子文件和目录 File[] files = dir.listFiles(); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; // 是文件，判断文件名并输出文件绝对路径 if (file.getName().endsWith(".java")) &#123; System.out.println("文件名:" + file.getAbsolutePath()); &#125; &#125; else &#123; // 是目录，继续遍历,形成递归 printDir(file); &#125; &#125; &#125;&#125; 文件过滤器优化java.io.FileFilter是一个接口，是File的过滤器。 该接口的对象可以传递给File类的listFiles(FileFilter) 作为参数， 接 口中只有一个方法。 boolean accept(File pathname) ：测试pathname是否应该包含在当前File目录中，符合则返回true。 分析： 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。 accept方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则： 要么是.java文件。 要么是目录，用于继续遍历。 通过过滤器的作用，listFiles(FileFilter)返回的数组元素中，子文件对象都是符合条件的，可以直接打印。 代码实现： 123456789101112131415161718192021222324public class DiGuiDemo4 &#123; public static void main(String[] args) &#123; File dir = new File("D:\\aaa"); printDir2(dir); &#125; public static void printDir2(File dir) &#123; // 匿名内部类方式,创建过滤器子类对象 File[] files = dir.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; return pathname.getName().endsWith(".java")||pathname.isDirectory(); &#125; &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println("文件名:" + file.getAbsolutePath()); &#125; else &#123; printDir2(file); &#125; &#125; &#125;&#125; Lambda优化分析：FileFilter是函数式接口，因此可以用lambda表达式简写。 代码实现： 123456789101112131415public static void printDir3(File dir) &#123; // lambda的改写 File[] files = dir.listFiles(f -&gt;&#123; return f.getName().endsWith(".java") || f.isDirectory(); &#125;); // 循环打印 for (File file : files) &#123; if (file.isFile()) &#123; System.out.println("文件名:" + file.getAbsolutePath()); &#125; else &#123; printDir3(file); &#125; &#125;&#125; IO概述什么是IO把数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output Java中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作 IO的分类根据数据的流向分为：输入流和输出流。 输入流 ：把数据从其他设备上读取到内存中的流。 输出流 ：把数据从内存 中写出到其他设备上的流。 根据数据的类型分为：字节流和字符流。 字节流 ：以字节为单位，读写数据的流。 字符流 ：以字符为单位，读写数据的流。 IO的流向说明图解 顶级父类们 输入流 输出流 字节流 字节输入流InputStream 字节输出流OutputStream 字符流 字符输入流Reader 字符输出流Writer 字节流一切皆为字节一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，所以字节流可以传输任意文件数据。 在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。 字节输出流java.io.OutputStream抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地 public void close() public void flush() public void write(byte[] b) public void write(byte[] b, int off, int len) public abstract void write(int b) close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileOutputStreamOutputStream有很多子类 java.io.FileOutputStream类是文件输出流，用于将数据写出到文件。 构造方法 public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。 public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件 如果有这个文件，会清空这个文件的数据。 1234File file = new File("a.txt");FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象FileOutputStream fos = new FileOutputStream("b.txt"); 写出字节数据 写出字节：write(int b) 方法，每次可以写出一个字节数据 12345678 // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 写出数据fos.write(97); // 写出第1个字节fos.write(98); // 写出第2个字节fos.write(99); // 写出第3个字节// 关闭资源 fos.close(); 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。 流操作完毕后，必须释放系统资源，调用close方法，千万记得。 写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示： 12345678 // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 字符串转换为字节数组byte[] b = "黑马程序员".getBytes();// 写出字节数组数据fos.write(b);// 关闭资源 fos.close(); 写出指定长度字节数组：write(byte[] b, int off, int len) 12345678 // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 字符串转换为字节数组 byte[] b = "abcde".getBytes();// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b,2,2); // 关闭资源 fos.close(); 数据追加续写 public FileOutputStream(File file, boolean append) public FileOutputStream(String name, boolean append) 这两个构造方法，参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示清空原有数据 12345678 // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"，true); // 字符串转换为字节数组 byte[] b = "abcde".getBytes();// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); 写出换行Windows系统里，换行符号是\r\n 12345678910111213 // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 定义字节数组byte[] words = &#123;97,98,99,100,101&#125;;// 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write("\r\n".getBytes()); &#125;// 关闭资源 fos.close(); 回车符\r和换行符\n ： 回车符：回到一行的开头（return）。 换行符：下一行（newline）。 系统中的换行： Windows系统里，每行结尾是 回车+换行 ，即\r\n； Unix系统里，每行结尾只有 换行 ，即\n； Mac系统里，每行结尾是 回车 ，即\r。从 Mac OS X开始与Linux统一。 字节输入流java.io.InputStream抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。 public abstract int read()： 从输入流读取数据的下一个字节。 public int read(byte[] b)： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。 小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。 FileInputStreamjava.io.FileInputStream类是文件输入流，从文件中读取字节。 构造方法 FileInputStream(File file) FileInputStream(String name) 当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 12345// 使用File对象创建流对象 File file = new File("a.txt"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream("b.txt"); 读取字节数据 读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1 12345678910 // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream("read.txt"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125;// 关闭资源 fis.close(); 小贴士： 虽然读取了一个字节，但是会自动提升为int类型 流操作完毕后，必须释放系统资源，调用close方法，千万记得 使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 12345678910111213 // 使用文件名称创建流对象. FileInputStream fis = new FileInputStream("read.txt"); // 文件中为abcde // 定义变量，作为有效个数 int len ； // 定义字节数组，作为装字节数据的容器 byte[] b = new byte[2]; // 循环读取 while (( len= fis.read(b))!=-1) &#123; // 每次读取后,把数组的有效字节部分，变成字符串打印 System.out.println(new String(b，0，len));// len 每次读取的有效字节个数 &#125;// 关闭资源 fis.close(); 小贴士： 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 练习：图片复制复制原理图解 案例实现复制图片文件，代码使用演示： 123456789101112131415161718// 1.创建流对象// 1.1 指定数据源FileInputStream fis = new FileInputStream("D:\\test.jpg");// 1.2 指定目的地FileOutputStream fos = new FileOutputStream("test_copy.jpg");// 2.读写数据// 2.1 定义数组byte[] b = new byte[1024];// 2.2 定义长度int len;// 2.3 循环读取while ((len = fis.read(b))!=-1) &#123; // 2.4 写出数据 fos.write(b, 0 , len);&#125;// 3.关闭资源fos.close();fis.close(); 流的关闭原则：先开后关，后开先关。 字符流当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字 符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。 字符流会用到文件缓冲区，所以写入时多了个flush方法 字符输入流java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中 public void close() public int read() public int read(char[] cbuf) FileReader类java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 小贴士： 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file) FileReader(String fileName) 读取字符数据 读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示： 12345678910 // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fr.read())!=-1) &#123; System.out.println((char)b); &#125;// 关闭资源 fr.close(); 小贴士：虽然读取了一个字符，但是会自动提升为int类型。 使用字符数组读取：read(char[] cbuf)，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回-1 123456789101112 // 使用文件名称创建流对象 FileReader fr = new FileReader("read.txt"); // 定义变量，保存有效字符个数 int len ； // 定义字符数组，作为装字符数据的容器 char[] cbuf = new char[2]; // 循环读取 while ((len = fr.read(cbuf))!=-1) &#123; System.out.println(new String(cbuf,0,len)); &#125;// 关闭资源 fr.close(); 字符输出流java.io.Writer抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地 void write(int c) 写入单个字符。 void write(char[] cbuf)写入字符数组。 abstract void write(char[] cbuf, int off, int len) void write(String str)写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。 void flush() void close() FileWriter类java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 构造方法 FileWriter(File file) FileWriter(String fileName) 基本写出数据写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示： 123456789101112 // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 写出数据fw.write(97); // 写出第1个字符fw.write('b'); // 写出第2个字符fw.write('C'); // 写出第3个字符fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。 /* 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。 */ fw.close(); 小贴士： 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们 既想写出数据，又想继续使用流，就需要flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。 close:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。 写出其他数据 写出字符数组 ：write(char[] cbuf) 和 write(char[] cbuf, int off, int len) 12345678910 // 使用文件名称创建流对象 FileWriter fw = new FileWriter("fw.txt"); // 字符串转换为字节数组 char[] chars = "黑马程序员".toCharArray(); // 写出字符数组 fw.write(chars); // 黑马程序员 // 写出从索引2开始，2个字节。索引2是'程'，两个字节，也就是'程序'。 fw.write(b,2,2); // 程序 // 关闭资源 fos.close(); 写出字符串：write(String str) 和 write(String str, int off, int len) ，每次可以写出字符串中的数据，更为方便 续写和换行：操作类似于FileOutputStream。 12345678910 // 使用文件名称创建流对象，可以续写数据 FileWriter fw = new FileWriter("fw.txt"，true); // 写出字符串 fw.write("黑马"); // 写出换行 fw.write("\r\n"); // 写出字符串fw.write("程序员"); // 关闭资源 fw.close(); 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。 当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流 IO异常的处理JDK7前处理之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块 1234567891011121314151617181920 // 声明变量 FileWriter fw = null; try &#123; //创建流对象 fw = new FileWriter("fw.txt"); // 写出数据 fw.write("黑马程序员"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; JDK7的处理还可以使用JDK7优化后的try-with-resource 语句，该语句确保了每个资源在语句结束时自动关闭。 所谓的资源（resource）是指在程序完成后，必须关闭的对象。 12345try (创建流对象语句，如果多个,使用';'隔开) &#123; // 读写数据&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 代码使用演示： 123456789 // 创建流对象 try ( FileWriter fw = new FileWriter("fw.txt"); ) &#123; // 写出数据 fw.write("黑马程序员"); //黑马程序员 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDK9的改进JDK9中try-with-resource 的改进，对于引入对象的方式，支持的更加简洁。被引入的对象，同样可以自动关闭 改进前格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource("resource1");// 普通对象Resource resource2 = new Resource("resource2");// 引入方式：创建新的变量保存try (Resource r1 = resource1; Resource r2 = resource2) &#123; // 使用对象&#125; 改进后格式： 123456789// 被final修饰的对象final Resource resource1 = new Resource("resource1");// 普通对象Resource resource2 = new Resource("resource2");// 引入方式：直接引入try (resource1; resource2) &#123; // 使用对象&#125; 改进后，代码使用演示： 1234567891011121314// 创建流对象final FileReader fr = new FileReader("in.txt");FileWriter fw = new FileWriter("out.txt");// 引入到try中try (fr; fw) &#123; int b; // 读取数据 while ((b = fr.read())!=-1) &#123; // 写出数据 fw.write(b); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 属性集概述java.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一 个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。 Properties类构造方法 public Properties() :创建一个空的属性列表。 基本的存储方法 public Object setProperty(String key, String value) public String getProperty(String key) public Set&lt;String&gt; stringPropertyNames() ：所有键的名称的集合。 123456789101112// 创建属性集对象Properties properties = new Properties();// 添加键值对元素properties.setProperty("location", "D:\\a.txt");// 通过键,获取属性值System.out.println(properties.getProperty("location"));// 遍历属性集,获取所有键的集合Set&lt;String&gt; strings = properties.stringPropertyNames();// 打印键值对for (String key : strings ) &#123; System.out.println(key+" -- "+properties.getProperty(key));&#125; 与流相关的方法读取12345678910111213141516171819202122232425 /* 可以使用Properties集合中的方法load,把硬盘中保存的文件(键值对),读取到集合中使用 void load(InputStream inStream) void load(Reader reader) 参数: InputStream inStream:字节输入流,不能读取含有中文的键值对 Reader reader:字符输入流,能读取含有中文的键值对 使用步骤: 1.创建Properties集合对象 2.使用Properties集合对象中的方法load读取保存键值对的文件 3.遍历Properties集合 注意: 1.存储键值对的文件中,键与值默认的连接符号可以使用=,空格(其他符号) 2.存储键值对的文件中,可以使用#进行注释,被注释的键值对不会再被读取 3.存储键值对的文件中,键与值默认都是字符串,不用再加引号*/ // 创建属性集对象 Properties pro = new Properties(); // 加载文本中信息到属性集 pro.load(new FileInputStream("read.txt")); // 遍历集合并打印 Set&lt;String&gt; strings = pro.stringPropertyNames(); for (String key : strings ) &#123; System.out.println(key+" -- "+pro.getProperty(key)); &#125; 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。 写入123456789101112131415161718192021222324252627/* 可以使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 void store(OutputStream out, String comments) void store(Writer writer, String comments) 参数: OutputStream out:字节输出流,不能写入中文 Writer writer:字符输出流,可以写中文 String comments:注释,用来解释说明保存的文件是做什么用的 不能使用中文,会产生乱码,默认是Unicode编码 一般使用""空字符串 使用步骤: 1.创建Properties集合对象,添加数据 2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 4.释放资源 */ //1.创建Properties集合对象,添加数据 Properties prop = new Properties(); prop.setProperty("赵丽颖","168"); prop.setProperty("迪丽热巴","165"); prop.setProperty("古力娜扎","160"); //2.创建字节输出流/字符输出流对象,构造方法中绑定要输出的目的地 FileWriter fw = new FileWriter("09_IOAndProperties\\prop.txt"); //3.使用Properties集合中的方法store,把集合中的临时数据,持久化写入到硬盘中存储 prop.store(fw,"save data"); //4.释放资源 fw.close(); 缓冲流概述缓冲流,也叫高效流，是对4个基本的FileXxx 流的增强 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 缓冲流的基本原理：在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数 字节缓冲流构造方法 public BufferedInputStream(InputStream in) public BufferedOutputStream(OutputStream out) 效率测试如何更快呢？使用数组的方式 1234567891011121314 // 创建流对象try ( BufferedInputStream bis = new BufferedInputStream(new FileInputStream("jdk9.exe")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.exe"));)&#123; // 读写数据 int len; byte[] bytes = new byte[8*1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0 , len); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 字符缓冲流构造方法 public BufferedReader(Reader in) public BufferedWriter(Writer out) 特有方法字符缓冲流的基本方法与普通字符流调用方式一致 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 readLine方法演示 1234567891011 // 创建流对象 BufferedReader br = new BufferedReader(new FileReader("in.txt"));// 定义字符串,保存读取的一行文字 String line = null; // 循环读取,读取到最后返回null while ((line = br.readLine())!=null) &#123; System.out.print(line); System.out.println("------"); &#125;// 释放资源 br.close(); newLine方法演示，代码如下： 12345678 // 创建流对象BufferedWriter bw = new BufferedWriter(new FileWriter("out.txt")); // 写出数据 bw.write("黑马"); // 写出换行 bw.newLine();// 释放资源 bw.close(); 练习:文本排序请将文本信息恢复顺序。 1234567893.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。9.今当远离，临表涕零，不知所言。6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。 案例分析 逐行读取文本信息。 解析文本信息到集合中。 遍历集合，按顺序，写出文本信息。 转换流字符编码和字符集字符编码计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后 的结果 编码:字符按一定规则转换为对应字节 解码:字节按之前编码规则，逆向来获得字符，选错编码规则就会造成乱码 字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则 字符集 字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码 可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。 ASCII字符集 ： 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。 ISO-8859-1字符集： 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。 ISO-8859-1使用单字节编码，兼容ASCII编码。 GBxxx字符集： GB就是国标的意思，是为了显示中文而设计的一套字符集。 GB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个 汉字，这样大约可以组合了包含7000多个简体汉字，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个 字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字， 完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 GB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持 中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ： Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。 它最多使用4个字节的数字来表达每个字母、符号，或者文字，有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。 UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采 用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码，它使用一至四个字节为每个字 符编码，编码规则： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 编码引出的问题在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是， 当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。 12345678 FileReader fileReader = new FileReader("E:\\File_GBK.txt"); int read; while ((read = fileReader.read()) != -1) &#123; System.out.print((char)read); &#125; fileReader.close();输出结果：��� InputStreamReader类转换流java.io.InputStreamReader，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其 解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 InputStreamReader(InputStream in) InputStreamReader(InputStream in, String charsetName) 指定编码读取12345678910111213141516171819 // 定义文件路径,文件为gbk编码 String FileName = "E:\\file_gbk.txt"; // 创建流对象,默认UTF8编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName)); // 创建流对象,指定GBK编码 InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , "GBK");// 定义变量,保存字符 int read; // 使用默认编码字符流读取,乱码 while ((read = isr.read()) != -1) &#123; System.out.print((char)read); // ��Һ� &#125; isr.close(); // 使用指定编码字符流读取,正常解析 while ((read = isr2.read()) != -1) &#123; System.out.print((char)read);// 大家好 &#125; isr2.close(); OutputStreamWriter类转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字 节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 构造方法 OutputStreamWriter(OutputStream in) OutputStreamWriter(OutputStream in, String charsetName) 指定编码写出123456789101112131415 // 定义文件路径 String FileName = "E:\\out.txt"; // 创建流对象,默认UTF8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName)); // 写出数据 osw.write("你好"); // 保存为6个字节 osw.close(); // 定义文件路径String FileName2 = "E:\\out2.txt"; // 创建流对象,指定GBK编码 OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),"GBK"); // 写出数据 osw2.write("你好");// 保存为4个字节 osw2.close(); 转换流理解图解转换流是字节与字符间的桥梁！ 练习：转换文件编码将GBK编码的文本文件，转换为UTF-8编码的文本文件。 案例分析 指定GBK编码的转换流，读取文本文件。 使用UTF-8编码的转换流，写出文本文件。 案例实现123456789101112131415161718192021 // 1.定义文件路径 String srcFile = "file_gbk.txt"; String destFile = "file_utf8.txt";// 2.创建流对象 // 2.1 转换输入流,指定GBK编码 InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , "GBK"); // 2.2 转换输出流,默认utf8编码 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));// 3.读写数据 // 3.1 定义数组 char[] cbuf = new char[1024]; // 3.2 定义长度 int len; // 3.3 循环读取 while ((len = isr.read(cbuf))!=-1) &#123; // 循环写出 osw.write(cbuf,0,len); &#125; // 4.释放资源 osw.close(); isr.close(); 序列化概述Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中 存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信 息，都可以用来在内存中创建对象 ObjectOutputStream类java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。 构造方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 序列化操作一个对象要想序列化，必须满足两个条件: 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列 化或反序列化，会抛出NotSerializableException 。 该类的所有属性必须是可序列化的。如果有属性不需要序列化，则必须注明是瞬态的，使用transient 关键字修饰。 static修饰的成员是属于类的，不序列化 12345678public class Employee implements java.io.Serializable &#123; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println("Address check : " + name + " -- " + address); &#125;&#125; 2.写出对象方法 public final void writeObject (Object obj) : 将指定的对象写出。 12345678910111213141516Employee e = new Employee();e.name = "zhangsan";e.address = "beiqinglu";e.age = 20; try &#123; // 创建序列化流对象 ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("employee.txt")); // 写出对象 out.writeObject(e); // 释放资源 out.close(); fileOut.close(); System.out.println("Serialized data is saved"); // 姓名，地址被序列化，年龄没有被序列化。 &#125; catch(IOException i) &#123; i.printStackTrace(); &#125; ObjectInputStream类ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 构造方法 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 反序列化操作1如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法： public final Object readObject () : 读取一个对象。 123456789101112131415161718192021222324Employee e = null;try &#123; // 创建反序列化流 FileInputStream fileIn = new FileInputStream("employee.txt"); ObjectInputStream in = new ObjectInputStream(fileIn); // 读取一个对象 e = (Employee) in.readObject(); // 释放资源 in.close(); fileIn.close();&#125;catch(IOException i) &#123; // 捕获其他异常 i.printStackTrace(); return;&#125;catch(ClassNotFoundException c) &#123; // 捕获类找不到异常 System.out.println("Employee class not found"); c.printStackTrace(); return;&#125;// 无异常,直接打印输出System.out.println("Name: " + e.name); // zhangsanSystem.out.println("Address: " + e.address); // beiqingluSystem.out.println("age: " + e.age); // 0 对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。 反序列化操作2另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失 败，抛出一个InvalidClassException异常。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和 对应类是否版本匹配。 12345678public class Employee implements java.io.Serializable &#123; // 加入序列版本号 private static final long serialVersionUID = 1L; // 原本是jvm来管理，这样自己手动管理 public String name; public String address; // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值. public int eid; &#125; 练习：序列化集合 将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。 反序列化list.txt ，并遍历集合，打印对象信息。 案例分析 把若干学生对象 ，保存到集合中。 把集合作为一个整体序列化。 反序列化读取时，只需要读取一次，转换为集合类型。 遍历集合，可以打印所有的学生信息 案例实现1234567891011121314151617181920212223242526272829 // 创建 学生对象 Student student = new Student("老王", "laow"); Student student2 = new Student("老张", "laoz"); Student student3 = new Student("老李", "laol"); ArrayList&lt;Student&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(student); arrayList.add(student2); arrayList.add(student3); // 序列化操作 serializ(arrayList); // 反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("list.txt")); // 读取对象,强转为ArrayList类型 ArrayList&lt;Student&gt; list = (ArrayList&lt;Student&gt;)ois.readObject(); for (int i = 0; i &lt; list.size(); i++ )&#123; Student s = list.get(i); System.out.println(s.getName()+"--"+ s.getPwd()); &#125;private static void serializ(ArrayList&lt;Student&gt; arrayList) throws Exception &#123; // 创建 序列化流 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("list.txt")); // 写出对象 oos.writeObject(arrayList); // 释放资源 oos.close();&#125; 打印流概述平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类 能够方便地打印各种数据类型的值，是一种便捷的输出方式。 PrintStream类构造方法 public PrintStream(String fileName)： 使用指定的文件名创建一个新的打印流。 改变打印流向System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过我们可以改变它的流向。 12345678910// 调用系统的打印流,控制台直接输出97 System.out.println(97); // 创建打印流,指定文件的名称 PrintStream ps = new PrintStream("ps.txt"); // 设置系统的打印流流向,输出到ps.txt System.setOut(ps); // 调用系统的打印流,ps.txt中输出97 System.out.println(97); 网络编程入门软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构 两种架构各有优势，但是无论哪种架构，都离不开网络的支持。 网络编程，就是在一定的协议下，实现两台计算机的通信的程序。 网络通信协议 网络通信协议：通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守 一定的规则。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步 骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。 TCP/IP协议： 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最 广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理 数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。 运输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。 应用层：主要负责应用程序的协议，例如HTTP协议、FTP协议等。 协议分类通信的协议还是比较复杂的，java.net 包中包含的类和接口，它们提供低层次的通信细节。我们可以直接使用这些类和接 口，来专注于网络程序开发，而不用考虑通信的细节。 java.net 包中提供了两种常见的网络协议的支持： UDP：用户数据报协议(User Datagram Protocol)。UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不 建立逻辑连接 由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP 协议 但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使 用UDP协议 特点:数据被限制在64kb以内，超出这个范围就不能发送了。 数据报(Datagram):网络传输的基本单位 TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和 接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 第一次握手，客户端向服务器端发出连接请求，等待服务器确认。(服务器确认客户有发送能力) 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。(客户确认服务器有发送和接收能力) 第三次握手，客户端再次向服务器端发送确认信息，确认连接。(服务器确认客户有接收能力) 由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛，例如下载文件、浏览网页等。 网络编程三要素协议 协议：计算机网络通信必须遵守的规则，已经介绍过了，不再赘述 IP地址 IP地址：指互联网协议地址（Internet Protocol Address），IP地址用来给一个网络中的计算机设备做唯一的编号 IP地址分类 IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。 为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示 成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789，这样就解决了网络地址资源数量不够的问题。 常用命令 查看本机IP地址，在控制台输入： 1ipconfig 检查网络是否连通，在控制台输入： 1ping 220.181.57.216 特殊的IP地址 本机IP地址：127.0.0.1、localhost 。 端口号网络的通信，本质上是两个进程（应用程序）的通信 如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。 端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和 应用，普通的应用程序需要使用1024以上的端口号 利用协议+IP地址+端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其它进程进行交互。 TCP通信程序概述TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。 两端通信时步骤： 服务端程序，需要事先启动，等待客户端的连接。 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。 在Java中，提供了两个类用于实现TCP通信程序： 客户端：java.net.Socket 。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。 服务端：java.net.ServerSocket 。创建ServerSocket对象，相当于开启一个服务，并等待客户端的连接。 Socket类Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。 构造方法 public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。 小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。 1Socket client = new Socket("127.0.0.1", 6666); 成员方法 public InputStream getInputStream() 如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。 关闭生成的InputStream也将关闭相关的Socket。 public OutputStream getOutputStream() 如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。 关闭生成的OutputStream也将关闭相关的Socket。 public void close() 一旦一个socket被关闭，它不可再使用。 关闭此socket也将关闭相关的InputStream和OutputStream 。 public void shutdownOutput() ： 禁用此套接字的输出流。 任何先前写出的数据将被发送，随后终止输出流，不然服务器端收不到结束标志，会一直等待 ServerSocket类ServerSocket类：这个类实现了服务器套接字，该对象等待通过网络的请求。 构造方法 public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，将其绑定到一个指定的端口号 1ServerSocket server = new ServerSocket(6666); 成员方法 public Socket accept() ：侦听并接受连接，返回一个Socket对象，用于和客户端通信。该方法一直阻塞直到建立连接 简单的TCP网络程序TCP通信分析图解 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 到此，客户端向服务端发送数据成功。 自此，服务端向客户端回写数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 服务端实现： 12345678910111213141516171819202122232425262728public class ServerTCP &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端启动 , 等待连接 .... "); // 1.创建 ServerSocket对象，绑定端口，开始等待连接 ServerSocket ss = new ServerSocket(6666); // 2.接收连接 accept 方法, 返回 socket 对象. Socket server = ss.accept(); // 3.通过socket 获取输入流 InputStream is = server.getInputStream(); // 4.一次性读取数据 // 4.1 创建字节数组 byte[] b = new byte[1024]; // 4.2 据读取到字节数组中. int len = is.read(b)； // 4.3 解析数组,打印字符串信息 String msg = new String(b, 0, len); System.out.println(msg); // =================回写数据======================= // 5. 通过 socket 获取输出流 OutputStream out = server.getOutputStream(); // 6. 回写数据 out.write("我很好,谢谢你".getBytes()); // 7.关闭资源. out.close(); is.close(); server.close(); &#125;&#125; 客户端实现： 12345678910111213141516171819202122public class ClientTCP &#123; public static void main(String[] args) throws Exception &#123; System.out.println("客户端 发送数据"); // 1.创建 Socket ( ip , port ) , 确定连接到哪里. Socket client = new Socket("localhost", 6666); // 2.通过Scoket,获取输出流对象 OutputStream os = client.getOutputStream(); // 3.写出数据. os.write("你好么? tcp ,我来了".getBytes());// 没有主动关闭，两边应该会一直等待吧 // ==============解析回写========================= // 4. 通过Scoket,获取 输入流对象 InputStream in = client.getInputStream(); // 5. 读取数据数据 byte[] b = new byte[100]; int len = in.read(b); System.out.println(new String(b, 0, len)); // 6. 关闭资源 . in.close(); os.close(); client.close(); &#125;&#125; 综合案例文件上传案例文件上传分析图解 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 基本实现服务端实现： 12345678910111213141516171819202122232425public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务器 启动..... "); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 建立连接 Socket accept = serverSocket.accept(); // 3. 创建流对象 // 3.1 获取输入流,读取文件数据 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); // 3.2 创建输出流,保存到本地 . BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("copy.jpg")); // 4. 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println("文件上传已保存"); &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425public class FileUPload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("test.jpg")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket("localhost", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); bos.flush(); &#125; System.out.println("文件发送完毕"); // 3.释放资源 bos.close(); socket.close(); bis.close(); System.out.println("文件上传完毕 "); &#125;&#125; 文件上传优化分析 文件名称写死的问题 服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下： 12FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+".jpg") // 文件名称BufferedOutputStream bos = new BufferedOutputStream(fis); 循环接收的问题 服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下： 12345// 每次接收新的连接,创建一个Socketwhile（true）&#123; Socket accept = serverSocket.accept(); ......&#125; 效率问题 服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下： 123456789while（true）&#123; Socket accept = serverSocket.accept(); // accept 交给子线程处理. new Thread(() -&gt; &#123; ...... InputStream bis = accept.getInputStream(); ...... &#125;).start();&#125; 优化实现12345678910111213141516171819202122232425262728293031323334353637public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务器 启动..... "); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + ".jpg"); BufferedOutputStream bos = new BufferedOutputStream(fis);) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //4. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println("文件上传已保存"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 信息回写分析图解前四步与基本文件上传一致. 【服务端】获取输出流，回写数据。 【客户端】获取输入流，解析回写数据。 回写实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class FileUpload_Server &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务器 启动..... "); // 1. 创建服务端ServerSocket ServerSocket serverSocket = new ServerSocket(6666); // 2. 循环接收,建立连接 while (true) &#123; Socket accept = serverSocket.accept(); /* 3. socket对象交给子线程处理,进行读写操作 Runnable接口中,只有一个run方法,使用lambda表达式简化格式 */ new Thread(() -&gt; &#123; try ( //3.1 获取输入流对象 BufferedInputStream bis = new BufferedInputStream(accept.getInputStream()); //3.2 创建输出流对象, 保存到本地 . FileOutputStream fis = new FileOutputStream(System.currentTimeMillis() + ".jpg"); BufferedOutputStream bos = new BufferedOutputStream(fis); ) &#123; // 3.3 读写数据 byte[] b = new byte[1024 * 8]; int len; while ((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; // 4.=======信息回写=========================== System.out.println("back ........"); OutputStream out = accept.getOutputStream(); out.write("上传成功".getBytes()); out.close(); //================================ //5. 关闭 资源 bos.close(); bis.close(); accept.close(); System.out.println("文件上传已保存"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 客户端实现： 12345678910111213141516171819202122232425262728293031public class FileUpload_Client &#123; public static void main(String[] args) throws IOException &#123; // 1.创建流对象 // 创建输入流,读取本地文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream("test.jpg")); // 1.2 创建输出流,写到服务端 Socket socket = new Socket("localhost", 6666); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); //2.写出数据. byte[] b = new byte[1024 * 8 ]; int len ; while (( len = bis.read(b))!=-1) &#123; bos.write(b, 0, len); &#125; // 关闭输出流,通知服务端,写出数据完毕 socket.shutdownOutput(); System.out.println("文件发送完毕"); // 3. =====解析回写============ InputStream in = socket.getInputStream(); byte[] back = new byte[20]; in.read(back); System.out.println(new String(back)); in.close(); // ============================ // 4.释放资源 socket.close(); bis.close(); &#125;&#125; 模拟B\S服务器(扩展知识点)模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。 案例分析 准备页面数据，web文件夹。 复制到我们Module中，比如复制到day08中 我们模拟服务器端，ServerSocket类监听端口，使用浏览器访问 12345678910public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8000); Socket socket = server.accept(); InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int len = in.read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); server.close();&#125; 服务器程序中字节输入流可以读取到浏览器发来的请求信息 GET/web/index.html HTTP/1.1是浏览器的请求消息。/web/index.html为浏览器想要请求的服务器端的资源,使用字符串切割方式获取到请求的资源。 12345678//转换流,读取浏览器请求第一行BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream()));String requst = readWb.readLine();//取出请求资源的路径String[] strArr = requst.split(" ");//去掉web前面的/String path = strArr[1].substring(1);System.out.println(path); 案例实现服务端实现： 1234567891011121314151617181920212223242526272829303132333435public class SerDemo &#123; public static void main(String[] args) throws IOException &#123; System.out.println("服务端 启动 , 等待连接 .... "); // 创建ServerSocket 对象 ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); // 转换流读取浏览器的请求消息 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); // 取出请求资源的路径 String[] strArr = requst.split(" "); // 去掉web前面的/ String path = strArr[1].substring(1); // 读取客户端请求的资源文件 FileInputStream fis = new FileInputStream(path); byte[] bytes= new byte[1024]; int len = 0 ; // 字节输出流,将文件写会客户端 OutputStream out = socket.getOutputStream(); // 写入HTTP协议响应头,固定写法 out.write("HTTP/200 OK\r\n".getBytes()); out.write("Content-Type:text/html\r\n".getBytes()); // 必须要写入空行,否则浏览器不解析 out.write("\r\n".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); server.close(); &#125;&#125; 访问效果 火狐 小贴士：不同的浏览器，内核不一样，解析效果有可能不一样。 发现浏览器中出现很多的叉子,说明浏览器没有读取到图片信息导致。 浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); while(true)&#123; Socket socket = server.accept(); new Thread(new Web(socket)).start(); &#125; &#125; static class Web implements Runnable&#123; private Socket socket; public Web(Socket socket)&#123; this.socket=socket; &#125; public void run() &#123; try&#123; //转换流,读取浏览器请求第一行 BufferedReader readWb = new BufferedReader(new InputStreamReader(socket.getInputStream())); String requst = readWb.readLine(); //取出请求资源的路径 String[] strArr = requst.split(" "); System.out.println(Arrays.toString(strArr)); String path = strArr[1].substring(1); System.out.println(path); FileInputStream fis = new FileInputStream(path); System.out.println(fis); byte[] bytes= new byte[1024]; int len = 0 ; //向浏览器 回写数据 OutputStream out = socket.getOutputStream(); out.write("HTTP/200 OK\r\n".getBytes()); out.write("Content-Type:text/html\r\n".getBytes()); out.write("\r\n".getBytes()); while((len = fis.read(bytes))!=-1)&#123; out.write(bytes,0,len); &#125; fis.close(); out.close(); readWb.close(); socket.close(); &#125;catch(Exception ex)&#123; &#125; &#125; &#125;&#125; 访问效果：]]></content>
      <categories>
        <category>heima57</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2020%2F02%2F19%2F%E6%A1%86%E6%9E%B6%2FSpring%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2F2020%2F02%2F19%2F%E6%A1%86%E6%9E%B6%2FMybatis%2F</url>
    <content type="text"><![CDATA[概述框架 框架是可被应用开发者定制的应用骨架 框架是一种规则,保证开发者遵循相同的开发方式 框架提倡不要重复造轮子,对基础功能进行封装 优点 极大提高开发效率 利于团队协作 灵活的配置,易于后期维护 Mybatis 优秀的ORM框架 使用XML将SQL与程序解耦 学习简单,执行高效,是JDBC的延伸 中文文档 开发流程 环境配置引入Mybatis依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--提高下载速度--&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--分页助手,官方插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--自定义连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 核心配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--从官方文档中找这个约束--&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- goods_id ==&gt; goodsId 自动进行驼峰命名转换 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt; &lt;!--启用Pagehelper分页插件--&gt; &lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!--设置数据库类型--&gt; &lt;property name="helperDialect" value="mysql"/&gt; &lt;!--分页合理化--&gt; &lt;property name="reasonable" value="true"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--设置默认指向的数据库--&gt; &lt;environments default="dev"&gt; &lt;!--配置环境，不同的环境不同的id名字--&gt; &lt;environment id="dev"&gt; &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--采用连接池方式管理数据库连接--&gt; &lt;!--&lt;dataSource type="POOLED"&gt;--&gt; &lt;dataSource type="com.imooc.mybatis.datasource.C3P0DataSourceFactory"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;property name="initialPoolSize" value="5"/&gt; &lt;property name="maxPoolSize" value="20"/&gt; &lt;property name="minPoolSize" value="5"/&gt; &lt;!--...--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="prd"&gt; &lt;!-- 采用JDBC方式对数据库事务进行commit/rollback --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--采用连接池方式管理数据库连接--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://192.168.1.155:3306/babytun?useUnicode=true&amp;amp;characterEncoding=UTF-8"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--配置映射文件--&gt; &lt;mappers&gt; &lt;mapper resource="mappers/goods.xml"/&gt; &lt;mapper resource="mappers/goods_detail.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 初始化SessionFactory MyBatis核心对象 全局唯一 用于初始化MyBatis,创建SqlSession对象 1234//利用Reader加载classpath下的mybatis-config.xml核心配置文件Reader reader = Resources.getResourceAsReader("mybatis-config.xml");//初始化SqlSessionFactory对象,同时解析mybatis-config.xml文件SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); 初始化SqlSession 操作数据库的核心对象 使用JDBC方式与数据库交互 提供了数据表CRUD对应方法 123456789101112131415SqlSession sqlSession = null;try &#123; //创建SqlSession对象,SqlSession是JDBC的扩展类,用于与数据库交互 sqlSession = sqlSessionFactory.openSession(); //创建数据库连接(测试用) 实际上mybatis会自动获取,无须显示调用 Connection connection = sqlSession.getConnection();&#125;catch (Exception e)&#123; e.printStackTrace();&#125;finally &#123; if(sqlSession != null)&#123; //如果type="POOLED",代表使用连接池,close则是将连接回收到连接池中 //如果type="UNPOOLED",代表直连,close则会调用Connection.close()方法关闭连接 sqlSession.close(); &#125;&#125; 数据查询创建实体类可以自动生成,手动逐个创建亦可 创建Mappper映射文件在resourses的mapper包下创建具体映射文件 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--SqlSession通过namespace.id来调用具体SQL--&gt;&lt;mapper namespace="goods"&gt;&lt;/mapper&gt; 编写&lt;select&gt;SQL标签在映射文件中编写具体SQL标签 开启驼峰命名映射在核心配置文件&lt;settings&gt;标签中设置 主要是为了解决由于命名不同而无法注入的问题，也可以通过resultMap来 新增&lt;mapper&gt;在核心配置文件&lt;mappers&gt;标签中设置 SqlSession执行select语句1234567891011121314151617181920212223242526/** * select查询语句执行 * @throws Exception */@Testpublic void testSelectAll() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); // selectList查询多条数据 selectOne查询单个数据 // 命名空间.id List&lt;Goods&gt; list = session.selectList("goods.selectAll"); for(Goods g : list)&#123; System.out.println(g.getTitle()); &#125; // CUD操作需要提交事务 // session.commit(); &#125;catch (Exception e)&#123; // if(session != null)&#123; // session.rollback();//回滚事务 // &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125;&#125; MyBatisUtil12345678910111213141516171819202122232425262728293031323334353637383940/** * MyBatisUtils工具类,创建全局唯一的SqlSessionFactory对象 * 饿汉式 */public class MyBatisUtils &#123; //利用static(静态)属于类不属于对象,且全局唯一 private static SqlSessionFactory sqlSessionFactory = null; //利用静态块在初始化类时实例化sqlSessionFactory static &#123; Reader reader = null; try &#123; reader = Resources.getResourceAsReader("mybatis-config.xml"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); &#125; catch (IOException e) &#123; e.printStackTrace(); //初始化错误时,通过抛出异常ExceptionInInitializerError通知调用者 throw new ExceptionInInitializerError(e); &#125; &#125; /** * openSession 创建一个新的SqlSession对象 * @return SqlSession对象 */ public static SqlSession openSession()&#123; //默认SqlSession对自动提交事务数据(commit) //设置false代表关闭自动提交,改为手动提交事务数据 return sqlSessionFactory.openSession(false); &#125; /** * 释放一个有效的SqlSession对象 * @param session 准备释放SqlSession对象 */ public static void closeSession(SqlSession session)&#123; if(session != null)&#123; session.close(); &#125; &#125;&#125; SQL标签CUD逐条处理1234567891011121314151617181920212223242526&lt;insert id="insert" parameterType="com.imooc.mybatis.entity.Goods"&gt; INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;) &lt;!--当前连接中最后--&gt; &lt;selectKey resultType="Integer" keyProperty="goodsId" order="AFTER"&gt; select last_insert_id() &lt;/selectKey&gt;&lt;/insert&gt;&lt;update id="update" parameterType="com.imooc.mybatis.entity.Goods"&gt; UPDATE t_goods SET title = #&#123;title&#125; , sub_title = #&#123;subTitle&#125; , original_cost = #&#123;originalCost&#125; , current_price = #&#123;currentPrice&#125; , discount = #&#123;discount&#125; , is_free_delivery = #&#123;isFreeDelivery&#125; , category_id = #&#123;categoryId&#125; WHERE goods_id = #&#123;goodsId&#125;&lt;/update&gt;&lt;!--delete from t_goods where goods_id in (1920,1921)--&gt;&lt;delete id="delete" parameterType="Integer"&gt; delete from t_goods where goods_id = #&#123;value&#125;&lt;/delete&gt; 批处理批处理也有上限，数据过多时可以使用循环嵌套来批量插入 12345678910111213141516&lt;!--INSERT INTO table--&gt;&lt;!--VALUES ("a" , "a1" , "a2"),("b" , "b1" , "b2"),(....)--&gt;&lt;insert id="batchInsert" parameterType="java.util.List"&gt; INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES &lt;foreach collection="list" item="item" index="index" separator=","&gt; (#&#123;item.title&#125;,#&#123;item.subTitle&#125;, #&#123;item.originalCost&#125;, #&#123;item.currentPrice&#125;, #&#123;item.discount&#125;, #&#123;item.isFreeDelivery&#125;, #&#123;item.categoryId&#125;) &lt;/foreach&gt;&lt;/insert&gt;&lt;!--in (1901,1902)--&gt;&lt;delete id="batchDelete" parameterType="java.util.List"&gt; DELETE FROM t_goods WHERE goods_id in &lt;foreach collection="list" item="item" index="index" open="(" close=")" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/delete&gt; R单表查询12345678910111213141516171819&lt;!-- 单参数传递,使用parameterType指定参数的数据类型即可,SQL中#&#123;value&#125;提取参数--&gt;&lt;select id="selectById" parameterType="Integer" resultType="com.imooc.mybatis.entity.Goods"&gt; select * from t_goods where goods_id = #&#123;value&#125;&lt;/select&gt;&lt;!-- 多参数传递时,使用parameterType指定Map接口,SQL中#&#123;key&#125;提取参数 --&gt;&lt;select id="selectByPriceRange" parameterType="java.util.Map" resultType="com.imooc.mybatis.entity.Goods"&gt; select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125; order by current_price limit 0,#&#123;limt&#125;&lt;/select&gt;&lt;select id="selectPage" resultType="com.imooc.mybatis.entity.Goods"&gt; select * from t_goods where current_price &amp;lt; 1000&lt;/select&gt; 多表查询123456789101112131415161718192021222324252627282930313233343536373839 &lt;!-- 单表查询可以建立对应实体类 多表可以使用LinkedHashMap或者关系映射 利用LinkedHashMap保存多表关联结果 使用LinkedHashMap是为了保证有序 MyBatis会将每一条记录包装为LinkedHashMap对象 key是字段名 value是字段对应的值 , 字段类型根据表结构进行自动判断 优点: 易于扩展,易于使用 缺点: 太过灵活,无法进行编译时检查 --&gt; &lt;select id="selectGoodsMap" resultType="java.util.LinkedHashMap" flushCache="true"&gt; select g.* , c.category_name,'1' as test from t_goods g , t_category c where g.category_id = c.category_id &lt;/select&gt; &lt;select id="selectByTitle" parameterType="java.util.Map" resultType="com.imooc.mybatis.entity.Goods"&gt; select * from t_goods where title = #&#123;title&#125; &lt;/select&gt; &lt;!--结果映射 可以只映射那些由于无法自动赋值的字段同一个值只会赋值一次,想要给多个字段赋值需要配置--&gt; &lt;resultMap id="rmGoods" type="com.imooc.mybatis.dto.GoodsDTO"&gt; &lt;!--设置主键字段与属性映射--&gt; &lt;id property="goods.goodsId" column="goods_id"&gt;&lt;/id&gt; &lt;!--设置非主键字段与属性映射--&gt; &lt;result property="goods.title" column="title"&gt;&lt;/result&gt; &lt;result property="goods.originalCost" column="original_cost"&gt;&lt;/result&gt; &lt;result property="goods.currentPrice" column="current_price"&gt;&lt;/result&gt; &lt;result property="goods.discount" column="discount"&gt;&lt;/result&gt; &lt;result property="goods.isFreeDelivery" column="is_free_delivery"&gt;&lt;/result&gt; &lt;result property="goods.categoryId" column="category_id"&gt;&lt;/result&gt; &lt;result property="category.categoryId" column="category_id"&gt;&lt;/result&gt; &lt;result property="category.categoryName" column="category_name"&gt;&lt;/result&gt; &lt;result property="category.parentId" column="parent_id"&gt;&lt;/result&gt; &lt;result property="category.categoryLevel" column="category_level"&gt;&lt;/result&gt; &lt;result property="category.categoryOrder" column="category_order"&gt;&lt;/result&gt; &lt;result property="test" column="test"/&gt; &lt;/resultMap&gt; &lt;select id="selectGoodsDTO" resultMap="rmGoods"&gt; select g.* , c.*,'1' as test from t_goods g , t_category c where g.category_id = c.category_id &lt;/select&gt; 预防SQL注入1234567891011121314151617181920212223242526272829@Testpublic void testSelectByTitle() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Map param = new HashMap(); /* $&#123;&#125;原文传值 有些时候使用会很方便，但使用须谨慎 select * from t_goods where title = '' or 1 =1 or title = '【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版' */ /* #&#123;&#125;预编译 select * from t_goods where title = "'' or 1 =1 or title = '【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版'" */ param.put("title","'' or 1=1 or title='【德国】爱他美婴幼儿配方奶粉1段800g*2罐 铂金版'"); param.put("order" , " order by title desc"); List&lt;Goods&gt; list = session.selectList("goods.selectByTitle", param); for(Goods g:list)&#123; System.out.println(g.getTitle() + ":" + g.getCurrentPrice()); &#125; &#125;catch (Exception e)&#123; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125;&#125; 动态SQL123456789101112&lt;select id="dynamicSQL" parameterType="java.util.Map" resultType="com.imooc.mybatis.entity.Goods"&gt; select * from t_goods &lt;!--可以将where标签替换为where '1' = '1'--&gt; &lt;where&gt; &lt;if test="categoryId != null"&gt; and category_id = #&#123;categoryId&#125; &lt;/if&gt; &lt;if test="currentPrice != null"&gt; and current_price &amp;lt; #&#123;currentPrice&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 多表级联查询OneToMany1234567891011121314151617181920212223 &lt;!-- resultMap可用于说明一对多或者多对一的映射逻辑 id 是resultMap属性引用的标志 type 指向One的实体(Goods)新建一个对应'多'的实体类在'一'的实体类中添加List&lt;GoodsDetail&gt; goodsDetails用于保存 --&gt; &lt;resultMap id="rmGoods1" type="com.imooc.mybatis.entity.Goods"&gt; &lt;!-- 映射goods对象的主键到goods_id字段 --&gt; &lt;id column="goods_id" property="goodsId"&gt;&lt;/id&gt; &lt;!-- collection的含义是,在 select * from t_goods limit 0,10 得到结果后,对所有Goods对象遍历得到goods_id字段值, 并代入到goodsDetail命名空间的findByGoodsId的SQL中执行查询, 将得到的"商品详情"集合赋值给goodsDetails List对象. column用于给select传入参数 --&gt; &lt;collection property="goodsDetails" select="goodsDetail.selectByGoodsId" column="goods_id"/&gt; &lt;/resultMap&gt; &lt;select id="selectOneToMany" resultMap="rmGoods1"&gt; select * from t_goods limit 0,10 &lt;/select&gt; ManyToOne12345678910111213141516&lt;select id="selectByGoodsId" parameterType="Integer" resultType="com.imooc.mybatis.entity.GoodsDetail"&gt; select * from t_goods_detail where goods_id = #&#123;value&#125;&lt;/select&gt;&lt;resultMap id="rmGoodsDetail" type="com.imooc.mybatis.entity.GoodsDetail"&gt; &lt;id column="gd_id" property="gdId"/&gt; &lt;!--goods_id用于传参后为给对应字段赋值，需手动映射--&gt; &lt;result column="goods_id" property="goodsId"/&gt; &lt;!--在'多'的实体类中添加一的字段 column用于传参--&gt; &lt;association property="goods" select="goods.selectById" column="goods_id"&gt;&lt;/association&gt;&lt;/resultMap&gt;&lt;select id="selectManyToOne" resultMap="rmGoodsDetail"&gt; select * from t_goods_detail limit 0,20&lt;/select&gt; 分页助手中文文档 常规分页步骤 maven依赖1234567891011&lt;!--分页助手,官方插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; 核心配置文件123456789&lt;!--启用Pagehelper分页插件--&gt;&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;!--设置数据库类型--&gt; &lt;property name="helperDialect" value="mysql"/&gt; &lt;!--分页合理化 首页和尾页的问题--&gt; &lt;property name="reasonable" value="true"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 代码12345678910111213141516171819202122232425262728@Test/** * PageHelper分页查询 * 不用修改mapper映射文件，在代码中开启即可 */public void testSelectPage() throws Exception &#123; SqlSession session = null; try &#123; session = MyBatisUtils.openSession(); /*startPage方法会自动将下一次查询进行分页*/ PageHelper.startPage(2,10); Page&lt;Goods&gt; page = (Page) session.selectList("goods.selectPage"); System.out.println("总页数:" + page.getPages()); System.out.println("总记录数:" + page.getTotal()); System.out.println("开始行号:" + page.getStartRow()); System.out.println("结束行号:" + page.getEndRow()); System.out.println("当前页码:" + page.getPageNum()); List&lt;Goods&gt; data = page.getResult();//当前页数据 for (Goods g : data) &#123; System.out.println(g.getTitle()); &#125; System.out.println(""); &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125;&#125; 自定义连接池C3P0maven123456&lt;!--自定义连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.4&lt;/version&gt; &lt;/dependency&gt; 代码12345678910111213package com.imooc.mybatis.datasource;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;/** * C3P0与MyBatis兼容使用的数据源工厂类 */public class C3P0DataSourceFactory extends UnpooledDataSourceFactory &#123; public C3P0DataSourceFactory()&#123; this.dataSource = new ComboPooledDataSource(); &#125;&#125; 核心配置缓存一级缓存默认开启，二级缓存需要手动开启 二级开启后默认所有查询会使用缓存，所有CUDcommit时会对该namesapce下缓存清空以保证数据一致性 建议对selectOne使用缓存 mapper中配置 12345678910111213141516171819202122232425&lt;!--开启了二级缓存 eviction是缓存的清除策略,当缓存对象数量达到上限后,自动触发对应算法对缓存对象清除 1.LRU – 最近最少使用的:移除最长时间不被使用的对象。 2.FIFO – 先进先出:按对象进入缓存的顺序来移除它们。 3.SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。 4.WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval 代表间隔多长时间自动清空缓存,单位毫秒,600000毫秒 = 10分钟 size 缓存存储上限,用于保存对象或集合(1个集合算1个对象)的数量上限 readOnly 设置为true ,代表返回只读缓存,每次从缓存取出的是缓存对象本身.这种执行效率较高 设置为false , 代表每次取出的是缓存对象的"副本",每一次取出的对象都是不同的,这种安全性较高 --&gt; &lt;cache eviction="LRU" flushInterval="600000" size="512" readOnly="true"/&gt; &lt;!-- useCache="false"代表不使用缓存 缓存开启之后默认为true --&gt; &lt;select id="selectAll" resultType="com.imooc.mybatis.entity.Goods" useCache="false"&gt; select * from t_goods order by goods_id desc limit 10 &lt;/select&gt; &lt;!--flushCache="true"在sql执行后强制清空缓存--&gt; &lt;insert id="insert" parameterType="com.imooc.mybatis.entity.Goods" flushCache="true"&gt; INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;) &lt;!--&lt;selectKey resultType="Integer" keyProperty="goodsId" order="AFTER"&gt;--&gt; &lt;!--select last_insert_id()--&gt; &lt;!--&lt;/selectKey&gt;--&gt; &lt;/insert&gt; 注解开发核心配置12345&lt;mappers&gt; &lt;!--&lt;mapper class="com.imooc.mybatis.dao.GoodsDAO"/&gt;--&gt; &lt;!--该包下的类会被作为mapper--&gt; &lt;package name="com.imooc.mybatis.dao"/&gt;&lt;/mappers&gt; 代码映射类12345678910111213141516171819202122232425262728package com.imooc.mybatis.dao;import com.imooc.mybatis.dto.GoodsDTO;import com.imooc.mybatis.entity.Goods;import org.apache.ibatis.annotations.*;import java.util.List;public interface GoodsDAO &#123; @Select("select * from t_goods where current_price between #&#123;min&#125; and #&#123;max&#125; order by current_price limit 0,#&#123;limt&#125;") public List&lt;Goods&gt; selectByPriceRange(@Param("min") Float min ,@Param("max") Float max ,@Param("limt") Integer limt); @Insert("INSERT INTO t_goods(title, sub_title, original_cost, current_price, discount, is_free_delivery, category_id) VALUES (#&#123;title&#125; , #&#123;subTitle&#125; , #&#123;originalCost&#125;, #&#123;currentPrice&#125;, #&#123;discount&#125;, #&#123;isFreeDelivery&#125;, #&#123;categoryId&#125;)") //&lt;selectKey&gt; @SelectKey(statement = "select last_insert_id()" , before = false , keyProperty = "goodsId" , resultType = Integer.class) public int insert(Goods goods); @Select("select * from t_goods") //&lt;resultMap&gt; @Results(&#123; //&lt;id&gt; @Result(column = "goods_id" ,property = "goodsId" , id = true) , //&lt;result&gt; @Result(column = "title" ,property = "title"), @Result(column = "current_price" ,property = "currentPrice") &#125;) public List&lt;GoodsDTO&gt; selectAll();&#125; 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyBatisTestor &#123; @Test public void testSelectByPriceRange() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); List&lt;Goods&gt; list = goodsDAO.selectByPriceRange(100f, 500f, 20); System.out.println(list.size()); &#125;catch (Exception e)&#123; throw e; &#125; finally &#123; MyBatisUtils.closeSession(session); &#125; &#125; /** * 新增数据 * @throws Exception */ @Test public void testInsert() throws Exception &#123; SqlSession session = null; try&#123; session = MyBatisUtils.openSession(); Goods goods = new Goods(); goods.setTitle("测试商品"); goods.setSubTitle("测试子标题"); goods.setOriginalCost(200f); goods.setCurrentPrice(100f); goods.setDiscount(0.5f); goods.setIsFreeDelivery(1); goods.setCategoryId(43); GoodsDAO goodsDAO = session.getMapper(GoodsDAO.class); //insert()方法返回值代表本次成功插入的记录总数 int num = goodsDAO.insert(goods); session.commit();//提交事务数据 System.out.println(goods.getGoodsId()); &#125;catch (Exception e)&#123; if(session != null)&#123; session.rollback();//回滚事务 &#125; throw e; &#125;finally &#123; MyBatisUtils.closeSession(session); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>mybatis</tag>
        <tag>主流框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web]]></title>
    <url>%2F2020%2F02%2F19%2Fheima57%2Fjava-Web%2F</url>
    <content type="text"><![CDATA[XML概述 与HTML比较 用途 文档规则 xml文档的后缀名 .xml xml第一行必须定义为文档声明 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&gt; version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 yes为依赖，no为不依赖 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 书写规则合理的标签名 适当的注释和缩进合理使用属性id属性值唯一 特殊字符实体引用 CDATA标签 子元素顺序一致语义约束XML文档结构正确，但可能不是有效的，需要加以约束 DTD概述 引用 本地： 网络： XML Schema概述 引用123456&lt;!-- 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 3.引入xsd文件命名空间. xsi:schemaLocation="http://www.itcast.cn/xml student.xsd" 4.为每一个xsd约束声明一个前缀,作为标识 xmlns="http://www.itcast.cn/xml" --&gt; 实例123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"&gt; &lt;element name="hr"&gt; &lt;!-- complexType标签含义是复杂节点，包含子节点时必须使用这个标签 --&gt; &lt;complexType&gt; &lt;!-- 下面的子节点必须有序 --&gt; &lt;sequence&gt; &lt;!-- 出现次数 --&gt; &lt;element name="employee" minOccurs="1" maxOccurs="9999"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="name" type="string"&gt;&lt;/element&gt; &lt;element name="age"&gt; &lt;!-- 对范围做限制 --&gt; &lt;simpleType&gt; &lt;restriction base="integer"&gt; &lt;minInclusive value="18"&gt;&lt;/minInclusive&gt; &lt;maxInclusive value="60"&gt;&lt;/maxInclusive&gt; &lt;/restriction&gt; &lt;/simpleType&gt; &lt;/element&gt; &lt;element name="salary" type="integer"&gt;&lt;/element&gt; &lt;element name="department"&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;element name="dname" type="string"&gt;&lt;/element&gt; &lt;element name="address" type="string"&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;!-- 对属性做限制 --&gt; &lt;attribute name="no" type="string" use="required"&gt;&lt;/attribute&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/schema&gt; XML解析器概述* 操作xml文档 1. 解析(读取)：将文档中的数据读取到内存中 2. 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式 DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见的解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 DOM4J概述 所有标签都是element对象 直接从网上下载jar包 解析示例12345678910111213141516171819202122232425262728293031323334public class HrReader &#123; public void readXml()&#123; String file = "d:/workspace/xml/src/hr.xml"; //SAXReader类是读取XML文件的核心类，用于将XML解析后以“树”的形式保存在内存中。 SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); //获取XML文档的根节点，即hr标签 Element root = document.getRootElement(); //elements方法用于获取指定的标签集合 List&lt;Element&gt; employees = root.elements("employee"); for(Element employee : employees)&#123; //element方法用于获取唯一的子节点对象 Element name = employee.element("name"); String empName = name.getText();//getText()方法用于获取标签文本 System.out.println(empName); System.out.println(employee.elementText("age")); System.out.println(employee.elementText("salary")); Element department = employee.element("department"); System.out.println(department.element("dname").getText()); System.out.println(department.element("address").getText()); Attribute att = employee.attribute("no"); System.out.println(att.getText()); &#125; &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrReader reader = new HrReader(); reader.readXml(); &#125; &#125; 写入示例123456789101112131415161718192021222324252627282930public class HrWriter &#123; public void writeXml()&#123; String file = "d:/workspace/xml/src/hr.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); Element root = document.getRootElement(); Element employee = root.addElement("employee"); employee.addAttribute("no", "3311"); Element name = employee.addElement("name"); name.setText("李铁柱"); employee.addElement("age").setText("37"); employee.addElement("salary").setText("3600"); Element department = employee.addElement("department"); department.addElement("dname").setText("人事部"); department.addElement("address").setText("XX大厦-B105"); // 将修改写入文件，这样写入不受约束文件限制 Writer writer = new OutputStreamWriter(new FileOutputStream(file) , "UTF-8"); document.write(writer); writer.close(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; HrWriter hrWriter = new HrWriter(); hrWriter.writeXml(); &#125;&#125; XPath概述 基本表达式 谓语表达式 Jaxen概述 国内可在阿里云中央仓库下载 示例12345678910111213141516171819202122232425262728293031323334353637public class XPathTestor &#123; public void xpath(String xpathExp)&#123; String file = "E:/lianxi/xml/hr.xml"; SAXReader reader = new SAXReader(); try &#123; Document document = reader.read(file); // Node为element和attribute的父类 List&lt;Node&gt; nodes = document.selectNodes(xpathExp); for(Node node : nodes)&#123; Element emp = (Element)node; System.out.println(emp.attributeValue("no")); System.out.println(emp.elementText("name")); System.out.println(emp.elementText("age")); System.out.println(emp.elementText("salary")); System.out.println("=============================="); &#125; &#125; catch (DocumentException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; XPathTestor testor = new XPathTestor();// testor.xpath("/hr/employee");// testor.xpath("//employee");// testor.xpath("//employee[salary&lt;4000]");// testor.xpath("//employee[name='李铁柱']");// testor.xpath("//employee[@no=3304]");// testor.xpath("//employee[1]");// testor.xpath("//employee[last()]"); //testor.xpath("//employee[position()&lt;3]"); testor.xpath("//employee[3] | //employee[8]"); &#125;&#125; J2EE概述 服务器概述 服务器：安装了服务器软件的计算机 服务器软件：接收用户的请求，处理请求，做出响应 web服务器软件：接收用户的请求，处理请求，做出响应。 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 web容器 常见的java相关的web服务器软件： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源免费 Tomcat与J2EE关系 使用 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格 卸载：删除目录就行了 启动： bin/startup.bat ,双击运行该文件即可 访问：浏览器输入：http://localhost:8080 回车访问自己 http://别人的ip:8080 访问别人 可能遇到的问题： 黑窗口一闪而过： 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错： 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 netstat -ano 温柔：修改自身的端口号 conf/server.xml &lt;Connector port=”8888” protocol=”HTTP/1.1”connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 关闭： 正常关闭： bin/shutdown.bat ctrl+c 强制关闭： 点击启动窗口的× 部署项目 直接将项目放到webapps目录下即可。 /hello：项目的访问路径–&gt;虚拟目录 默认为工程名 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩 修改虚拟目录 法一：配置conf/server.xml文件在标签体中配置 docBase:项目存放的路径 path：虚拟目录 法二：在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写 虚拟目录：xml文件的名称 项目结构 集成到IDEA 相关配置 IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台的log：Using CATALINA_BASE: “C:\Users\fqy.IntelliJIdea2018.1\system\tomcat_itcast” idea对tomcat端口，虚拟目录等配置都对应着该路径下的配置文件 工作空间项目和tomcat部署的web项目 tomcat真正访问的是“tomcat部署的web项目” “tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 tomcat部署的web项目通过工作空间项目经过编译等处理生成 WEB-INF目录下的资源不能被浏览器直接访问。 断点调试：使用”小虫子”启动 dubug 启动 中文乱码get方式tomcat8及以后默认支持中文 post方式request.setCharcterEncoding(&quot;utf-8&quot;) response.setContentType(&quot;text/heml;charset=utf-8&quot;) 或者new String(request.getParamter(&quot;hehe&quot;).getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;) Servlet概述Server Applet，服务器小程序，主要用于生成动态Web内容，是J2EE最重要的组成部分 Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 将来我们自定义一个类，实现Servlet接口，复写方法 基础知识创建JavaEE项目 实现1234567891011121314151. 定义一个类，实现Servlet接口 * public class ServletDemo1 implements Servlet2. 实现接口中的抽象方法 3. 配置Servlet 在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的标签体内容。 如果有，则在找到对应的全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 生命周期方法1234567891011121314151617181. 被创建：执行init方法，只执行一次 * Servlet什么时候被创建？ * 默认情况下，第一次被访问时，Servlet被创建 * 可以配置执行Servlet的创建时机。 * 在&lt;servlet&gt;标签下配置 1. 第一次被访问时，创建 * &lt;load-on-startup&gt;的值为负数 默认 2. 在服务器启动时，创建 * &lt;load-on-startup&gt;的值为0或正整数 越小越优先 * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 * 多个用户同时访问时，可能存在线程安全问题。 * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值2. 提供服务：执行service方法，执行多次 核心方法 * 每次访问Servlet时，Service方法都会被调用一次。3. 被销毁：执行destroy方法，只执行一次 * Servlet被销毁时执行。服务器关闭时，Servlet被销毁 * 只有服务器正常关闭时，才会执行destroy方法。 * destroy方法在Servlet被销毁之前执行，一般用于释放资源 Servlet3.0支持注解配置。可以不需要web.xml了 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 定义一个类，实现Servlet接口 复写方法 在类上使用@WebServlet注解，进行配置 @WebServlet(“资源路径”) urlpartten:Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“/d4”,”/dd4”,”/ddd4”}) 路径定义规则： /xxx：路径匹配 /xxx/xxx:多层路径，目录结构 *.do：扩展名匹配 12345678910111213141516// @WebServlet的源码@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface WebServlet &#123; String name() default "";//相当于&lt;Servlet-name&gt; String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default ""; String largeIcon() default ""; String description() default ""; String displayName() default "";&#125; 访问 体系结构Servlet – 接口 |GenericServlet – 抽象类 |HttpServlet – 抽象类 GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 HttpServlet：对http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet/doPost方法 request对象概述 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 体系结构ServletRequest – 接口 | 继承HttpServletRequest – 接口 | 实现org.apache.catalina.connector.RequestFacade 类(tomcat) 功能获取请求消息数据 获取请求行数据 1. 获取请求方式 ：GET * String getMethod() 2. (*)获取虚拟目录：/day14 通过这个来动态获取 * String getContextPath() 3. 获取Servlet路径: /demo1 * String getServletPath() 4. 获取get方式请求参数：name=zhangsan * String getQueryString() 5. (*)获取请求URI：/day14/demo1 * String getRequestURI(): /day14/demo1 * StringBuffer getRequestURL() :http://localhost/day14/demo1 * URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 * URI：统一资源标识符 : /day14/demo1 共和国 * URL是URI的一种具体实现 6. 获取协议及版本：HTTP/1.1 * String getProtocol() 7. 获取客户机的IP地址： * String getRemoteAddr()获取请求头数据 123&gt; * String getHeader(String name):通过请求头的名称获取请求头的值&gt; * Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称&gt; 获取请求体数据 1234567&gt; * 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数&gt; * 步骤：&gt; 1. 获取流对象&gt; * BufferedReader getReader()：获取字符输入流，只能操作字符数据&gt; * ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据&gt; 2. 再从流对象中拿数据&gt; 其他功能 获取请求参数通用方式 123456789&gt; 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123&gt; 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game&gt; 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称&gt; 4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合&gt; * 中文乱码问题：&gt; * get方式：tomcat 8 已经将get方式乱码问题解决了&gt; * post方式：会乱码&gt; * 解决：在获取参数前，设置request的编码request.setCharacterEncoding("utf-8");&gt; 请求转发 123456789&gt; 一种在服务器内部的资源跳转方式&gt; 1. 步骤：&gt; 1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)&gt; 2. 使用RequestDispatcher对象调用forward方法转发&gt; 2. 特点：&gt; 1. 浏览器地址栏路径不发生变化&gt; 2. 只能转发到当前服务器内部资源中。&gt; 3. 转发是一次请求&gt; 共享数据 1234567&gt; * 域对象：一个有作用范围的对象，可以在范围内共享数据&gt; * request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据&gt; * 方法：&gt; 1. void setAttribute(String name,Object obj):存储数据&gt; 2. Object getAttitude(String name):通过键获取值&gt; 3. void removeAttribute(String name):通过键移除键值对&gt; 获取ServletContext ServletContext getServletContext() response对象 设置响应消息 12345678910&gt; 1. 设置响应行&gt; 1. 格式：HTTP/1.1 200 ok&gt; 2. 设置状态码：setStatus(int sc) &gt; 2. 设置响应头：setHeader(String name, String value) &gt; 3. 设置响应体：&gt; 1. 获取输出流&gt; * 字符输出流：PrintWriter getWriter()&gt; * 字节输出流：ServletOutputStream getOutputStream()&gt; 2. 使用输出流，将数据输出到客户端浏览器&gt; 重定向 资源跳转的方式 * 代码实现： //1. 设置状态码为302 response.setStatus(302); //2.设置响应头location response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法 response.sendRedirect(&quot;/day15/responseDemo2&quot;); * 重定向的特点:redirect 1. 地址栏发生变化 2. 重定向可以访问其他站点(服务器)的资源 3. 重定向是两次请求。不能使用request对象来共享数据 * 转发的特点：forward 1. 转发地址栏路径不变 2. 转发只能访问当前服务器下的资源 3. 转发是一次请求，可以使用request对象来共享数据路径设置 1234567891011121314151617&gt; 1. 相对路径：通过相对路径不可以确定唯一资源&gt; * 如：./index.html&gt; * 不以/开头，以.开头路径(./可以省略)&gt; &gt; * 规则：找到当前资源和目标资源之间的相对位置关系&gt; 2. 绝对路径：通过绝对路径可以确定唯一资源&gt; * 如：http://localhost/day15/responseDemo2 /day15/responseDemo2&gt; * 以/开头的路径&gt; &gt; * 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出&gt; tips：&gt; * 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)&gt; * 建议虚拟目录动态获取：request.getContextPath()&gt; * &lt;a&gt; , &lt;form&gt;，重定向...&gt; * 给服务器使用：不需要加虚拟目录&gt; * 转发路径&gt; 服务器输出字符数据到浏览器 1234567891011121314&gt; * 步骤：&gt; 1. 获取字符输出流&gt; 2. 输出数据&gt; &gt; * 注意：&gt; * 乱码问题：&gt; 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1&gt; 2. 设置该流的默认编码&gt; response.setCharactorEncoding(&quot;utf-8&quot;)&gt; 3. 告诉浏览器响应体使用的编码 由此可以不用第二步&gt; response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;)&gt; //2,3可以简写为此，是在获取流之前设置&gt; response.setContentType(&quot;text/html;charset=utf-8&quot;);&gt; 服务器输出字节数据到浏览器 12345&gt; 1. 获取字节输出流&gt; 2. 输出数据&gt; response.setContentType(&quot;text/html;charset=utf-8&quot;);&gt; response.getOutputStream().write(&quot;你好&quot;.getbytes(&quot;utf-8&quot;))&gt; ServletContext123456789101112131415161718192021222324251. 概念：代表整个web应用，可以和程序的容器(服务器)来通信2. 获取： 1. 通过request对象获取 request.getServletContext(); 2. 通过HttpServlet获取 this.getServletContext();3. 功能： 1. 获取MIME类型： tomcat的web.xml(所有web.xml的父文件)中定义了文件后缀和MIME类型的映射 * MIME类型:在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取：String getMimeType(String file) * 通过文件名来获取，web.xml中保存了扩展名和MIME类型关系 2. 域对象：共享数据 生命周期和服务器一样，所以尽量少往里面存数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) * ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 classloader只能获取src下文件的路径，这个可以获取web下的 方法：String getRealPath(String path) 从web目录开始 String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问 String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问 String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问 案例登录案例 验证码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@WebServlet("/checkCodeServlet")public class CheckCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; //服务器通知浏览器不要缓存 response.setHeader("pragma","no-cache"); response.setHeader("cache-control","no-cache"); response.setHeader("expires","0"); //在内存中创建一个长80，宽30的图片，默认黑色背景 //参数一：长 //参数二：宽 //参数三：颜色 int width = 80; int height = 30; BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //获取画笔 Graphics g = image.getGraphics(); //设置画笔颜色为灰色 g.setColor(Color.GRAY); //填充图片 g.fillRect(0,0, width,height); //产生4个随机验证码，12Ey String checkCode = getCheckCode(); //将验证码放入HttpSession中 request.getSession().setAttribute("CHECKCODE_SERVER",checkCode); //设置画笔颜色为黄色 g.setColor(Color.YELLOW); //设置字体的小大 g.setFont(new Font("黑体",Font.BOLD,24)); //向图片上写入验证码 g.drawString(checkCode,15,25); //将内存中的图片输出到浏览器 //参数一：图片对象 //参数二：图片的格式，如PNG,JPG,GIF //参数三：图片输出到哪里去 ImageIO.write(image,"PNG",response.getOutputStream()); &#125; /** * 产生4位随机字符串 */ private String getCheckCode() &#123; String base = "0123456789ABCDEFGabcdefg"; int size = base.length(); Random r = new Random(); StringBuffer sb = new StringBuffer(); for(int i=1;i&lt;=4;i++)&#123; //产生0到size-1的随机值 int index = r.nextInt(size); //在base字符串中获取下标为index的字符 char c = base.charAt(index); //将c放入到StringBuffer中去 sb.append(c); &#125; return sb.toString(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request,response); &#125;&#125; 下载文件工具类 123456789101112131415161718public class DownLoadUtils &#123; public static String getFileName(String agent, String filename) throws UnsupportedEncodingException &#123; if (agent.contains("MSIE")) &#123; // IE浏览器 filename = URLEncoder.encode(filename, "utf-8"); filename = filename.replace("+", " "); &#125; else if (agent.contains("Firefox")) &#123; // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?="; &#125; else &#123; // 其它浏览器 filename = URLEncoder.encode(filename, "utf-8"); &#125; return filename; &#125;&#125; 文件名中文乱码 1234567891011121314151617181920212223242526272829303132protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.获取请求参数，文件名称 String filename = request.getParameter("filename"); //2.使用字节输入流加载文件进内存 //2.1找到文件服务器路径 ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath("/img/" + filename); //2.2用字节流关联 FileInputStream fis = new FileInputStream(realPath); //3.设置response的响应头 //3.1设置响应头类型：content-type String mimeType = servletContext.getMimeType(filename);//获取文件的mime类型 response.setHeader("content-type",mimeType); //3.2设置响应头打开方式:content-disposition //解决中文文件名问题 //1.获取user-agent请求头、 String agent = request.getHeader("user-agent"); //2.使用工具类方法编码文件名即可 filename = DownLoadUtils.getFileName(agent, filename); response.setHeader("content-disposition","attachment;filename="+filename); //4.将输入流的数据写出到输出流中 ServletOutputStream sos = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while((len = fis.read(buff)) != -1)&#123; sos.write(buff,0,len); &#125; fis.close();&#125; Web.xml HTTP概述 概念：Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 特点： 基于TCP/IP的高级协议 默认端口号:80 基于请求/响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0：每一次请求响应都会建立新的连接 1.1：复用连接 请求消息格式12345678910111213141516171819202122232425261. 请求行请求方式 请求url 请求协议/版本GET /login.html HTTP/1.1* HTTP协议有7中请求方式，常用的有2种 * GET： 1. 请求参数在请求行中，在url后。 2. 请求的url长度有限制的 3. 不太安全 * POST： 1. 请求参数在请求体中 2. 请求的url长度没有限制的 3. 相对安全 2. 请求头：客户端浏览器告诉服务器一些信息请求头名称: 请求头值* 常见的请求头： 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 * 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 2. Referer：http://localhost/login.html * 告诉服务器，我(当前请求)从哪里来？ * 作用： 1. 防盗链： 2. 统计工作：3. 请求空行空行，就是用于分割POST请求的请求头，和请求体的。4. 请求体(正文)：* 封装POST请求消息的请求参数的 实例123456789101112* 字符串格式：POST /login.html HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username=zhangsan 响应消息服务器端发送给客户端的数据 格式123456789101112131415161718192021221. 响应行组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 状态码都是3位数字 1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2. 2xx：成功。代表：200 3. 3xx：重定向。代表：302(重定向)，304(访问缓存) 4. 4xx：客户端错误。 * 代表： * 404（请求路径没有对应的资源） * 405：请求方式没有对应的doXxx方法 5. 5xx：服务器端错误。代表：500(服务器内部出现异常)2. 响应头：格式：头名称： 值 常见的响应头： 1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据 * 值： * in-line:默认值,在当前页面内打开 * attachment;filename=xxx：以附件形式打开响应体。文件下载3. 响应空行4. 响应体:传输的数据 实例HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt;会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie客户端会话技术，将数据保存到客户端，不够安全 使用 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 原理 基于响应头set-cookie和请求头cookie实现 细节1. 一次可不可以发送多个cookie? * 可以 * 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 2. cookie在浏览器中保存多长时间？ 1. 默认情况下，当浏览器关闭后，Cookie数据被销毁 2. 持久化存储： * setMaxAge(int seconds) 1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间， 时间到后，cookie文件自动失效 2. 负数：默认值 3. 零：删除cookie信息 3. cookie能不能存中文？ * 在tomcat 8 之前 cookie中不能直接存储中文数据。 * 需要将中文数据转码---一般采用URL编码(%E3) * 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 4. cookie共享问题？ 1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ * 默认情况下cookie不能共享 * setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 * 如果要共享，则可以将path设置为&quot;/&quot; 2. 不同的tomcat服务器间cookie共享问题？ * setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 * setDomain(&quot;.baidu.com&quot;),那么tieba.baidu.com和news.baidu.com中cookie可以共享特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 session概念服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门 获取HttpSession对象： HttpSession session = request.getSession(); 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ * 默认情况下。不是。 * 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ * 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 * session的钝化： * 在服务器正常关闭之前，将session对象系列化到硬盘上 * session的活化： * 在服务器启动后，将session文件转化为内存中的session对象即可。 3. session什么时候被销毁？ 1. 服务器关闭 2. session对象调用invalidate() 。 3. session默认失效时间 30分钟 手动修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全 JSP概念Java Server Pages： java服务器端页面 可以理解为一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ JSP本质上就是一个Servlet 定义java代码 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 注释 html注释： :只能注释html代码片段 仍会输出到页面，只是由于注释了不再显示 jsp注释：推荐使用 &lt;%– –%&gt;：可以注释所有 压根不会输出 指令用于配置JSP页面，导入资源文件 &lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 … %&gt; 1. page ： 配置JSP页面的 * contentType：等同于response.setContentType() 1. 设置响应体的mime类型以及字符集 2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具， 则需要设置pageEncoding属性设置当前页面的字符集） * import：导包 * errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 * isErrorPage：标识当前也是是否是错误页面。 * true：是，可以使用内置对象exception * false：否。默认值。不可以使用内置对象exception 2. include ： 页面包含的。导入页面的资源文件 * &lt;%@include file=&quot;top.jsp&quot;%&gt; 3. taglib ： 导入资源 * &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; * prefix：前缀，自定义的九大内置对象在jsp页面中不需要创建，直接使用的对象 pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 request HttpServletRequest 一次请求访问的多个资源(转发) session HttpSession 一次会话的多个请求间 application ServletContext 所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 tips response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 即response.getWriter()数据输出永远在out.write()之前 EL表达式 概念：Expression Language 表达式语言 作用：替换和简化jsp页面中java代码的编写 语法：${表达式} 注意： jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中：isELIgnored=”true” 忽略当前jsp页面中所有的el表达式 ${表达式} ：忽略当前这个el表达式 使用： 1234567891011121314151617181920212223242526272829303132333435361. 运算： * 运算符： 1. 算数运算符： + - * /(div) %(mod) 2. 比较运算符： &gt; &lt; &gt;= &lt;= == != 3. 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 4. 空运算符： empty * 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 * $&#123;empty list&#125;:判断字符串、集合、数组对象是否为null或者长度为0 * $&#123;not empty str&#125;:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;02. 获取值 1. el表达式只能从域对象中获取值 2. 语法： 1. $&#123;域名称.键名&#125;：从指定域中获取指定键的值 * 域名称： 1. pageScope --&gt; pageContext 2. requestScope --&gt; request 3. sessionScope --&gt; session 4. applicationScope --&gt; application（ServletContext） * 举例：在request域中存储了name=张三 * 获取：$&#123;requestScope.name&#125; 2. $&#123;键名&#125;：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 3. 获取对象、List集合、Map集合的值 1. 对象：$&#123;域名称.键名.属性名&#125; * 本质上会去调用对象的getter方法 2. List集合：$&#123;域名称.键名[索引]&#125; 3. Map集合： * $&#123;域名称.键名.key名称&#125; * $&#123;域名称.键名[&quot;key名称&quot;]&#125;3. 隐式对象： * el表达式中有11个隐式对象 * pageContext： * 获取jsp其他八个内置对象 * $&#123;pageContext.request.contextPath&#125;：动态获取虚拟目录 JSTL 概念：JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt; 作用：用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关jar包 引入标签库：taglib指令： &lt;%@ taglib prefix=”” uri = “”%&gt; ​ fmt用于对输出内容进行格式化 使用标签 常用jstl标签 1234567891011121314151. if:相当于java代码的if语句 1. 属性： * test 必须属性，接受boolean表达式 * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 * 一般情况下，test属性值会结合el表达式一起使用 2. 注意： * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签2. choose:相当于java代码的switch语句 1. 使用choose标签声明 相当于switch声明 2. 使用when标签做判断 相当于case 3. 使用otherwise标签做其他情况的声明 相当于default3. foreach:相当于java代码的for语句 items 被遍历对象 var 当前取出的值 varStatus 索引4. out：value 输出的值 escapeXml 跳过转义，原样输出 default 值为空时的默认值 MVC开发模式概述 M：Model，模型。JavaBean 完成具体的业务操作，如：查询数据库，封装对象 V：View，视图。JSP 展示数据 C：Controller，控制器。Servlet 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 三层架构 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互 业务逻辑层：处理业务逻辑的。 数据访问层：操作数据存储文件。 过滤器概述 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 过滤器的作用： 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 快速入门步骤 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 代码@WebFilter(&quot;/*&quot;) // 访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException {} @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() {} }细节web.xml配置12345678910111213141516171819202122&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;!--在过滤器中添加config属性，在init中给config赋值， 在doFilter中通过config.getInitParameter("配置的参数名")来取值--&gt; &lt;init-param&gt; &lt;param-name&gt;charset&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;!--拦截方式 可以配置多个 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 --&gt; &lt;dispatcher&gt;&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 配置详解 拦截路径配置 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行后缀名拦截： .jsp 访问所有后缀名为jsp资源时，过滤器都会被执行拦截所有资源：/\ 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置：设置dispatcherTypes属性 web.xml配置: 设置标签即可 执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 生命周期方法 init:在服务器启动后，会创建Filter对象，然后调用init方法，用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法，用于释放资源 过滤器链 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： 谁定义在上边，谁先执行 监听器事件监听机制 事件 ：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 统计在线人数,页面访问量,应用启动时完成信息初始化等 配置 web.xml 多个监听器按配置顺序启动 123&lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注解 @WebListener 常用监听器 123456&lt;!--在监听器方法中,通过sce.getServletContext().getIninParameter("配置的参数名")来获取可以将获取到的值保存到ServletContext的属性中,便于其它地方调用--&gt;&lt;context-param&gt; &lt;param-name&gt;age&lt;/param-name&gt; &lt;param-value&gt;18&lt;/param-value&gt;&lt;/context-param&gt; 1通过getName(),getValue()来获取监听对象的名称和值 JSON概述JavaScript Object Notation JavaScript对象表示法 轻量级的文本数据交换格式 独立于语言，具有自我描述性，更易于理解 语法规则 键用引号(单双都行)引起来，也可以不使用引号 值的取值类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） {“address”:{“province”：”陕西”….}} null JavaScript操作JSON默认支持JSON 初始化12345678910111213141516171819202122// 法一：直接赋值 var json = &#123; "empno": 7499, "ename": "王乐", "job": "客户经理", "hiredate": "2017-04-22", "salary": 10000, "dname": "市场部", "customers": [ &#123; "cname": "李东" &#125;, &#123; "cname": "刘楠" &#125; ] &#125;;//法二：当作对象处理var json2 = &#123;&#125;;json2.class_name = "五年级五班";json2.floor = "逸夫楼四层";json2.teacher = "王义夫"; 取值 json对象.键名 json对象[“键名”] 数组对象[索引] 遍历1234567891011121314151617var ps = [&#123;"name": "张三", "age": 23, "gender": true&#125;, &#123;"name": "李四", "age": 24, "gender": true&#125;, &#123;"name": "王五", "age": 25, "gender": false&#125;];//for in 循环for(var key in person)&#123; //这样的方式获取不行。因为相当于 person."name" //alert(key + ":" + person.key); alert(key+":"+person[key]);&#125;//获取ps中的所有值for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+":"+p[key]); &#125;&#125; JSON与字符串转换 123var str = "&#123;\"class_name\":\"五年级四班\"&#125;";//str.enamevar json = JSON.parse(str);document.write("班级:" + json.class_name); JSON工具包 FastJson官网下载jar包导入项目 常用方法123456789//FastJSON中提供了JSON对象，完成对象与JSON字符串的互相转换// 传入对应的JavaBean对象String json = JSON.toJSONString(employee);// 将JSON字符串封装为对象 // 单个对象 Employee emp = JSON.parseObject(json, Employee.class); // 传入JSON为数组时返回List集合 List&lt;Employee&gt; emps = JSON.parseArray(json , Employee.class); 常用注解1234@JSONField(name = &quot;hiredate&quot; , format=&quot;yyyy-MM-dd&quot;)private Date hdate;@JSONField(serialize = false)private String dname; AJAX概述Asynchronous JavaScript And Xml 异步的js和xml 在不刷新页面的情况下，进行局部更新 异步和同步：客户端和服务器端相互通信的基础上 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 使用JavaScript方式//1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); } else {// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() { //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); } }JQuery方式1. $.ajax() * 语法：$.ajax({键值对}); //使用$.ajax()发送异步请求 $.ajax({ url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:{&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23}, success:function (data) { alert(data); },//响应成功后的回调函数 error:function () { alert(&quot;出错啦...&quot;) },//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 }); 2. $.get()：发送get请求 * 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 3. $.post()：发送post请求 * 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型]]></content>
      <categories>
        <category>heima57</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java进阶]]></title>
    <url>%2F2020%2F02%2F19%2Fheima57%2Fjava%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[常用类Object类java.lang.Object类是Java语言中的根类，那么默认则继承自Object类 toString方法toString方法返回该对象的字符串表示，默认为对象的类型+@+内存地址值的hash值。 如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写 在我们直接使用输出语句输出对象名的时候,其实默认通过该对象调用了其toString()方法。 equals方法调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的 Object类中默认进行==运算符的对象地址比较 如果希望进行对象的内容比较，则需要覆盖重写equals方法 有很多细小的安全性问题需要兼顾 idea可以直接生成 通常和hashcode方法一同重写，例如利用散列表存储时 Objects类在JDK7添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）/ null-tolerant（容忍空指针的） public static boolean equals(Object a, Object b):判断两个对象是否相等。 123public static boolean equals(Object a, Object b) &#123; return (a == b) || (a != null &amp;&amp; a.equals(b)); &#125; Date类java.util.Date类 表示特定的瞬间，精确到毫秒。 public Date()：分配Date对象并初始化此对象，以表示分配它的时间 public Date(long date)：分配Date对象并初始化此对象，以表示自从标准基准时间以来的指定毫秒数。 tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。 1234// 创建日期对象，把当前的时间System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018// 创建日期对象，把当前的毫秒值转成日期对象System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970 常用方法 public long getTime() 把日期对象转换成对应的时间毫秒值。 DateFormat类java.text.DateFormat 是日期/时间格式化子类的抽象类，我们通过这个类可以在Date对象与String对象之间进行来回转换 构造方法由于DateFormat为抽象类，所以常用子类java.text.SimpleDateFormat 这个类需要一个模式来指定格式化或解析的标准。 public SimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造 格式规则常用的格式规则为： 标识字母 含义 y 年 M 月 d 日 H 时 m 分 s 秒 12// 对应的日期格式如：2018-01-16 15:06:38DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); 常用方法DateFormat类的常用方法有： public String format(Date date)：将Date对象格式化为字符串。 public Date parse(String source)：将字符串解析为Date对象。 Calendar类概念java.util.Calendar是日历类，在Date后出现 该类将所有可能用到的时间信息封装为静态成员变量，方便获取 获取方式Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建 public static Calendar getInstance()：使用默认时区和语言环境获得一个日历 常用方法根据Calendar类的API文档，常用方法有： public int get(int field)：返回给定日历字段的值。 public void set(int field, int value)：将给定的日历字段设置为给定值。 public abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。 字段值 含义 YEAR 年 MONTH 月（从0开始，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（周几，周日为1，可以-1使用） 12345int year = cal.get(Calendar.YEAR);// 获取月 默认是0-11int month = cal.get(Calendar.MONTH) + 1;// 获取日int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH); 1cal.set(Calendar.YEAR, 2020); 12cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天cal.add(Calendar.YEAR, -3); // 减3年 小贴士： 西方星期的开始为周日，中国为周一。 在Calendar类中，月份的表示是以0-11代表1-12月。 日期是有大小关系的，时间靠后，时间越大。 System类java.lang.System类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作 public static long currentTimeMillis()：返回以毫秒为单位的当前时间。 public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)：将数组中指定的数据拷贝到另一个数组中。 StringBuilder类字符串拼接问题字符串是常量，它们的值在创建后不能被更改。 故若对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。 为了解决这一问题，可以使用java.lang.StringBuilder类。 StringBuilder概述StringBuilder是个字符串的缓冲区，即它是一个容器 它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容 StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充) 构造方法 public StringBuilder()：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 常用方法StringBuilder常用的方法有2个： public StringBuilder append(...)：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString()：将当前StringBuilder对象转换为String对象。 包装类概述Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，必须使用对象 基本类型 对应的包装类（位于java.lang包中） byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 装箱与拆箱 装箱：从基本类型转换为对应的包装类对象。 拆箱：从包装类对象转换为对应的基本类型。 用Integer与 int为例 基本数值—-&gt;包装对象 12Integer i = new Integer(4);Integer iii = Integer.valueOf(4); 包装对象—-&gt;基本数值 1int num = i.intValue(); 自动装箱与自动拆箱从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成 123Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);i = i + 5; //等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; //加法运算完成后，再次装箱，把基本数值转成对象。 基本类型与字符串转换基本类型转换为String基本类型转换String总共有三种方式 基本类型直接与””相连接即可；如：34+”” 包装类中的toString方法 String中的静态方法valueOf String转换成对应的基本类型除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型： public static Xxx parseXxx(String s)：将字符串参数转换为对应的Xxx基本类型。 以Integer类的静态方法parseXxx为例 1int num = Integer.parseInt("100"); 若正确转换为对应的基本类型，则会抛出java.lang.NumberFormatException异常。 集合框架集合是java中提供的一种容器，可以用来存储多个数据。 集合和数组区别 数组的长度是固定的。集合的长度是可变的。 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致 集合按照其存储结构可以分为两大类，分别是单列集合java.util.Collection和双列集合java.util.Map Collection概述 Collection：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是java.util.List和java.util.Set。 List的特点是元素有序、元素可重复。 Set的特点是元素无序，而且不可重复。 常用功能Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下： public boolean add(E e) public void clear() public boolean remove(E e) public boolean contains(E e) public boolean isEmpty() public int size() public Object[] toArray() Iterator迭代器Iterator接口Iterator接口也是Java集合中的一员，但它与Collection、Map接口有所不同，Collection接口与Map接口主要用于存储 元素，而Iterator主要用于迭代访问（即遍历）Collection中的元素，因此Iterator对象也被称为迭代器。 想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法： public Iterator iterator(): 获取集合对应的迭代器 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来， 继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。 常用方法 public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 1234567//使用迭代器 遍历 每个集合对象都有自己的迭代器Iterator&lt;String&gt; it = coll.iterator();// 泛型指的是 迭代出 元素的数据类型while(it.hasNext()) &#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s);&#125; tips:：如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。 迭代器的实现原理 在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法 后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，直到hasNext方法返回false，表示到达了集合的末 尾 增强for增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。 格式： 123for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现 List介绍java.util.List接口继承自Collection接口，是单列集合的一个重要分支 允许出现重复的元素， 所有的元素是以线性方式进行存储的， 在程序中可以通过索引来访问集合中的指定元素 元素有序，即元素的存入顺序和取出顺序一致。 常用方法List作为Collection集合的子接口，不但继承了Collection接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法 public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 public E get(int index):返回集合中指定位置的元素。 public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 List集合特有的方法都是跟索引相关 1234567891011121314List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 往 尾部添加 指定元素list.add("图图");// String remove(int index) 删除指定位置元素 返回被删除元素// 删除索引位置为2的元素 System.out.println(list.remove(2)); // String set(int index,String s)// 在指定位置 进行 元素替代（改） list.set(0, "三毛"); // String get(int index) 获取指定位置元素// 跟size() 方法一起用 来 遍历的 for(int i = 0;i&lt;list.size();i++)&#123; System.out.println(list.get(i));&#125; 子类ArrayList集合java.util.ArrayList集合数据存储的结构是数组结构，元素增删慢，查找快 由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。 LinkedList集合java.util.LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。 LinkedList是一个双向链表，那么双向链表是什么样子的呢，我们用个图了解下 实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。这些方法我们作为了解即可： public void addFirst(E e):将指定元素插入此列表的开头。 public void addLast(E e):将指定元素添加到此列表的结尾。 public E getFirst():返回此列表的第一个元素。 public E getLast():返回此列表的最后一个元素。 public E removeFirst():移除并返回此列表的第一个元素。 public E removeLast():移除并返回此列表的最后一个元素。 public E pop():从此列表所表示的堆栈处弹出一个元素。 public void push(E e):将元素推入此列表所表示的堆栈。 public boolean isEmpty()：如果列表不包含元素，则返回true 1234567891011121314LinkedList&lt;String&gt; link = new LinkedList&lt;String&gt;();//添加元素link.addFirst("abc3");System.out.println(link);// 获取元素System.out.println(link.getFirst());System.out.println(link.getLast());// 删除元素System.out.println(link.removeFirst());System.out.println(link.removeLast());while (!link.isEmpty()) &#123; //判断集合是否为空 System.out.println(link.pop()); //弹出集合中的栈顶元素&#125; Vector线程安全，是List最初的实现类，底层是数组，在JDK1.2之后增加由于访问速度慢渐渐被遗弃 Set接口java.util.Set接口继承自Collection接口，它与Collection接口中的方法基本一致，没有对Collection接口进行功能上的扩充，只是比Collection接口更加严格 Set接口中元素无序，并且存入的元素不可重复。 HashSetjava.util.HashSet是Set接口的一个实现类，它所存储的元素是不可重复的，并且是无序的 java.util.HashSet底层的实现其实是一个java.util.HashMap支持 HashSet是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能 保证元素唯一性的方式依赖于：hashCode与equals方法。 存储数据的结构（哈希表）在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当 位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。 而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减 少了查找时间。 保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。 如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法 LinkedHashSet在HashSet下面有一个子类java.util.LinkedHashSet，它是链表和哈希表组合的一个数据存储结构，但他是有序的 Collections常用功能 public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements):往集合中一次添加多个元素。 public static void shuffle(List&lt;?&gt; list) 打乱顺序:打乱集合顺序。 比较 public static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ):将集合中元素按照指定规则排序。 Comparablepublic static &lt;T&gt; void sort(List&lt;T&gt; list):将集合中元素按照默认规则排序。 说到排序了，在JAVA中提供了两种比较实现的方式，一种是比较死板的采用java.lang.Comparable接口去实现，一种是灵 活的当我需要做排序的时候在去选择的java.util.Comparator接口完成。 那么我们采用的public static &lt;T&gt; void sort(List&lt;T&gt; list)这个方法完成的排序，实际上要求了被排序的类型需要实现 Comparable接口完成比较的功能，在String类型上如下： 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String类实现了这个接口，并完成了比较规则的定义，但是这样就把这种规则写死了，那比如我想要字符串按照第一个字符 降序排列，那么这样就要修改String的源代码 Comparatorpublic static void sort(List list，Comparator&lt;? super T&gt; )`涉及到了Comparator这个接口，位于位于java.util包 下，该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，那么比较的方法就是： public int compare(String o1, String o2)：比较其两个参数的顺序。 两个对象比较的结果有三种：大于，等于，小于。 如果要按照升序排序，则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）如果要按照降序排序则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数） 操作如下: 1234567Collections.sort(list, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // o1 - o2 为降序，反之为升序 return o2.charAt(0) - o1.charAt(0); &#125;&#125;); 结果如下： 1[sba, nba, cba, aba] 简述Comparable和Comparator两个接口的区别Comparable：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它 的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表 （和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素， 无需指定比较器。 Comparator强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从 而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为 那些没有自然顺序的对象collection提供排序。 Map集合概述一一对应的关系，叫做映射。Java提供了专门的集合来存放这种关系的对象，即java.util.Map接口。 Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。 Collection中的集合称为单列集合，Map中的集合称为双列集合。 需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。 常用子类 HashMap&lt;K,V&gt;：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要 重写键的hashCode()方法、equals()方法。 LinkedHashMap&lt;K,V&gt;：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表 结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、 equals()方法。 tips：Map接口中的集合有两个泛型变量&lt;K,V&gt;，两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。 Map接口中的常用方法Map接口中定义了很多方法，常用的如下： public V put(K key, V value): 把指定的键与指定的值添加到Map集合中。 public V remove(Object key): 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。 public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 boolean containsKey(Object key) 判断集合中是否包含指定的键。 boolean containsValue(Object value) 判断集合中是否包含指定的值。 public Set&lt;K&gt; keySet(): 获取Map集合中所有的键，存储到Set集合中。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 tips:使用put方法时 若指定的键(key)在集合中没有，返回null，并把指定的键值添加到集合中； 若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 遍历遍历键找值方式键找值方式：即通过元素中的键，获取键所对应的值 分析步骤： 获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键——keyset() 遍历键的Set集合，得到每一个键。 根据键，获取键所对应的值。方法提示:get(K key) Entry键值对对象Map中一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了键值对对象 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法： public K getKey()：获取Entry对象中的键。 public V getValue()：获取Entry对象中的值。 在Map集合中也提供了获取所有Entry对象的方法： public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。 操作步骤与图解： 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:entrySet()。 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。 通过键值对(Entry)对象，获取Entry对象中的键与值。 方法提示:getkey() getValue() tips：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。 练习需求： 计算一个字符串中每个字符出现次数。 分析： 获取一个字符串对象 创建一个Map集合，键代表字符，值代表次数。 遍历字符串得到每个字符。 判断Map中是否有该键。 如果没有，第一次出现，存储次数为1；如果有，则说明已经出现过，获取到对应的值进行++，再次存储。 打印最终结果 代码： 1234567891011121314151617181920212223242526272829public class MapTest &#123;public static void main(String[] args) &#123; //友情提示 System.out.println("请录入一个字符串:"); String line = new Scanner(System.in).nextLine(); // 定义 每个字符出现次数的方法 findChar(line); &#125; private static void findChar(String line) &#123; //1:创建一个集合 存储 字符 以及其出现的次数 HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); //2:遍历字符串 for (int i = 0; i &lt; line.length(); i++) &#123; char c = line.charAt(i); //判断 该字符 是否在键集中 if (!map.containsKey(c)) &#123;//说明这个字符没有出现过 //那就是第一次 map.put(c, 1); &#125; else &#123; //先获取之前的次数 Integer count = map.get(c); //count++; //再次存入 更新 map.put(c, ++count); &#125; &#125; System.out.println(map); &#125;&#125; 集合综合案例版本一用collection来实现简单的斗地主 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.ArrayList;import java.util.Collections;public class Poker &#123; public static void main(String[] args) &#123; /* * 1: 准备牌操作 */ //1.1 创建牌盒 将来存储牌面的 ArrayList&lt;String&gt; pokerBox = new ArrayList&lt;String&gt;(); //1.2 创建花色集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); //1.3 创建数字集合 ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); //1.4 分别给花色 以及 数字集合添加元素 colors.add("♥"); colors.add("♦"); colors.add("♠"); colors.add("♣"); for(int i = 2;i&lt;=10;i++)&#123; numbers.add(i+""); &#125; numbers.add("J"); numbers.add("Q"); numbers.add("K"); numbers.add("A"); //1.5 创造牌 拼接牌操作 // 拿出每一个花色 然后跟每一个数字 进行结合 存储到牌盒中 for (String color : colors) &#123; //color每一个花色 //遍历数字集合 for(String number : numbers)&#123; //结合 String card = color+number; //存储到牌盒中 pokerBox.add(card); &#125; &#125; //1.6大王小王 pokerBox.add("小☺"); pokerBox.add("大☠"); // System.out.println(pokerBox); //洗牌 是不是就是将 牌盒中 牌的索引打乱 // Collections类 工具类 都是 静态方法 // shuffer方法 /* * static void shuffle(List&lt;?&gt; list) * 使用默认随机源对指定列表进行置换。 */ //2:洗牌 Collections.shuffle(pokerBox); //3 发牌 //3.1 创建 三个 玩家集合 创建一个底牌集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); //遍历 牌盒 必须知道索引 for(int i = 0;i&lt;pokerBox.size();i++)&#123; //获取 牌面 String card = pokerBox.get(i); //留出三张底牌 存到 底牌集合中 if(i&gt;=51)&#123;//存到底牌集合中 dipai.add(card); &#125; else &#123; //玩家1 %3 ==0 if(i%3==0)&#123; player1.add(card); &#125;else if(i%3==1)&#123;//玩家2 player2.add(card); &#125;else&#123;//玩家3 player3.add(card); &#125; &#125; &#125; //看看 System.out.println("令狐冲："+player1); System.out.println("田伯光："+player2); System.out.println("绿竹翁："+player3); System.out.println("底牌："+dipai); &#125;&#125; 版本二 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class Poker &#123; public static void main(String[] args) &#123; /* * 1组装54张扑克牌 */ // 1.1 创建Map集合存储 HashMap&lt;Integer, String&gt; pokerMap = new HashMap&lt;Integer, String&gt;(); // 1.2 创建 花色集合 与 数字集合 ArrayList&lt;String&gt; colors = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); // 1.3 存储 花色 与数字 Collections.addAll(colors, "♦", "♣", "♥", "♠"); Collections.addAll(numbers, "2", "A", "K", "Q", "J", "10", "9", "8", "7", "6", "5", "4", "3"); // 设置 存储编号变量 int count = 1; pokerMap.put(count++, "大王"); pokerMap.put(count++, "小王"); // 1.4 创建牌 存储到map集合中 for (String number : numbers) &#123; for (String color : colors) &#123; String card = color + number; pokerMap.put(count++, card); &#125; &#125; /* * 2 将54张牌顺序打乱 */ // 取出编号 集合 Set&lt;Integer&gt; numberSet = pokerMap.keySet(); // 因为要将编号打乱顺序 所以 应该先进行转换到 list集合中 ArrayList&lt;Integer&gt; numberList = new ArrayList&lt;Integer&gt;(); numberList.addAll(numberSet); // 打乱顺序 Collections.shuffle(numberList); // 3 完成三个玩家交替摸牌，每人17张牌，最后三张留作底牌 // 3.1 发牌的编号 // 创建三个玩家编号集合 和一个 底牌编号集合 ArrayList&lt;Integer&gt; noP1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; noP3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; dipaiNo = new ArrayList&lt;Integer&gt;(); // 3.2发牌的编号 for (int i = 0; i &lt; numberList.size(); i++) &#123; // 获取该编号 Integer no = numberList.get(i); // 发牌 // 留出底牌 if (i &gt;= 51) &#123; dipaiNo.add(no); &#125; else &#123; if (i % 3 == 0) &#123; noP1.add(no); &#125; else if (i % 3 == 1) &#123; noP2.add(no); &#125; else &#123; noP3.add(no); &#125; &#125; &#125; // 4 查看三人各自手中的牌（按照牌的大小排序）、底牌 // 4.1 对手中编号进行排序 Collections.sort(noP1); Collections.sort(noP2); Collections.sort(noP3); Collections.sort(dipaiNo); // 4.2 进行牌面的转换 // 创建三个玩家牌面集合 以及底牌牌面集合 ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;(); ArrayList&lt;String&gt; dipai = new ArrayList&lt;String&gt;(); // 4.3转换 for (Integer i : noP1) &#123; // 4.4 根据编号找到 牌面 pokerMap String card = pokerMap.get(i); // 添加到对应的 牌面集合中 player1.add(card); &#125; for (Integer i : noP2) &#123; String card = pokerMap.get(i); player2.add(card); &#125; for (Integer i : noP3) &#123; String card = pokerMap.get(i); player3.add(card); &#125; for (Integer i : dipaiNo) &#123; String card = pokerMap.get(i); dipai.add(card); &#125; //4.5 查看 System.out.println("令狐冲："+player1); System.out.println("石破天："+player2); System.out.println("鸠摩智："+player3); System.out.println("底牌："+dipai); &#125;&#125; 小知识点泛型泛型概述集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。 当我们在取出每一个对象进行相应的操作时，必须采用类型转换。 12345678910Collection coll = new ArrayList();coll.add("abc");coll.add("itcast");coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放Iterator it = coll.iterator();while(it.hasNext())&#123; //需要打印每个字符串的长度,就要把迭代出来的对象转成String类型 String str = (String) it.next(); System.out.println(str.length());&#125; 程序在运行时发生了问题java.lang.ClassCastException。 Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象 泛型：可以在类或方法中预支地使用未知的类型。 tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。 使用泛型的好处 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。 避免了类型强转的麻烦。 通过我们如下代码体验一下： 12345678Collection&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add("itcast");// list.add(5);//当集合明确类型后，存放类型不一致就会编译报错// 集合已经明确具体存放的元素类型，迭代器也同样会知道具体遍历元素类型Iterator&lt;String&gt; it = list.iterator();while(it.hasNext())&#123; String str = it.next(); //当使用Iterator&lt;String&gt;控制元素类型后，就不需要强转了。获取到的元素就是String类型 tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。 泛型的定义与使用含有泛型的类定义格式：1修饰符 class 类名&lt;代表泛型的变量&gt; &#123; &#125; 例如，API中的ArrayList集合： 123456class ArrayList&lt;E&gt;&#123; public boolean add(E e)&#123; &#125; public E get(int index)&#123; &#125; ....&#125; 使用泛型： 即什么时候确定泛型。 在创建对象的时候确定泛型ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 含有泛型的方法定义格式：1修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数)&#123; &#125; 例如， 123456789public class MyGenericMethod &#123; public &lt;MVP&gt; void show(MVP mvp) &#123; System.out.println(mvp.getClass()); &#125; public &lt;MVP&gt; MVP show2(MVP mvp) &#123; return mvp; &#125;&#125; 调用方法时，确定泛型的类型123456// 创建对象MyGenericMethod mm = new MyGenericMethod();// 演示看方法提示mm.show("aaa");mm.show(123);mm.show(12.45); 含有泛型的接口定义格式：1修饰符 interface接口名&lt;代表泛型的变量&gt; &#123; &#125; 例如， 12345public interface MyGenericInterface&lt;E&gt;&#123; public abstract void add(E e); public abstract E getE(); &#125; 使用格式：定义类时确定泛型的类型1234567891011public class MyImp1 implements MyGenericInterface&lt;String&gt; &#123; @Override public void add(String e) &#123; // 省略... &#125; @Override public String getE() &#123; return null; &#125;&#125; 此时，泛型E的值就是String类型。 始终不确定泛型的类型，直到创建对象时，确定泛型的类型 例如 1234567891011public class MyImp2&lt;E&gt; implements MyGenericInterface&lt;E&gt; &#123; @Override public void add(E e) &#123; // 省略... &#125; @Override public E getE() &#123; return null; &#125;&#125; 确定泛型： 123456789/* * 使用 */public class GenericInterface &#123; public static void main(String[] args) &#123; MyImp2&lt;String&gt; my = new MyImp2&lt;String&gt;(); my.add("aa"); &#125;&#125; 泛型通配符当使用泛型类或者接口做参数接收数据时，泛型类型不确定，可以通过通配符&lt;?&gt;表示。 但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 通配符基本使用此时只能接受数据,不能往该集合中存储数据。 举个例子大家理解使用即可： 12345678public static void main(String[] args) &#123; Collection&lt;Intger&gt; list1 = new ArrayList&lt;Integer&gt;(); getElement(list1); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); getElement(list2);&#125;public static void getElement(Collection&lt;?&gt; coll)&#123;&#125;//？代表可以接收任意类型 tips:泛型不存在继承关系 Collection list = new ArrayList();这种是错误的。 通配符高级使用—-受限泛型JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类 123456789101112131415161718192021public static void main(String[] args) &#123; Collection&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); Collection&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); Collection&lt;Number&gt; list3 = new ArrayList&lt;Number&gt;(); Collection&lt;Object&gt; list4 = new ArrayList&lt;Object&gt;(); getElement(list1); getElement(list2);//报错 getElement(list3); getElement(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4);&#125;// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125; 可变参数在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，可以对其简化成如下格式： 1修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 其实这个书写完全等价与 1修饰符 返回值类型 方法名(参数类型[] 形参名)&#123; &#125; 只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可 JDK1.5以后。出现了简化操作。… 用在参数上，称之为可变参数。 同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际 参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时， 自动完成了 多个方法符合条件时，优先调用不含可变参数的方法 代码演示： 注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。 可以直接传入数组，但以数组作为形参时不可传入可变参数 JDK9对集合优化通常，我们在代码中创建一个集合（例如，List 或 Set ），并直接用一些元素填充它。 实例化集合，几个 add方法 调用， 使得代码重复。 Java 9，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方 便地创建集合的不可变实例。 例子： 1234567 Set&lt;String&gt; str1=Set.of("a","b","c"); //str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合 System.out.println(str1); Map&lt;String,Integer&gt; str2=Map.of("a",1,"b",2); System.out.println(str2); List&lt;String&gt; str3=List.of("a","b"); System.out.println(str3); 需要注意以下两点： 1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法 2:返回的集合是不可变的； 异常概念 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。 Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 体系异常机制其实是帮助我们找到程序中的问题，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正 异常(Exception)的分类 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 产生过程解析 处理Java异常处理的五个关键字：try、catch、finally、throw、throws 抛出异常throw在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。通过关键字throw就可以完成 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 12throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException("哥们，角标越界了~~~"); &#125; int element = arr[index]; return element;&#125; 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理，那么必须通过throws进行声明，让调用者去处理。 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 捕获异常try…catch如果异常出现的话,会立刻终止程序 两种处理异常的方法： 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws) 在方法中使用try-catch的语句块来处理异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 finally 代码块finally：无论异常是否发生，在finally代码块中存放的代码都是一定会被执行的，常用于资源的释放 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 注意事项 多个异常使用捕获又该如何处理呢？ 多个异常分别处理 多个异常一次捕获，多次处理。(推荐) 多个异常一次捕获一次处理。 12345678910&gt; try&#123;&gt; 编写可能会出现异常的代码&gt; &#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获.&gt; 处理异常的代码&gt; //记录日志/打印异常信息/继续抛出异常&gt; &#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获.&gt; 处理异常的代码&gt; //记录日志/打印异常信息/继续抛出异常&gt; &#125;&gt; 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果finally有return语句,永远返回finally中的结果,避免该情况. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或父类异常的子类或不抛出异常。 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常，此时子类产生异常，只能捕获处理，不能声明抛出 自定义异常概述什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: RegisterException。一个注册异常类。 异常类如何定义: 编译期异常: 自定义类 并继承于java.lang.Exception。 运行期异常:自定义类 并继承于java.lang.RuntimeException。 命名：XxxException 练习要求：我们模拟注册操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类RegisterException： 1234567891011121314// 业务逻辑异常public class RegisterException extends Exception &#123; /** * 空参构造 */ public RegisterException() &#123; &#125; /** * @param message 表示异常提示 */ public RegisterException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;"bill","hill","jill"&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername("nill"); System.out.println("注册成功");//如果没有异常就是注册成功 &#125;catch(RegisterException e)&#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException&#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new RegisterException("亲"+name+"已经被注册了！"); &#125; &#125; return true; &#125;&#125; Junit单元测试测试分类 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 白盒测试：需要写代码的。关注程序具体的执行流程。 Junit使用白盒测试 步骤： 定义一个测试类(测试用例) 建议： 测试类名：被测试的类名Test CalculatorTest 包名：xxx.xxx.xx.test cn.itcast.test 定义测试方法：可以独立运行* 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 给方法加@Test 导入junit依赖环境 判定结果 红色：失败 绿色：成功 用断言操作来处理结果 Assert.assertEquals(期望的结果,运算的结果); 补充 @Before: 修饰的方法会在测试方法之前被自动执行，申请资源 @After: 修饰的方法会在测试方法执行之后自动被执行，释放资源 反射：框架设计的灵魂123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码* 反射：将类的各个组成部分封装为其他对象，这就是反射机制 * 好处： 1. 可以在程序运行过程中，操作这些对象。 2. 可以解耦，提高程序的可扩展性。* 获取Class对象的方式： 1. Class.forName("全类名")：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次， 不论通过哪一种方式获取的Class对象都是同一个。* Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName()* Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射* Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化为Class对象的newInstance方法* Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名* 案例： * 需求：写一个"框架"，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象， 并且执行其中任意方法 * 实现： 1. 配置文件 2. 反射 * 步骤： 1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2. 在程序中加载读取配置文件 3. 使用反射技术来加载类文件进内存 4. 创建对象 5. 执行方法 //1.加载配置文件 //1.1创建Properties对象 Properties pro = new Properties(); //1.2加载配置文件，转换为一个集合 //1.2.1获取class目录下的配置文件 ClassLoader classLoader = ReflectTest.class.getClassLoader(); InputStream is = classLoader.getResourceAsStream("pro.properties"); pro.load(is); //2.获取配置文件中定义的数据 String className = pro.getProperty("className"); String methodName = pro.getProperty("methodName"); //3.加载该类进内存 Class cls = Class.forName(className); //4.创建对象 Object obj = cls.newInstance(); //5.获取方法对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(obj); 注解 概念：说明程序的。给计算机看的 注释：用文字描述程序的。给程序员看的 定义：注解（Annotation），也叫元数据。一种代码级别的说明，与类、接口、枚举是在同一个层次。JDK1.5之后的新 特性,它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释 作用分类： 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 JDK中预定义的一些注解 @Override：检测被该注解标注的方法是否是继承自父类(接口)的 @Deprecated：该注解标注的内容，表示已过时 @SuppressWarnings：压制警告 一般传递参数all @SuppressWarnings(“all”) 自定义注解 1234元注解public @interface 注解名称&#123; 属性列表;&#125; 12345* 本质：注解本质上就是一个接口，该接口默认继承Annotation接口```java public interface MyAnno extends java.lang.annotation.Annotation &#123;&#125; * 属性：接口中的抽象方法 * 要求： 1. 属性的返回值类型有下列取值 &gt; 基本数据类型 &gt; &gt; String &gt; &gt; 枚举 &gt; &gt; 注解 &gt; &gt; 以上类型的数组 2. 定义了属性，在使用时需要给属性赋值 &gt; 如果定义属性时，使用default关键字给属性默认初始化值， &gt; &gt; 如果只有一个属性需要赋值且属性名是value，则value可以省略，直接定义值即可。 &gt; &gt; 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 * 元注解：用于描述注解的注解 * @Target：描述注解能够作用的位置 * ElementType取值： &gt; TYPE：可以作用于类上 &gt; &gt; METHOD：可以作用于方法上 &gt; &gt; FIELD：可以作用于成员变量上 * @Retention：描述注解被保留的阶段 &gt; @Retention(RetentionPolicy.SOURCE)： &gt; 当前被描述的注解，仅保留在源文件中 &gt; @Retention(RetentionPolicy.CLASS)： &gt; 当前被描述的注解，会保留到class字节码文件中，加载到JVM时丢弃 &gt; @Retention(RetentionPolicy.RUNTIME)： &gt; 当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 * @Documented：描述注解是否被抽取到api文档中 * @Inherited：描述注解是否被子类继承 在程序使用(解析)注解：获取注解中定义的属性值 获取注解定义的位置的对象 （Class，Method,Field） 获取指定的注解 getAnnotation(Class)其实就是在内存中生成了一个该注解接口的子类实现对象 12345678public class ProImpl implements Pro&#123; public String className()&#123; return "cn.itcast.annotation.Demo1"; &#125; public String methodName()&#123; return "show"; &#125; &#125; 调用注解中的抽象方法获取配置的属性值 案例：简单的测试框架 小结： 以后大多数时候，我们会使用注解，而不是自定义注解 注解给谁用？ 编译器 给解析程序用 注解不是程序的一部分，可以理解为注解就是一个标签 学习项目流程 第一遍：看视频确认理解后开始自己实现 ​ 遇到问题先独立思考，实在不行再回头看视频 第二遍：将自己写的与源码进行对比，分析优缺点 第三遍：自行独立从头实现一遍]]></content>
      <categories>
        <category>heima57</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java入门]]></title>
    <url>%2F2020%2F02%2F14%2Fheima57%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java初识语言特性跨平台性，通过jvm实现 Java程序运行过程 javac xxx.class 编译 java xxx 运行，注意别加后缀 常识注释单行 // 多行 /* */ 文档 /** */ 关键字 访问控制 private protected public 类,方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 标识符命名规则建议 包名规范：域名倒叙+模块+功能，全部小写 package com.guardwarm.train 必须定义在java文件第一行 同一个包下不能存在重名的类，建议每个包功能单一 调用不同包下的类：全类名/导入包 import com.guardwarm.train.Classify 推荐 import com.guardwarm.train.* .*只能加载该包下直接包含的类，不会遍历其下所有子包的类 com.guardwarm.train.Classify c = new com.guardwarm.train.Classify(); 当调用两个同名类时，只能这样 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式） 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式） 变量名规范：全部小写 常量变量名全部大写，用final修饰 ASCII码表标准用7位表示，扩展用八位 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 转义字符 值传递Java只有值传递 变量的默认值栈中变量(局部变量)没有默认值，必须初始化，堆中变量(new)有默认值 包装类有自动装箱和拆箱的存在，使用很方便 权限修饰符 建议 成员变量使用 private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用 public ，方便调用方法。 访问顺序 编译看左—-向上转型 运行看右—-动态绑定 成员变量是静态绑定，故运行看左 privae/static/final的方法，按照静态绑定 数据类型分类 基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。 引用数据类型：包括 类 、 数组 、 接口 。 基本数据类型 数据类型 关键字 内存占用 取值范围 字节型 byte 1 -128~127 短整型 short 2 -32768~32767 整型 int 4 -2的31次方~2的31次方 长整型 long 8 -2的63次方~2的63 单精度浮点数 float 4 1.4013E-45~3.4028E+38 双精度浮点数 double 8 4.9E-324~1.7977E+308 字符型 char 2 0-65535 布尔类型 boolean 1 true，false 变量定义数据类型 变量名 = 数据值; 1234567891011121314 //定义字节型变量 byte b = 100; //定义短整型变量 short s = 1000; //定义长整型变量 long l = 12345678900L; //定义单精度浮点型变量 float f = 5.5F; //定义双精度浮点型变量 double d = 8.5;double d = 1.23E5;double d = .2; //定义字符型变量 char c = 'A'; 类型转换自动类型转换 将取值范围小的类型自动提升为 取值范围大的类型 注意：是按取值大小来分，eg：float比long所占字节少，但由于是浮点型取值范围更大 byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double byte、short、char 运算时直接提升为 int (类型提升) 1234567891011byte b1 = 1// 由于jvm的优化，都是常量会在运算成一个数后编译，所以不存在类型提升，可以通过byte b3 = 1 + 2// 由于右侧是变量，所以不会优化，编译都无法通过byte b4 = b1 + b3short a = 1// +=是一个运算符，所以不存在类型提升，一切ok a += 1// 这样会被提升为int类型 a = a + 1 强制类型转换数据类型 变量名 = （数据类型）被转数据值; 将 取值范围大的类型 强制转换成 取值范围小的类型 浮点转成整数，直接取消小数点，可能造成数据损失精度 int 强制转成 short 砍掉2个字节，可能造成数据丢失 表达式运算符+操作数 运算符 tips：&amp;&amp;会出现短路，但&amp;不会 在运算时可以将数字放大一定倍数来避免小数计算 引用类型引用类型也可以作为 成员变量、作为方法参数、作为方法的返回值 接口是对方法的封装 我们使用一个接口作为成员变量，增强了程序的扩展性。可以通过多种匿名内部类实现丰富的扩展 接口作为成员变量时，对它进行赋值的操作，实际上是赋给它该接口的一个子类对象。 流程控制语句if语句1234567if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125; else &#123; 执行语句n+1;&#125; switch语句1234567891011121314// 表达式类型：byte，short，int，char，enum（枚举），JDK7后可以接收字符串switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; // 最后一个break虽说可有可无，但为了保持良好习惯，应该添加 break; &#125; for循环1234// 初始化表达式中的值，仅在for循环内有效for(初始化表达式①; 布尔表达式②; 步进表达式④)&#123; 循环体③&#125; while循环12345初始化表达式①while(布尔表达式②)&#123; 循环体③ 步进表达式④&#125; do-while循环12345初始化表达式①do&#123; 循环体③ 步进表达式④&#125;while(布尔表达式②); 有明确次数时用for 无限循环，但有退出条件用while 最少执行一次用do-while break，continue进行循环控制 方法定义相当于别的语言中的函数 将一些常用的功能抽象为一个方法，便于提高代码的复用 1234修饰符 返回值类型 方法名(参数列表)&#123; 代码... return ;&#125; 方法重载 函数名相同，但参数列表不同，与修饰符和返 回值类型无关 参数列表：个数不同，数据类型不同，顺序不同 重载方法调用：JVM通过方法的参数列表，调用不同的方法。 数组定义容器：是将多个数据存储到一起，每个数据称为该容器的元素。 数组： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 1234567// 数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];int[] arr = new int[3];// 数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;int[] arr = new int[]&#123;1,2,3,4,5&#125;;// 数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;int[] arr = &#123;1,2,3,4,5&#125;;// 前两种申明和定义可以分开，最后一种必须一体 二维数组 12345678int[][] arr = new int[5][7];int[][] a = new int[3][];a[0] = new int[4];a[0] = new int[6];a[0] = new int[3];int[][] a2 = &#123;&#123;1,2,3&#125;,&#123;3,6,8,3&#125;,&#123;2,4&#125;&#125; 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值. 所以数组作为方法参数传递，传递的参数是数组内存的地址。 访问123// 数组名[索引]=数值，为数组中的元素赋值// 变量=数组名[索引]，获取出数组中的元素// 数组名.length 获取数组名中元素个数 内存图 异常 NullPointerException：只定义未申明 ArrayIndexOutOfBoundsException：操作下标越界 常用操作12345678910111213141516171819202122232425262728293031323334353637383940414243// 遍历public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125;// 取出最大元素public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++) &#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println("数组最大值是： " + max);&#125;// 反转(双向遍历，交换数据)public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 面向对象定义这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去 操作实现。 特点封装、继承和多态。 类和对象定义类：是一组相关属性和行为的集合 属性：就是该事物的状态信息 行为：就是该事物能够做什么。 1234public class ClassName &#123; //成员变量 //成员方法&#125; 对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性 和行为 123// 类名 对象名 = new 类名();// 对象名.成员变量；// 对象名.成员方法()； 匿名对象new 类名(参数列表)； . 创建匿名对象直接调用方法，没有变量名，对于那些只使用一次的变量(参数，返回值，…) 二者关系类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 内存图一个对象调用一个方法 两个对象调用一个方法 成员变量和局部变量 在类中的位置不同 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 成员变量：类中 局部变量：方法中 初始化值的不同 成员变量：有默认值 局部变量：没有默认值，必须先定义，赋值，最后使用 在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 构造函数与成员方法 命名规则不同 一个与类名相同，一个随意 返回值不同 一个无返回值类型，一个必须有 作用不同 一个用于创建对象，一个用于实现对象方法 调用不同 一个通过new来创建对象，一个通过对象名调用 封装定义封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的 方式。 原则隐藏对象的信息，留出访问的接口 步骤 可以通过异常或判断来控制 封装优化 用this来解决命名冲突 方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 提供构造方法 如果你不提供构造方法，系统会给出无参数构造方法 如果你提供了构造方法，系统将不再提供无参数构造方法 构造方法是可以重载的，既可以定义参数，也可以不定义参数 1234// 构造方法无须返回值修饰符 构造方法名(参数列表)&#123; // 方法体&#125; JavaBeanJavaBean 是 Java语言编写类的一种标准规范，可重用的组件 符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 12345678910public class ClassName&#123; //成员变量 //构造方法 //无参构造方法【必须】 //有参构造方法【建议】 //成员方法 // boolean的get方法为isXxx() //getXxx() //setXxx()&#125; static关键字定义它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。可以不靠创建对象来调用了 类属性 当 static 修饰成员变量时，该变量称为类属性。类对象共享，类加载时产生，销毁时释放，生命周期长 静态方法 当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用 静态方法可以直接访问类变量和静态方法 静态方法不能直接访问普通成员变量或成员方法。但反之，成员方法可以直接访问类变量或静态方法 若一定要调用非静态成员，需先实例化一个对象，用该对象去调用 原因：内存中先加载静态方法，实例化时再加载成员方法 静态方法中，不能使用this关键字 静态代码块 位置：类中方法外 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行 作用：用于变量的初始化赋值 12345678910111213141516171819202122232425262728public class Game &#123; public static int number; public int sex; public int version; public static ArrayList&lt;String&gt; list; // 静态代码块，只能操作静态成员 只在加载类时执行一次 static &#123; // 给类变量赋值 number = 2; list = new ArrayList&lt;String&gt;(); // 添加元素到集合中 list.add("张三"); list.add("李四"); &#125; // 代码块 每次构造对象时执行 &#123; version = 3; sex = 0; number = 3; &#125; public void change(int num) &#123; // 普通代码块随着方法的调用而执行 &#123; number++; &#125; this.number = num; &#125;&#125; 两个对象相互联系 继承定义由来：多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要 继承那一个类即可 子类可以直接访问父类中的非私有的属性和行为 提高代码重用性 类与类之间产生了关系，是多态的前提 子类 is a 父类，满足这样的一般都可以 特点 java只支持单继承，但支持多层继承 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰 接口中，没有构造方法，不能创建对象 接口中，没有静态代码块。 成员变量的访问子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰父类成员变量 super和this不能用于静态方法 成员方法的访问子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效 果，也称为重写或者复写。声明不变，重新实现。 通过重写，可以实现子类对父类方法的拓展 12345678@override // 对是否重写做检验public void showNum()&#123; //调用父类已经存在的功能使用super 在原基础上扩展 super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println("显示来电姓名"); System.out.println("显示头像");&#125; 注意 子类方法覆盖父类方法，必须要保证权限大于等于父类权限，一般采用相同权限 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 构造方法123456789class Zi extends Fu &#123; Zi()&#123; // super（），调用父类构造方法 // 子类的每个构造方法中有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super() // super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 super(); System.out.println("Zi（）"); &#125;&#125; super ：代表父类的存储空间标识(可以理解为父亲的引用)。 super(…) super.成员方法名() super.成员变量 this ：代表当前对象的引用(谁调用就代表谁)。 方法重写 抽象类定义抽象方法 ： 没有方法体的方法，只有声明，没有实现 抽象类：用abstract修饰的类，不必须包含抽象方法，只要不想让该方法可以直接实例化，即可声明为抽象类 1234public abstract class Animal &#123; // 修饰符 abstract 返回值类型 方法名 (参数列表)； public abstract void run()；&#125; 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。 抽象类不能实例化 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类 抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类 接口定义接口，是Java语言中一种引用类型，是方法的集合，接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法 （JDK 9）。 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并 不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 接口的使用，它不能创建对象，但是可以被实现（ implements）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 123456789101112131415161718public interface 接口名称 &#123; // 抽象方法 public abstract void method(); // 默认方法 用于接口功能扩展，如果再加抽象方法，使用实现类都得改，当然子类也可以重写 public default void method() &#123; // 执行语句 &#125; // 静态方法 供接口直接调用，子类无法继承亦无法调用 public static void method2() &#123; // 执行语句 &#125; // 私有方法 用于将默认方法中的重复代码抽取 // 私有方法：只有默认方法可以调用。 // 私有静态方法：默认方法和静态方法可以调用。 private void method() &#123; // 执行语句 &#125;&#125; 多实现子类重写接口默认方法后 接口名.super.方法名来调用接口的默认方法 1234567class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123; // 重写接口中抽象方法【必须】 如果抽象方法有重名的，只需要重写一次。 // 如果默认方法有重名的，必须重写一次，不重名时随意 // 存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法 // 若一个成员变量在接口和父类中都出现，子类必须重新定义 // 若一个成员方法在接口和父类中都出现，子类会调用父类的&#125; 优先级当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。 123456789101112131415161718192021interface A &#123; public default void methodA()&#123; System.out.println("AAAAAAAAAAAA"); &#125;&#125;class D &#123; public void methodA()&#123; System.out.println("DDDDDDDDDDDD"); &#125;&#125;class C extends D implements A &#123; // 未重写methodA方法&#125;public class Test &#123; public static void main(String[] args) &#123; C c = new C(); c.methodA(); &#125;&#125;输出结果:DDDDDDDDDDDD 接口的多继承一个接口能继承另一个或者多个接口，和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继 承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次 子接口重写默认方法时，default关键字可以保留 子类重写默认方法时，default关键字不可以保留 多态定义多态： 是指同一行为，具有多个不同表现形式。(单一的父类来接收多种多样的子类) 12345// 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。// 父类类型 变量名 = new 子类对象；// 变量名.方法名();Fu f = new Zi();f.method(); 前提 继承或者实现【二选一】 方法的重写【意义体现——不重写的话，多态没有意义】 父类引用指向子类对象【格式体现】 特点当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法 好处可以使程序编写的更简单，并有良好的扩展 用多态作为参数或返回值来避免使用大量的方法重载 引用类型转换 向上转型 多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的 12// 父类类型 变量名 = new 子类类型();Animal a = new Cat(); 向下转型 父类类型向子类类型向下转换的过程，这个过程是强制的。 12345678910111213141516171819// 为了调用子类特有的方法// 子类类型 变量名 = (子类类型) 父类变量名;Cat c =(Cat) a;// 经常面临ClassCastException// instanceof运算符public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat)&#123; Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog)&#123; Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse &#125;&#125; final定义final： 不可改变。可以用于修饰类、方法和变量。变量名一般全大写 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 修饰成员属性时必须初始化，要么在定义时初始化，要么就是在构造代码块或者构造方法中初始化 初始化 基本类型的变量被final修饰后仅能赋值一次 成员变量涉及到初始化的问题，初始化方式有两种，必须二选一 1234567891011121314// 显示初始化；public class User &#123; final String USERNAME = "张三"; private int age;&#125;// 构造方法初始化。public class User &#123; final String USERNAME ; private int age; public User(String username, int age) &#123; this.USERNAME = username; this.age = age; &#125;&#125; 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的 修改（变量和那个对象绑定了，但那个对象自己还可以变） 内部类将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类 成员内部类成员内部类 ：定义在类中方法外的类 在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机 类 Engine ，这时， Engine 就可以使用内部类来描述，定义在成员位置。 12345678class 外部类 &#123; // 通常会提供访问内部类的方法 public 内部类 get内部类()&#123; return 内部类; &#125; class 内部类&#123; &#125;&#125; 内部类可以直接访问外部类的成员，包括私有成员。 当内部类与外部类变量重名时：外部类类名.this.变量名来访问外部类变量 外部类要访问内部类的成员，必须要建立内部类的对象 内部类可以用任意访问修饰符，但相应的访问权限会受到限制 在其他类中获取内部类有如下三种方式 123456789101112131415161718192021//法一 // 外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；//法二 // 外部类名.内部类名 对象名 = 外部类对象.new 内部类型()；//法三 // 外部类中提供get内部类的方法public static void main(String[] args) &#123; // 创建外部类对象 Person p = new Person(); // 创建内部类对象 Heart heart = p.new Heart(); // 调用内部类方法 heart.jump(); // 调用外部类方法 p.setLive(false); // 调用内部类方法 heart.jump();&#125;// 内部类是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但前面冠以外部类的类名和$符号// 比如，Person$Heart.class 匿名内部类是内部类的简化写法。它的本质是一个带具体实现的父类或者父接口的匿名的子类对象。 开发中，最常用到的内部类就是匿名内部类了 12345678910111213141516171819202122232425// 对于那些只实例化一次的方法不配专门创建文件// 类似匿名对象，那些只使用一次的对象不配拥有姓名new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;;public class InnerDemo &#123; public static void main(String[] args) &#123; /* 1.等号右边:是匿名内部类，定义并创建该接口的子类对象 2.等号左边:是多态赋值,接口类型引用指向子类对象 */ FlyAble f = new FlyAble()&#123; public void fly() &#123; System.out.println("我飞了~~~"); &#125; &#125;; //调用 fly方法,执行重写后的方法 f.fly(); &#125;&#125; 区别匿名对象和匿名内部类： ​ 匿名内部类是只实例化一次，但该实例可被变量接收，多次调用 ​ 匿名对象是仅调用一次 常量池参见这篇文章 常用类Scanner类12345678910111213//1. 导包import java.util.Scanner;public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println("请录入一个整数："); int i = sc.nextInt(); //4. 输出数据 System.out.println("i:"+i); &#125;&#125; Random类123456789101112131415//1. 导包import java.util.Random; public class Demo01_Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 // 可以通过平移和伸缩来实现输出任意范围随机数 int number = r.nextInt(10); //4. 输出数据 System.out.println("number:"+ number); &#125; &#125;&#125; ArrayList类缘起而数组的长度是固定的，无法适应数据变化的需 求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对 象数据。 定义java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储 的元素。 ArrayList 中可自动扩容 123456// 创建 jdk1.7之后右侧&lt;&gt;可以留空ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();public boolean add(E e) // 将指定的元素添加到此集合的尾部。public E remove(int index) // 移除此集合中指定位置上的元素。返回被删除的元素。public E get(int index) // 返回此集合中指定位置上的元素。返回获取的元素。public int size() // 返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 ArrayList对象不能存储基本类型，只能存储引用类型的数据。所以需要存入对应的包装类 String类定义Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。 特点 字符串不变：字符串的值在创建后不能被更改。但凡改变，必定是生成了新的字符串 因为String对象是不可变的，所以它们可以被共享。 类似于python中的缓存机制，java中应该被称为常量池 “abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 123456例如：String str = "abc";相当于：char data[] = &#123;'a', 'b', 'c'&#125;;String str = new String(data);// String底层是靠字符数组实现的。 构造12345678// 无参构造String str = new String（）；// 通过字符数组构造char chars[] = &#123;'a', 'b', 'c'&#125;;String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;;String str3 = new String(bytes); 常用方法 12345678910111213// 判断public boolean equalsIgnoreCase (String anotherString) // 将此字符串与指定对象进行比较，忽略大小写。// 获取public String concat (String str) // 将指定的字符串连接到该字符串的末尾。public char charAt (int index) // 按索引取char值// 转换public char[] toCharArray () // 将此字符串转换为新的字符数组。public String replace (CharSequence target, CharSequence replacement) // 将与target匹配的字符串使用replacement字符串替换。 StringBuilder与StringBuffer区别在于不是线程安全的，所以效率较高 Arrays类java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法 123456789101112public static String toString(int[] a) // 返回指定数组内容的字符串表示形式public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;2,34,35,4,657,8,69,9&#125;; // 打印数组,输出地址值 System.out.println(arr); // [I@2ac1fdc4 // 数组内容转为字符串 String s = Arrays.toString(arr); // 打印字符串,输出内容 System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9]&#125;public static void sort(int[] a) // 对指定的 int 型数组按数字升序进行排序，改变原数组 Math类java.lang.Math 类包含用于执行基本数学运算的方法，其所有方法均为静态方法 1234public static double abs(double a) ：返回 double 值的绝对值public static double ceil(double a) ：返回大于等于参数的最小的整数public static double floor(double a) ：返回小于等于参数最大的整数public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)]]></content>
      <categories>
        <category>heima57</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven使用]]></title>
    <url>%2F2020%2F02%2F12%2Fheima57%2Fmaven%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[概述 项目管理工具，对软件项目提供构建和依赖管理 国外：中央仓库 国内：阿里云 官方文档 核心特性 项目设置遵循统一规则，保证不同开发平台的兼容性 强大的依赖管理，项目依赖自动下载 jar包管理 导入依赖时，如果这个依赖也有pom.xml文件，会自动导入其它需要的依赖 可扩展插件机制 一键编译 一键测试 一键部署 依赖管理maven工程对jar包的管理过程，实现了jar包的重用 安装与配置去官网解压到一个路径下即可 添加环境变量 path中添加 maven运行依赖于JAVA_HOME变量 本地仓库 项目结构目录结构 pom文件结构 1234567891011121314151617181920212223242526272829303132333435 &lt;!-- 配置私服 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;!-- 从阿里云获取私服链接 --&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;build&gt; &lt;!--最终包名--&gt; &lt;finalName&gt;Pinyin&lt;/finalName&gt; &lt;plugins&gt; &lt;!--打jar包--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;!--入口类--&gt; &lt;manifest&gt; &lt;mainClass&gt;com.imooc.maven.PinyinTestor&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;!--将所有相关jar包打到一个jar包里--&gt; &lt;discriptorRefs&gt; &lt;discriptorRef&gt;jar-with-dependencies&lt;/discriptorRef&gt; &lt;/discriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--java -jar jar包名来运行jar包--&gt; &lt;/plugins&gt;&lt;/build&gt; 常用命令 idea集成maven配置确认下电脑上是否安装好了maven setting中配置如下信息 -DarchetypeCatalog=internal 创建项目 web项目所用的骨架 把没有提供全的目录自己添加一下，一般java项目不需要用骨架 jar包添加本地添加 scope标签作用：有些jar包仅在编译时需要 包名 作用域 servlet provided jsp provided junit test mysql runtime system 元素与 provided 元素类似，但是被依赖项不会从 maven 仓库中查找，而是从本地系统中获取，systemPath 元素用于制定本地系统中 jar 文件的路径 中央仓库添加去中央仓库查找 运行环境修改 可以将常用的添加为模板]]></content>
      <tags>
        <tag>maven</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python例题]]></title>
    <url>%2F2020%2F02%2F11%2Fpython%2Fpython%E4%BE%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[函数12345678func_list = []for i in range(10): func_list.append(lambda x:x+i)for i in range(0,len(func_list)): result = func_list[i](i) print(result) lambda返回的是个函数地址，且里面各变量在真正执行前都是保存着地址 通过闭包保存传入的参数，其余变量则在命名空间中寻找 12345678910def func(name): v = lambda x: x + name return vv1 = func('太白')v2 = func('alex')v3 = v1('银角')v4 = v2('金角')print(v1, v2, v3, v4)]]></content>
      <tags>
        <tag>python</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2020%2F02%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[常识计算机基本组件cpu计算机的运算和计算中心 人类一秒，可以运行10亿条指令，比内存快百度，硬盘快百万倍 内存暂时存储数据，临时加载数据应用程序，分为RAM，ROM 硬盘长期存储数据 操作系统一个软件，连接计算机的硬件与所有软件之间的一个软件 python历史python崇尚优雅，简洁 2和3有较多区别 python的种类 Cpython：官方推荐解释器。可以转化成C语言能识别的字节码。 Jpython: 可以转化成Java语言能识别的字节码。 Ironpython：可以转化成.net语言能识别的字节码 pypy: 动态编译 编程语言分类编译型​ 将代码一次性全部编译成二进制，然后再执行。 ​ 优点：执行效率高。 ​ 缺点：开发效率低，不能跨平台。 ​ 代表语言：C 解释型​ 逐行解释成二进制，逐行运行。 ​ 优点：开发效率高，可以跨平台。 ​ 缺点：执行效率低。 ​ 代表语言：python 变量相当于为对应内存空间起别名，不同类型变量为不同大小内存块或有不同作用 变量命名 变量全部由数字，字母下划线任意组合。 不能以数字开头。 不能是python的关键字。 [‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’] 要具有描述性。name= ‘太白金星’ sex 不能使用中文。 不能过长。 推荐 驼峰体：AgeOfOldboy = 73 下划线：age_of_oldboy = 73 常量代指生活中一直不变的 python中没有真正的常量，为了应和其他语言的口味，全部大写的变量称之为常量。所以是一种约定俗成的东西，没有实际约束。将变量名全部大写，放在文件的最上面 注释便于你理解对方的代码，自己的代码。 单行注释： # 多行注释： ‘’’被注释内容’’’ “””被注释内容””” 运算符算数运算以下假设变量：a=10，b=20 / 是除法，例如：2/3 = 0.6666。而//是表示向下取整的除法，例如3//2=1，6.0//4 = 1。也就是说 / 返回的是浮点类型的结果， 而 // 返回的是整数结果(可以理解为/的整数部分) 比较运算以下假设变量：a=10，b=20 赋值运算以下假设变量：a=10，b=20 逻辑运算 断路与或 x or y , x为真，值就是x，x为假，值是y x and y, x为真，值是y,x为假，值是x。 成员运算判断子元素是否在原字符串（字典，列表，集合）中 123print('喜欢' in 'dkfljadklf喜欢hfjdkas')print('a' in 'bcvd')print('y' not in 'ofkjdslaf') 三目运算符123456max = a if a &gt; b else b# 两者等价if a &gt; b: max = aelse: max = b Python运算符优先级 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 pass语句Python pass 是空语句，是为了保持程序结构的完整性。 pass 不做任何事情，一般用做占位语句。 id()返回输入对象的内存地址 is和==12a is b # 比较内存地址a == b # 比较值 基本数据类型分类 不可变（可哈希）的数据类型：int，str，bool，tuple。 可变（不可哈希）的数据类型：list，dict，set。 int不同进制间转化 方法 名称 作用 bit_length(self) 转为对应二进制后有效位的长度 bool常用于条件 while 1：比while True：更高效 str12345678# 由单(双)引号引起# 三引号：带换行的字符串 msg = ''' 今天我想写首小诗， 歌颂我的同桌， 你看他那乌黑的短发， 好像一只炸毛鸡。 ''' 格式化输出 法一 符号 指代 %s str %d digit %i int %r 输出时对应字符串带引号 %% 普通%号 123456789101112131415name = input("Name:")age = input("Age:")job = input("Job:")hobbie = input("Hobbie:")info = '''------------ info of %s ----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 name Name : %s #代表 name Age : %s #代表 age job : %s #代表 job Hobbie: %s #代表 hobbie ------------- end -----------------''' %(name,name,age,job,hobbie) # 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来 # %%来输出普通百分号print(info) 法二 123res='&#123;&#125; &#123;&#125; &#123;&#125;'.format('egon',18,'male')res='&#123;1&#125; &#123;0&#125; &#123;1&#125;'.format('egon',18,'male')res='&#123;name&#125; &#123;age&#125; &#123;sex&#125;'.format(sex='male',name='egon',age=18) 法三 f-strings 是python3.6开始加入标准库的格式化输出新的写法，这个格式化输出比之前的%s 或者 format 效率高并且更加简化，非常的好用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 任意表达式print(f'&#123;3*21&#125;') # 63name = 'barry'print(f"全部大写：&#123;name.upper()&#125;") # 全部大写：BARRY# 字典也可以teacher = &#123;'name': '太白金星', 'age': 18&#125;msg = f"The teacher is &#123;teacher['name']&#125;, aged &#123;teacher['age']&#125;"print(msg) # The comedian is 太白金星, aged 18# 列表也行l1 = ['太白金星', 18]msg = f'姓名：&#123;l1[0]&#125;,年龄：&#123;l1[1]&#125;.'print(msg) # 姓名：太白金星,年龄：18.# 用函数完成相应的功能，然后将返回值返回到字符串相应的位置def sum_a_b(a,b): return a + ba = 1b = 2print('求和的结果为' + f'&#123;sum_a_b(a,b)&#125;')# 多行name = 'barry'age = 18ajd = 'handsome'speaker = f'''Hi &#123;name&#125;.You are &#123;age&#125; years old.You are a &#123;ajd&#125; guy!'''speaker = f'Hi &#123;name&#125;.'\ f'You are &#123;age&#125; years old.'\ f'You are a &#123;ajd&#125; guy!'print(speaker)# 一些细节print(f"&#123;&#123;73&#125;&#125;") # &#123;73&#125;print(f"&#123;&#123;&#123;73&#125;&#125;&#125;") # &#123;73&#125;print(f"&#123;&#123;&#123;&#123;73&#125;&#125;&#125;&#125;") # &#123;&#123;73&#125;&#125;m = 21# ! , : &#123; &#125; ;这些标点不能出现在&#123;&#125; 这里面。# print(f'&#123;;12&#125;') # 报错# 所以使用lambda 表达式会出现一些问题。# 解决方式：可将lambda嵌套在圆括号里面解决此问题。x = 5print(f'&#123;(lambda x: x*2) (x)&#125;') # 10 索引按下标取值，从零开始 切片通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串 左闭右开 1234567a = 'ABCDEFGHIJK'print(a[0:3]) # print(a[:3]) 从开头开始取0可以默认不写print(a[2:5])print(a[:]) #默认到最后print(a[:-1]) # -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素print(a[:5:2]) #加步长print(a[-1:-5:-2]) #反向加步长 常用方法 方法名 作用 upper(self) 转为大写 lower(self) 转为小写 count(str,i,j) 从i到j的切片中str出现了几次 startswith(str,i,j) 从i到j，是不是str，不写i，j时从头匹配 endswith(str,i,j) 从i到j，是不是str，不写i，j时从尾匹配 replace(str,i) 默认全部替换，i可以指定替换个数 strip() 去除空拍字符(\t,\n,空格)，从左右两边开始删到都一个非空白为止 lstrip() 删左侧 rstrip() 删右侧 strip(str) 去除在str中的字符 isalnum() 字符串由字母或数字组成 isalpha() 字符串只由字母组成 isdecimal() 字符串只由十进制组成 len(str) 获取数据的元素个数 12345678910111213141516171819202122232425262728293031# split 以什么分割，最终形成一个列表此列表不含有这个分割的元素。ret9 = 'title,Tilte,atre,'.split('t')print(ret9)ret91 = 'title,Tilte,atre,'.rsplit('t',1)print(ret91)# join 与split相对，若是str则以每个元素都以指定字符连接，多是给链表使用s1 = "advewvbe"s2 = "+".join(s1)# a+d+v+e+w+v+b+el1 = ["2","chjs","你好"]l2 = ":".join(l1)# 2:chjs:你好# 列表中元素必须全是字#寻找字符串中的元素是否存在ret6 = a4.find("fjdk",1,6)print(ret6) # 返回的找到的元素的索引，如果找不到返回-1ret61 = a4.index("fjdk",4,6)print(ret61) # 返回的找到的元素的索引，找不到报错。#captalize,swapcase,titleprint(name.capitalize()) #首字母大写print(name.swapcase()) #大小写翻转msg='taibai say hi'print(msg.title()) #每个单词的首字母大写# 内同居中，总长度，空白处填充ret2 = a1.center(20,"*")print(ret2) listl1 = [100, ‘alex’,True,[1, 2, 3]] 承载任意数据类型，存储大量的数据 python常用的容器型数据类型。相当于其他语言的数组 列表是有序的，可索引，切片（步长） 切片，索引同str 列表的创建123456789101112131415161718# 列表的创建# 方式一# l1 = [1, 2, 'Alex']# 方式二 对可迭代的数据类型# l1 = list()# l1 = list('fhdsjkafsdafhsdfhsdaf')# print(l1)# ['f', 'h', 'd', 's', 'j', 'k', 'h', 's', 'd', 'a', 'f']# 方式三：列表推导式# [i(对i的简单处理) 循环(可多层，但一般最多两到三层) 条件]# 循环模式 [变量(加工的变量) for 变量 in iterable]# 多层循环 [变量(加工的变量) for i in iterable for j in iterable]l1 = [i for i in range(1,5)]print(l1) # [1, 2, 3, 4]l2 = [i for i in range(2,11)] + list("JQKA") #扑克(不完整)# 筛选模式 [变量(加工的变量) for 变量 in iterable if 条件] 列表的增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 增删改查l1 = ['太白', '女神', 'xiao','吴老师', '闫龙']# 增：# append:追加# l1.append('xx')# print(l1)# insert 插入# l1.insert(2,'wusir')# print(l1)#extend 迭代着追加# l1.extend('abcd')# l1.extend(['alex',])# l1.extend(['alex', 1, 3])# print(l1)# 删# pop 按照索引位置删除，返回的是删除的元素# l1.pop(-2) # 按照索引删除# print(l1.pop(-2))# l1.pop() # 默认删除最后一个# print(l1)# remove 指定元素删除,如果有重名元素，默认删除从左数第一个# l1.remove('xiao')# print(l1)# clear(了解)# l1.clear() # 清空# print(l1)# del # 按照索引删除 # del l1[-1] # print(l1) # 按照切片(步长)删除 # del l1[::2] # print(l1)# 改 # 按照索引改值 # l1[0] = '男神' # 按照切片改（了解） 整个切片替换 # l1[2:] = 'fsdafsdafsdfdsfsadfdsfdsgsfdag' # print(l1) # 按照切片（步长） 逐个替换，对应个数必须相同 # l1[::2] = 'abc' # l1[::2] = 'abcd' # print(l1)# 查：# 索引，切片（步长）# for i in l1:# print(i) 列表相加或相乘1234l1 = [1, 2, 3]l2 = [4, 5, 6]# print(l1+l2) # [1, 2, 3, 4, 5, 6]print(l1*3) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 其他操作count（数）（方法统计某个元素在列表中出现的次数）。 12a = ["q","w","q","r","t","y"]print(a.count("q")) index（方法用于从列表中找出某个值第一个匹配项的索引位置） 12a = ["q","w","r","t","y"]print(a.index("r")) sort （方法用于在原位置对列表进行排序） reverse （方法将列表中的元素反向存放） 123456a = [2,1,3,4,5]a.sort()# 他没有返回值，所以只能打印aa.sort(reverse=True)# 默认单增，这样可以单减print(a)a.reverse()#他也没有返回值，所以只能打印aprint(a) 列表的嵌套相当于多维数组 12345l1 = [1, 2, 'taibai', [1, 'alex', 3,]]# 1, 将l1中的'taibai'变成大写并放回原处。# 2，给小列表[1,'alex',3,]追加一个元素,'老男孩教育'。l1[3] = l1[3].append("老男孩教育")# 3，将列表中的'alex'通过字符串拼接的方式在列表中变成'alexsb' 循环列表，改变列表大小的问题用这个进行举例：当你循环到22时，你将列表中的22删除了，但是你带来的影响是：33,44,55都会往前进一位，他们的索引由原来的2,3,4变成了1,2,3 所以你在往下进行循环时，就会发现，额……..完全不对了 所以for循环遍历本质是在按索引遍历，正序遍历时删除元素会打乱原有顺序 12345l1 = [11,22,33,44,55]for index in len(l1): if index % 2 == 1: l1.pop(index)# [11,33,44] 直接删除 12l1 = [11,22,33,44,55]del l1[1::2] 倒序删除 1234l1 = [11,22,33,44,55]for i in range(len(l1)-1:-1:-1): if i % 2 == 1: l1.pop(i) 思维转换 123456l1 = [11,22,33,44,55]new_l1 = []for i in len(l1): if i % 2 == 0: new_l1.append(i)l1 = new_l1 循环一个列表时最好不要改变列表的大小，容易出现错误 必须修改时可以用上诉三种方法 tuple俗称不可变的列表,又被成为只读列表,也是python的基本数据类型之一,用小括号括起来,里面可以放任何数据类型的数据,查询可以,循环也可以,切片也可以.但就是不能改. 当元组中包含可变类型时，其仍可变，如包含链表时，该链表仍可修改 python中元组有一个特性，元组中如果只含有一个元素且没有逗号，则该元组不是元组，与改元素数据类型一致，如果有逗号，那么它是元组 拆包专用，虽然链表也可以拆 拆包(分别赋值)123456789101112131415161718192021a,b = 1,2print(a,b)结果:2a,b = ('你好','世界') # 这个用专业名词就叫做元组的拆包print(a,b)结果:你好 世界a,b = ['你好','大飞哥']print(a,b)结果:你好 世界a,b = &#123;'汪峰':'北京北京','王菲':'天后'&#125;print(a,b)结果:汪峰 王菲 索引和切片1234567tu1 = ('a', 'b', '太白', 3, 666)print(tu1[0]) # 'a'print(tu1[-1]) # 666print(tu1[1:3]) # ('b', '太白')print(tu1[:-1]) # ('a', 'b', '太白', 3)print(tu1[::2]) # ('a', '太白', 666)print(tu1[::-1]) # (666, 3, '太白', 'b', 'a') 其他操作因为元组的特性，直接从属于元组的元素不能更改，所以元组只能查看。 12345# 可以利用for循环查询tu1 = ('a', 'b', '太白', 3, 666)for i in tu1: print(i) index：通过元素找索引（可切片），找到第一个元素就返回，找不到该元素即报错。 12tu = ('太白', [1, 2, 3, ], 'WuSir', '女神')print(tu.index('太白')) # 0 count: 获取某元素在列表中出现的次数 12tu = ('太白', '太白', 'WuSir', '吴超')print(tu.count('太白')) # 2 dict字典是Python语言中的映射类型，他是以{}括起来，里面的内容是以键值对的形式储存的： Key: 不可变（可哈希）的数据类型.并且键是唯一的，不重复的。 Value:任意数据(int，str，bool，tuple，list，dict，set)，包括后面要学的实例对象等。 在Python3.5版本（包括此版本）之前，字典是无序的。 在Python3.6版本之后，字典会按照初建字典时的顺序排列(即第一次插入数据的顺序排序)。 当然，字典也有缺点：他的缺点就是内存消耗巨大。 为何查询快？底层用了散列表 创建方式1234567891011121314151617181920212223242526272829303132333435363738394041# 方式1: 元组dic = dict((('one', 1),('two', 2),('three', 3)))# dic = dict([('one', 1),('two', 2),('three', 3)])print(dic) # &#123;'one': 1, 'two': 2, 'three': 3&#125;# 方式2: 关键字dic = dict(one=1,two=2,three=3)print(dic) # &#123;'one': 1, 'two': 2, 'three': 3&#125;# 方式3: 键值对dic = dict(&#123;'one': 1, 'two': 2, 'three': 3&#125;)print(dic) # &#123;'one': 1, 'two': 2, 'three': 3&#125;# 方式5: 内置函数zipdic = dict(zip(['one', 'two', 'three'],[1, 2, 3]))print(dic)# 方式6: 字典推导式dic = &#123; k: v for k,v in [('one', 1),('two', 2),('three', 3)]&#125;print(dic)# 方式7: 利用fromkey("keys(可迭代类型)","所有键共用的值")dic = dict.fromkeys('abcd','太白')print(dic) # &#123;'a': '太白', 'b': '太白', 'c': '太白', 'd': '太白'&#125;dic = dict.fromkeys([1, 2, 3],'太白')print(dic) # &#123;1: '太白', 2: '太白', 3: '太白'&#125; # 这里有一个坑，就是如果通过fromkeys得到的字典的值为可变的数据类型，那么你的小心了。dic = dict.fromkeys([1, 2, 3], [])dic[1].append(666)print(id(dic[1]),id(dic[2]),id(dic[3])) # &#123;1: [666], 2: [666], 3: [666]&#125;print(dic) # &#123;1: [666], 2: [666], 3: [666]&#125;# 字典推导式lst1 = ['jay','jj','meet']lst2 = ['周杰伦','林俊杰','郭宝元']dic = &#123;lst1[i]:lst2[i] for i in range(len(lst1))&#125;print(dic) 增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# 增 # 通过键值对直接增加 有则改之，无则增加 dic = &#123;'name': '太白', 'age': 18&#125; dic['weight'] = 75 # 没有weight这个键，就增加键值对 print(dic) # &#123;'name': '太白', 'age': 18, 'weight': 75&#125; dic['name'] = 'barry' # 有name这个键，就成了字典的改值 print(dic) # &#123;'name': 'barry', 'age': 18, 'weight': 75&#125; # setdefault 有则不变，无则加之 dic = &#123;'name': '太白', 'age': 18&#125; dic.setdefault('height',175) # 没有height此键，则添加 print(dic) # &#123;'name': '太白', 'age': 18, 'height': 175&#125; dic.setdefault('name','barry') # 有此键则不变 print(dic) # &#123;'name': '太白', 'age': 18, 'height': 175&#125; #它有返回值 可用于查看 dic = &#123;'name': '太白', 'age': 18&#125; ret = dic.setdefault('name') print(ret) # 太白# 删 # pop 通过key删除字典的键值对，有返回值，可设置返回值。 dic = &#123;'name': '太白', 'age': 18&#125; # ret = dic.pop('name') # print(ret,dic) # 太白 &#123;'age': 18&#125; ret1 = dic.pop('n',None) print(ret1,dic) # None &#123;'name': '太白', 'age': 18&#125; #popitem 3.5版本之前，popitem为随机删除，3.6之后为删除最后一个，有返回值 dic = &#123;'name': '太白', 'age': 18&#125; ret = dic.popitem() print(ret,dic) # ('age', 18) &#123;'name': '太白'&#125; # 值可以重复，所以不像其他有remove方法 # clear 清空字典 dic = &#123;'name': '太白', 'age': 18&#125; dic.clear() print(dic) # &#123;&#125; # del # 通过键删除键值对 dic = &#123;'name': '太白', 'age': 18&#125; del dic['name'] print(dic) # &#123;'age': 18&#125; #删除整个字典 del dic# 改 # 通过键值对直接改 dic = &#123;'name': '太白', 'age': 18&#125; dic['name'] = 'barry' print(dic) # &#123;'name': 'barry', 'age': 18&#125; # update 类似于创建字典 dic = &#123;'name': '太白', 'age': 18&#125; dic.update(sex='男', height=175) print(dic) # &#123;'name': '太白', 'age': 18, 'sex': '男', 'height': 175&#125; dic = &#123;'name': '太白', 'age': 18&#125; dic.update([(1, 'a'),(2, 'b'),(3, 'c'),(4, 'd')]) print(dic) # &#123;'name': '太白', 'age': 18, 1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125; # 有则加之，无则不变 dic1 = &#123;"name":"jin","age":18,"sex":"male"&#125; dic2 = &#123;"name":"alex","weight":75&#125; dic1.update(dic2) print(dic1) # &#123;'name': 'alex', 'age': 18, 'sex': 'male', 'weight': 75&#125; print(dic2) # &#123;'name': 'alex', 'weight': 75&#125; # 查 # 通过键查询 # 直接dic[key](没有此键会报错) dic = &#123;'name': '太白', 'age': 18&#125; print(dic['name']) # 太白 # get dic = &#123;'name': '太白', 'age': 18&#125; v = dic.get('name') print(v) # '太白' v = dic.get('name1') print(v) # None v = dic.get('name2','没有此键') print(v) # 没有此键 keys() dic = &#123;'name': '太白', 'age': 18&#125; print(dic.keys()) # dict_keys(['name', 'age']) values() dic = &#123;'name': '太白', 'age': 18&#125; print(dic.values()) # dict_values(['太白', 18]) items() dic = &#123;'name': '太白', 'age': 18&#125; print(dic.items()) # dict_items([('name', '太白'), ('age', 18)]) """ dict_keys(['name', 'age']) dict_values(['太白', 18]) dict_items([('name', '太白'), ('age', 18)]) 这些高仿的列表可以用于for循环，亦可传入list()来转换为真正的列表 """ 字典的嵌套循环字典，改变字典大小的问题来，先来研究一个小题，有如下字典： dic = {‘k1’:’太白’,’k2’:’barry’,’k3’: ‘白白’, ‘age’: 18} 请将字典中所有键带k元素的键值对删除。 12345678910dic = &#123;'k1':'太白','k2':'barry','k3': '白白', 'age': 18&#125;for i in dic: if 'k' in i: del dic[i]print(dic)# 你会发现，报错了。。。。。# 错误原因：# RuntimeError: dictionary changed size during iteration# 翻译过来是：字典在循环迭代时，改变了大小。 所以说，他和列表差不多，只不过比列表更暴力一些，对其进行总结就是： 在循环一个字典的过程中，不要改变字典的大小（增，删字典的元素），这样会直接报错。 思维转换 1234567l1 = []dic = &#123;'k1':'太白','k2':'barry','k3': '白白', 'age': 18&#125;for key in dic: if 'k' in key: l1.append(i)for i in l1: dic.pop(i) 简化 1234dic = &#123;'k1':'太白','k2':'barry','k3': '白白', 'age': 18&#125;for key in list(dic.keys()): if 'k' in key: dic.pop(key) set集合是无序的，不重复的数据集合 它里面的元素是可哈希的(不可变类型)，但是集合本身不可哈希（所以集合做不了字典的键） 以下是集合最重要的两点： 去重，把一个列表变成集合，就自动去重了。 关系测试，测试两组数据之前的交集、差集、并集等关系。 创建123456789# 一set1 = set(&#123;1,2,'barry'&#125;)# 二set2 = &#123;1,2,'barry'&#125;print(set1,set2) # &#123;1, 2, 'barry'&#125; &#123;1, 2, 'barry'&#125;# 集合推导式lst = [1,2,3,-1,-3,-7,9]s = &#123;abs(i) for i in lst&#125;print(s) 增删改查12345678910111213141516171819202122232425262728 # 增 set1 = &#123;'alex','wusir','ritian','egon','barry'&#125; set1.add('景女神') print(set1) #update：迭代着增加 set1.update('A') print(set1) set1.update('老师') print(set1) set1.update([1,2,3]) print(set1)# 删 set1 = &#123;'alex','wusir','ritian','egon','barry'&#125; # 因为无序，所以没有按所以删除 set1.remove('alex') # 按内容删 print(set1) set1.pop() # 随机删除一个元素 print(set1) set1.clear() # 清空集合 print(set1) del set1 # 删除集合 print(set1)# 无序，所以无法改查# 但改可以通过先把要改元素删除，再把要改成的数据作为新值加入 集合的其他操作4.1 交集。（&amp; 或者 intersection） 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 &amp; set2) # &#123;4, 5&#125;print(set1.intersection(set2)) # &#123;4, 5&#125; 4.2 并集。（| 或者 union） 123set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 | set2) # &#123;1, 2, 3, 4, 5, 6, 7,8&#125;print(set2.union(set1)) # &#123;1, 2, 3, 4, 5, 6, 7,8&#125; 4.3 差集。（- 或者 difference） 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 - set2) # &#123;1, 2, 3&#125;print(set1.difference(set2)) # &#123;1, 2, 3&#125; 4.4反交集。 （^ 或者 symmetric_difference） 排斥或 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 ^ set2) # &#123;1, 2, 3, 6, 7, 8&#125;print(set1.symmetric_difference(set2)) # &#123;1, 2, 3, 6, 7, 8&#125; 4.5子集与超集 12345678set1 = &#123;1,2,3&#125;set2 = &#123;1,2,3,4,5,6&#125;print(set1 &lt; set2)print(set1.issubset(set2)) # 这两个相同，都是说明set1是set2子集。print(set2 &gt; set1)print(set2.issuperset(set1)) # 这两个相同，都是说明set2是set1超集。 5，frozenset不可变集合，让集合变成不可变类型。 12s = frozenset('barry')print(s,type(s)) # frozenset(&#123;'a', 'y', 'b', 'r'&#125;) &lt;class 'frozenset'&gt; 数据类型转化bool，int，str互化12345678910111213141516171819202122232425262728# int ---&gt; booli = 100print(bool(i)) # True # 非零即Truei1 = 0print(bool(i1)) # False 零即False# bool ---&gt; intt = Trueprint(int(t)) # 1 True --&gt; 1t = Falseprint(int(t)) # 0 False --&gt; 0# int ---&gt; stri1 = 100print(str(i1)) # '100'# str ---&gt; int # 全部由数字组成的字符串才可以转化成数字s1 = '90'print(int(s1)) # 90# str ---&gt; bools1 = '太白's2 = ''print(bool(s1)) # True 非空即Trueprint(bool(s2)) # False# bool ---&gt; strt1 = Trueprint(str(True)) # 'True' str，list互化1234567# str ---&gt; lists1 = 'alex 太白 武大'print(s1.split()) # ['alex', '太白', '武大']# list ---&gt; str # 前提 list 里面所有的元素必须是字符串类型才可以l1 = ['alex', '太白', '武大']print(' '.join(l1)) # 'alex 太白 武大' list set互化1234567# list ---&gt; sets1 = [1, 2, 3]print(set(s1))# set ---&gt; listset1 = &#123;1, 2, 3, 3,&#125;print(list(set1)) # [1, 2, 3] str，bytes互化1234567# str ---&gt; bytess1 = '太白'print(s1.encode('utf-8')) # b'\xe5\xa4\xaa\xe7\x99\xbd'# bytes ---&gt; strb = b'\xe5\xa4\xaa\xe7\x99\xbd'print(b.decode('utf-8')) # '太白' 所有皆可转为bool转化成bool值为False的数据类型有：‘’, 0, (), {}, [], set(), None 基础数据类型总结思维导图 按存储空间的占用分（从低到高）数字字符串集合：无序，即无序存索引相关信息元组：有序，需要存索引相关信息，不可变列表：有序，需要存索引相关信息，可变，需要处理数据的增删改字典：有序，需要存key与value映射的相关信息，可变，需要处理数据的增删改（3.6之后有序） 按存值个数区分 标量／原子类型 数字，字符串 容器类型 列表，元组，字典 按可变不可变区分 可变 列表，字典 不可变 数字，字符串，元组，布尔值 按访问顺序区分 直接访问 数字 顺序访问（序列类型） 字符串，列表，元组 key值访问（映射类型） 字典 流程控制语句条件判断相当于生活中的一次次决策 1234567891011121314151617181920# 基本结构if 条件: 结果 if int(age) &gt; 18: print('恭喜你，成年了')else: print('小屁孩儿') # 多个条件，python中无switch...case... if num == 1: print('晚上请你吃饭')elif num == 3: print('一起溜达')elif num == 2: print('请你大宝剑')else: print('太笨了....') # if可以嵌套 while循环用于重复执行的代码，一般没有明确次数用while，有确定次数用for 一般得在循环体内改变条件，或使用break，否则会出现死循环 12345while 条件: 循环体else： 在循环正常结束时执行 若通过break跳出则不执行 continue：跳过本次条件 break：跳出循环 for循环12for i in str: print(i) for…else 同while用法 1234567891011msg = '老男孩python是全国范围内最好的python培训机构'for item in msg: print(item)li = ['alex','银角','女神','egon','太白']for i in li: print(i)dic = &#123;'name':'太白','age':18,'sex':'man'&#125;for k,v in dic.items(): print(k,v) 与循环配合的方法range指定范围，生成指定数字 12345678for i in range(1,10): print(i)for i in range(1,10,2): # 步长 print(i)for i in range(10,1,-2): # 反向步长 print(i) enumerate枚举，对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 1234567li = ['alex','银角','女神','egon','太白']for i in enumerate(li): print(i)for index,name in enumerate(li,1): print(index,name)for index, name in enumerate(li, 100): # 起始位置默认是0，可更改 print(index, name) 控制台输入输出input1name = input("请输入用户名") print123print("name")# 默认输出自带换行print(name,end="") 编码初始计算机存储，传输文件底层都是二进制码 解码：将二进制文件按对应编码还原为数据 编码：将数据按指定编码转为二进制数据 常用编码ASCII码最早的编码，只包含英文字母，数字，特殊字符 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 每个字符对应8bit GBK国标，包含英文字母，数字，特殊字符，中文 一个英文字符占1byte 一个中文字符占2byte Unicode万国码，把世界上所有的文字都记录 起初每个字符用2byte，后来为了记录所有，每个字符用4byte 虽然全面，但浪费资源 UTF-8Unicode升级版 字符 大小 英文 1byte 欧洲文字 2byte 中文，亚洲文字 3byte 数据大小12345678910118bit = 1byte1024byte = 1KB1024KB = 1MB1024MB = 1GB1024GB = 1TB1024TB = 1PB1024TB = 1EB1024EB = 1ZB1024ZB = 1YB1024YB = 1NB1024NB = 1DB 补充知识 1. 在计算机内存中，统一使用Unicode编码，当需要将数据保存到硬盘或者需要网络传输的时候，就转换为非Unicode编码比如：UTF-8编码。 其实这个不用深入理解，他就是规定，举个例子：用文件编辑器（word，wps,等）编辑文件的时候，从文件将你的数据（此时你的数据是非Unicode（可能是UTF-8，也可能是gbk，这个编码取决于你的编辑器设置））字符被转换为Unicode字符读到内存里，进行相应的编辑，编辑完成后，保存的时候再把Unicode转换为非Unicode（UTF-8，GBK 等）保存到文件。 2. 不同编码之间，不能直接互相识别。 比如你的一个数据：‘老铁没毛病’是以utf-8的编码方式编码并发送给一个朋友，那么你发送的肯定是通过utf-8的编码转化成的二进制01010101，那么你的朋友接收到你发的这个数据，他如果想查看这个数据必须将01010101转化成汉字，才可以查看，那么此时那也必须通过utf-8编码反转回去，如果要是通过gbk编码反转，那么这个内容可能会出现乱码或者报错 前提条件：python3x版本（python2x版本与这个不同）。 主要用途：数据的存储或者传输。 刚才咱们也说过了，在计算机内存中，统一使用Unicode编码，当需要将数据保存到硬盘或者需要网络传输的时候，就转换为非Unicode编码比如：UTF-8编码 引例：网络传输 解决方式：用bytes做中介 bytes 类名 str类型 bytes类型 标注 名称 str,字符串,文本文字 bytes,字节文字 组成单位 字符 字节 组成形式 ‘’ 或者 “” 或者 ‘’’ ‘’’ 或者 “”” “”” b’’ 或者 b”” 或者 b’’’ ‘’’ 或者 b””” “”” 不同，bytes类型就是在引号前面+b(B)大小写都可以 表现形式 英文： ‘alex’ 中文： ‘中国’ 英文：b’alex’中文：b’\xe4\xb8\xad\xe5\x9b\xbd’ 字节文字对于ascii中的元素是可以直接显示的。 编码方式 Unicode 可指定编码（除Unicode之外）比如UTF-8，GBK 等 非ascii码中的元素是以十六进制的形式表示的 相应功能 upper lower spllit 等等 upper lower spllit 等等 几乎相同 转译 可在最前面加r进行转译 可在最前面加r进行转译 相同 重要用途 python基础数据类型，用于存储少量的常用的数据 负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等bytes是唯一可以指定编码化为非unicode编码的 bytes就是用于数据存储和网络传输数据 bytes类型也称作字节文本，他的主要用途就是网络的数据传输，与数据存储。那么有些同学肯定问，bytes类型既然与str差不多，而且操作方法也很相似，就是在字符串前面加个b不就行了，python为什么还要这两个数据类型呢？我只用bytes不行么？ 如果你只用bytes开发，不方便。因为对于非ascii码里面的文字来说，bytes只是显示的是16进制。很不方便。 str bytes互化1234567891011121314151617# 通过编码将str转为对应bytes# encode称作编码:将 str 转化成 bytes类型s1 = '中国'b1 = s1.encode('utf-8') # 转化成utf-8的bytes类型print(s1) # 中国print(b1) # b'\xe4\xb8\xad\xe5\x9b\xbd's1 = '中国'b1 = s1.encode('gbk') # 转化成gbk的bytes类型print(s1) # 中国print(b1) # b'\xd6\xd0\xb9\xfa'# 通过解码将bytes还原为对应字符串# decode称作解码, 将 bytes 转化成 str类型b1 = b'\xe4\xb8\xad\xe5\x9b\xbd's1 = b1.decode('utf-8')print(s1) # 中国 不同编码间转换本质为不同编码形成的bytes，故以str为中介 示例：将gbk转为utf-8 代码块和缓存机制代码块Python程序是由代码块构造的。块是一个python程序的文本，他是作为一个单元执行的。 代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。 而作为交互方式输入的每个命令都是一个代码块 代码块的缓存机制 前提条件：在同一个代码块内。 机制内容：Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用。换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这个值。所以在你给出的例子中，文件执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足缓存机制则他们在内存中只存在一个，即：id相同。 适用对象： int（float），str，bool。 变量之间相互赋值时都是直接指向了这些对象，而不是相互指向 对象的具体细则：（了解） int(float):任何数字在同一代码块下都会复用。 bool:True和False在字典中会以1，0方式存在，并且复用。 str：几乎所有的字符串都会符合缓存机制，具体规定如下（了解即可！）： 1，非乘法得到的字符串都满足代码块的缓存机制： 2,乘法得到的字符串分两种情况： 2.1 乘数为1时，任何字符串满足代码块的缓存机制： 2.2 乘数&gt;=2时：仅含大小写字母，数字，下划线，总长度&lt;=20，满足代码块的缓存机制： 优点 能够提高一些字符串，整数处理人物在时间和空间上的性能；需要值相同的字符串，整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。 小数据池小数据池，不同代码块的缓存机制，也称为小整数缓存机制，或者称为驻留机制等等， 前提条件在不同代码块内。 *机制内容*Python自动将-5~256的整数进行了缓存，当你将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。 python会将一定规则的字符串在字符串驻留池中，创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。 其实，无论是缓存还是字符串驻留池，都是python做的一个优化，就是将~5-256的整数，和一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中那些变量指向这些范围内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存中之创建一个。 适用对象 int（float），str，bool \对象的具体细则：（了解即可）**int：那么大家都知道对于整数来说，小数据池的范围是-5~256 ，如果多个变量都是指向同一个（在这个范围内的）数字，他们在内存中指向的都是一个内存地址。 str:字符串要从下面这几个大方向讨论（了解即可！）： 1,字符串的长度为0或者1，默认都采用了驻留机制（小数据池）。 2,字符串的长度&gt;1,且只含有大小写字母，数字，下划线时，才会默认驻留。 3,用乘法得到的字符串，分两种情况。 3.1 乘数为1时： 仅含大小写字母，数字，下划线，默认驻留。 含其他字符，长度&lt;=1,默认驻留。 含其他字符，长度&gt;1,默认驻留。 3.2 乘数&gt;=2时： 仅含大小写字母，数字，下划线，总长度&lt;=20,默认驻留。 4，指定驻留。 12345from sys import interna = intern('hello!@'*20)b = intern('hello!@'*20)print(a is b)# 指定驻留是你可以指定任意的字符串加入到小数据池中，让其只在内存中创建一个对象，多个变量都是指向这一个字符串 bool：值就是True，False，无论你创建多少个变量指向True，False，那么他在内存中只存在一个。 效率显而易见，节省大量内存在字符串比较时，非驻留比较效率o(n)，驻留时比较效率o(1) 深浅copy浅copy对于浅copy来说，只是在内存中重新创建了开辟了一个空间存放一个新列表，但是新列表中的元素与原列表中的元素是公用的 12345678910111213141516#同一代码块下：l1 = [1, '太白', True, (1,2,3), [22, 33]]l2 = l1.copy()print(id(l1), id(l2)) # 2713214468360 2713214524680print(id(l1[-2]), id(l2[-2])) # 2547618888008 2547618888008print(id(l1[-1]),id(l2[-1])) # 2547620322952 2547620322952# 不同代码块下：&gt;&gt;&gt; l1 = [1, '太白', True, (1, 2, 3), [22, 33]]&gt;&gt;&gt; l2 = l1.copy()&gt;&gt;&gt; print(id(l1), id(l2))1477183162696&gt;&gt;&gt; print(id(l1[-2]), id(l2[-2]))1477181814032&gt;&gt;&gt; print(id(l1[-1]), id(l2[-1]))1477183162504 深copy对于深copy来说，列表是在内存中重新创建的，列表中可变的数据类型是重新创建的，列表中的不可变的数据类型是公用的 切片相当于浅copy 123456789101112131415161718192021# 同一代码块下import copyl1 = [1, 'alex', True, (1,2,3), [22, 33]]l2 = copy.deepcopy(l1)print(id(l1), id(l2)) # 2788324482440 2788324483016print(id(l1[0]),id(l2[0])) # 1470562768 1470562768print(id(l1[-1]),id(l2[-1])) # 2788324482632 2788324482696print(id(l1[-2]),id(l2[-2])) # 2788323047752 2788323047752# 不同代码块下&gt;&gt;&gt; import copy&gt;&gt;&gt; l1 = [1, '太白', True, (1, 2, 3), [22, 33]]&gt;&gt;&gt; l2 = copy.deepcopy(l1)&gt;&gt;&gt; print(id(l1), id(l2))1477183162632&gt;&gt;&gt; print(id(0), id(0))1470562736&gt;&gt;&gt; print(id(-2), id(-2))1470562672&gt;&gt;&gt; print(id(l1[-1]), id(l2[-1]))1477183162312 文件操作概念计算机系统分为：计算机硬件，操作系统，应用程序三部分。 我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。 有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程 文件操作的内容流程 12345678#1. 打开文件，得到文件句柄并赋值给一个变量f=open('a.txt','r',encoding='utf-8') #默认打开模式就为r#2. 通过句柄对文件进行操作data=f.read()#3. 关闭文件f.close() 常出的错路径问题 这个是没有找到该文件，很可能是你的文件路径错了 你的的路径里面的\与后面的字符产生了特殊意义类似于\t，\n，换行符一样 C:\Users\金鑫\Desktop\111.txt’ 凡是路径会产生特殊意义的地方，多加一个\ 这样就是前面\对后面的\进行转译，告诉计算机这个只是想单纯的表示\路径而已。即用\\代替\ r’C:\Users\金鑫\Desktop\111.txt’ 在路径的整体前面加一个r。（推荐） 相对路径与绝对路径： 绝对路径:从磁盘根目录开始一直到文件名 相对路径:用一个文件夹下的文件,相对于当前这个程序所在的文件而言.如果在同一个文件中,则相对路劲就是这个文件名.如果再上一层文件夹则要使用../相对路径下，你就可以直接写文件名即可。 编码问题 用了错误的编码来打开文件 读r模式以只读方式打开文件，文件的指针将会放在文件的开头。是文件操作最常用的模式，也是默认模式 rb模式以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。记住下面讲的也是一样，带b的都是以二进制的格式操作文件，他们主要是操作非文字文件：图片，音频，视频等,并且如果你要是带有b的模式操作文件，那么不用声明编码方式 写w模式 如果文件不存在，利用w模式操作文件，那么它会先创建文件，然后写入内容. 如果文件存在，利用w模式操作文件，先清空原文件内容，在写入新内容。 wb模式wb模式：以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如：图片，音频，视频等。 12345678# 先以rb的模式将一个图片的内容以bytes类型全部读取出来，# 然后在以wb将全部读取出来的数据写入一个新文件，这样就完成了类似于一个图片复制的流程f = open("a.jpg",mode = "rb")content = f.read()f.close()f1 = open("b.jpg", mode = "wb")f1.write(content)f1.close 追加a模式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 小结各种模式12345678910111213141516171819202122# 1. 打开文件的模式有(默认为文本模式)：r，只读模式【默认模式，文件必须存在，不存在则抛出异常】w，只写模式【不可读；不存在则创建；存在则清空内容】a， 只追加写模式【不可读；不存在则创建；存在则只追加内容】# 2. 对于非文本文件，我们只能使用b模式，"b"表示以字节的方式操作#（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、# 图片文件的jgp格式、视频文件的avi格式）rb wbab注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码# 3,‘+’模式（就是增加了一个功能）r+， 读写【可读，可写】w+，写读【可写，可读】a+， 写读【可写，可读】# 4，以bytes类型操作的读写，写读，写读模式r+b， 读写【可读，可写】w+b，写读【可写，可读】a+b， 写读【可写，可读】 注意：如果你在读写模式下，先写后读，那么文件就会出问题，因为默认光标是在文件的最开始，你要是先写，则写入的内容会讲原内容覆盖掉，直到覆盖到你写完的内容，然后在后面开始读取。 常用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# f.read()一次性读取所有内容f = open('path1/小娃娃.txt',mode='r',encoding='utf-8')msg = f.read()f.close()# f.read(n) 以字符为单位，读取n个字符 光标亦随之移动了n个字符 # 1. 文件打开方式为文本模式时，代表读取n个字符 # 2. 文件打开方式为b模式时，代表读取n个字节f = open('path1/小娃娃.txt',mode='r',encoding='utf-8')msg = f.read(3)msg1 = f.read()f.close()# readline()读取每次只读取一行,注意点:readline()读取出来的数据在后面都有一个\n，# 加上print本身自动换行所以一般会加stripf = open('path1/小娃娃.txt',mode='r',encoding='utf-8')msg1 = f.readline().strip()msg2 = f.readline().strip()msg3 = f.readline().strip()msg4 = f.readline().strip()f.close()# readlines() 返回一个列表，列表里面每个元素是原文件的每一行，如果文件很大，占内存，容易崩盘# 可以通过for循环去读取，文件句柄是一个迭代器，他的特点就是每次循环只在内存中占一行的数据，非常节省内存f = open('../path1/弟子规',mode='r',encoding='utf-8')for line in f: print(line) #这种方式就是在一行一行的进行读取,它就执行了下边的功能print(f.readline())print(f.readline())print(f.readline())print(f.readline())f.close()#注意:读完的文件句柄一定要关闭# seek(n)光标移动到n位置,注意: 移动单位是byte,所有如果是utf-8的中文部分要是3的倍数# 通常我们使用seek都是移动到开头或者结尾# 移动到开头:seek(0)# 移动到结尾:seek(0,2) # seek的第二个参数表示的是从哪个位置进行偏移,默认是0,表示开头,1表示当前位置,2表示结尾f = open("小娃娃", mode="r+", encoding="utf-8")f.seek(0) # 光标移动到开头content = f.read() # 读取内容, 此时光标移动到结尾print(content)f.seek(0) # 再次将光标移动到开头f.seek(0, 2) # 将光标移动到结尾content2 = f.read() # 读取内容. 什么都没有print(content2)f.seek(0) # 移动到开头f.write("张国荣") # 写入信息. 此时光标在9 中文3 * 3个 = 9f.flush()f.close()# 使用tell()可以帮我们获取当前光标在什么位置# readable(),writeable()f = open('Test',encoding='utf-8',mode='r')print(f.readable()) # Trueprint(f.writable()) # Falsecontent = f.read()f.close()# flush() 刷新文件内部缓冲区 另一种打开方式123456789# 1,利用with上下文管理这种方式，它会自动在一段时间后哦关闭文件句柄。with open('t1',encoding='utf-8') as f1: f1.read() # 2，一个with 语句可以操作多个文件，产生多个文件句柄。with open('t1',encoding='utf-8') as f1,\ open('Test', encoding='utf-8', mode = 'w') as f2: f1.read() f2.write('老男孩老男孩') 文件修改文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，我们平时看到的修改文件，都是模拟出来的效果 具体的说有两种实现方式： 方式一：将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘（word，vim，nodpad++等编辑器） 12345678910import os # 调用系统模块with open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: data=read_f.read() #全部读入内存,如果文件很大,会很卡 data=data.replace('alex','SB') #在内存中完成修改 write_f.write(data) #一次性写入新文件os.remove('a.txt') #删除原文件os.rename('.a.txt.swap','a.txt') #将新建的文件重命名为原文件 方式二：将硬盘存放的该文件的内容一行一行地读入内存，修改完毕就写入新文件，最后用新文件覆盖源文件 (当文件过大无法全部加载入内存中时用此法) 123456789import oswith open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: for line in read_f: line=line.replace('alex','SB') write_f.write(line)os.remove('a.txt')os.rename('.a.txt.swap','a.txt') 函数 1，对一些功能就行封装，减少代码的重复性。 2，使代码可读性更好 函数结构12def 函数名(): 函数体 def 关键词开头，空格之后接函数名称和圆括号()，最后还有一个”:”。 def 是固定的，不能变，他就是定义函数的关键字。 空格 为了将def关键字和函数名分开 函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并且要具有可描述性 括号：是必须加的，用于写形参 下面的函数体一定全部都要缩进，这代表是这个函数的代码 函数调用使用函数名加小括号就可以调用了 写法:函数名() 这个时候函数的函数体会被执行 返回值1.遇到return,函数结束,return下面的（函数内）的代码不会执行。 2.return 会给函数的执行者返回值。 ​ 如果return后面什么都不写，或者函数中没有return,则返回的结果是None ​ 如果return后面写了一个值,返回给调用者这个值 ​ 如果return后面写了多个结果,,返回给调用者一个tuple(元组),调用者可以直接使用元组的解构获取多个变量。 参数将函数盘活，使函数能应对更多情况 形参写在函数声明的位置的变量叫形参,形式上的一个完整.表示这个函数需要xxx 位置参数，args，默认参数，仅限关键字参数，**kwargs 实参在函数调用的时候给函数传递的值 函数的传参就是函数将实际参数交给形式参数的过程. 按需传入 动态参数动态接收位置参数：*args*args实参所有的位置参数接收，放置在一个元组中，并将这个元组赋值给args这个形参，PEP8规范中规定就使用args，约定俗成的 动态接收关键字参数: kwargs**kwargs接受所有的关键字参数然后将其转换成一个字典赋值给kwargs这个形参 1234def func(*args,**kwargs): print(args) # ('蒸羊羔儿', '蒸熊掌', '蒸鹿尾儿') print(kwargs) # &#123;'name': '太白金星', 'sex': '男'&#125;func('蒸羊羔儿', '蒸熊掌', '蒸鹿尾儿',name='太白金星',sex='男') *的用法函数中 聚合 在函数的定义时： *起到的是聚合的作用，将多个参数聚合为一个元组(字典) 打散 出一个小题：你如何将三个数据（这三个数据都是可迭代对象类型的每一元素传给动态参数*args？ 123456s1 = 'alex'l1 = [1, 2, 3, 4]tu1 = ('武sir', '太白', '女神',)def func(*args): print(args) # ('alex', [1, 2, 3, 4], ('武sir', '太白', '女神'))func(s1,l1,tu1) 这样肯定是不行，他会将这个三个数据类型当成三个位置参数传给args，没有实现我的要求。 123456s1 = 'alex'l1 = [1, 2, 3, 4]tu1 = ('武sir', '太白', '女神',)def func(*args): print(args) # ('a', 'l', 'e', 'x', 1, 2, 3, 4, '武sir', '太白', '女神')func(*s1,*l1,*tu1) 将位置参数的实参（可迭代类型）前面加上，相当于将这些实参给拆解成一个一个的组成元素当成位置参数，然后传给args，所以在函数的执行时：\，**起到的是打散的作用。 12345dic1 = &#123;'name': '太白', 'age': 18&#125;dic2 = &#123;'hobby': '喝茶', 'sex': '男'&#125;def func(**kwargs): print(kwargs) # &#123;'name': '太白', 'age': 18, 'hobby': '喝茶', 'sex': '男'&#125;func(**dic1,**dic2) 函数外接收时聚合，传值时打散 123456789# 之前讲过的分别赋值a,b = (1,2)print(a, b) # 1 2# 其实还可以这么用：a,*b = (1, 2, 3, 4,)print(a, b) # 1 [2, 3, 4]*rest,a,b = range(5)print(rest, a, b) # [0, 1, 2] 3 4print([1, 2, *[3, 4, 5]]) # [1, 2, 3, 4, 5] 仅限关键字参数他的位置要放在args后面，*kwargs前面（如果有**kwargs），也就是默认参数的位置，它与默认参数的前后顺序无所谓，它只接受关键字传的参数 123456789101112def func(a,b,*args,c):print(a,b) # 1 2print(args) # (4, 5)# 这样传参是错误的，因为仅限关键字参数c只接受关键字参数# func(1, 2, 3, 4, 5)def func(a,b,*args,c):print(a,b) # 1 2print(args) # (3, 4)print(5)# 这样就正确了：func(1, 2, 3, 4, c=5) 这个仅限关键字参数从名字定义就可以看出他只能通过关键字参数传参，其实可以把它当成不设置默认值的默认参数而且必须要传参数，不传就报错。 命名空间内置命名空间–&gt; 存放python解释器为我们提供的名字, list, tuple, str, int这些都是内置命名空间 全局命名空间–&gt; 我们直接在py文件中, 函数外声明的变量都属于全局命名空间 局部命名空间–&gt; 在函数中声明的变量会放在局部命名空间 作用域全局作用域: 包含内置命名空间和全局命名空间. 在整个文件的任何位置都可以使用(遵循 从上到下逐⾏执行). 局部作用域: 在函数内部可以使用. 两个内置函数globals(): 以字典的形式返回全局作用域所有的变量对应关系。 locals(): 以字典的形式返回当前作用域的变量的对应关系。 12345678910111213141516171819202122# 在全局作用域下打印，则他们获取的都是全局作用域的所有的内容。a = 2b = 3print(globals())print(locals())'''&#123;'__name__': '__main__', '__doc__': None, '__package__': None,'__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001806E50C0B8&gt;, '__spec__': None, '__annotations__': &#123;&#125;,'__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'D:/lnh.python/py project/teaching_show/day09~day15/function.py','__cached__': None, 'a': 2, 'b': 3&#125;'''# 在局部作用域中打印。a = 2b = 3def foo(): c = 3 print(globals()) # 和上面一样，还是全局作用域的内容 print(locals()) # &#123;'c': 3&#125;foo() 高阶函数(函数嵌套)12345678910111213141516171819202122232425262728293031323334# 例1：def func1(): print('in func1') print(3)def func2(): print('in func2') print(4)func1()print(1)func2()print(2)# 例2：def func1(): print('in func1') print(3)def func2(): print('in func2') func1() print(4)print(1)func2()print(2)# 例3：def fun2(): print(2) def fun3(): print(6) print(4) fun3() print(8)print(3)fun2()print(5) globalglobal关键字有两个作用： 1，声明一个全局变量。 2，在局部作用域想要对全局作用域的全局变量进行修改时，需要用到 global(限于字符串，数字) nonlocalnonlocal的总结： 1，不能更改全局变量。 2，在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变 函数名函数名指向的是这个函数的内存地址，其实深一步理解可得知，与其说函数名()可以执行这个函数，不如说是函数的内存地址()才是执行这个函数的关键 函数名可以赋值给其他变量 函数名可以当做容器类的元素 1234567891011def func1(): print("in func1: 嘻嘻")def func2(): print("in func2: 哈哈")def func3(): print("in func3: 咯咯")def func4(): print("in func4: 吱吱")lst = [func1, func2, func3, func4]for i in lst: i() 函数名可以当做函数的参数 12345678def func1(): print('in func1')def func2(f): print('in func2') f()func2(func1) 函数名可以当做函数的返回值 123456789def func1(): print('in func1')def func2(f): print('in func2') return fret = func2(func1)ret() # ret, f, func1 都是指向的func1这个函数的内存地址 函数名是一个特殊的变量，他除了具有变量的功能，还有最主要一个特点就是加上() 就执行，其实他还有一个学名叫第一类对象 迭代器可迭代对象 从字面意思来说：可迭代对象就是一个可以重复取值的实实在在的东西。 从专业角度来说：但凡内部含有iter方法的对象，都是可迭代对象。 可迭代对象可以通过判断该对象是否有’iter’方法来判断。 优缺点 可迭代对象的优点： 可以直观的查看里面的数据。 可迭代对象的缺点： 占用内存。 可迭代对象不能迭代取值（除去索引，key以外 即使抛去索引,key以外，这些我可以通过for循环进行取值呀！对，他们都可以通过for循环进行取值，其实for循环在底层做了一个转化，就是先将可迭代对象转化成迭代器，然后在进行取值的 判断dir()会返回一个列表，这个列表中含有该对象的以字符串的形式所有方法名。这样我们就可以判断python中的一个对象是不是可迭代对象了： 1234s1 = 'alex'i = 100print('__iter__' in dir(i)) # Falseprint('__iter__' in dir(s1)) # True 迭代器 从字面意思来说迭代器，是一个可以迭代取值的工具，器：在这里当做工具比较合适。 从专业角度来说：迭代器是这样的对象：实现了无参数的next方法，返回序列中的下一个元素，如果没有元素了，那么抛出StopIteration异常.python中的迭代器还实现了iter方法，因此迭代器也可以迭代。 出自《流畅的python》 简单来说：在python中，内部含有’Iter‘方法并且含有’next‘方法的对象就是迭代器。 判断1234567891011121314151617181920o1 = 'alex'o2 = [1, 2, 3]o3 = (1, 2, 3)o4 = &#123;'name': '太白','age': 18&#125;o5 = &#123;1, 2, 3&#125;f = open('file',encoding='utf-8', mode='w')print('__iter__' in dir(o1)) # Trueprint('__iter__' in dir(o2)) # Trueprint('__iter__' in dir(o3)) # Trueprint('__iter__' in dir(o4)) # Trueprint('__iter__' in dir(o5)) # Trueprint('__iter__' in dir(f)) # True# hsagnprint('__next__' in dir(o1)) # Falseprint('__next__' in dir(o2)) # Falseprint('__next__' in dir(o3)) # Falseprint('__next__' in dir(o4)) # Falseprint('__next__' in dir(o5)) # Falseprint('__next__' in dir(f)) # Truef.close() 之前我们学过的这些对象，只有文件句柄是迭代器，剩下的那些数据类型都是可迭代对象。 迭代器取值取值之前仅是保存了那些地址 可迭代对象是不可以一直迭代取值的（除去用索引，切片以及Key），但是转化成迭代器就可以了，迭代器是利用next()进行取值： 12345678910111213l1 = [1, 2, 3,]obj = l1.__iter__() # 或者 iter(l1)# print(obj) # &lt;list_iterator object at 0x000002057FE1A3C8&gt;ret = obj.__next__()print(ret)ret = obj.__next__()print(ret)ret = obj.__next__()print(ret)ret = obj.__next__() # StopIterationprint(ret)# 迭代器利用next取值：一个next取对应的一个值，如果迭代器里面的值取完了，还要next，# 那么就报StopIteration的错误。 while模拟forfor循环的内部机制是：将可迭代对象转换成迭代器，然后利用next进行取值，最后利用异常处理处理StopIteration抛出的异常 12345678910l1 = [1, 2, 3, 4, 5, 6]# 1 将可迭代对象转化成迭代器obj = iter(l1)# 2,利用while循环，next进行取值while 1: # 3,利用异常处理终止循环 try: print(next(obj)) except StopIteration: break 优缺点​ 迭代器的优点： ​ 节省内存。​ 迭代器在内存中相当于只占一个数据的空间：因为每次取值都上一条数据会在内存释放，加载当前的此条数据。 ​ 惰性机制。​ next一次，取一个值，绝不过多取值。​ ​ 迭代器的缺点： ​ 不能直观的查看里面的数据。 ​ 取值时不走回头路，只能一直向下取值。 可迭代对象转化成迭代器1234l1 = [1, 2, 3, 4, 5, 6]obj = l1.__iter__() # 或者 iter(l1)# &lt;list_iterator object at 0x000002057FE1A3C8&gt; 迭代器与可迭代对象对比 可迭代对象： 是一个私有的方法比较多，操作灵活（比如列表，字典的增删改查，字符串的常用操作方法等）,比较直观，但是占用内存，而且不能直接通过循环迭代取值的这么一个数据集。 应用：当你侧重于对于数据可以灵活处理，并且内存空间足够，将数据集设置为可迭代对象是明确的选择。 迭代器： 是一个非常节省内存，可以记录取值位置，可以直接通过循环+next方法取值，但是不直观，操作方法比较单一的数据集。 应用：当你的数据量过大，大到足以撑爆你的内存或者你以节省内存为首选因素时，将数据集设置为迭代器是一个不错的选择。（可参考为什么python把文件句柄设置成迭代器）。 生成器什么是生成器？各种文献都有不同的理解，但是核心基本相同。生成器的本质就是迭代器，在python社区中，大多数时候都把迭代器和生成器是做同一个概念。生成器和迭代器也有不同，唯一的不同就是：迭代器都是Python给你提供的已经写好的工具或者通过数据转化得来的，（比如文件句柄，iter([1,2,3])。生成器是需要我们自己用python代码构建的工具。最大的区别也就如此了 构建方式通过生成器函数 通过生成器推导式 python内置函数或者模块提供 （其实1,3两种本质上差不多，只不过1是自己写的生成器函数，3是python提供的生成器函数而已） 生成器函数1234567def func(): print(11) yield 22ret = func()print(ret)# 运行结果:&lt;generator object func at 0x000001A575163888&gt; 由于函数中存在yield,那么这个函数就是一个生成器函数. 我们在执行这个函数的时候.就不再是函数的执行了.而是获取这个生成器对象，那么生成器对象如何取值呢？ 生成器的本质就是迭代器。所以我们可以直接执行next()来执行以下生成器 123456def func(): print("111") yield 222gener = func() # 这个时候函数不会执⾏. ⽽是获取到⽣成器ret = gener.__next__() # 这个时候函数才会执⾏print(ret) # 并且yield会将func生产出来的数据 222 给了 ret 当程序运行完最后一个yield,那么后面继续运行next()程序会报错，一个yield对应一个next，next超过yield数量，就会报错，与迭代器一样。 yield与return的区别​ return一般在函数中只设置一个，他的作用是终止函数，并且给函数的执行者返回值。 ​ yield在生成器函数中可设置多个，他并不会终止函数，next会获取对应yield生成的元素。 举例： 我们来看一下这个需求：老男孩向楼下卖包子的老板订购了10000个包子.包子铺老板非常实在，一下就全部都做出来了 1234567def eat(): lst = [] for i in range(1,10000): lst.append('包子'+str(i)) return lste = eat()print(e) 这样做没有问题，但是我们由于学生没有那么多，只吃了2000个左右，剩下的8000个，就只能占着一定的空间，放在一边了。如果包子铺老板效率够高，我吃一个包子，你做一个包子，那么这就不会占用太多空间存储了，完美。 123456def eat(): for i in range(1,10000): yield '包子'+str(i)e = eat()for i in range(200): next(e) 这两者的区别: 第一种是直接把包子全部做出来，占用内存。 第二种是吃一个生产一个，非常的节省内存，而且还可以保留上次的位置。 123456789def eat(): for i in range(1,10000): yield '包子'+str(i)e = eat()for i in range(200): next(e) for i in range(300): next(e)# 多次next包子的号码是按照顺序记录的。 yield from可以直接把可迭代对象中的每一个数据作为生成器的结果进行返回 12345678910111213141516171819202122232425# 对比yield 与 yield from def func(): lst = ['卫龙','老冰棍','北冰洋','牛羊配'] yield lstg = func()print(g)print(next(g)) # 只是返回一个列表def func(): lst = ['卫龙','老冰棍','北冰洋','牛羊配'] yield from lstg = func()print(g)# 他会将这个可迭代对象(列表)的每个元素当成迭代器的每个结果进行返回。print(next(g))print(next(g))print(next(g))print(next(g))'''yield from ['卫龙','老冰棍','北冰洋','牛羊配'] 等同于： yield '卫龙' yield '老冰棍' yield '北冰洋' yield '牛羊配'''' 两个yield from不会交替输出，而会先打印完第一个，在打印第二个 123456789def func(): lst1 = ['卫龙','老冰棍','北冰洋','牛羊配'] lst2 = ['馒头','花卷','豆包','大饼'] yield from lst1 yield from lst2 g = func()for i in g: print(i) send方法(补充)send和next()区别: ​ 相同点： ​ send 和 next()都可以让生成器对应的yield向下执行一次。 ​ 都可以获取到yield生成的值。 ​ 不同点： ​ 第一次获取yield值只能用next不能用send（可以用send(None)）。 ​ send可以给上一个yield置传递值 1234567891011121314151617181920212223242526272829303132# next只能获取yield生成的值，但是不能传递值。def gen(name): print(f'&#123;name&#125; ready to eat') while 1: food = yield print(f'&#123;name&#125; start to eat &#123;food&#125;')dog = gen('alex')next(dog)next(dog)next(dog)# 而使用send这个方法是可以的。def gen(name): print(f'&#123;name&#125; ready to eat') while 1: food = yield 222 print(f'&#123;name&#125; start to eat &#123;food&#125;')dog = gen('alex')next(dog) # 第一次必须用next让指针停留在第一个yield后面# 与next一样，可以获取到yield的值ret = dog.send('骨头')print(ret)def gen(name): print(f'&#123;name&#125; ready to eat') while 1: food = yield print(f'&#123;name&#125; start to eat &#123;food&#125;')dog = gen('alex')next(dog)# 还可以给上一个yield发送值dog.send('骨头')dog.send('狗粮')dog.send('香肠') 生成器表达式形式上仅是将列表生成式的[]改为() 生成器表达式和列表推导式的区别: 列表推导式比较耗内存,所有数据一次性加载到内存。而.生成器表达式遵循迭代器协议，逐个产生元素。 得到的值不一样,列表推导式得到的是一个列表.生成器表达式获取的是一个生成器 列表推导式一目了然，生成器表达式只是一个内存地址 123gen = (i for i in range(1,100) if i % 3 == 0)for num in gen: print(num) 内置函数思维导图 函数就是以功能为导向，一个函数封装一个功能，那么Python将一些常用的功能（比如len）给我们封装成了一个一个的函数，供我们使用，他们不仅效率高（底层都是用C语言写的），而且是拿来即用，避免重复早轮子，那么这些函数就称为内置函数，到目前为止python给我们提供的内置函数一共是68个 了解all：可迭代对象中，全都是True才是True any：可迭代对象中，有一个True 就是True 1234# all 可迭代对象中，全都是True才是True# any 可迭代对象中，有一个True 就是Trueprint(all([1,2,True,0]))print(any([1,'',0])) bytes：用于不同编码之间的转化。 12345678910s = '你好'bs = s.encode('utf-8')print(bs)s1 = bs.decode('utf-8')print(s1)bs = bytes(s,encoding='utf-8')print(bs)b = '你好'.encode('gbk')b1 = b.decode('gbk')print(b1.encode('utf-8')) ord:输入字符找该字符编码的位置 chr:输入位置数字找出其对应的字符 1234567# ord 输入字符找该字符编码的位置print(ord('a'))print(ord('中'))# chr 输入位置数字找出其对应的字符print(chr(97))print(chr(20013)) repr:返回一个对象的string形式（原形毕露）。 1234567# %r 原封不动的写出来name = 'taibai'print('我叫%r'%name)# repr 原形毕露print(repr('&#123;"name":"alex"&#125;'))print('&#123;"name":"alex"&#125;') eval：执行字符串类型的代码，并返回最终结果。 exec:执行字符串类型的代码。 用于网络上数据处理时易出现安全分险 1234eval('2 + 2') # 4n=81eval("n + 4") # 85eval('print(666)') # 666 12345s = '''for i in [1,2,3]: print(i)'''exec(s) hash：获取一个对象（可哈希对象：int，str，Bool，tuple）的哈希值。 1234567891011121314print(hash(12322))print(hash('123'))print(hash('arg'))print(hash('alex'))print(hash(True))print(hash(False))print(hash((1,2,3)))'''-2996001552409009098-463751598188813973912528502973977326415''' help：函数用于查看函数或模块用途的详细说明。 12print(help(list))print(help(str.split)) callable：函数用于检查一个对象是否是可调用的。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。 12345name = 'alex'def func(): passprint(callable(name)) # Falseprint(callable(func)) # True int：函数用于将一个字符串或数字(取整)转换为整型。 1234print(int()) # 0print(int('12')) # 12print(int(3.6)) # 3print(int('0100',base=2)) # 将2进制的 0100 转化成十进制。结果为 4 float：函数用于将整数和字符串转换成浮点数。 complex：函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。。 12print(float(3)) # 3.0print(complex(1,2)) # (1+2j) bin：将十进制转换成二进制并返回。 oct：将十进制转化成八进制字符串并返回。 hex：将十进制转化成十六进制字符串并返回。 123print(bin(10),type(bin(10))) # 0b1010 &lt;class 'str'&gt;print(oct(10),type(oct(10))) # 0o12 &lt;class 'str'&gt;print(hex(10),type(hex(10))) # 0xa &lt;class 'str'&gt; divmod：计算除数与被除数的结果，返回一个包含商和余数的元组(a // b, a % b)。 round：保留浮点数的小数位数，默认保留整数。 pow：求xy次幂。（三个参数为xy的结果对z取余） 123456print(divmod(7,2)) # (3, 1)print(round(7/3,2)) # 2.33print(round(7/3)) # 2print(round(3.32567,3)) # 3.326print(pow(2,3)) # 两个参数为2**3次幂print(pow(2,3,3)) # 三个参数为2**3次幂，对3取余。 重点print() 屏幕输出。 123456789101112131415161718''' 源码分析def print(self, *args, sep=' ', end='\n', file=None): # known special case of print """ print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False) file: 默认是输出到屏幕，如果设置为文件句柄，输出到文件 sep: 打印多个值之间的分隔符，默认为空格 end: 每一次打印的结尾，默认为换行符 flush: 立即把内容输出到流文件，不作缓存 """'''print(111,222,333,sep='*') # 111*222*333print(111,end='')print(222) #两行的结果 111222f = open('log','w',encoding='utf-8')print('写入文件',fle=f,flush=True) int():pass str():pass bool():pass set(): pass list() 将一个可迭代对象转换成列表 tuple() 将一个可迭代对象转换成元组 dict() 通过相应的方式创建字典。 12345listl1 = list('abcd')print(l1) # ['a', 'b', 'c', 'd']tu1 = tuple('abcd')print(tu1) # ('a', 'b', 'c', 'd') abs() 返回绝对值 12i = -5print(abs(i)) # 5 sum() 求和 12print(sum([1,2,3]))print(sum((1,2,3),100)) min() 求最小值 123456789print(min([1,2,3])) # 返回此序列最小值ret = min([1,2,-5,],key=abs) # 按照绝对值的大小，返回此序列最小值print(ret)# 加key是可以加函数名，min自动会获取传入函数中的参数的每个元素，然后通过你设定的返回值比较大小，# 返回最小的传入的那个参数。print(min(1,2,-5,6,-3,key=lambda x:abs(x))) # 可以设置很多参数比较大小dic = &#123;'a':3,'b':2,'c':1&#125;print(min(dic,key=lambda x:dic[x]))# x为dic的key，lambda的返回值（即dic的值进行比较）返回最小的值对应的键 max() 最大值与最小值用法相同。 reversed() 将一个序列翻转, 返回翻转序列的迭代器 1234l = reversed('你好') # l 获取到的是一个生成器print(list(l))ret = reversed([1, 4, 3, 7, 9])print(list(ret)) # [9, 7, 3, 4, 1] bytes() 把字符串转换成bytes类型 1234567891011121314s = '你好太白'bs = s.encode('utf-8')print(bs)# 结果:b'\xe4\xbd\xa0\xe5\xa5\xbd\xe6\xad\xa6\xe5\xa4\xa7's1 = bs.decode('utf-8')print(s1)# 结果: 你好太白s = '你好'bs = bytes(s,encoding='utf-8')print(bs)# 将字符串转换成字节bs1 = str(bs,encoding='utf-8')print(bs1)# 将字节转换成字符串 zip() 拉链方法。函数用于将可迭代的对象作为参数,将对象中对应的元素打包成一个个元组, 然后返回由这些元祖组成的内容,如果各个迭代器的元素个数不一致,则按照长度最短的返回， 123456789lst1 = [1,2,3]lst2 = ['a','b','c','d']lst3 = (11,12,13,14,15)for i in zip(lst1,lst2,lst3): print(i)结果:(1, 'a', 11)(2, 'b', 12)(3, 'c', 13) sorted排序函数 123456789101112131415161718192021222324252627282930313233343536373839404142# 语法:sorted(iterable,key=None,reverse=False)# iterable : 可迭代对象# key: 排序规则(排序函数),在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数.# 根据函数运算的结果进行排序# reverse :是否是倒叙,True 倒叙 False 正序lst = [1,3,2,5,4]lst2 = sorted(lst)print(lst) #原列表不会改变print(lst2) #返回的新列表是经过排序的 lst3 = sorted(lst,reverse=True)print(lst3) #倒叙 # 结果:[1, 3, 2, 5, 4][1, 2, 3, 4, 5][5, 4, 3, 2, 1]# 字典使用sorted排序dic = &#123;1:'a',3:'c',2:'b'&#125;print(sorted(dic)) # 字典排序返回的就是排序后的key # 结果:[1,2,3]# 和函数组合使用# 定义一个列表,然后根据一元素的长度排序lst = ['天龙八部','西游记','红楼梦','三国演义'] # 计算字符串的长度def func(s): return len(s)print(sorted(lst,key=func)) # 结果:# ['西游记', '红楼梦', '天龙八部', '三国演义']和lambda组合使用lst = ['天龙八部','西游记','红楼梦','三国演义'] print(sorted(lst,key=lambda s:len(s))) 结果:['西游记', '红楼梦', '天龙八部', '三国演义'] lst = [&#123;'id':1,'name':'alex','age':18&#125;, &#123;'id':2,'name':'wusir','age':17&#125;, &#123;'id':3,'name':'taibai','age':16&#125;,] # 按照年龄对学生信息进行排序 print(sorted(lst,key=lambda e:e['age'])) 结果:[&#123;'id': 3, 'name': 'taibai', 'age': 16&#125;, \ &#123;'id': 2, 'name': 'wusir', 'age': 17&#125;, &#123;'id': 1, 'name': 'alex', 'age': 18&#125;] filter筛选过滤 类似于各种推导式 123456789101112# 语法: filter(function,iterable)# function: 用来筛选的函数,在filter中会自动的把iterable中的元素传递给function,# 然后根据function返回的True或者False来判断是否保留此项数据iterable:可迭代对象lst = [&#123;'id':1,'name':'alex','age':18&#125;, &#123;'id':1,'name':'wusir','age':17&#125;, &#123;'id':1,'name':'taibai','age':16&#125;,] ls = filter(lambda e:e['age'] &gt; 16,lst) print(list(ls)) # 结果:[&#123;'id': 1, 'name': 'alex', 'age': 18&#125;, &#123;'id': 1, 'name': 'wusir', 'age': 17&#125;] map 123456789101112131415161718# 映射函数# 语法: map(function,iterable) 可以对可迭代对象中的每一个元素进映射,分别取执行function,返回一个迭代器# 计算列表中每个元素的平方,返回新列表lst = [1,2,3,4,5]def func(s): return s*smp = map(func,lst)print(mp)print(list(mp))# 改写成lambdalst = [1,2,3,4,5]print(list(map(lambda s:s*s,lst)))# 计算两个列表中相同位置的数据的和lst1 = [1, 2, 3, 4, 5]lst2 = [2, 4, 6, 8, 10]print(list(map(lambda x, y: x+y, lst1, lst2)))# 结果:[3, 6, 9, 12, 15] reduce 123456789101112131415161718192021222324from functools import reducedef func(x,y): return x + y# reduce 的使用方式:# reduce(函数名,可迭代对象) # 这两个参数必须都要有,缺一个不行ret = reduce(func,[3,4,5,6,7])print(ret) # 结果 25# reduce的作用是先把列表中的前俩个元素取出计算出一个值然后临时保存着,# 接下来用这个临时保存的值和列表中第三个元素进行计算,求出一个新的值将最开始# 临时保存的值覆盖掉,然后在用这个新的临时值和列表中第四个元素计算.依次类推# 注意:我们放进去的可迭代对象没有更改# 以上这个例子我们使用sum就可以完全的实现了.我现在有[1,2,3,4]想让列表中的数变成1234,就要用到reduce了.# 普通函数版from functools import reducedef func(x,y): return x * 10 + yl = reduce(func,[1,2,3,4])print(l)# 匿名函数版l = reduce(lambda x,y:x*10+y,[1,2,3,4])print(l)# 在Python2.x版本中recude是直接 import就可以的, Python3.x版本中需要从functools这个包中导入# 龟叔本打算将 lambda 和 reduce 都从全局名字空间都移除, 舆论说龟叔不喜欢lambda 和 reduce# 最后lambda没删除是因为和一个人写信写了好多封,进行交流然后把lambda保住了. 匿名函数匿名函数 lambda，顾名思义就是没有名字的函数，也叫一句话函数。 语法 函数名 = lambda 参数:返回值(对参数的简单处理) 1）此函数不是没有名字，他是有名字的，他的名字就是你给其设置的变量，比如func. 2）lambda 是定义匿名函数的关键字，相当于函数的def. 3）lambda 后面直接加形参，形参加多少都可以，只要用逗号隔开就行。 123func = lambda a,b,*args,sex= 'alex',c,**kwargs: kwargsprint(func(3, 4,c=666,name='alex')) # &#123;'name': 'alex'&#125;# 所有类型的形参都可以加，但是一般使用匿名函数只是加位置参数，其他的用不到。 4）返回值在冒号之后设置，返回值和正常的函数一样,可以是任意数据类型。 5）匿名函数不管多复杂.只能写一行.且逻辑结束后直接返回数据 小题写匿名函数：接收一个可切片的数据，返回索引为0与2的对应的元素（元组形式）。 12func = lambda x:(x[0],x[2])print(func(&apos;afafasd&apos;)) 写匿名函数：接收两个int参数，将较大的数据返回。 12func = lambda x,y: x if x &gt; y else yprint(func(3,100)) 闭包1234567891011121314def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averageravg = make_averager()print(avg(100000))print(avg(110000))print(avg(120000)) 大家仔细看一下这个代码，我是在函数中嵌套了一个函数。那么avg 这个变量接收的实际是averager函数名，也就是其对应的内存地址，我执行了三次avg 也就是执行了三次averager这个函数。那么此时你们有什么问题？ 肯定有学生就会问，那么我的make_averager这个函数只是执行了一次，为什么series这个列表没有消失？反而还可以被调用三次呢？这个就是最关键的地方，也是闭包的精华所在。我给大家说一下这个原理，以图为证： 上面被红色方框框起来的区域就是闭包，被蓝色圈起来的那个变量应该是make_averager()函数的局部变量，它应该是随着make_averager()函数的执行结束之后而消失。但是他没有，是因为此区域形成了闭包，series变量就变成了一个叫自由变量的东西，averager函数的作用域会延伸到包含自由变量series的绑定。也就是说，每次我调用avg对应的averager函数 时，都可以引用到这个自用变量series，这个就是闭包。 闭包的定义： 闭包是嵌套在函数中的函数。 闭包必须是内层函数对外层函数的变量（非全局变量）的引用。 判断123456789101112131415161718192021222324252627# 例一：def wrapper(): a = 1 def inner(): print(a) return innerret = wrapper()# 例二：a = 2def wrapper(): def inner(): print(a) return innerret = wrapper()# 例三：def wrapper(a,b): def inner(): print(a) print(b) return innera = 2b = 3ret = wrapper(a,b) 以上三个例子，最难判断的是第三个，其实第三个也是闭包，如果我们每次去研究代码判断其是不是闭包，有一些不科学，或者过于麻烦了，那么有一些函数的属性是可以获取到此函数是否拥有自由变量的，如果此函数拥有自由变量，那么就可以侧面证明其是否是闭包函数了（了解）： 12345678910111213141516171819202122def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averageravg = make_averager()# 函数名.__code__.co_freevars 查看函数的自由变量print(avg.__code__.co_freevars) # ('series',)当然还有一些参数，仅供了解：# 函数名.__code__.co_freevars 查看函数的自由变量print(avg.__code__.co_freevars) # ('series',)# 函数名.__code__.co_varnames 查看函数的局部变量print(avg.__code__.co_varnames) # ('new_value', 'total')# 函数名.__closure__ 获取具体的自由变量对象，也就是cell对象。# (&lt;cell at 0x0000020070CB7618: int object at 0x000000005CA08090&gt;,)# cell_contents 自由变量具体的值print(avg.__closure__[0].cell_contents) # [] 作用保存局部信息不被销毁，保证数据的安全性。 应用 可以保存一些非全局变量但是不易被销毁、改变的数据。 装饰器 装饰器开发封闭原则 1.对扩展是开放的 ​ 我们说，任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。 2.对修改是封闭的 ​ 就像我们刚刚提到的，因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对函数内部进行修改，或者修改了函数的调用方式，很有可能影响其他已经在使用该函数的用户。OK，理解了开封封闭原则之后，我们聊聊装饰器。 所以装饰器最终最完美的定义就是：在不改变原被装饰的函数的源代码以及调用方式下，为其添加额外的功能。]]></content>
      <tags>
        <tag>python</tag>
        <tag>老男孩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests]]></title>
    <url>%2F2020%2F02%2F01%2Fpython%2Frequests%2F</url>
    <content type="text"></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫踩得坑]]></title>
    <url>%2F2020%2F01%2F31%2Fpython%2F%E7%88%AC%E8%99%AB%E8%B8%A9%E5%BE%97%E5%9D%91%2F</url>
    <content type="text"><![CDATA[百度最近更新，需要过安检默认情况 下先请求一次百度获取这些参数，然后每次请求带上即可 1234567item.Header.Add(&quot;Bdpagetype&quot;, &quot; 3&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Bdqid&quot;, &quot; 0xd30b86920004fb3f&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Cache-Control&quot;, &quot; private&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Ckpacknum&quot;, &quot; 2&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Ckrndstr&quot;, &quot; 20004fb3f&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Strict-Transport-Security&quot;, &quot; max-age=172800&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Traceid&quot;, &quot; 1574759518274850689015207396528370285375&quot;);//设置请求头信息（Header） 抓取简书登录cookie登录发现post需要包含参数 检查页面，发现在这儿，但不知如何取值 authenticity_token应该每个页面动态生成]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门]]></title>
    <url>%2F2020%2F01%2F31%2Fpython%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HTTP 爬虫入门爬虫简介 &lt; urllib.requestpython3内置的包 123456789101112131415161718import urllib.requestdef load_data(): # 用https时拿不到数据 url = "http://www.baidu.com/" response = urllib.request.urlopen(url) # print(response) data = response.read().decode("utf-8") # print(data) with open("baidu.html", "w", encoding="utf-8") as f: f.write(data) # python爬取到的多为str,bytes # str通过对应encode("编码")转为bytes，同理bytes通过decode转为str # 具体编码格式见html页面head头信息中load_data() get传参要注意转成url编码 由于百度更新，以下过不了安检，实际上拿不到数据了 123456789101112131415161718import urllib.requestimport urllib.parseimport stringdef get_param(): url = "http://www.baidu.com/s?wd=" param = "美女" final_url = url + param # python解释器只支持ASCII码，所以必须转码 final_url = urllib.parse.quote(final_url, safe=string.printable) response = urllib.request.urlopen(final_url) data_str = response.read().decode("utf-8") with open("meinv.html", "w", encoding="utf-8") as f: f.write(data_str)get_param() 字典传参时,这样得到字符串参数 123456params = &#123; "wd": "中文", "key": "zhang", "value": "san"&#125;params_str = urllib.parse.urlencode(params) 绑定请求头 12345678url = "https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3"header = &#123; # 浏览器版本 "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36",&#125;# 创建时绑定请求头，也可以requset.add_header()来动态绑定request = urllib.request.Request(url, headers=header)response = urllib.request.urlopen(request) 获取随机的User-Agent(第三方包) 1234567from fake_useragent import UserAgent print(UserAgent().chrome) print(UserAgent().ie) print(UserAgent().firefox) print(UserAgent().opera) print(UserAgent().safari) print(UserAgent().random) Handler对urlopen进行扩展 urlopen源码如下 123456789101112131415161718192021222324252627global _openerif cafile or capath or cadefault: import warnings warnings.warn("cafile, capath and cadefault are deprecated, use a " "custom context instead.", DeprecationWarning, 2) if context is not None: raise ValueError( "You can't pass both context and any of cafile, capath, and " "cadefault" ) # 安全套阶层，第三方CA数字证书 if not _have_ssl: raise ValueError('SSL support not available') context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=cafile, capath=capath) # 默认用HTTPSHandler，可以用别的Handler来实现功能扩展 https_handler = HTTPSHandler(context=context) opener = build_opener(https_handler)elif context: https_handler = HTTPSHandler(context=context) opener = build_opener(https_handler)elif _opener is None: _opener = opener = build_opener()else: opener = _openerreturn opener.open(url, data, timeout) HTTPHandler演示12345678910url = "https://www.baidu.com/"header = &#123; # 浏览器版本 "User-Agent": UserAgent().random&#125;request = urllib.request.Request(url, headers=header)handler = urllib.request.HTTPHandler()opener = urllib.request.build_opener(handler)response = opener.open(request)data = response.read().decode("utf-8") ProxyHandler123456789101112131415161718192021222324import urllib.requestfrom fake_useragent import UserAgentdef create_proxy_handler(): url = "https://blog.csdn.net/willsnowdev/article/details/90140266" header = &#123; # 浏览器版本 "User-Agent": UserAgent().random &#125; # 可以用多个IP，到时候随机选取 # "http": "163.204.247.20:9999"也可 proxy = &#123; "http": "http://163.204.247.20:9999" &#125; request = urllib.request.Request(url, headers=header) proxy_handler = urllib.request.ProxyHandler(proxy) opener = urllib.request.build_opener(proxy_handler) response = opener.open(request) with open("requset_header.html", "w", encoding="utf-8") as f: f.write(response.read().decode())create_proxy_handler() 多个免费代理 123456proxy_list = [ &#123;"https":"106.75.226.36:808"&#125;, &#123;"https":"61.135.217.7:80"&#125;, &#123;"https":"125.70.13.77:8080"&#125;, &#123;"https":"118.190.95.35:9001"&#125; ] 付费代理 1234567891011121314# 第一种方式proxy = &#123; "http": "username:pwd@163.204.247.20:9999"&#125;# 第二种方式username = "xunzhao"pwd = "173hjgew8"money_proxy1 = "163.204.247.20:9999"# 创建密码管理器password_manger = urllib.request.HTTPPasswordMgr()password_manger.add_password(None, money_proxy1, username, pwd)handle_auth = urllib.request.ProxyBasicAuthHandler(password_manger)opener_auth = urllib.request.build_opener(handle_auth)response = opener_auth.open(url) 用公司内网爬数据 1234567891011121314def auth_nei_wang(): nei_url = "https://www.jianshu.com/p/325bdc0ae92f" header = &#123; "User-Agent": UserAgent().random &#125; username = "admin" pwd = "admin007" password_manger = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_manger.add_password(None, nei_url, username, pwd) # handle不同，其他和付费代理很像 handle_nei = urllib.request.HTTPBasicAuthHandler(password_manger) opener_nei = urllib.request.build_opener(handle_nei) response = opener_nei.open(nei_url) print(response.read().decode("utf-8")) cookie认证手动获取cookie，添加到header中 1234header = &#123; "User-Agent": UserAgent().random, "Cookie": "__yadk_uid=e2gl8vcNK8DLVH2eQd6vHpvH1QvuStkO; web_login_version=MTU4MDA5MDc3OQ%3D%3D--366eb244926d0d504aa444afc85df5e80948cee6; remember_user_token=W1syMTAxNzY3NV0sIiQyYSQxMSRUVGNQenhyZjFtMzdiN3Mxc0xzT25lIiwiMTU4MDQ2MzkzNy42MjQ5NjA0Il0%3D--2fd8938f7291d2405e0c23b0f267c631fad3fd9b; read_mode=day; default_font=font2; locale=zh-CN; _m7e_session_core=ad86ea9fddf5bd5d6969bc414a322298; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%2221017675%22%2C%22%24device_id%22%3A%2216bea6ca2e9365-067bb910973608-e343166-1049088-16bea6ca2ea5c2%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E8%87%AA%E7%84%B6%E6%90%9C%E7%B4%A2%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fwww.baidu.com%2Fs%22%2C%22%24latest_search_keyword%22%3A%22%E7%AE%80%E4%B9%A6%22%2C%22%24latest_utm_source%22%3A%22desktop%22%2C%22%24latest_utm_medium%22%3A%22not-signed-in-like-note-btn-in-bottom%22%2C%22%24latest_referrer_host%22%3A%22www.baidu.com%22%7D%2C%22first_id%22%3A%2216bea6ca2e9365-067bb910973608-e343166-1049088-16bea6ca2ea5c2%22%7D; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1580090858,1580277385,1580463938,1580466286; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1580466310"&#125; 自动获取，用cookiejar来保存cookie 123456获取 个人中心的页面1. 代码登录 登录成功 cookie(有效)2. 自动带着cookie 去请求个人中心cookiejar 自动保存这个cookie 1234567891011121314151617181920212223242526header = &#123; "User-Agent": UserAgent().random, &#125; url = 'https://www.yaozh.com/login' # 1.2 登录的参数 login_form_data = &#123; "username": "xiaomaoera12", "pwd": "lina081012", "formhash": "CE3ADF28C5", "backurl": "https%3A%2F%2Fwww.yaozh.com%2F" &#125; login_form_data_str = urllib.parse.urlencode(login_form_data).encode("utf-8") cookie_jar = cookiejar.CookieJar() cookie_handle = urllib.request.HTTPCookieProcessor(cookie_jar) cookie_opener = urllib.request.build_opener(cookie_handle) requset = urllib.request.Request(url, headers=header, data=login_form_data_str) cookie_opener.open(requset) # 2. 代码带着cooke去访问 个人中心 center_url = 'https://www.yaozh.com/member/' center_request = urllib.request.Request(center_url, headers=header) response = cookie_opener.open(center_url) data = response.read().decode("utf-8") with open("jianshu.html", "w", encoding="utf-8") as f: f.write(data) 疑问cookiejar原理和urlencode中safe=string.printable作用 常见报错URLErrorurl不存在 HTTPError4××，5××，可通过catch到error后，error.code来打印状态码 小结]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础]]></title>
    <url>%2F2020%2F01%2F31%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[B/S架构详解 资源分类静态资源使用静态网页开发技术发布的资源。 特点： 所有用户访问，得到的结果是一样的。 如：文本，图片，音频、视频, HTML,CSS,JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源使用动态网页及时发布的资源。 特点： 所有用户访问，得到的结果可能不一样。 如：jsp/servlet,php,asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 html概述HyperText Markup Language 超文本标记语言 常用标签简单标签 超级链接 锚点链接，实现在各元素间跳转 本地：通过想跳转到的元素的id属性，href设置为#对应id值来实现跳转 其他页面：href=地址#id值 表格 表单* 属性： * action:指定提交数据的URL * method:指定提交方式 123456789101112131415161718192021222324252627* input：可以通过type属性值，改变元素展示的样式* type属性： * text：文本输入框，默认值 * placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 * password：密码输入框 * radio:单选框 * 注意： 1. 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 2. 一般会给每一个单选框提供value属性，指定其被选中后提交的值 3. checked属性，可以指定默认值 * checkbox：复选框 * file：文件选择框 * hidden：隐藏域，用于提交一些信息。 * 按钮： * submit：提交按钮。可以提交表单 * button：普通按钮 * image：图片提交按钮 * src属性指定图片的路径 * label：指定输入项的文字描述信息 * 注意： * label的for属性一般会和 input的id属性值对应 * select: 下拉列表 * 子元素：option，指定列表项 * 指定size属性后变为普通列表框 * textarea：文本域 * cols：指定列数，每一行有多少个字符 * rows：默认多少行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;form action="" method="get"&gt; &lt;label&gt;请输入姓名：&lt;/label&gt;&lt;input type="text" name="userName"&gt;&lt;br&gt; &lt;label&gt;请输入密码：&lt;/label&gt;&lt;input type="password" name="password"&gt;&lt;br&gt; &lt;label&gt;再次输入密码：&lt;/label&gt;&lt;input type="password" name="password"&gt;&lt;br&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type="radio" name="sex" value="1"&gt;男 &lt;input type="radio" name="sex" value="0"&gt;女&lt;br&gt; &lt;label&gt;兴趣爱好：&lt;/label&gt; &lt;input type="checkbox" name="hobby" value="1"&gt;游泳 &lt;input type="checkbox" name="hobby" value="2"&gt;看书 &lt;input type="checkbox" name="hobby" value="3"&gt;爬山 &lt;input type="checkbox" name="hobby" value="4"&gt;思考&lt;br&gt; &lt;label&gt;生日：&lt;/label&gt; &lt;select&gt; &lt;option&gt;1993&lt;/option&gt; &lt;option&gt;1994&lt;/option&gt; &lt;option&gt;1995&lt;/option&gt; &lt;option&gt;1996&lt;/option&gt; &lt;option&gt;1997&lt;/option&gt; &lt;option&gt;1998&lt;/option&gt; &lt;/select&gt;年 &lt;select&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;option&gt;6&lt;/option&gt; &lt;/select&gt;月 &lt;select&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;option&gt;6&lt;/option&gt; &lt;/select&gt;日&lt;br&gt; &lt;label&gt;头像：&lt;/label&gt; &lt;img src="5.jpg" alt="路径错误" width="50px"&gt; &lt;select&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;option value="4"&gt;4&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;input type="button" name="ptbtn" value="普通按钮"&gt; &lt;input type="submit" name="tjbtn" value="提交按钮"&gt;&lt;br&gt; &lt;textarea rows="5" cols="100" placeholder="请输入你的想法"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;input type="file" name="upload"&gt; &lt;input type="button" name="upload" value="上传文件"&gt;&lt;br&gt; &lt;input type="hidden" name="" value=""&gt;&lt;br&gt; &lt;select size="5" multiple="true"&gt; &lt;option value="1"&gt;4&lt;/option&gt; &lt;option value="2"&gt;er&lt;/option&gt; &lt;option value="3"&gt;er&lt;/option&gt; &lt;option value="4"&gt;2&lt;/option&gt; &lt;option value="5"&gt;5&lt;/option&gt; &lt;option value="6"&gt;9&lt;/option&gt; &lt;option value="7"&gt;2&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 特殊字符 CSS简介Cascading Style Sheets 层叠(多次设置)样式列表 作用将结构与样式分离，可以随意切换多套样式 使页面载入更快，降低服务器的成本 分类内部 123456&lt;style type="text/css"&gt; p &#123; background-color: red; font-size: 20px; &#125;&lt;/style&gt; 外部 1&lt;link rel="stylesheet" type="text/css" href="文件路径"&gt; 行内 1&lt;div style="color:red;"&gt;hello css&lt;/div&gt; 常用样式背景样式块级元素 12345678body&#123; background-color:yellow; background-image:url("路径"); background-repeat:no-repeat; background-attachment:fixed; background-position:top center; background: yellow url("路径") no-repeat fixed top center;&#125; 颜色设置 文本样式 123456789color:rgb(238,130,238);direction:ltr;letter-spacing:5px;line-height:20px;text-align:justify;text-decoration:underline;text-shadow:5px 5px 5px red;text-transform:uppercase;text-indent:2em; 字体样式 列表样式 z-index设置层叠时的优先级 常用选择器标签选择器类选择器.类名 伪类状态伪类所有具备这些状态的都可以使用，只是经常和搭配 结构伪类 伪元素选择器 其它 优先级 div概述层叠样式表中的定位技术，有时称之为图层，更多的时候称为块 样式大小，背景，位置1234567891011div &#123; &lt;!--背景--&gt; background-color: yellow; &lt;!--大小--&gt; width: 400px; height: 300px; &lt;!--位置，多为浮动，定位，内外边距--&gt; position: relative; top: 40px; left: 60px;&#125; 溢出效果通过overflow来设置 边框，轮廓 盒子模型 元素分类行级元素 块级元素 定位机制文档流默认样式 脱标流float脱离文档流，同级元素的float位于同一层 属性 inherit 继承父元素的浮动 特性崩溃起因：元素默认宽度为父级元素宽度，高度默认为其内元素的高度 子一级元素float后，若父元素未设置高度，其高度会崩溃 包裹父元素设为float后，会将子元素包裹起来 当包裹的是行级元素时，会在下边沿留下一个基准线的宽度 对子元素设置vertical-align: bottom来取消基准线 环绕平级元素会环绕显示 清除浮动原因 为了父元素不会出现高度崩溃 如果强制规定父元素高度，就不灵活了，不能自适应高度 从某个元素开始，不需要浮动了 方法法一：在不需要浮动的元素添加clear: both 法二：专门在不需要的地方添加一个clearDiv，然后设置如下 1234567#clearDiv::after &#123; content: ""; visibility: hidden; height: 0px; display: block; clear: both;&#125; 定位概述 相对定位 绝对定位 固定定位​ Tips 没有定位时，top，left设置无效，因为无参照物 通常子绝父相 绝对定位与相对定位主要在于是否脱离文档流，以及参照物的不同 绝对定位和float都会脱离文档流，但float的文字会环绕，而绝对定位会覆盖 同时设置相对定位和浮动时，会既具有文字环绕，又可相对自身定位 JavaScript概述是一种脚本语言，无需安装，所有浏览器内置 JavaScript = ECMAScript(客户端脚本语言标准) + JavaScript特有的(BOM,DOM) 引用内置 123&lt;script type="text/javascript"&gt; alert("hello js")&lt;/script&gt; 外联 1&lt;script type="text/javascript" src="文件路径"&gt;&lt;/script&gt; ECMAScript变量弱类型语言，声明时自动推导，使用时区分类型 123var x; x=1; // 用var声明为局部变量，不用则为全局变量var x=1,name="zhangsan"typeof(变量) //获取变量类型 null运算后得到object 数据类型原始数据类型 引用数据类型 类型转换12345678910// 转为数字类型parseInt()parseFloat()Number() //比前两个更安全，只要有非数字就返回NaNBoolean()1. number：0或NaN为假，其他为真2. string：除了空字符串("")，其他都是true3. null&amp;undefined:都是false4. 对象：所有对象都为true 作用域全局变量和局部变量和java一致 运算符优先级==仅比较内容，===为全比较，会先判断类型 调试alert 弹窗调试 console.log 输出到控制台 程序控制语句if，else if ，else， switch， while， do … while，for，增强for循环 写法和java一致 函数自定义函数1234567891011121314151617// 函数声明，可以先使用后声明function func1(a,b)&#123; 代码片段 return ***&#125;// 函数表达式，必须先定义后使用var fun1 = function func2(x)&#123; 代码片段 return ***&#125;// 属性： // length:代表形参的个数// 特点： // 方法定义是，形参的类型不用写,返回值类型也不写。 // 方法是一个对象，如果定义名称相同的方法，会覆盖 // 在JS中，方法的调用只与方法的名称有关，和参数列表无关 // 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 内置函数 123456789101112131415161718192021222324252627// 字符串var str = "124ttgegvqwa";str.substring(3,3); //开始位置，个数str.substr(3,6); //开始位置，结束位置str.indexOf(1,4) //一出现的位置，从4开始找str.indexOf(1) //一出现的位置n.toFixed(3) //保留三位小数Math.max(3,56,7,3,2)// Date // toLocaleString()：返回当前date对象对应的时间本地字符串格式 // getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差//时间格式化function format_date()&#123; var date = new Date(); var yy,mo,dd,hh,mi,ss; var time; yy = date.getFullYear(); mo = date.getMonth()+1; dd = date.getDate(); hh = date.getHours(); mi = date.getMinutes(); ss = date.getSeconds(); time = yy+"-"+mo+"-"+dd+"-"+hh+"-"+mi+"-"+ss; return time;&#125; 数组12345678910111213141516var arrayObj = new Array();var arrayObj = new Array(5);var arrayObj = new Array(2,3,453,23,67);var arrayObj = new [2,46,77,532,"df"];// 遍历for (var str in arrayObj) &#123; console.log(arrayObj[str])&#125;// 方法 // join(参数):将数组中的元素按照指定的分隔符拼接为字符串 // push() 向数组的末尾添加一个或更多元素，并返回新的长度。// 属性 // length:数组的长度// 特点： // JS中，数组元素的类型可变的。 // JS中，数组长度可变的。 全局对象全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名(); 123456789101112encodeURI():url编码decodeURI():url解码encodeURIComponent():url编码,编码的字符更多decodeURIComponent():url解码parseInt():将字符串转为数字* 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为numberisNaN():判断一个值是否是NaN* NaN六亲不认，连自己都不认。NaN参与的==比较全部问falseeval():将字符串作为脚本代码来执行。 BOM 概念：Browser Object Model 浏览器对象模型 将浏览器的各个组成部分封装成对象。 组成 Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Window窗口对象 方法1234567891011121314151617181920211. 与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 * 如果用户点击确定按钮，则方法返回true * 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。 * 返回值：获取用户输入的值2. 与打开关闭有关的方法： close() 关闭浏览器窗口。 * 谁调用我 ，我关谁 open() 打开一个新的浏览器窗口 * 返回新的Window对象3. 与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 * 参数： 1. js代码或者方法对象 2. 毫秒值 * 返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 属性 获取其他BOM对象historylocationNavigatorScreen 获取DOM对象document 特点 Window对象不需要创建可以直接使用 window使用。 window.方法名(); window引用可以省略。 方法名(); Location地址栏对象 123456781. 创建(获取)： 1. window.location 2. location2. 方法： * reload() 重新加载当前文档。刷新3. 属性 * href 设置或返回完整的 URL。 History历史记录对象 123456789101112131. 创建(获取)： 1. window.history 2. history2. 方法： * back() 加载 history 列表中的前一个 URL。 * forward() 加载 history 列表中的下一个 URL。 * go(参数) 加载 history 列表中的某个具体页面。 * 参数： * 正数：前进几个历史记录 * 负数：后退几个历史记录3. 属性： * length 返回当前窗口历史列表中的 URL 数量。 DOM概述 概念： Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 组成 核心 DOM - 针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment:注释对象 Node：节点对象，其他5个的父对象 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 核心DOMDocument 创建(获取)：在html dom模型中可以使用window对象来获取 window.document document 方法 获取Element对象： getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象：createAttribute(name)createComment()createElement()createTextNode() Element 获取/创建：通过document来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 示例下拉列表框 123yy = document.getElementById("yyyy");yy.options.add(new Option(1,1)); // 添加optionyy.option.remove(1); // 删除指定索引的option 靠遍历删除所有时要注意倒叙删 图片 img.src = &quot;F:/aa.jpg&quot; 复选框 img.checked = True; value 标签.value = &quot;haha&quot;; Node节点对象，其他5个的父对象 特点：所有dom对象都可以被认为是一个节点 方法： CRUD dom树： appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild() ：删除（并返回）当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 属性： parentNode 返回节点的父节点。 HTML DOM1. 标签体(标签内容)的设置和获取：innerHTML 2. 使用html元素对象的属性 3. 控制元素样式 明确获取的对象是哪一个？ 查看API文档，找其中有哪些属性可以设置 1. 使用元素的style属性来设置 如： //修改样式方式1 div1.style.border = &quot;1px solid red&quot;; div1.style.width = &quot;200px&quot;; //font-size--&gt; fontSize div1.style.fontSize = &quot;20px&quot;; 2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。事件 概念：某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见事件js事件都以on开头 1. 点击事件： 1. onclick：单击事件 2. ondblclick：双击事件 2. 焦点事件 1. onblur：失去焦点 2. onfocus:元素获得焦点。 3. 加载事件： 1. onload：一张页面或一幅图像完成加载。 4. 鼠标事件： 1. onmousedown 鼠标按钮被按下。 2. onmouseup 鼠标按键被松开。 3. onmousemove 鼠标被移动。 4. onmouseover 鼠标移到某元素之上。 5. onmouseout 鼠标从某元素移开。 5. 键盘事件： 1. onkeydown 某个键盘按键被按下。 2. onkeyup 某个键盘按键被松开。 3. onkeypress 某个键盘按键被按下并松开。 6. 选择和改变 1. onchange 域的内容被改变。 2. onselect 文本被选中。 7. 表单事件： 1. onsubmit 确认按钮被点击。 2. onreset 重置按钮被点击。事件绑定 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 通过js获取元素对象，指定事件属性，设置一个函数]]></content>
      <categories>
        <category>heima57</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法]]></title>
    <url>%2F2019%2F10%2F02%2F%E5%B7%A5%E5%85%B7%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[前提须知用处 写出性能更高的程序 更快更深的掌握一门技术 数据结构+算法=程序 数组 定义 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 链表适合插入、删除，时间复杂度O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1) 警惕数组的访问越界问题 我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。 容器可否完全替代数组 .Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。 如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。 .还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList &gt; array。 总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。 数组下标为何从零开始 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式： 1a[k]_address = base_address + k * type_size 但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为： 1a[k]_address = base_address + (k-1)*type_size 对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。 不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非0开始不可。所以我觉得最主要的原因可能是历史原因。链表 常见的缓存淘汰策略有三种：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。 排序]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F09%2F21%2Fheima57%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySql数据库的基本概念1. 数据库的英文单词： DataBase 简称 ： DB 2. 什么数据库？ * 用于存储和管理数据的仓库。 3. 数据库的特点： 1. 持久化存储数据的。其实数据库就是一个文件系统 2. 方便存储和管理数据 3. 使用了统一的方式操作数据库 -- SQL 4. 常见的数据库软件 * 参见《MySQL基础.pdf》 MySQL数据库软件1. 安装 * 参见《MySQL基础.pdf》 2. 卸载 1. 去mysql的安装目录找到my.ini文件 * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; 2. 卸载MySQL 3. 删除C:/ProgramData目录下的MySQL文件夹。 3. 配置 * MySQL服务启动 1. 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 * MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql --host=ip --user=root --password=连接目标的密码 * MySQL退出 1. exit 2. quit * MySQL目录结构 1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot; * 配置文件 my.ini 2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot; * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据SQL1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表操作库12345678910111213141516171819202122232425262728291. 操作数据库：CRUD 1. C(Create):创建 * 创建数据库： * create database 数据库名称; * 创建数据库，判断不存在，再创建： * create database if not exists 数据库名称; * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名; * 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk * create database if not exists db4 character set gbk; 2. R(Retrieve)：查询 * 查询所有数据库的名称: * show databases; * 查询某个数据库的字符集、某个数据库的创建语句 * show create database 数据库名称; 3. U(Update):修改 * 修改数据库的字符集 * alter database 数据库名称 character set 字符集名称; 4. D(Delete):删除 * 删除数据库 * drop database 数据库名称; * 判断数据库存在，存在再删除 * drop database if exists 数据库名称; 5. 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称; 操作表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 1. C(Create):创建 1. 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); * 注意：最后一列，不需要加逗号（,） * 数据库类型： 1. int：整数类型 * age int, 2. double:小数类型 * score double(5,2) 3. date:日期，只包含年月日，yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符 * 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; 2. R(Retrieve)：查询 * 查询某个数据库中所有的表名称 * show tables; * 查询表结构 * desc 表名;3. U(Update):修改 1. 修改表名 alter table 表名 rename to 新的表名; 2. 修改表的字符集 alter table 表名 character set 字符集名称; 3. 添加一列 alter table 表名 add 列名 数据类型; 4. 修改列名称 类型 alter table 表名 change 列名 新列名 新数据类型; alter table 表名 modify 列名 新数据类型; 5. 删除列 alter table 表名 drop 列名;4. D(Delete):删除 * drop table 表名; * drop table if exists 表名 ; 添加约束1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 * 分类： 1. 主键约束：primary key 2. 非空约束：not null 3. 唯一约束：unique 4. 外键约束：foreign key* 非空约束：not null，某一列的值不能为null 1. 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); 2. 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3. 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20);* 唯一约束：unique，某一列的值不能重复 1. 注意： * 唯一约束可以有NULL值，但是只能有一条记录为null 2. 在创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE -- 手机号 ); 3. 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 4. 在表创建完后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;* 主键约束：primary key。 1. 注意： 1. 含义：非空且唯一 2. 一张表只能有一个字段为主键 3. 主键就是表中记录的唯一标识 2. 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 3. 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 4. 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 5. 自动增长： 1. 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 2. 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 4. 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。 1. 在创建表时，可以添加外键 * 语法： create table 表名( .... 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 2. 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 3. 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 4. 级联操作 1. 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 2. 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE 添加需谨慎 DML：增删改表中数据123456789101112131415161718192021221. 添加数据： * 语法： * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n); * 注意： 1. 列名和值要一一对应。 2. 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,...值n); 3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据： * 语法： * delete from 表名 [where 条件] * 注意： 1. 如果不加条件，则删除表中所有记录。 2. 如果要删除所有记录 1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作 2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。3. 修改数据： * 语法： * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]; * 注意： 1. 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566671. 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定2. 基础查询 1. 多个字段的查询 select 字段名1，字段名2... from 表名； * 注意： * 如果查询所有字段，则可以使用*来替代字段列表，但不推荐使用 2. 去除重复： * distinct 3. 计算列 * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null * 表达式1：哪个字段需要判断是否为null * 如果该字段为null后的替换值。 4. 起别名： * as：as也可以省略3. 条件查询 1. where子句后跟条件 2. 运算符 * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; * BETWEEN...AND * IN( 集合) * LIKE：模糊查询 * 占位符： * _:单个任意字符 * %：多个任意字符 * IS NULL * and 或 &amp;&amp; * or 或 || * not 或 ! -- 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; -- 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); -- 查询英语成绩为null SELECT * FROM student WHERE english = NULL; -- null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; -- 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; -- 查询姓马的有哪些？ like SELECT * FROM student WHERE NAME LIKE &apos;马%&apos;; -- 查询姓名第二个字是化的人 SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;; -- 查询姓名是3个字的人 SELECT * FROM student WHERE NAME LIKE &apos;___&apos;; -- 查询姓名中包含德的人 SELECT * FROM student WHERE NAME LIKE &apos;%德%&apos;; 复杂查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581. 排序查询 * 语法：order by 子句 * order by 排序字段1 排序方式1 ， 排序字段2 排序方式2... * 排序方式： * ASC：升序，默认的。 * DESC：降序。 * 注意： * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。 1. count：计算个数 1. 一般选择非空的列：主键 2. count(*) 2. max：计算最大值 3. min：计算最小值 4. sum：计算和 5. avg：计算平均值 * 注意：聚合函数的计算，排除null值。 解决方案： 1. 选择不包含非空的列进行计算 2. IFNULL函数3. 分组查询: 1. 语法：group by 分组字段； 2. 注意： 1. 分组之后查询的字段：分组字段、聚合函数 2. where 和 having 的区别？ 1. where 在分组之前进行限定，如果不满足条件，则不参与分组。 having在分组之后进行限定，如果不满足结果，则不会被查询出来 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。 -- 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; -- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组, -- 分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2;4. 分页查询 1. 语法：limit 开始的索引,每页查询的条数; 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 -- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 3. limit 是一个MySQL&quot;方言&quot; 多表查询12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667* 查询语法： select 列名列表 from 表名列表 where....* 笛卡尔积： * 有两个集合A,B .取这两个集合的所有组成情况。 * 要完成多表查询，需要消除无用的数据* 多表查询的分类： 1. 内连接查询： 1. 隐式内连接：使用where条件消除无用数据 -- 查询员工表的名称，性别。部门表的名称 SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称 FROM emp t1, dept t2 WHERE t1.`dept_id` = t2.`id`; 2. 显式内连接： * 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 * 例如： * SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`; * SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; 2. 外链接查询： 1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分---右表+与左表符合条件的交集 * 例子： SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 3. 子查询： * 概念：查询中嵌套查询，称嵌套查询为子查询。 * 子查询不同情况 1. 子查询的结果是单行单列的： * 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= = -- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 2. 子查询的结果是多行单列的： * 子查询可以作为条件，使用运算符in来判断 -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息 SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; -- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;); 3. 子查询的结果是多行多列的： * 子查询可以作为一张虚拟表参与查询 -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 -- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &apos;2011-11-11&apos; 多表查询练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175-- 部门表CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地);-- 添加4个部门INSERT INTO dept(id,dname,loc) VALUES (10,&apos;教研部&apos;,&apos;北京&apos;),(20,&apos;学工部&apos;,&apos;上海&apos;),(30,&apos;销售部&apos;,&apos;广州&apos;),(40,&apos;财务部&apos;,&apos;深圳&apos;);-- 职务表，职务名称，职务描述CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50));-- 添加4个职务INSERT INTO job (id, jname, description) VALUES(1, &apos;董事长&apos;, &apos;管理整个公司，接单&apos;),(2, &apos;经理&apos;, &apos;管理部门员工&apos;),(3, &apos;销售员&apos;, &apos;向客人推销产品&apos;),(4, &apos;文员&apos;, &apos;使用办公软件&apos;);-- 员工表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id));-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&apos;孙悟空&apos;,4,1004,&apos;2000-12-17&apos;,&apos;8000.00&apos;,NULL,20),(1002,&apos;卢俊义&apos;,3,1006,&apos;2001-02-20&apos;,&apos;16000.00&apos;,&apos;3000.00&apos;,30),(1003,&apos;林冲&apos;,3,1006,&apos;2001-02-22&apos;,&apos;12500.00&apos;,&apos;5000.00&apos;,30),(1004,&apos;唐僧&apos;,2,1009,&apos;2001-04-02&apos;,&apos;29750.00&apos;,NULL,20),(1005,&apos;李逵&apos;,4,1006,&apos;2001-09-28&apos;,&apos;12500.00&apos;,&apos;14000.00&apos;,30),(1006,&apos;宋江&apos;,2,1009,&apos;2001-05-01&apos;,&apos;28500.00&apos;,NULL,30),(1007,&apos;刘备&apos;,2,1009,&apos;2001-09-01&apos;,&apos;24500.00&apos;,NULL,10),(1008,&apos;猪八戒&apos;,4,1004,&apos;2007-04-19&apos;,&apos;30000.00&apos;,NULL,20),(1009,&apos;罗贯中&apos;,1,NULL,&apos;2001-11-17&apos;,&apos;50000.00&apos;,NULL,10),(1010,&apos;吴用&apos;,3,1006,&apos;2001-09-08&apos;,&apos;15000.00&apos;,&apos;0.00&apos;,30),(1011,&apos;沙僧&apos;,4,1004,&apos;2007-05-23&apos;,&apos;11000.00&apos;,NULL,20),(1012,&apos;李逵&apos;,4,1006,&apos;2001-12-03&apos;,&apos;9500.00&apos;,NULL,30),(1013,&apos;小白龙&apos;,4,1004,&apos;2001-12-03&apos;,&apos;30000.00&apos;,NULL,20),(1014,&apos;关羽&apos;,4,1007,&apos;2002-01-23&apos;,&apos;13000.00&apos;,NULL,10);-- 工资等级表CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资);-- 添加5个工资等级INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000),(2,12010,14000),(3,14010,20000),(4,20010,30000),(5,30010,99990);-- 需求：-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述/* 分析： 1.员工编号，员工姓名，工资，需要查询emp表 职务名称，职务描述 需要查询job表 2.查询条件 emp.job_id = job.id*/SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description` -- 职务描述FROM emp t1, job t2WHERE t1.`job_id` = t2.`id`;-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description`, -- 职务描述 t3.`dname`, -- 部门名称 t3.`loc` -- 部门位置FROM emp t1, job t2,dept t3WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`; -- 3.查询员工姓名，工资，工资等级SELECT t1.ename , t1.`salary`, t2.*FROM emp t1, salarygrade t2WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级SELECT t1.`ename`, t1.`salary`, t2.`jname`, t2.`description`, t3.`dname`, t3.`loc`, t4.`grade`FROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;-- 5.查询出部门编号、部门名称、部门位置、部门人数/* 分析： 1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表 2.使用分组查询。按照emp.dept_id完成分组，查询count(id) 3.使用子查询将第2步的查询结果和dept表进行关联查询 */SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.totalFROM dept t1, (SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2WHERE t1.`id` = t2.dept_id;-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询/* 分析： 1.姓名 emp， 直接上级的姓名 emp * emp表的id 和 mgr 是自关联 2.条件 emp.id = emp.mgr 3.查询左表的所有数据，和 交集数据 * 使用左外连接查询 *//*select t1.ename, t1.mgr, t2.`id`, t2.enamefrom emp t1, emp t2where t1.mgr = t2.`id`;*/SELECT t1.ename, t1.mgr, t2.`id`, t2.`ename`FROM emp t1LEFT JOIN emp t2ON t1.`mgr` = t2.`id`; DCL：用户及其权限管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657* SQL分类： 1. DDL：操作数据库和表 2. DML：增删改表中数据 3. DQL：查询表中数据 4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权 1. 管理用户 1. 添加用户： * 语法：CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;; 2. 删除用户： * 语法：DROP USER &apos;用户名&apos;@&apos;主机名&apos;; 3. 修改用户密码： UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;; UPDATE USER SET PASSWORD = PASSWORD(&apos;abc&apos;) WHERE USER = &apos;lisi&apos;; SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;); SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos; = PASSWORD(&apos;123&apos;); * mysql中忘记了root用户的密码？ 1. cmd -- &gt; net stop mysql 停止mysql服务 * 需要管理员运行该cmd 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 4. use mysql; 5. update user set password = password(&apos;你的新密码&apos;) where user = &apos;root&apos;; 6. 关闭两个窗口 7. 打开任务管理器，手动结束mysqld.exe 的进程 8. 启动mysql服务 9. 使用新密码登录。 4. 查询用户： -- 1. 切换到mysql数据库 USE myql; -- 2. 查询user表 SELECT * FROM USER; * 通配符： % 表示可以在任意主机使用用户登录数据库 2. 权限管理： 1. 查询权限： -- 查询权限 SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;; SHOW GRANTS FOR &apos;lisi&apos;@&apos;%&apos;; 2. 授予权限： -- 授予权限 grant 权限列表 on 数据库名.表名 to &apos;用户名&apos;@&apos;主机名&apos;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &apos;zhangsan&apos;@&apos;localhost&apos;; 3. 撤销权限： -- 撤销权限： revoke 权限列表 on 数据库名.表名 from &apos;用户名&apos;@&apos;主机名&apos;; REVOKE UPDATE ON db3.`account` FROM &apos;lisi&apos;@&apos;%&apos;; 数据库的设计多表关系123456789101112131415161718192021221. 多表之间的关系 1. 分类： 1. 一对一(了解)： * 如：人和身份证 * 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： * 如：部门和员工 * 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： * 如：学生和课程 * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： * 如：部门和员工 * 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： * 如：学生和课程 * 实现方式：多对多关系实现需要借助第三张中间表。 中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： * 如：人和身份证 * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-- 创建旅游线路分类表 tab_category-- cid 旅游线路分类主键，自动增长-- cname 旅游线路分类名称非空，唯一，字符串 100CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE);-- 创建旅游线路表 tab_route/*rid 旅游线路主键，自动增长rname 旅游线路名称非空，唯一，字符串 100price 价格rdate 上架时间，日期类型cid 外键，所属分类*/CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid));/*创建用户表 tab_useruid 用户主键，自增长username 用户名长度 100，唯一，非空password 密码长度 30，非空name 真实姓名长度 100birthday 生日sex 性别，定长字符串 1telephone 手机号，字符串 11email 邮箱，字符串长度 100*/CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &apos;男&apos;, telephone VARCHAR(11), email VARCHAR(100));/*创建收藏表 tab_favoriterid 旅游线路 id，外键date 收藏时间uid 用户 id，外键rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次*/CREATE TABLE tab_favorite ( rid INT, -- 线路id DATE DATETIME, uid INT, -- 用户id -- 创建复合主键 PRIMARY KEY(rid,uid), -- 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid)); 数据库设计的范式123456789101112131415161718192021222324252627282930* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库， 这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、 巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。* 分类： 1. 第一范式（1NF）：每一列都是不可分割的原子数据项 2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码 （在1NF基础上消除非主属性对主码的部分函数依赖） * 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组， 则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B，若A是一个属性组，则B属性值确定只需依赖于A属性组中某些值 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值， 在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖， 则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） * 主属性：码属性组中的所有属性 * 非主属性：除过码属性组的属性 3. 第三范式（3NF）:在2NF基础上,任何非主属性不依赖于其它非主属性，即在2NF基础上消除传递依赖 范例 系下面有两个子项，根据范式一将其拆分– 即所有可以建表的都满足范式一 范式二：消除非主属性对主码的部分函数依赖 学号-&gt;姓名，系名，系主任(包含传递依赖) 学号，课程名称-&gt;成绩 姓名，系名，系主任对（学号，课程名称）存在部分依赖 选课表不存在传递依赖 学号 –&gt; 姓名 –&gt; 系名 –&gt; 系主任 存在传递依赖 数据库的备份和还原1234567891. 命令行： * 语法： * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 * 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件 source 文件路径2. 图形化工具： 事务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051521. 事务的基本介绍 1. 概念： * 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 2. 操作： 1. 开启事务： start transaction; 2. 回滚：rollback; 3. 提交：commit; 3. MySQL数据库中事务默认自动提交 * 事务提交的两种方式： * 自动提交： * mysql就是自动提交的 * 一条DML(增删改)语句会自动提交一次事务。 * 手动提交： * Oracle 数据库默认是手动提交事务 * 需要先开启事务，再提交 * 修改事务的默认提交方式： * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 * 修改默认提交方式： set @@autocommit = 0;2. 事务的四大特征： 1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 3. 隔离性：多个事务之间。相互独立。 4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解） * 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 * 存在问题： 1. 脏读：一个事务，读取到另一个事务中没有提交的数据 2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 * 隔离级别： 1. read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 4. serializable：串行化 * 可以解决所有的问题 * 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 * 数据库查询隔离级别： * select @@tx_isolation; * 数据库设置隔离级别： * set global transaction isolation level 级别字符串; * 演示： set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2; 异常解决【MySQL】SELECT list is not in GROUP BY clause… 12345678910SELECT a.* FROM tbl_inspection_equipment_record aRIGHT JOIN ( SELECT * FROM tbl_inspection_equipment_record WHERE state = 1 AND build_id = ? ORDER BY end_time DESC) AS tempON a.id = temp.idGROUP BY room_idORDER BY end_time DESC 问题原因 MySQL 5.7.5及以上功能依赖检测功能。如果启用了 ONLY_FULL_GROUP_BY SQL 模式（默认情况下），MySQL 将拒绝选择列表，HAVING 条件或 ORDER BY 列表的查询引用在 GROUP BY 子句中既未命名的非集合列，也不在功能上依赖于它们。（5.7.5之前，MySQL 没有检测到功能依赖关系，默认情况下不启用 ONLY_FULL_GROUP_BY。有关5.7.5之前的行为的说明，请参见“MySQL 5.6参考手册”。） 解决方案方法一(该方式每次mysql服务重新启动恢复原来的模式) S1：select @@global.sql_mode; S2：执行以下sql语句，去除步骤1中 ONLY_FULL_GROUP_BY 1234567set @@global.sql_mode =&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;; 方法二：修改配置文件 远程服务器找到 my.cnf 文件 在文件底部加入 12sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 重启mysql JDBCJDBC简单实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221. 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门： * 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键--&gt;Add As Library 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql 5. 获取执行sql语句的对象 Statement 6. 执行sql，接受返回结果 7. 处理结果 8. 释放资源 * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName("com.mysql.jdbc.Driver"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db3", "root", "root"); //4.定义sql语句 String sql = "update account set balance = 500 where id = 1"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close();3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName("com.mysql.jdbc.Driver"); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 * 例子：jdbc:mysql://localhost:3306/db3 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble("balance") * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next())&#123; //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString("name"); double balance = rs.getDouble(3); System.out.println(id + "---" + name + "---" + balance); &#125; 5. PreparedStatement：执行sql的对象 1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 1. 输入用户随便，输入密码：a' or 'a' = 'a 2. sql：select * from user where username = 'fhdsjkf' and password = 'a' or 'a' = 'a' 2. 解决sql注入问题：使用PreparedStatement对象来解决 3. 预编译的SQL：参数使用?作为占位符 4. 步骤： 1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 2. 注册驱动 3. 获取数据库连接对象 Connection 4. 定义sql * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 5. 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 6. 给？赋值： * 方法： setXxx(参数1,参数2) * 参数1：？的位置编号 从1 开始 * 参数2：？的值 7. 执行sql，接受返回结果，不需要传递sql语句 8. 处理结果 9. 释放资源 5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 1. 可以防止SQL注入 2. 效率更高 抽取JDBC工具类 ： JDBCUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 1. 注册驱动也抽取 2. 抽取一个方法获取连接对象 * 需求：不想传递参数（麻烦），还得保证工具类的通用性。 * 解决：配置文件 jdbc.properties url= user= password= 3. 抽取一个方法释放资源*/ public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static&#123; //读取资源文件，获取值。 try &#123; //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource("jdbc.properties"); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties")); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); driver = pro.getProperty("driver"); //4. 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn)&#123; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; ​ /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } * 练习： * 需求： 1. 通过键盘录入用户名和密码 2. 判断用户是否登录成功 * select * from user where username = &quot;&quot; and password = &quot;&quot;; * 如果这个sql有查询结果，则成功，反之，则失败 * 步骤： 1. 创建数据库表 user CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,&apos;zhangsan&apos;,&apos;123&apos;); INSERT INTO USER VALUES(NULL,&apos;lisi&apos;,&apos;234&apos;); 2. 代码实现： public class JDBCDemo9 { public static void main(String[] args) { //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag){ //登录成功 System.out.println(&quot;登录成功！&quot;); }else{ System.out.println(&quot;用户名或密码错误！&quot;); }​ }​​ /** * 登录方法 */ public boolean login(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = &quot;select * from user where username = &apos;&quot;+username+&quot;&apos; and password = &apos;&quot;+password+&quot;&apos; &quot;; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); }​ return false; } }JDBC控制事务：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。2. 操作： 1. 开启事务 2. 提交事务 3. 回滚事务3. 使用Connection对象来管理事务 * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 在执行sql之前开启事务 * 提交事务：commit() * 当所有sql都执行完提交事务 * 回滚事务：rollback() * 在catch中回滚事务*/ public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = "update account set balance = balance - ? where id = ?"; //2.2 李四 + 500 String sql2 = "update account set balance = balance + ? where id = ?"; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125; &#125; 数据库连接池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/*1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时， 从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处： 1. 节约资源 2. 用户访问高效3. 实现： 1. 标准接口：DataSource javax.sql包下的 1. 方法： * 获取连接：getConnection() * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的， 那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 2. 一般我们不去实现它，有数据库厂商来实现 1. C3P0：数据库连接池技术 2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术 * 步骤： 1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， * 不要忘记导入数据库驱动jar包 2. 定义配置文件： * 名称： c3p0.properties 或者 c3p0-config.xml * 路径：直接将文件放在src目录下即可。 3. 创建核心对象 数据库连接池对象 ComboPooledDataSource 4. 获取连接： getConnection*/ //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection();/*5. Druid：数据库连接池实现技术，由阿里巴巴提供的 1. 步骤： 1. 导入jar包 druid-1.0.9.jar 2. 定义配置文件： * 是properties形式的 * 可以叫任意名称，可以放在任意目录下 3. 加载配置文件。Properties 4. 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 5. 获取连接：getConnection*/ //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream("druid.properties"); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection();/* 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法*/ public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125; &#125; Spring JDBCSpring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤： 1. 导入jar包 2. 创建JdbcTemplate对象。依赖于数据源DataSource * JdbcTemplate template = new JdbcTemplate(ds); 3. 调用JdbcTemplate的方法来完成CRUD的操作 * update():执行DML语句。增、删、改语句 * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 * 注意：这个方法查询的结果集长度只能是1 * queryForList():查询结果将结果集封装为list集合 * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 * query():查询结果，将结果封装为JavaBean对象 * query的参数：RowMapper * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 * new BeanPropertyRowMapper&lt;类型&gt;(类型.class) * queryForObject：查询结果，将结果封装为对象 * 一般用于聚合函数的查询练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/* * 需求： 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数*/ import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = "select * from emp where id = ? or id = ?"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = "select * from emp"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt("id"); String ename = rs.getString("ename"); int job_id = rs.getInt("job_id"); int mgr = rs.getInt("mgr"); Date joindate = rs.getDate("joindate"); double salary = rs.getDouble("salary"); double bonus = rs.getDouble("bonus"); int dept_id = rs.getInt("dept_id"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = "select * from emp"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = "select count(id) from emp"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125; &#125;]]></content>
      <categories>
        <category>heima57</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%B7%A5%E5%85%B7%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式概述正则表达式（regular expression，简称regex）：是一些用来匹配和处理文本的字符串 正则表达式通常被简称为模式，其实是一些由字符构成的字符串 这些字符可以是普通字符（纯文本）或元字符（有特殊含义的特殊字符） 在线测试网站 字符范围匹配 元字符 [\b] 回退（删除）一个字符 \f 换页符 \n 换行符 \r 回车符 \t 制表符（tab） \v 垂直制表符 \s 任何一个空白字符 [\f\n\r\t\v] \S 任何一个非空白字符 \x 十六进制 \0 八进制 多次重复匹配 定位匹配将字符串作为一个整体 \b 用来匹配单词的开始或结束（\w与非\w之间） 只匹配一个位置，而不匹配任何字符 \B 匹配一个前后都不是单词边界 \&lt; 单词开始 \&gt; 单词结束 (?m) 分行匹配模式，必须写在模式最前面 非贪婪模式默认为贪婪模式，尽可能多的匹配 模式后面加个？转换为非贪婪 表达式分组可读性更高 在java中可通过group方法来分别获取一个个分组 POSIX字符串[[:alnum:]] 数字字符 [[:alpha:]] 字母字符 [[:lower:]] 小写字母字符 [[:print:]] 可显示的字符 [[:blank:]] 空格(space)与定位字符 [[:punct:]] 除[[:cntrl:]]和[[:alnum:]]外 [[:cntrl:]] ASCII控制字符(0-31和127) [[:space:]] 空白(whitespace)字符 [[:upper:]] 大写字母字符 [[:digit:]] 数字字符 [[:graph:]] 非空格(nonspace)字符 [[:xdigit:]] 十六进制数字字符 回溯引用前后一致匹配 \n 匹配前面第n个子表达式 $n 替换时使用，匹配上一条查询中的第n个子表达式匹配到的内容 大小写转换（替换时使用） \E 结束\L或\U转换 \I 把下一个字符转换为小写 \L 把后面的字符转换为小写 \u 把下一个字符转换为大写 \U 把后面的字符转换为大写 前后查找都是只匹配但不消费 (?=字符) 正向前查找，匹配到指定字符，停止匹配 (?!字符) 正向前查找，匹配到不是指定字符的，停止匹配 (?&lt;=字符) 正向后查找，匹配到指定字符，停止匹配 (&lt;=字符) 负向后查找，匹配到不是指定字符，停止匹配 嵌入条件(?(n)regex) 如果前一个子表达式匹配到了则执行该正则 (?(前后查找)regex) 如果前后查找成功了则执行该正则 JavaScript 创建 var reg = new RegExp(“正则表达式”); var reg = /正则表达式/; 方法 test(参数):验证指定的字符串是否符合正则定义的规范 Java创建​ Pattern p = Pattern.compile(&quot;&lt;li&gt;([\\u4e00-\\u9fa5]{2,10})([a-zA-Z]+)&lt;/li&gt;&quot;); 匹配​ Matcher m = p.matcher(content); 查找匹配结果1234567while(m.find()) &#123; // group(0)匹配整个正则 System.out.println(m.group(0)); // 1，2，...按分组匹配 String chs = m.group(1); String eng = m.group(2);&#125;]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%B7%A5%E5%85%B7%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git版本控制系统 记录版本信息（记录每一次的修改） 方便团队相互之间协作，共同开发 常用版本控制系统 svn/cvs：集中式版本控制系统 共用一个服务器，一旦出问题就全完了，保存差异 git：分布式版本控制系统 保存的是所有文件的快照，每个人本地都相当于一个服务器 Git安装这个网上很常见，自行参考网上教程 使用GitHub目的：托管项目代码工作区 -&gt; 暂存区 -&gt; 历史区 1.Git的全局配置123456789第一次安装完成git后，要在全局环境下配置基本信息：我是谁？$ git config -l 查看配置信息$ git config --global -l 查看全局配置信息配置全局信息，用户名和邮箱$ git config --global user.name 'xxx'$ git config --global user.email 'xxx@xx.xx'初始化ssh$ ssh-Keygon 先是确定保存路径，再是密码，三次回车即可在C:\Users\asus\.ssh用记事本打开id_ssh.pub,复制其中内容 2.创建仓库完成版本控制123456789101112131415161718192021222324252627282930创建本地git仓库$ git init会生成一个隐藏文件夹“.git”（这个文件夹很重要，暂存区和历史区以及一些其他数据都在里面存着）在本地编写完成代码后（在工作区），把一些文件提交到暂存区$ git add xxx 把某一个文件或者文件夹提交到暂存区$ git add . || git add A 把当前仓库中所有最新修改的文件都提交到暂存区$ git status 查看当前文件的状态（红色代表工作区，绿色代表暂存区，看不见东西代表所有东西都已提交到历史区）把暂存区内容提交到历史区$ git commit -m'描述信息'本地版本库回退$ git checkout -- 文件名 回到最近的一次add/commit时的状态$ git reset --hard/mixed/soft HEAD~num --hard 回退全部，包括HEAD，index，working tree --mixed 回退部分，包括HEAD，index --soft 只回退HEAD查看历史版本信息（历史记录）$ git log$ git reflog 包含回滚的信息 可以获得版本号差异比较$ git diff 比较工作区和暂存区$ git diff --cached 比较暂存区和本地库最近一次提交的区别$ git diff HEAD 比较工作区和本地库最近一次提交的区别分支操作$ git branch -d 分支名 删除分支$ git remote push 分支一：分支二 将分支一推给分支二$ git branch 查看现在有哪些分支$ git checkout 分支名 切换到分支$ git checkout -b 分支名 创建并切换到新分支 通过移动head指针来改变版本 一般多分支同时开发，然后由项目组长来分支合并 git小技巧 把一些暂时用不到的修改，暂存起来 GitHub一个网站（开源的代码管理平台），用户注册号，可以在自己账户下创建仓库，用来管理项目的源代码（源代码基于git传到仓库中） 我们所熟知的插件，类库，框架等都在这个平台上有托管，我们可以下载观看和研究源码等 settings用户设置 profile 修改自己的基本信息 account 作用修改用户名 security 可以改自己的密码 emails 私有仓库作为内部团队协作管理的项目 …… new repository -&gt; 填写信息，公私有都免费 -&gt; create repository public 公共开源 private 私有，作为内部团队项目 settings -&gt; 删除仓库 ​ -&gt; collaborators 设置协助开发人员，需对方同意邀请 code可以查看历史版本和分支信息 把本地仓库信息提交到远程仓库 12345678910111213141516171819202122查看本地仓库和哪些远程仓库保持连接$ git remote -v让本地仓库和远程仓库创建一个连接 origin是随便起的一个名字，但一般都用这个$ git remote add origin [仓库地址]$ git remote rename old new 重命名解除关联信息$ git remote rm origin提交之前最好先拉取$ git pull origin master将本地代码提交到远程仓库（第一次需要输入用户名和密码）$ git push origin master将远程仓库代码拉取到本地$ git clone [远程仓库git地址] [别名，默认为仓库名，也可以起一个作为拉取后的文件夹名]/* *真实项目开发流程： * 1.组长或者负责人先创建中央仓库 * 2.小组成员基于$ git clone 把远程仓库及默认的内容克隆到本地（解决了三个事情：初始化一个 本地仓库“git init”，和对应的远程仓库也保持了关联“git remote add”，把远程仓库默认内人拉取到本地 “git pull” * 3.每个组员写自己的程序后，基于“git add/git commit”把自己修改的内容存放到历史区，然后通过 “git pull/git push”把本地信息和远程仓库信息保持同步即可（可能涉及冲突处理） */ NPMnode package manger:NODE模块管理工具，根据NPM我们可快速安装、卸载所需要的资源文件 区NODE官网：下载NODE重启支持版，安装NODE后，NPM也跟着安装了 基于npm是从npmjs.com平台下下载安装 123//在终端中检测安装是否成功，出现版本号即成功了node -vnpm -v 12345678910111213$ npm install xxx 把模块安装在当前项目中（node_modules）$ npm install xxx -g 把模块安装在全局环境中$ npm i xxx@1.0.0 安装指定版本号的模块$ npm view xx version &gt; xxx.version.json 查看某个模块的版本信息（输出到指定json文件中）$ npm init -y 初始化当前项目的配置依赖清单$ npm i xxx -save 把模块保存在清单生产依赖中$ npm i xxx --save-dev 把模块保存在清单开发依赖中$ npm install 跑环境，按照清单安装所需模块$ npm root -g 查看全局安装模块的目录$ npm -uninstall xxx$ npm -uninstall xxx -g 卸载安装过的模块 高级搜索 更多高级搜索]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看过的一些编程书及评价]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8F%8A%E8%AF%84%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[汇编 汇编语言基础教程 James T.Streib整体讲解不够深入，用了很多高级汇编指令，与最初想了解底层如何实现的初衷相违背，并且很多话说的不清楚，很绕。整体学到了一些东西，算是入门了，但整体感觉不好，不推荐。 运维 跟阿铭学linux（第三版）学linux最初的各种命令是看的网课。那几个明明运用及理解都不难的命令，反反复复讲了好长时间，白白浪费了不少时间。我感觉看书来学习linux的各种命令更高效，这本书整体节奏不错，难度感觉略高一点，但认着看，感觉看的很舒服，收货很多。勉强算适合小白吧，我感觉还是有一些对新手不怎么友好的点。 （这本书学习笔记参见）]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出现过的小问题]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[与git相关​ fatal: Not a git repository (or any of the parent directories): .git ​ git init ​ 生成子项目 ​ git submodule add 项目路径 文件路径 与hexo相关常用命令 ​ 清楚缓存 hexo clean ​ 本地检测 hexo s (-p 4001 指定端口，默认4000) （–debug检测） ​ 生成静态文件 hexo g（-w 监视文件变动） ​ 部署 hexo d ​ (hexo clean &amp;&amp; hexo g -d) 与Markdown相关 感觉没有光标移动很不舒服，暂时没找到解决办法 默认开启了拼写检查，很多编程的英文下面都是红线，很难受 文件 -&gt; 偏好设置，下拉就可以找到钱拼写检查 不喜欢默认主题的可以在偏好设置中获取主题 选择自己喜欢的点击download，会给出css源码（有时也会直接给一个压缩文件），自己ctrl A,ctrl C存为一个css文件，导入主题文件夹即可 （从偏好设置中打开主题文件夹，导入即可） 与intellij IDEA相关]]></content>
      <tags>
        <tag>编程</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
