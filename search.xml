<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java入门]]></title>
    <url>%2F2020%2F02%2F13%2Fjava%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java初识发展简史95由sun开发，1.5和1.8是两次较大的版本更新 09年在1.6版本时被Oracle收购 应用各种互联网程序以及服务器后台处理大数据的存储，查询和数据挖掘等 常用DOS命令win+r进入 命令 作用 盘符名: 切换盘符 dir 查看当前文件夹 cd 文件夹名 切换文件夹 cd \ 切换到磁盘根目录 cls 清屏 语言特性跨平台性，通过jvm实现 jdk安装官网下载安装包 设置环境变量JAVA_HOME java安装目录 path中添加 %JAVA_HOME%\bin; Java程序开发 javac xxx.class 编译 java xxx 运行，注意别加后缀 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 每个文件中仅能有一个公共类，且必须与文件名相同 常识main称为主方法，是程序的入口 注释单行 // 多行 /* */ 文档 /** */ 关键字 访问控制 private protected public 类,方法和变量修饰符 abstract class extends final implements interface native new static strictfp synchronized transient volatile 程序控制 break continue return do while if else for instanceof switch case default 错误处理 try catch throw throws 包相关 import package 基本类型 boolean byte char double float int long short null true false 变量引用 super this void 保留字 goto const 标识符命名规则 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 标识符不能以数字开头 标识符不能是关键字 建议 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式） 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式） 变量名规范：全部小写 常量变量名全部大写 类型 含义 数据举例 整数常量 所有的整数 0，1， 567， -9 小数常量 所有的小数 0.0， -0.1， 2.55 字符常量 单引号引起来,只能写一个字符,必须有内容 ‘a’ ， ‘ ‘， ‘好’ 字符串常量 双引号引起来,可以写多个字符,也可以不写 “A” ，”Hello” ，”你好” ，”” 布尔常量 只有两个值 true ， false 空常量 只有一个值 null ASCII码表 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 jshelljdk9提供的，可以方便的进行小片段的代码测试 值传递和引用传递方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值. eg：数组作为方法参数传递，传递的参数是数组内存的地址。 变量的默认值栈中变量(局部变量)没有默认值，必须初始化，堆中变量(new)有默认值 API使用看包(是否需要导包) 看构造 看具体方法 包装类有自动装箱和拆箱的存在，使用很方便 权限修饰符 建以 成员变量使用 private ，隐藏细节。 构造方法使用 public ，方便创建对象。 成员方法使用 public ，方便调用方法。 数据类型分类 基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。 引用数据类型：包括 类 、 数组 、 接口 。 基本数据类型四类八种 数据类型 关键字 内存占用 取值范围 字节型 byte 1 -128~127 短整型 short 2 -32768~32767 整型 int 4 -2的31次方~2的31次方 长整型 long 8 -2的63次方~2的63 单精度浮点数 float 4 1.4013E-45~3.4028E+38 双精度浮点数 double 8 4.9E-324~1.7977E+308 字符型 char 2 0-65535 布尔类型 boolean 1 true，false 变量定义数据类型 变量名 = 数据值; 12345678910111213141516171819202122232425262728public class Variable &#123; public static void main(String[] args)&#123; //定义字节型变量 byte b = 100; System.out.println(b); //定义短整型变量 short s = 1000; System.out.println(s); //定义整型变量 int i = 123456; System.out.println(i); //定义长整型变量 long l = 12345678900L; System.out.println(l); //定义单精度浮点型变量 float f = 5.5F; System.out.println(f); //定义双精度浮点型变量 double d = 8.5; System.out.println(d); //定义布尔型变量 boolean bool = false; System.out.println(bool); //定义字符型变量 char c = 'A'; System.out.println(c); &#125;&#125; 类型转换自动类型转换 将取值范围小的类型自动提升为 取值范围大的类型 注意：是按取值大小来分，eg：float比long所占字节少，但由于是浮点型取值范围更大 byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double byte、short、char 运算时直接提升为 int (类型提升) 1234567891011byte b1 = 1// 由于jvm的优化，都是常量会在运算成一个数后编译，所以不存在类型提升，可以通过byte b3 = 1 + 2// 由于右侧是变量，所以不会优化，编译都无法通过byte b4 = b1 + b3short a = 1// +=是一个运算符，所以不存在类型提升，一切ok a += 1// 这样会被提升为int类型 a = a + 1 强制类型转换数据类型 变量名 = （数据类型）被转数据值; 将 取值范围大的类型 强制转换成 取值范围小的类型 浮点转成整数，直接取消小数点，可能造成数据损失精度 int 强制转成 short 砍掉2个字节，可能造成数据丢失 运算符数值运算(+_*/)，赋值运算(+=,-=,…)，比较运算，逻辑运算(&amp;&amp;,||,!), 三元运算符(数据类型 变量名 = 布尔类型表达式？结果1：结果2) 在运算时可以将数字放大一定倍数来避免小数计算 流程控制语句if语句1234567891011if (判断条件1) &#123; 执行语句1;&#125; else if (判断条件2) &#123; 执行语句2;&#125;...&#125;else if (判断条件n) &#123; 执行语句n;&#125; else &#123; 执行语句n+1;&#125; switch语句1234567891011121314// 表达式类型：byte，short，int，char，enum（枚举），JDK7后可以接收字符串switch(表达式) &#123; case 常量值1: 语句体1; break; case 常量值2: 语句体2; break; ... default: 语句体n+1; // 最后一个break虽说可有可无，但为了保持良好习惯，应该添加 break; &#125; for循环1234// 初始化表达式中的值，仅在for循环内有效for(初始化表达式①; 布尔表达式②; 步进表达式④)&#123; 循环体③&#125; while循环12345初始化表达式①while(布尔表达式②)&#123; 循环体③ 步进表达式④&#125; do-while循环12345初始化表达式①do&#123; 循环体③ 步进表达式④&#125;while(布尔表达式②); 有明确次数时用for 无限循环，但有退出条件用while 最少执行一次用do-while break，continue进行循环控制 方法定义相当于别的语言中的函数 将一些常用的功能抽象为一个方法，便于提高代码的复用 1234修饰符 返回值类型 方法名(参数列表)&#123; 代码... return ;&#125; 方法重载 函数名相同，但参数列表不同，与修饰符和返 回值类型无关 参数列表：个数不同，数据类型不同，顺序不同 重载方法调用：JVM通过方法的参数列表，调用不同的方法。 数组定义容器：是将多个数据存储到一起，每个数据称为该容器的元素。 数组： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 1234567// 数组存储的数据类型[] 数组名字 = new 数组存储的数据类型[长度];int[] arr = new int[3];// 数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;int[] arr = new int[]&#123;1,2,3,4,5&#125;;// 数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;;int[] arr = &#123;1,2,3,4,5&#125;;// 前两种申明和定义可以分开，最后一种必须一体 方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值. 所以数组作为方法参数传递，传递的参数是数组内存的地址。 访问123// 数组名[索引]=数值，为数组中的元素赋值// 变量=数组名[索引]，获取出数组中的元素// 数组名.length 获取数组名中元素个数 内存图 异常 NullPointerException：只定义未申明 ArrayIndexOutOfBoundsException：操作下标越界 常用操作12345678910111213141516171819202122232425262728293031323334353637383940414243// 遍历public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125;// 取出最大元素public static void main(String[] args) &#123; int[] arr = &#123; 5, 15, 2000, 10000, 100, 4000 &#125;; //定义变量，保存数组中0索引的元素 int max = arr[0]; //遍历数组，取出每个元素 for (int i = 0; i &lt; arr.length; i++) &#123; //遍历到的元素和变量max比较 //如果数组元素大于max if (arr[i] &gt; max) &#123; //max记录住大值 max = arr[i]; &#125; &#125; System.out.println("数组最大值是： " + max);&#125;// 反转(双向遍历，交换数据)public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; /* 循环中定义变量min=0最小索引 max=arr.length‐1最大索引 min++,max‐‐ */ for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 面向对象定义Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下， 使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算 机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去 操作实现。 特点封装、继承和多态。 类和对象定义类：是一组相关属性和行为的集合 属性：就是该事物的状态信息 行为：就是该事物能够做什么。 1234public class ClassName &#123; //成员变量 //成员方法&#125; 对象：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性 和行为 123// 类名 对象名 = new 类名();// 对象名.成员变量；// 对象名.成员方法()； 匿名对象new 类名(参数列表)； . 创建匿名对象直接调用方法，没有变量名，对于那些只使用一次的变量(参数，返回值，…) 二者关系类是对一类事物的描述，是抽象的。 对象是一类事物的实例，是具体的。 类是对象的模板，对象是类的实体。 内存图一个对象调用一个方法 两个对象调用一个方法 成员变量和局部变量 在类中的位置不同 成员变量：类中，方法外 局部变量：方法中或者方法声明上(形式参数) 作用范围不一样 成员变量：类中 局部变量：方法中 初始化值的不同 成员变量：有默认值 局部变量：没有默认值，必须先定义，赋值，最后使用 在内存中的位置不同 成员变量：堆内存 局部变量：栈内存 生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 封装定义封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的 方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 原则将属性隐藏起来，若需要访问某个属性，提供公共方法对其访问。 步骤 使用 private 关键字来修饰成员变量。 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。 封装优化 用this来解决命名冲突 方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 提供构造方法 如果你不提供构造方法，系统会给出无参数构造方法 如果你提供了构造方法，系统将不再提供无参数构造方法 构造方法是可以重载的，既可以定义参数，也可以不定义参数 1234// 构造方法无须返回值修饰符 构造方法名(参数列表)&#123; // 方法体&#125; JavaBeanJavaBean 是 Java语言编写类的一种标准规范，可重用的组件 符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无 参数的构造方法，提供用来操作成员变量的 set 和 get 方法。 12345678910public class ClassName&#123; //成员变量 //构造方法 //无参构造方法【必须】 //有参构造方法【建议】 //成员方法 // boolean的get方法为isXxx() //getXxx() //setXxx()&#125; static关键字定义它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。可以不靠创建对象来调用了 类变量 当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改 该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 静态方法 当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用 静态方法可以直接访问类变量和静态方法 静态方法不能直接访问普通成员变量或成员方法。但反之，成员方法可以直接访问类变量或静态方法 原因：内存中先加载静态方法，实例化时再加载成员方法 静态方法中，不能使用this关键字 静态代码块 位置：类中方法外 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行 作用：用于变量的初始化赋值 123456789101112public class Game &#123; public static int number; public static ArrayList&lt;String&gt; list; static &#123; // 给类变量赋值 number = 2; list = new ArrayList&lt;String&gt;(); // 添加元素到集合中 list.add("张三"); list.add("李四"); &#125;&#125; 继承定义由来：多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要 继承那一个类即可 子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为 提高代码重用性 类与类之间产生了关系，是多态的前提 特点 java只支持单继承，但支持多层继承 接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰 接口中，没有构造方法，不能创建对象 接口中，没有静态代码块。 成员变量的访问子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 super 关键字，修饰 父类成员变量 成员方法的访问子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效 果，也称为重写或者复写。声明不变，重新实现。 通过重写，可以实现子类对父类方法的拓展 12345678@override // 对是否重写做检验public void showNum()&#123; //调用父类已经存在的功能使用super 在原基础上扩展 super.showNum(); //增加自己特有显示姓名和图片功能 System.out.println("显示来电姓名"); System.out.println("显示头像");&#125; 注意 子类方法覆盖父类方法，必须要保证权限大于等于父类权限，一般采用相同权限 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。 构造方法123456789class Zi extends Fu &#123; Zi()&#123; // super（），调用父类构造方法 // 子类的每个构造方法中有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super() // super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 super(); System.out.println("Zi（）"); &#125;&#125; super ：代表父类的存储空间标识(可以理解为父亲的引用)。 super(…) super.成员方法名() super.成员变量 this ：代表当前对象的引用(谁调用就代表谁)。 抽象类定义抽象方法 ： 没有方法体的方法，只有声明，没有实现 抽象类：用abstract修饰的类，不必须包含抽象方法，只要不想让该方法可以直接实例化，即可声明为抽象类 1234public abstract class Animal &#123; // 修饰符 abstract 返回值类型 方法名 (参数列表)； public abstract void run()；&#125; 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。 抽象类不能实例化 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类 抽象类的子类，必须重写抽象父类中所有的抽象方法，除非该子类也是抽象类 接口定义接口，是Java语言中一种引用类型，是方法的集合，接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法 （JDK 9）。 接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并 不是类，而是另外一种引用数据类型。 引用数据类型：数组，类，接口。 接口的使用，它不能创建对象，但是可以被实现（ implements）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。 123456789101112131415161718public interface 接口名称 &#123; // 抽象方法 public abstract void method(); // 默认方法 用于接口功能扩展，如果再加抽象方法，使用实现类都得改，当然子类也可以重写 public default void method() &#123; // 执行语句 &#125; // 静态方法 供接口直接调用，子类无法继承亦无法调用 public static void method2() &#123; // 执行语句 &#125; // 私有方法 用于将默认方法中的重复代码抽取 // 私有方法：只有默认方法可以调用。 // 私有静态方法：默认方法和静态方法可以调用。 private void method() &#123; // 执行语句 &#125;&#125; 多实现12345class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... &#123; // 重写接口中抽象方法【必须】 如果抽象方法有重名的，只需要重写一次。 // 如果默认方法有重名的，必须重写一次，不重名时随意 // 存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法&#125; 优先级当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执 行父类的成员方法。 123456789101112131415161718192021interface A &#123; public default void methodA()&#123; System.out.println("AAAAAAAAAAAA"); &#125;&#125;class D &#123; public void methodA()&#123; System.out.println("DDDDDDDDDDDD"); &#125;&#125;class C extends D implements A &#123; // 未重写methodA方法&#125;public class Test &#123; public static void main(String[] args) &#123; C c = new C(); c.methodA(); &#125;&#125;输出结果:DDDDDDDDDDDD 接口的多继承一个接口能继承另一个或者多个接口，和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继 承父接口的方法。如果父接口中的默认方法有重名的，那么子接口需要重写一次 子接口重写默认方法时，default关键字可以保留 子类重写默认方法时，default关键字不可以保留 多态定义多态： 是指同一行为，具有多个不同表现形式。(单一的父类来接收多种多样的子类) 12345// 父类类型：指子类对象继承的父类类型，或者实现的父接口类型。// 父类类型 变量名 = new 子类对象；// 变量名.方法名();Fu f = new Zi();f.method(); 前提 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 特点当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写 后方法 编译看左，运行看右 好处可以使程序编写的更简单，并有良好的扩展 引用类型转换 向上转型 多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的 12// 父类类型 变量名 = new 子类类型();Animal a = new Cat(); 向下转型 父类类型向子类类型向下转换的过程，这个过程是强制的。 123456789101112131415161718192021// 为了调用子类特有的方法// 子类类型 变量名 = (子类类型) 父类变量名;Cat c =(Cat) a;// 经常面临ClassCastException// 变量名 instanceof 数据类型// 如果变量属于该数据类型，返回true。// 如果变量不属于该数据类型，返回false。public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat)&#123; Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog)&#123; Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse &#125;&#125; final定义final： 不可改变。可以用于修饰类、方法和变量。变量名一般全大写 类：被修饰的类，不能被继承。 方法：被修饰的方法，不能被重写。 变量：被修饰的变量，不能被重新赋值。 初始化 基本类型的变量被final修饰后仅能赋值一次 成员变量涉及到初始化的问题，初始化方式有两种，必须二选一 1234567891011121314// 显示初始化；public class User &#123; final String USERNAME = "张三"; private int age;&#125;// 构造方法初始化。public class User &#123; final String USERNAME ; private int age; public User(String username, int age) &#123; this.USERNAME = username; this.age = age; &#125;&#125; 引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的 修改 常用类Scanner类12345678910111213//1. 导包import java.util.Scanner;public class Demo01_Scanner &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Scanner sc = new Scanner(System.in); //3. 接收数据 System.out.println("请录入一个整数："); int i = sc.nextInt(); //4. 输出数据 System.out.println("i:"+i); &#125;&#125; Random类123456789101112131415//1. 导包import java.util.Random; public class Demo01_Random &#123; public static void main(String[] args) &#123; //2. 创建键盘录入数据的对象 Random r = new Random(); for(int i = 0; i &lt; 3; i++)&#123; //3. 随机生成一个数据 // 可以通过平移和伸缩来实现输出任意范围随机数 int number = r.nextInt(10); //4. 输出数据 System.out.println("number:"+ number); &#125; &#125;&#125; ArrayList类缘起而数组的长度是固定的，无法适应数据变化的需 求。为了解决这个问题，Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对 象数据。 定义java.util.ArrayList 是大小可变的数组的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储 的元素。 ArrayList 中可自动扩容 123456// 创建 jdk1.7之后右侧&lt;&gt;可以留空ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();public boolean add(E e) // 将指定的元素添加到此集合的尾部。public E remove(int index) // 移除此集合中指定位置上的元素。返回被删除的元素。public E get(int index) // 返回此集合中指定位置上的元素。返回获取的元素。public int size() // 返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。 ArrayList对象不能存储基本类型，只能存储引用类型的数据。所以需要存入对应的包装类 String类定义Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。 特点 字符串不变：字符串的值在创建后不能被更改。但凡改变，必定是生成了新的字符串 因为String对象是不可变的，所以它们可以被共享。 类似于python中的缓存机制，java中应该被称为常量池 “abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 123456例如：String str = "abc";相当于：char data[] = &#123;'a', 'b', 'c'&#125;;String str = new String(data);// String底层是靠字符数组实现的。 构造12345678// 无参构造String str = new String（）；// 通过字符数组构造char chars[] = &#123;'a', 'b', 'c'&#125;;String str2 = new String(chars);// 通过字节数组构造byte bytes[] = &#123; 97, 98, 99 &#125;;String str3 = new String(bytes); 常用方法123456789101112131415161718192021222324252627282930// 判断public boolean equals (Object anObject) // 将此字符串与指定对象进行比较。public boolean equalsIgnoreCase (String anotherString) // 将此字符串与指定对象进行比较，忽略大小写。public int length () // 返回此字符串的长度。// 获取public String concat (String str) // 将指定的字符串连接到该字符串的末尾。public char charAt (int index) // 按索引取char值public int indexOf (String str) // 返回指定子字符串第一次出现在该字符串内的索引。public String substring (int beginIndex) // 返回一个子字符串，从beginIndex开始截取字符串到字符 类似切片串结尾。public String substring (int beginIndex, int endIndex) // 返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。// 转换public char[] toCharArray () // 将此字符串转换为新的字符数组。public byte[] getBytes () // 使用平台的默认字符集将该 String编码转换为新的字节数组。public String replace (CharSequence target, CharSequence replacement) // 将与target匹配的字符串使用replacement字符串替换。// 分割public String[] split(String regex) // 将此字符串按照给定的regex（规则）拆分为字符串数组。 Arrays类java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法 123456789101112public static String toString(int[] a) // 返回指定数组内容的字符串表示形式public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;2,34,35,4,657,8,69,9&#125;; // 打印数组,输出地址值 System.out.println(arr); // [I@2ac1fdc4 // 数组内容转为字符串 String s = Arrays.toString(arr); // 打印字符串,输出内容 System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9]&#125;public static void sort(int[] a) // 对指定的 int 型数组按数字升序进行排序，改变原数组 Math类java.lang.Math 类包含用于执行基本数学运算的方法，其所有方法均为静态方法 1234public static double abs(double a) ：返回 double 值的绝对值public static double ceil(double a) ：返回大于等于参数的最小的整数public static double floor(double a) ：返回小于等于参数最大的整数public static long round(double a) ：返回最接近参数的 long。(相当于四舍五入方法)]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven使用]]></title>
    <url>%2F2020%2F02%2F11%2Fmaven%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[用处 jar包管理 一键编译 一键测试 一键部署 依赖管理maven工程对jar包的管理过程，实现了jar包的重用 安装去官网解压到一个路径下即可 添加环境变量 path中添加 maven运行依赖于JAVA_HOME变量 本地仓库 目录结构 pom文件结构 常用命令 idea集成maven确认下电脑上是否安装好了maven setting中配置如下信息 -DarchetypeCatalog=internal 创建java项目 web项目所用的骨架 把没有提供全的目录自己添加一下，一般java项目不需要用骨架 jar包添加本地添加 scope标签作用：有些jar包仅在编译时需要 包名 作用域 servlet provided jsp provided junit test mysql runtime 中央仓库添加 运行环境修改 可以将常用的添加为模板 先添加一个组]]></content>
      <tags>
        <tag>maven</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python例题]]></title>
    <url>%2F2020%2F02%2F10%2Fpython%E4%BE%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[函数12345678func_list = []for i in range(10): func_list.append(lambda x:x+i)for i in range(0,len(func_list)): result = func_list[i](i) print(result) lambda返回的是个函数地址，且里面各变量在真正执行前都是保存着地址 通过闭包保存传入的参数，其余变量则在命名空间中寻找 12345678910def func(name): v = lambda x: x + name return vv1 = func('太白')v2 = func('alex')v3 = v1('银角')v4 = v2('金角')print(v1, v2, v3, v4)]]></content>
      <tags>
        <tag>python</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础]]></title>
    <url>%2F2020%2F02%2F01%2Fpython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[常识计算机基本组件cpu计算机的运算和计算中心 人类一秒，可以运行10亿条指令，比内存快百度，硬盘快百万倍 内存暂时存储数据，临时加载数据应用程序，分为RAM，ROM 硬盘长期存储数据 操作系统一个软件，连接计算机的硬件与所有软件之间的一个软件 python历史python崇尚优雅，简洁 2和3有较多区别 python的种类 Cpython：官方推荐解释器。可以转化成C语言能识别的字节码。 Jpython: 可以转化成Java语言能识别的字节码。 Ironpython：可以转化成.net语言能识别的字节码 pypy: 动态编译 编程语言分类编译型​ 将代码一次性全部编译成二进制，然后再执行。 ​ 优点：执行效率高。 ​ 缺点：开发效率低，不能跨平台。 ​ 代表语言：C 解释型​ 逐行解释成二进制，逐行运行。 ​ 优点：开发效率高，可以跨平台。 ​ 缺点：执行效率低。 ​ 代表语言：python 变量相当于为对应内存空间起别名，不同类型变量为不同大小内存块或有不同作用 变量命名 变量全部由数字，字母下划线任意组合。 不能以数字开头。 不能是python的关键字。 [‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’, ‘del’, ‘elif’, ‘else’, ‘except’, ‘exec’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘not’, ‘or’, ‘pass’, ‘print’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’] 要具有描述性。name= ‘太白金星’ sex 不能使用中文。 不能过长。 推荐 驼峰体：AgeOfOldboy = 73 下划线：age_of_oldboy = 73 常量代指生活中一直不变的 python中没有真正的常量，为了应和其他语言的口味，全部大写的变量称之为常量。所以是一种约定俗成的东西，没有实际约束。将变量名全部大写，放在文件的最上面 注释便于你理解对方的代码，自己的代码。 单行注释： # 多行注释： ‘’’被注释内容’’’ “””被注释内容””” 运算符算数运算以下假设变量：a=10，b=20 / 是除法，例如：2/3 = 0.6666。而//是表示向下取整的除法，例如3//2=1，6.0//4 = 1。也就是说 / 返回的是浮点类型的结果， 而 // 返回的是整数结果(可以理解为/的整数部分) 比较运算以下假设变量：a=10，b=20 赋值运算以下假设变量：a=10，b=20 逻辑运算 断路与或 x or y , x为真，值就是x，x为假，值是y x and y, x为真，值是y,x为假，值是x。 成员运算判断子元素是否在原字符串（字典，列表，集合）中 123print('喜欢' in 'dkfljadklf喜欢hfjdkas')print('a' in 'bcvd')print('y' not in 'ofkjdslaf') 三目运算符123456max = a if a &gt; b else b# 两者等价if a &gt; b: max = aelse: max = b Python运算符优先级 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 &gt;&gt; &lt;&lt; 右移，左移运算符 &amp; 位 ‘AND’ ^ | 位运算符 &lt;= &lt; &gt; &gt;= 比较运算符 &lt;&gt; == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 pass语句Python pass 是空语句，是为了保持程序结构的完整性。 pass 不做任何事情，一般用做占位语句。 id()返回输入对象的内存地址 is和==12a is b # 比较内存地址a == b # 比较值 基本数据类型分类 不可变（可哈希）的数据类型：int，str，bool，tuple。 可变（不可哈希）的数据类型：list，dict，set。 int不同进制间转化 方法 名称 作用 bit_length(self) 转为对应二进制后有效位的长度 bool常用于条件 while 1：比while True：更高效 str12345678# 由单(双)引号引起# 三引号：带换行的字符串 msg = ''' 今天我想写首小诗， 歌颂我的同桌， 你看他那乌黑的短发， 好像一只炸毛鸡。 ''' 格式化输出 法一 符号 指代 %s str %d digit %i int %r 输出时对应字符串带引号 %% 普通%号 123456789101112131415name = input("Name:")age = input("Age:")job = input("Job:")hobbie = input("Hobbie:")info = '''------------ info of %s ----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 name Name : %s #代表 name Age : %s #代表 age job : %s #代表 job Hobbie: %s #代表 hobbie ------------- end -----------------''' %(name,name,age,job,hobbie) # 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来 # %%来输出普通百分号print(info) 法二 123res='&#123;&#125; &#123;&#125; &#123;&#125;'.format('egon',18,'male')res='&#123;1&#125; &#123;0&#125; &#123;1&#125;'.format('egon',18,'male')res='&#123;name&#125; &#123;age&#125; &#123;sex&#125;'.format(sex='male',name='egon',age=18) 法三 f-strings 是python3.6开始加入标准库的格式化输出新的写法，这个格式化输出比之前的%s 或者 format 效率高并且更加简化，非常的好用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 任意表达式print(f'&#123;3*21&#125;') # 63name = 'barry'print(f"全部大写：&#123;name.upper()&#125;") # 全部大写：BARRY# 字典也可以teacher = &#123;'name': '太白金星', 'age': 18&#125;msg = f"The teacher is &#123;teacher['name']&#125;, aged &#123;teacher['age']&#125;"print(msg) # The comedian is 太白金星, aged 18# 列表也行l1 = ['太白金星', 18]msg = f'姓名：&#123;l1[0]&#125;,年龄：&#123;l1[1]&#125;.'print(msg) # 姓名：太白金星,年龄：18.# 用函数完成相应的功能，然后将返回值返回到字符串相应的位置def sum_a_b(a,b): return a + ba = 1b = 2print('求和的结果为' + f'&#123;sum_a_b(a,b)&#125;')# 多行name = 'barry'age = 18ajd = 'handsome'speaker = f'''Hi &#123;name&#125;.You are &#123;age&#125; years old.You are a &#123;ajd&#125; guy!'''speaker = f'Hi &#123;name&#125;.'\ f'You are &#123;age&#125; years old.'\ f'You are a &#123;ajd&#125; guy!'print(speaker)# 一些细节print(f"&#123;&#123;73&#125;&#125;") # &#123;73&#125;print(f"&#123;&#123;&#123;73&#125;&#125;&#125;") # &#123;73&#125;print(f"&#123;&#123;&#123;&#123;73&#125;&#125;&#125;&#125;") # &#123;&#123;73&#125;&#125;m = 21# ! , : &#123; &#125; ;这些标点不能出现在&#123;&#125; 这里面。# print(f'&#123;;12&#125;') # 报错# 所以使用lambda 表达式会出现一些问题。# 解决方式：可将lambda嵌套在圆括号里面解决此问题。x = 5print(f'&#123;(lambda x: x*2) (x)&#125;') # 10 索引按下标取值，从零开始 切片通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串 左闭右开 1234567a = 'ABCDEFGHIJK'print(a[0:3]) # print(a[:3]) 从开头开始取0可以默认不写print(a[2:5])print(a[:]) #默认到最后print(a[:-1]) # -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素print(a[:5:2]) #加步长print(a[-1:-5:-2]) #反向加步长 常用方法 方法名 作用 upper(self) 转为大写 lower(self) 转为小写 count(str,i,j) 从i到j的切片中str出现了几次 startswith(str,i,j) 从i到j，是不是str，不写i，j时从头匹配 endswith(str,i,j) 从i到j，是不是str，不写i，j时从尾匹配 replace(str,i) 默认全部替换，i可以指定替换个数 strip() 去除空拍字符(\t,\n,空格)，从左右两边开始删到都一个非空白为止 lstrip() 删左侧 rstrip() 删右侧 strip(str) 去除在str中的字符 isalnum() 字符串由字母或数字组成 isalpha() 字符串只由字母组成 isdecimal() 字符串只由十进制组成 len(str) 获取数据的元素个数 12345678910111213141516171819202122232425262728293031# split 以什么分割，最终形成一个列表此列表不含有这个分割的元素。ret9 = 'title,Tilte,atre,'.split('t')print(ret9)ret91 = 'title,Tilte,atre,'.rsplit('t',1)print(ret91)# join 与split相对，若是str则以每个元素都以指定字符连接，多是给链表使用s1 = "advewvbe"s2 = "+".join(s1)# a+d+v+e+w+v+b+el1 = ["2","chjs","你好"]l2 = ":".join(l1)# 2:chjs:你好# 列表中元素必须全是字#寻找字符串中的元素是否存在ret6 = a4.find("fjdk",1,6)print(ret6) # 返回的找到的元素的索引，如果找不到返回-1ret61 = a4.index("fjdk",4,6)print(ret61) # 返回的找到的元素的索引，找不到报错。#captalize,swapcase,titleprint(name.capitalize()) #首字母大写print(name.swapcase()) #大小写翻转msg='taibai say hi'print(msg.title()) #每个单词的首字母大写# 内同居中，总长度，空白处填充ret2 = a1.center(20,"*")print(ret2) listl1 = [100, ‘alex’,True,[1, 2, 3]] 承载任意数据类型，存储大量的数据 python常用的容器型数据类型。相当于其他语言的数组 列表是有序的，可索引，切片（步长） 切片，索引同str 列表的创建123456789101112131415161718# 列表的创建# 方式一# l1 = [1, 2, 'Alex']# 方式二 对可迭代的数据类型# l1 = list()# l1 = list('fhdsjkafsdafhsdfhsdaf')# print(l1)# ['f', 'h', 'd', 's', 'j', 'k', 'h', 's', 'd', 'a', 'f']# 方式三：列表推导式# [i(对i的简单处理) 循环(可多层，但一般最多两到三层) 条件]# 循环模式 [变量(加工的变量) for 变量 in iterable]# 多层循环 [变量(加工的变量) for i in iterable for j in iterable]l1 = [i for i in range(1,5)]print(l1) # [1, 2, 3, 4]l2 = [i for i in range(2,11)] + list("JQKA") #扑克(不完整)# 筛选模式 [变量(加工的变量) for 变量 in iterable if 条件] 列表的增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 增删改查l1 = ['太白', '女神', 'xiao','吴老师', '闫龙']# 增：# append:追加# l1.append('xx')# print(l1)# insert 插入# l1.insert(2,'wusir')# print(l1)#extend 迭代着追加# l1.extend('abcd')# l1.extend(['alex',])# l1.extend(['alex', 1, 3])# print(l1)# 删# pop 按照索引位置删除，返回的是删除的元素# l1.pop(-2) # 按照索引删除# print(l1.pop(-2))# l1.pop() # 默认删除最后一个# print(l1)# remove 指定元素删除,如果有重名元素，默认删除从左数第一个# l1.remove('xiao')# print(l1)# clear(了解)# l1.clear() # 清空# print(l1)# del # 按照索引删除 # del l1[-1] # print(l1) # 按照切片(步长)删除 # del l1[::2] # print(l1)# 改 # 按照索引改值 # l1[0] = '男神' # 按照切片改（了解） 整个切片替换 # l1[2:] = 'fsdafsdafsdfdsfsadfdsfdsgsfdag' # print(l1) # 按照切片（步长） 逐个替换，对应个数必须相同 # l1[::2] = 'abc' # l1[::2] = 'abcd' # print(l1)# 查：# 索引，切片（步长）# for i in l1:# print(i) 列表相加或相乘1234l1 = [1, 2, 3]l2 = [4, 5, 6]# print(l1+l2) # [1, 2, 3, 4, 5, 6]print(l1*3) # [1, 2, 3, 1, 2, 3, 1, 2, 3] 其他操作count（数）（方法统计某个元素在列表中出现的次数）。 12a = ["q","w","q","r","t","y"]print(a.count("q")) index（方法用于从列表中找出某个值第一个匹配项的索引位置） 12a = ["q","w","r","t","y"]print(a.index("r")) sort （方法用于在原位置对列表进行排序） reverse （方法将列表中的元素反向存放） 123456a = [2,1,3,4,5]a.sort()# 他没有返回值，所以只能打印aa.sort(reverse=True)# 默认单增，这样可以单减print(a)a.reverse()#他也没有返回值，所以只能打印aprint(a) 列表的嵌套相当于多维数组 12345l1 = [1, 2, 'taibai', [1, 'alex', 3,]]# 1, 将l1中的'taibai'变成大写并放回原处。# 2，给小列表[1,'alex',3,]追加一个元素,'老男孩教育'。l1[3] = l1[3].append("老男孩教育")# 3，将列表中的'alex'通过字符串拼接的方式在列表中变成'alexsb' 循环列表，改变列表大小的问题用这个进行举例：当你循环到22时，你将列表中的22删除了，但是你带来的影响是：33,44,55都会往前进一位，他们的索引由原来的2,3,4变成了1,2,3 所以你在往下进行循环时，就会发现，额……..完全不对了 所以for循环遍历本质是在按索引遍历，正序遍历时删除元素会打乱原有顺序 12345l1 = [11,22,33,44,55]for index in len(l1): if index % 2 == 1: l1.pop(index)# [11,33,44] 直接删除 12l1 = [11,22,33,44,55]del l1[1::2] 倒序删除 1234l1 = [11,22,33,44,55]for i in range(len(l1)-1:-1:-1): if i % 2 == 1: l1.pop(i) 思维转换 123456l1 = [11,22,33,44,55]new_l1 = []for i in len(l1): if i % 2 == 0: new_l1.append(i)l1 = new_l1 循环一个列表时最好不要改变列表的大小，容易出现错误 必须修改时可以用上诉三种方法 tuple俗称不可变的列表,又被成为只读列表,也是python的基本数据类型之一,用小括号括起来,里面可以放任何数据类型的数据,查询可以,循环也可以,切片也可以.但就是不能改. 当元组中包含可变类型时，其仍可变，如包含链表时，该链表仍可修改 python中元组有一个特性，元组中如果只含有一个元素且没有逗号，则该元组不是元组，与改元素数据类型一致，如果有逗号，那么它是元组 拆包专用，虽然链表也可以拆 拆包(分别赋值)123456789101112131415161718192021a,b = 1,2print(a,b)结果:2a,b = ('你好','世界') # 这个用专业名词就叫做元组的拆包print(a,b)结果:你好 世界a,b = ['你好','大飞哥']print(a,b)结果:你好 世界a,b = &#123;'汪峰':'北京北京','王菲':'天后'&#125;print(a,b)结果:汪峰 王菲 索引和切片1234567tu1 = ('a', 'b', '太白', 3, 666)print(tu1[0]) # 'a'print(tu1[-1]) # 666print(tu1[1:3]) # ('b', '太白')print(tu1[:-1]) # ('a', 'b', '太白', 3)print(tu1[::2]) # ('a', '太白', 666)print(tu1[::-1]) # (666, 3, '太白', 'b', 'a') 其他操作因为元组的特性，直接从属于元组的元素不能更改，所以元组只能查看。 12345# 可以利用for循环查询tu1 = ('a', 'b', '太白', 3, 666)for i in tu1: print(i) index：通过元素找索引（可切片），找到第一个元素就返回，找不到该元素即报错。 12tu = ('太白', [1, 2, 3, ], 'WuSir', '女神')print(tu.index('太白')) # 0 count: 获取某元素在列表中出现的次数 12tu = ('太白', '太白', 'WuSir', '吴超')print(tu.count('太白')) # 2 dict字典是Python语言中的映射类型，他是以{}括起来，里面的内容是以键值对的形式储存的： Key: 不可变（可哈希）的数据类型.并且键是唯一的，不重复的。 Value:任意数据(int，str，bool，tuple，list，dict，set)，包括后面要学的实例对象等。 在Python3.5版本（包括此版本）之前，字典是无序的。 在Python3.6版本之后，字典会按照初建字典时的顺序排列(即第一次插入数据的顺序排序)。 当然，字典也有缺点：他的缺点就是内存消耗巨大。 为何查询快？底层用了散列表 创建方式1234567891011121314151617181920212223242526272829303132333435363738394041# 方式1: 元组dic = dict((('one', 1),('two', 2),('three', 3)))# dic = dict([('one', 1),('two', 2),('three', 3)])print(dic) # &#123;'one': 1, 'two': 2, 'three': 3&#125;# 方式2: 关键字dic = dict(one=1,two=2,three=3)print(dic) # &#123;'one': 1, 'two': 2, 'three': 3&#125;# 方式3: 键值对dic = dict(&#123;'one': 1, 'two': 2, 'three': 3&#125;)print(dic) # &#123;'one': 1, 'two': 2, 'three': 3&#125;# 方式5: 内置函数zipdic = dict(zip(['one', 'two', 'three'],[1, 2, 3]))print(dic)# 方式6: 字典推导式dic = &#123; k: v for k,v in [('one', 1),('two', 2),('three', 3)]&#125;print(dic)# 方式7: 利用fromkey("keys(可迭代类型)","所有键共用的值")dic = dict.fromkeys('abcd','太白')print(dic) # &#123;'a': '太白', 'b': '太白', 'c': '太白', 'd': '太白'&#125;dic = dict.fromkeys([1, 2, 3],'太白')print(dic) # &#123;1: '太白', 2: '太白', 3: '太白'&#125; # 这里有一个坑，就是如果通过fromkeys得到的字典的值为可变的数据类型，那么你的小心了。dic = dict.fromkeys([1, 2, 3], [])dic[1].append(666)print(id(dic[1]),id(dic[2]),id(dic[3])) # &#123;1: [666], 2: [666], 3: [666]&#125;print(dic) # &#123;1: [666], 2: [666], 3: [666]&#125;# 字典推导式lst1 = ['jay','jj','meet']lst2 = ['周杰伦','林俊杰','郭宝元']dic = &#123;lst1[i]:lst2[i] for i in range(len(lst1))&#125;print(dic) 增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# 增 # 通过键值对直接增加 有则改之，无则增加 dic = &#123;'name': '太白', 'age': 18&#125; dic['weight'] = 75 # 没有weight这个键，就增加键值对 print(dic) # &#123;'name': '太白', 'age': 18, 'weight': 75&#125; dic['name'] = 'barry' # 有name这个键，就成了字典的改值 print(dic) # &#123;'name': 'barry', 'age': 18, 'weight': 75&#125; # setdefault 有则不变，无则加之 dic = &#123;'name': '太白', 'age': 18&#125; dic.setdefault('height',175) # 没有height此键，则添加 print(dic) # &#123;'name': '太白', 'age': 18, 'height': 175&#125; dic.setdefault('name','barry') # 有此键则不变 print(dic) # &#123;'name': '太白', 'age': 18, 'height': 175&#125; #它有返回值 可用于查看 dic = &#123;'name': '太白', 'age': 18&#125; ret = dic.setdefault('name') print(ret) # 太白# 删 # pop 通过key删除字典的键值对，有返回值，可设置返回值。 dic = &#123;'name': '太白', 'age': 18&#125; # ret = dic.pop('name') # print(ret,dic) # 太白 &#123;'age': 18&#125; ret1 = dic.pop('n',None) print(ret1,dic) # None &#123;'name': '太白', 'age': 18&#125; #popitem 3.5版本之前，popitem为随机删除，3.6之后为删除最后一个，有返回值 dic = &#123;'name': '太白', 'age': 18&#125; ret = dic.popitem() print(ret,dic) # ('age', 18) &#123;'name': '太白'&#125; # 值可以重复，所以不像其他有remove方法 # clear 清空字典 dic = &#123;'name': '太白', 'age': 18&#125; dic.clear() print(dic) # &#123;&#125; # del # 通过键删除键值对 dic = &#123;'name': '太白', 'age': 18&#125; del dic['name'] print(dic) # &#123;'age': 18&#125; #删除整个字典 del dic# 改 # 通过键值对直接改 dic = &#123;'name': '太白', 'age': 18&#125; dic['name'] = 'barry' print(dic) # &#123;'name': 'barry', 'age': 18&#125; # update 类似于创建字典 dic = &#123;'name': '太白', 'age': 18&#125; dic.update(sex='男', height=175) print(dic) # &#123;'name': '太白', 'age': 18, 'sex': '男', 'height': 175&#125; dic = &#123;'name': '太白', 'age': 18&#125; dic.update([(1, 'a'),(2, 'b'),(3, 'c'),(4, 'd')]) print(dic) # &#123;'name': '太白', 'age': 18, 1: 'a', 2: 'b', 3: 'c', 4: 'd'&#125; # 有则加之，无则不变 dic1 = &#123;"name":"jin","age":18,"sex":"male"&#125; dic2 = &#123;"name":"alex","weight":75&#125; dic1.update(dic2) print(dic1) # &#123;'name': 'alex', 'age': 18, 'sex': 'male', 'weight': 75&#125; print(dic2) # &#123;'name': 'alex', 'weight': 75&#125; # 查 # 通过键查询 # 直接dic[key](没有此键会报错) dic = &#123;'name': '太白', 'age': 18&#125; print(dic['name']) # 太白 # get dic = &#123;'name': '太白', 'age': 18&#125; v = dic.get('name') print(v) # '太白' v = dic.get('name1') print(v) # None v = dic.get('name2','没有此键') print(v) # 没有此键 keys() dic = &#123;'name': '太白', 'age': 18&#125; print(dic.keys()) # dict_keys(['name', 'age']) values() dic = &#123;'name': '太白', 'age': 18&#125; print(dic.values()) # dict_values(['太白', 18]) items() dic = &#123;'name': '太白', 'age': 18&#125; print(dic.items()) # dict_items([('name', '太白'), ('age', 18)]) """ dict_keys(['name', 'age']) dict_values(['太白', 18]) dict_items([('name', '太白'), ('age', 18)]) 这些高仿的列表可以用于for循环，亦可传入list()来转换为真正的列表 """ 字典的嵌套循环字典，改变字典大小的问题来，先来研究一个小题，有如下字典： dic = {‘k1’:’太白’,’k2’:’barry’,’k3’: ‘白白’, ‘age’: 18} 请将字典中所有键带k元素的键值对删除。 12345678910dic = &#123;'k1':'太白','k2':'barry','k3': '白白', 'age': 18&#125;for i in dic: if 'k' in i: del dic[i]print(dic)# 你会发现，报错了。。。。。# 错误原因：# RuntimeError: dictionary changed size during iteration# 翻译过来是：字典在循环迭代时，改变了大小。 所以说，他和列表差不多，只不过比列表更暴力一些，对其进行总结就是： 在循环一个字典的过程中，不要改变字典的大小（增，删字典的元素），这样会直接报错。 思维转换 1234567l1 = []dic = &#123;'k1':'太白','k2':'barry','k3': '白白', 'age': 18&#125;for key in dic: if 'k' in key: l1.append(i)for i in l1: dic.pop(i) 简化 1234dic = &#123;'k1':'太白','k2':'barry','k3': '白白', 'age': 18&#125;for key in list(dic.keys()): if 'k' in key: dic.pop(key) set集合是无序的，不重复的数据集合 它里面的元素是可哈希的(不可变类型)，但是集合本身不可哈希（所以集合做不了字典的键） 以下是集合最重要的两点： 去重，把一个列表变成集合，就自动去重了。 关系测试，测试两组数据之前的交集、差集、并集等关系。 创建123456789# 一set1 = set(&#123;1,2,'barry'&#125;)# 二set2 = &#123;1,2,'barry'&#125;print(set1,set2) # &#123;1, 2, 'barry'&#125; &#123;1, 2, 'barry'&#125;# 集合推导式lst = [1,2,3,-1,-3,-7,9]s = &#123;abs(i) for i in lst&#125;print(s) 增删改查12345678910111213141516171819202122232425262728 # 增 set1 = &#123;'alex','wusir','ritian','egon','barry'&#125; set1.add('景女神') print(set1) #update：迭代着增加 set1.update('A') print(set1) set1.update('老师') print(set1) set1.update([1,2,3]) print(set1)# 删 set1 = &#123;'alex','wusir','ritian','egon','barry'&#125; # 因为无序，所以没有按所以删除 set1.remove('alex') # 按内容删 print(set1) set1.pop() # 随机删除一个元素 print(set1) set1.clear() # 清空集合 print(set1) del set1 # 删除集合 print(set1)# 无序，所以无法改查# 但改可以通过先把要改元素删除，再把要改成的数据作为新值加入 集合的其他操作4.1 交集。（&amp; 或者 intersection） 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 &amp; set2) # &#123;4, 5&#125;print(set1.intersection(set2)) # &#123;4, 5&#125; 4.2 并集。（| 或者 union） 123set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 | set2) # &#123;1, 2, 3, 4, 5, 6, 7,8&#125;print(set2.union(set1)) # &#123;1, 2, 3, 4, 5, 6, 7,8&#125; 4.3 差集。（- 或者 difference） 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 - set2) # &#123;1, 2, 3&#125;print(set1.difference(set2)) # &#123;1, 2, 3&#125; 4.4反交集。 （^ 或者 symmetric_difference） 排斥或 1234set1 = &#123;1,2,3,4,5&#125;set2 = &#123;4,5,6,7,8&#125;print(set1 ^ set2) # &#123;1, 2, 3, 6, 7, 8&#125;print(set1.symmetric_difference(set2)) # &#123;1, 2, 3, 6, 7, 8&#125; 4.5子集与超集 12345678set1 = &#123;1,2,3&#125;set2 = &#123;1,2,3,4,5,6&#125;print(set1 &lt; set2)print(set1.issubset(set2)) # 这两个相同，都是说明set1是set2子集。print(set2 &gt; set1)print(set2.issuperset(set1)) # 这两个相同，都是说明set2是set1超集。 5，frozenset不可变集合，让集合变成不可变类型。 12s = frozenset('barry')print(s,type(s)) # frozenset(&#123;'a', 'y', 'b', 'r'&#125;) &lt;class 'frozenset'&gt; 数据类型转化bool，int，str互化12345678910111213141516171819202122232425262728# int ---&gt; booli = 100print(bool(i)) # True # 非零即Truei1 = 0print(bool(i1)) # False 零即False# bool ---&gt; intt = Trueprint(int(t)) # 1 True --&gt; 1t = Falseprint(int(t)) # 0 False --&gt; 0# int ---&gt; stri1 = 100print(str(i1)) # '100'# str ---&gt; int # 全部由数字组成的字符串才可以转化成数字s1 = '90'print(int(s1)) # 90# str ---&gt; bools1 = '太白's2 = ''print(bool(s1)) # True 非空即Trueprint(bool(s2)) # False# bool ---&gt; strt1 = Trueprint(str(True)) # 'True' str，list互化1234567# str ---&gt; lists1 = 'alex 太白 武大'print(s1.split()) # ['alex', '太白', '武大']# list ---&gt; str # 前提 list 里面所有的元素必须是字符串类型才可以l1 = ['alex', '太白', '武大']print(' '.join(l1)) # 'alex 太白 武大' list set互化1234567# list ---&gt; sets1 = [1, 2, 3]print(set(s1))# set ---&gt; listset1 = &#123;1, 2, 3, 3,&#125;print(list(set1)) # [1, 2, 3] str，bytes互化1234567# str ---&gt; bytess1 = '太白'print(s1.encode('utf-8')) # b'\xe5\xa4\xaa\xe7\x99\xbd'# bytes ---&gt; strb = b'\xe5\xa4\xaa\xe7\x99\xbd'print(b.decode('utf-8')) # '太白' 所有皆可转为bool转化成bool值为False的数据类型有：‘’, 0, (), {}, [], set(), None 基础数据类型总结思维导图 按存储空间的占用分（从低到高）数字字符串集合：无序，即无序存索引相关信息元组：有序，需要存索引相关信息，不可变列表：有序，需要存索引相关信息，可变，需要处理数据的增删改字典：有序，需要存key与value映射的相关信息，可变，需要处理数据的增删改（3.6之后有序） 按存值个数区分 标量／原子类型 数字，字符串 容器类型 列表，元组，字典 按可变不可变区分 可变 列表，字典 不可变 数字，字符串，元组，布尔值 按访问顺序区分 直接访问 数字 顺序访问（序列类型） 字符串，列表，元组 key值访问（映射类型） 字典 流程控制语句条件判断相当于生活中的一次次决策 1234567891011121314151617181920# 基本结构if 条件: 结果 if int(age) &gt; 18: print('恭喜你，成年了')else: print('小屁孩儿') # 多个条件，python中无switch...case... if num == 1: print('晚上请你吃饭')elif num == 3: print('一起溜达')elif num == 2: print('请你大宝剑')else: print('太笨了....') # if可以嵌套 while循环用于重复执行的代码，一般没有明确次数用while，有确定次数用for 一般得在循环体内改变条件，或使用break，否则会出现死循环 12345while 条件: 循环体else： 在循环正常结束时执行 若通过break跳出则不执行 continue：跳过本次条件 break：跳出循环 for循环12for i in str: print(i) for…else 同while用法 1234567891011msg = '老男孩python是全国范围内最好的python培训机构'for item in msg: print(item)li = ['alex','银角','女神','egon','太白']for i in li: print(i)dic = &#123;'name':'太白','age':18,'sex':'man'&#125;for k,v in dic.items(): print(k,v) 与循环配合的方法range指定范围，生成指定数字 12345678for i in range(1,10): print(i)for i in range(1,10,2): # 步长 print(i)for i in range(10,1,-2): # 反向步长 print(i) enumerate枚举，对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值 1234567li = ['alex','银角','女神','egon','太白']for i in enumerate(li): print(i)for index,name in enumerate(li,1): print(index,name)for index, name in enumerate(li, 100): # 起始位置默认是0，可更改 print(index, name) 控制台输入输出input1name = input("请输入用户名") print123print("name")# 默认输出自带换行print(name,end="") 编码初始计算机存储，传输文件底层都是二进制码 解码：将二进制文件按对应编码还原为数据 编码：将数据按指定编码转为二进制数据 常用编码ASCII码最早的编码，只包含英文字母，数字，特殊字符 字符 数值 0 48 9 57 A 65 Z 90 a 97 z 122 每个字符对应8bit GBK国标，包含英文字母，数字，特殊字符，中文 一个英文字符占1byte 一个中文字符占2byte Unicode万国码，把世界上所有的文字都记录 起初每个字符用2byte，后来为了记录所有，每个字符用4byte 虽然全面，但浪费资源 UTF-8Unicode升级版 字符 大小 英文 1byte 欧洲文字 2byte 中文，亚洲文字 3byte 数据大小12345678910118bit = 1byte1024byte = 1KB1024KB = 1MB1024MB = 1GB1024GB = 1TB1024TB = 1PB1024TB = 1EB1024EB = 1ZB1024ZB = 1YB1024YB = 1NB1024NB = 1DB 补充知识 1. 在计算机内存中，统一使用Unicode编码，当需要将数据保存到硬盘或者需要网络传输的时候，就转换为非Unicode编码比如：UTF-8编码。 其实这个不用深入理解，他就是规定，举个例子：用文件编辑器（word，wps,等）编辑文件的时候，从文件将你的数据（此时你的数据是非Unicode（可能是UTF-8，也可能是gbk，这个编码取决于你的编辑器设置））字符被转换为Unicode字符读到内存里，进行相应的编辑，编辑完成后，保存的时候再把Unicode转换为非Unicode（UTF-8，GBK 等）保存到文件。 2. 不同编码之间，不能直接互相识别。 比如你的一个数据：‘老铁没毛病’是以utf-8的编码方式编码并发送给一个朋友，那么你发送的肯定是通过utf-8的编码转化成的二进制01010101，那么你的朋友接收到你发的这个数据，他如果想查看这个数据必须将01010101转化成汉字，才可以查看，那么此时那也必须通过utf-8编码反转回去，如果要是通过gbk编码反转，那么这个内容可能会出现乱码或者报错 前提条件：python3x版本（python2x版本与这个不同）。 主要用途：数据的存储或者传输。 刚才咱们也说过了，在计算机内存中，统一使用Unicode编码，当需要将数据保存到硬盘或者需要网络传输的时候，就转换为非Unicode编码比如：UTF-8编码 引例：网络传输 解决方式：用bytes做中介 bytes 类名 str类型 bytes类型 标注 名称 str,字符串,文本文字 bytes,字节文字 组成单位 字符 字节 组成形式 ‘’ 或者 “” 或者 ‘’’ ‘’’ 或者 “”” “”” b’’ 或者 b”” 或者 b’’’ ‘’’ 或者 b””” “”” 不同，bytes类型就是在引号前面+b(B)大小写都可以 表现形式 英文： ‘alex’ 中文： ‘中国’ 英文：b’alex’中文：b’\xe4\xb8\xad\xe5\x9b\xbd’ 字节文字对于ascii中的元素是可以直接显示的。 编码方式 Unicode 可指定编码（除Unicode之外）比如UTF-8，GBK 等 非ascii码中的元素是以十六进制的形式表示的 相应功能 upper lower spllit 等等 upper lower spllit 等等 几乎相同 转译 可在最前面加r进行转译 可在最前面加r进行转译 相同 重要用途 python基础数据类型，用于存储少量的常用的数据 负责以二进制字节序列的形式记录所需记录的对象，至于该对象到底表示什么（比如到底是什么字符）则由相应的编码格式解码所决定。Python3中，bytes通常用于网络数据传输、二进制图片和文件的保存等等bytes是唯一可以指定编码化为非unicode编码的 bytes就是用于数据存储和网络传输数据 bytes类型也称作字节文本，他的主要用途就是网络的数据传输，与数据存储。那么有些同学肯定问，bytes类型既然与str差不多，而且操作方法也很相似，就是在字符串前面加个b不就行了，python为什么还要这两个数据类型呢？我只用bytes不行么？ 如果你只用bytes开发，不方便。因为对于非ascii码里面的文字来说，bytes只是显示的是16进制。很不方便。 str bytes互化1234567891011121314151617# 通过编码将str转为对应bytes# encode称作编码:将 str 转化成 bytes类型s1 = '中国'b1 = s1.encode('utf-8') # 转化成utf-8的bytes类型print(s1) # 中国print(b1) # b'\xe4\xb8\xad\xe5\x9b\xbd's1 = '中国'b1 = s1.encode('gbk') # 转化成gbk的bytes类型print(s1) # 中国print(b1) # b'\xd6\xd0\xb9\xfa'# 通过解码将bytes还原为对应字符串# decode称作解码, 将 bytes 转化成 str类型b1 = b'\xe4\xb8\xad\xe5\x9b\xbd's1 = b1.decode('utf-8')print(s1) # 中国 不同编码间转换本质为不同编码形成的bytes，故以str为中介 示例：将gbk转为utf-8 代码块和缓存机制代码块Python程序是由代码块构造的。块是一个python程序的文本，他是作为一个单元执行的。 代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。 而作为交互方式输入的每个命令都是一个代码块 代码块的缓存机制 前提条件：在同一个代码块内。 机制内容：Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用。换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这个值。所以在你给出的例子中，文件执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足缓存机制则他们在内存中只存在一个，即：id相同。 适用对象： int（float），str，bool。 变量之间相互赋值时都是直接指向了这些对象，而不是相互指向 对象的具体细则：（了解） int(float):任何数字在同一代码块下都会复用。 bool:True和False在字典中会以1，0方式存在，并且复用。 str：几乎所有的字符串都会符合缓存机制，具体规定如下（了解即可！）： 1，非乘法得到的字符串都满足代码块的缓存机制： 2,乘法得到的字符串分两种情况： 2.1 乘数为1时，任何字符串满足代码块的缓存机制： 2.2 乘数&gt;=2时：仅含大小写字母，数字，下划线，总长度&lt;=20，满足代码块的缓存机制： 优点 能够提高一些字符串，整数处理人物在时间和空间上的性能；需要值相同的字符串，整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。 小数据池小数据池，不同代码块的缓存机制，也称为小整数缓存机制，或者称为驻留机制等等， 前提条件在不同代码块内。 *机制内容*Python自动将-5~256的整数进行了缓存，当你将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。 python会将一定规则的字符串在字符串驻留池中，创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。 其实，无论是缓存还是字符串驻留池，都是python做的一个优化，就是将~5-256的整数，和一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中那些变量指向这些范围内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存中之创建一个。 适用对象 int（float），str，bool \对象的具体细则：（了解即可）**int：那么大家都知道对于整数来说，小数据池的范围是-5~256 ，如果多个变量都是指向同一个（在这个范围内的）数字，他们在内存中指向的都是一个内存地址。 str:字符串要从下面这几个大方向讨论（了解即可！）： 1,字符串的长度为0或者1，默认都采用了驻留机制（小数据池）。 2,字符串的长度&gt;1,且只含有大小写字母，数字，下划线时，才会默认驻留。 3,用乘法得到的字符串，分两种情况。 3.1 乘数为1时： 仅含大小写字母，数字，下划线，默认驻留。 含其他字符，长度&lt;=1,默认驻留。 含其他字符，长度&gt;1,默认驻留。 3.2 乘数&gt;=2时： 仅含大小写字母，数字，下划线，总长度&lt;=20,默认驻留。 4，指定驻留。 12345from sys import interna = intern('hello!@'*20)b = intern('hello!@'*20)print(a is b)# 指定驻留是你可以指定任意的字符串加入到小数据池中，让其只在内存中创建一个对象，多个变量都是指向这一个字符串 bool：值就是True，False，无论你创建多少个变量指向True，False，那么他在内存中只存在一个。 效率显而易见，节省大量内存在字符串比较时，非驻留比较效率o(n)，驻留时比较效率o(1) 深浅copy浅copy对于浅copy来说，只是在内存中重新创建了开辟了一个空间存放一个新列表，但是新列表中的元素与原列表中的元素是公用的 12345678910111213141516#同一代码块下：l1 = [1, '太白', True, (1,2,3), [22, 33]]l2 = l1.copy()print(id(l1), id(l2)) # 2713214468360 2713214524680print(id(l1[-2]), id(l2[-2])) # 2547618888008 2547618888008print(id(l1[-1]),id(l2[-1])) # 2547620322952 2547620322952# 不同代码块下：&gt;&gt;&gt; l1 = [1, '太白', True, (1, 2, 3), [22, 33]]&gt;&gt;&gt; l2 = l1.copy()&gt;&gt;&gt; print(id(l1), id(l2))1477183162696&gt;&gt;&gt; print(id(l1[-2]), id(l2[-2]))1477181814032&gt;&gt;&gt; print(id(l1[-1]), id(l2[-1]))1477183162504 深copy对于深copy来说，列表是在内存中重新创建的，列表中可变的数据类型是重新创建的，列表中的不可变的数据类型是公用的 切片相当于浅copy 123456789101112131415161718192021# 同一代码块下import copyl1 = [1, 'alex', True, (1,2,3), [22, 33]]l2 = copy.deepcopy(l1)print(id(l1), id(l2)) # 2788324482440 2788324483016print(id(l1[0]),id(l2[0])) # 1470562768 1470562768print(id(l1[-1]),id(l2[-1])) # 2788324482632 2788324482696print(id(l1[-2]),id(l2[-2])) # 2788323047752 2788323047752# 不同代码块下&gt;&gt;&gt; import copy&gt;&gt;&gt; l1 = [1, '太白', True, (1, 2, 3), [22, 33]]&gt;&gt;&gt; l2 = copy.deepcopy(l1)&gt;&gt;&gt; print(id(l1), id(l2))1477183162632&gt;&gt;&gt; print(id(0), id(0))1470562736&gt;&gt;&gt; print(id(-2), id(-2))1470562672&gt;&gt;&gt; print(id(l1[-1]), id(l2[-1]))1477183162312 文件操作概念计算机系统分为：计算机硬件，操作系统，应用程序三部分。 我们用python或其他语言编写的应用程序若想要把数据永久保存下来，必须要保存于硬盘中，这就涉及到应用程序要操作硬件，众所周知，应用程序是无法直接操作硬件的，这就用到了操作系统。操作系统把复杂的硬件操作封装成简单的接口给用户/应用程序使用，其中文件就是操作系统提供给应用程序来操作硬盘虚拟概念，用户或应用程序通过操作文件，可以将自己的数据永久保存下来。 有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程 文件操作的内容流程 12345678#1. 打开文件，得到文件句柄并赋值给一个变量f=open('a.txt','r',encoding='utf-8') #默认打开模式就为r#2. 通过句柄对文件进行操作data=f.read()#3. 关闭文件f.close() 常出的错路径问题 这个是没有找到该文件，很可能是你的文件路径错了 你的的路径里面的\与后面的字符产生了特殊意义类似于\t，\n，换行符一样 C:\Users\金鑫\Desktop\111.txt’ 凡是路径会产生特殊意义的地方，多加一个\ 这样就是前面\对后面的\进行转译，告诉计算机这个只是想单纯的表示\路径而已。即用\\代替\ r’C:\Users\金鑫\Desktop\111.txt’ 在路径的整体前面加一个r。（推荐） 相对路径与绝对路径： 绝对路径:从磁盘根目录开始一直到文件名 相对路径:用一个文件夹下的文件,相对于当前这个程序所在的文件而言.如果在同一个文件中,则相对路劲就是这个文件名.如果再上一层文件夹则要使用../相对路径下，你就可以直接写文件名即可。 编码问题 用了错误的编码来打开文件 读r模式以只读方式打开文件，文件的指针将会放在文件的开头。是文件操作最常用的模式，也是默认模式 rb模式以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。记住下面讲的也是一样，带b的都是以二进制的格式操作文件，他们主要是操作非文字文件：图片，音频，视频等,并且如果你要是带有b的模式操作文件，那么不用声明编码方式 写w模式 如果文件不存在，利用w模式操作文件，那么它会先创建文件，然后写入内容. 如果文件存在，利用w模式操作文件，先清空原文件内容，在写入新内容。 wb模式wb模式：以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如：图片，音频，视频等。 12345678# 先以rb的模式将一个图片的内容以bytes类型全部读取出来，# 然后在以wb将全部读取出来的数据写入一个新文件，这样就完成了类似于一个图片复制的流程f = open("a.jpg",mode = "rb")content = f.read()f.close()f1 = open("b.jpg", mode = "wb")f1.write(content)f1.close 追加a模式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 小结各种模式12345678910111213141516171819202122# 1. 打开文件的模式有(默认为文本模式)：r，只读模式【默认模式，文件必须存在，不存在则抛出异常】w，只写模式【不可读；不存在则创建；存在则清空内容】a， 只追加写模式【不可读；不存在则创建；存在则只追加内容】# 2. 对于非文本文件，我们只能使用b模式，"b"表示以字节的方式操作#（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、# 图片文件的jgp格式、视频文件的avi格式）rb wbab注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码# 3,‘+’模式（就是增加了一个功能）r+， 读写【可读，可写】w+，写读【可写，可读】a+， 写读【可写，可读】# 4，以bytes类型操作的读写，写读，写读模式r+b， 读写【可读，可写】w+b，写读【可写，可读】a+b， 写读【可写，可读】 注意：如果你在读写模式下，先写后读，那么文件就会出问题，因为默认光标是在文件的最开始，你要是先写，则写入的内容会讲原内容覆盖掉，直到覆盖到你写完的内容，然后在后面开始读取。 常用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# f.read()一次性读取所有内容f = open('path1/小娃娃.txt',mode='r',encoding='utf-8')msg = f.read()f.close()# f.read(n) 以字符为单位，读取n个字符 光标亦随之移动了n个字符 # 1. 文件打开方式为文本模式时，代表读取n个字符 # 2. 文件打开方式为b模式时，代表读取n个字节f = open('path1/小娃娃.txt',mode='r',encoding='utf-8')msg = f.read(3)msg1 = f.read()f.close()# readline()读取每次只读取一行,注意点:readline()读取出来的数据在后面都有一个\n，# 加上print本身自动换行所以一般会加stripf = open('path1/小娃娃.txt',mode='r',encoding='utf-8')msg1 = f.readline().strip()msg2 = f.readline().strip()msg3 = f.readline().strip()msg4 = f.readline().strip()f.close()# readlines() 返回一个列表，列表里面每个元素是原文件的每一行，如果文件很大，占内存，容易崩盘# 可以通过for循环去读取，文件句柄是一个迭代器，他的特点就是每次循环只在内存中占一行的数据，非常节省内存f = open('../path1/弟子规',mode='r',encoding='utf-8')for line in f: print(line) #这种方式就是在一行一行的进行读取,它就执行了下边的功能print(f.readline())print(f.readline())print(f.readline())print(f.readline())f.close()#注意:读完的文件句柄一定要关闭# seek(n)光标移动到n位置,注意: 移动单位是byte,所有如果是utf-8的中文部分要是3的倍数# 通常我们使用seek都是移动到开头或者结尾# 移动到开头:seek(0)# 移动到结尾:seek(0,2) # seek的第二个参数表示的是从哪个位置进行偏移,默认是0,表示开头,1表示当前位置,2表示结尾f = open("小娃娃", mode="r+", encoding="utf-8")f.seek(0) # 光标移动到开头content = f.read() # 读取内容, 此时光标移动到结尾print(content)f.seek(0) # 再次将光标移动到开头f.seek(0, 2) # 将光标移动到结尾content2 = f.read() # 读取内容. 什么都没有print(content2)f.seek(0) # 移动到开头f.write("张国荣") # 写入信息. 此时光标在9 中文3 * 3个 = 9f.flush()f.close()# 使用tell()可以帮我们获取当前光标在什么位置# readable(),writeable()f = open('Test',encoding='utf-8',mode='r')print(f.readable()) # Trueprint(f.writable()) # Falsecontent = f.read()f.close()# flush() 刷新文件内部缓冲区 另一种打开方式123456789# 1,利用with上下文管理这种方式，它会自动在一段时间后哦关闭文件句柄。with open('t1',encoding='utf-8') as f1: f1.read() # 2，一个with 语句可以操作多个文件，产生多个文件句柄。with open('t1',encoding='utf-8') as f1,\ open('Test', encoding='utf-8', mode = 'w') as f2: f1.read() f2.write('老男孩老男孩') 文件修改文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，我们平时看到的修改文件，都是模拟出来的效果 具体的说有两种实现方式： 方式一：将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘（word，vim，nodpad++等编辑器） 12345678910import os # 调用系统模块with open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: data=read_f.read() #全部读入内存,如果文件很大,会很卡 data=data.replace('alex','SB') #在内存中完成修改 write_f.write(data) #一次性写入新文件os.remove('a.txt') #删除原文件os.rename('.a.txt.swap','a.txt') #将新建的文件重命名为原文件 方式二：将硬盘存放的该文件的内容一行一行地读入内存，修改完毕就写入新文件，最后用新文件覆盖源文件 (当文件过大无法全部加载入内存中时用此法) 123456789import oswith open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: for line in read_f: line=line.replace('alex','SB') write_f.write(line)os.remove('a.txt')os.rename('.a.txt.swap','a.txt') 函数 1，对一些功能就行封装，减少代码的重复性。 2，使代码可读性更好 函数结构12def 函数名(): 函数体 def 关键词开头，空格之后接函数名称和圆括号()，最后还有一个”:”。 def 是固定的，不能变，他就是定义函数的关键字。 空格 为了将def关键字和函数名分开 函数名：函数名只能包含字符串、下划线和数字且不能以数字开头。虽然函数名可以随便起，但我们给函数起名字还是要尽量简短，并且要具有可描述性 括号：是必须加的，用于写形参 下面的函数体一定全部都要缩进，这代表是这个函数的代码 函数调用使用函数名加小括号就可以调用了 写法:函数名() 这个时候函数的函数体会被执行 返回值1.遇到return,函数结束,return下面的（函数内）的代码不会执行。 2.return 会给函数的执行者返回值。 ​ 如果return后面什么都不写，或者函数中没有return,则返回的结果是None ​ 如果return后面写了一个值,返回给调用者这个值 ​ 如果return后面写了多个结果,,返回给调用者一个tuple(元组),调用者可以直接使用元组的解构获取多个变量。 参数将函数盘活，使函数能应对更多情况 形参写在函数声明的位置的变量叫形参,形式上的一个完整.表示这个函数需要xxx 位置参数，args，默认参数，仅限关键字参数，**kwargs 实参在函数调用的时候给函数传递的值 函数的传参就是函数将实际参数交给形式参数的过程. 按需传入 动态参数动态接收位置参数：*args*args实参所有的位置参数接收，放置在一个元组中，并将这个元组赋值给args这个形参，PEP8规范中规定就使用args，约定俗成的 动态接收关键字参数: kwargs**kwargs接受所有的关键字参数然后将其转换成一个字典赋值给kwargs这个形参 1234def func(*args,**kwargs): print(args) # ('蒸羊羔儿', '蒸熊掌', '蒸鹿尾儿') print(kwargs) # &#123;'name': '太白金星', 'sex': '男'&#125;func('蒸羊羔儿', '蒸熊掌', '蒸鹿尾儿',name='太白金星',sex='男') *的用法函数中 聚合 在函数的定义时： *起到的是聚合的作用，将多个参数聚合为一个元组(字典) 打散 出一个小题：你如何将三个数据（这三个数据都是可迭代对象类型的每一元素传给动态参数*args？ 123456s1 = 'alex'l1 = [1, 2, 3, 4]tu1 = ('武sir', '太白', '女神',)def func(*args): print(args) # ('alex', [1, 2, 3, 4], ('武sir', '太白', '女神'))func(s1,l1,tu1) 这样肯定是不行，他会将这个三个数据类型当成三个位置参数传给args，没有实现我的要求。 123456s1 = 'alex'l1 = [1, 2, 3, 4]tu1 = ('武sir', '太白', '女神',)def func(*args): print(args) # ('a', 'l', 'e', 'x', 1, 2, 3, 4, '武sir', '太白', '女神')func(*s1,*l1,*tu1) 将位置参数的实参（可迭代类型）前面加上，相当于将这些实参给拆解成一个一个的组成元素当成位置参数，然后传给args，所以在函数的执行时：\，**起到的是打散的作用。 12345dic1 = &#123;'name': '太白', 'age': 18&#125;dic2 = &#123;'hobby': '喝茶', 'sex': '男'&#125;def func(**kwargs): print(kwargs) # &#123;'name': '太白', 'age': 18, 'hobby': '喝茶', 'sex': '男'&#125;func(**dic1,**dic2) 函数外接收时聚合，传值时打散 123456789# 之前讲过的分别赋值a,b = (1,2)print(a, b) # 1 2# 其实还可以这么用：a,*b = (1, 2, 3, 4,)print(a, b) # 1 [2, 3, 4]*rest,a,b = range(5)print(rest, a, b) # [0, 1, 2] 3 4print([1, 2, *[3, 4, 5]]) # [1, 2, 3, 4, 5] 仅限关键字参数他的位置要放在args后面，*kwargs前面（如果有**kwargs），也就是默认参数的位置，它与默认参数的前后顺序无所谓，它只接受关键字传的参数 123456789101112def func(a,b,*args,c):print(a,b) # 1 2print(args) # (4, 5)# 这样传参是错误的，因为仅限关键字参数c只接受关键字参数# func(1, 2, 3, 4, 5)def func(a,b,*args,c):print(a,b) # 1 2print(args) # (3, 4)print(5)# 这样就正确了：func(1, 2, 3, 4, c=5) 这个仅限关键字参数从名字定义就可以看出他只能通过关键字参数传参，其实可以把它当成不设置默认值的默认参数而且必须要传参数，不传就报错。 命名空间内置命名空间–&gt; 存放python解释器为我们提供的名字, list, tuple, str, int这些都是内置命名空间 全局命名空间–&gt; 我们直接在py文件中, 函数外声明的变量都属于全局命名空间 局部命名空间–&gt; 在函数中声明的变量会放在局部命名空间 作用域全局作用域: 包含内置命名空间和全局命名空间. 在整个文件的任何位置都可以使用(遵循 从上到下逐⾏执行). 局部作用域: 在函数内部可以使用. 两个内置函数globals(): 以字典的形式返回全局作用域所有的变量对应关系。 locals(): 以字典的形式返回当前作用域的变量的对应关系。 12345678910111213141516171819202122# 在全局作用域下打印，则他们获取的都是全局作用域的所有的内容。a = 2b = 3print(globals())print(locals())'''&#123;'__name__': '__main__', '__doc__': None, '__package__': None,'__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001806E50C0B8&gt;, '__spec__': None, '__annotations__': &#123;&#125;,'__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'D:/lnh.python/py project/teaching_show/day09~day15/function.py','__cached__': None, 'a': 2, 'b': 3&#125;'''# 在局部作用域中打印。a = 2b = 3def foo(): c = 3 print(globals()) # 和上面一样，还是全局作用域的内容 print(locals()) # &#123;'c': 3&#125;foo() 高阶函数(函数嵌套)12345678910111213141516171819202122232425262728293031323334# 例1：def func1(): print('in func1') print(3)def func2(): print('in func2') print(4)func1()print(1)func2()print(2)# 例2：def func1(): print('in func1') print(3)def func2(): print('in func2') func1() print(4)print(1)func2()print(2)# 例3：def fun2(): print(2) def fun3(): print(6) print(4) fun3() print(8)print(3)fun2()print(5) globalglobal关键字有两个作用： 1，声明一个全局变量。 2，在局部作用域想要对全局作用域的全局变量进行修改时，需要用到 global(限于字符串，数字) nonlocalnonlocal的总结： 1，不能更改全局变量。 2，在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变 函数名函数名指向的是这个函数的内存地址，其实深一步理解可得知，与其说函数名()可以执行这个函数，不如说是函数的内存地址()才是执行这个函数的关键 函数名可以赋值给其他变量 函数名可以当做容器类的元素 1234567891011def func1(): print("in func1: 嘻嘻")def func2(): print("in func2: 哈哈")def func3(): print("in func3: 咯咯")def func4(): print("in func4: 吱吱")lst = [func1, func2, func3, func4]for i in lst: i() 函数名可以当做函数的参数 12345678def func1(): print('in func1')def func2(f): print('in func2') f()func2(func1) 函数名可以当做函数的返回值 123456789def func1(): print('in func1')def func2(f): print('in func2') return fret = func2(func1)ret() # ret, f, func1 都是指向的func1这个函数的内存地址 函数名是一个特殊的变量，他除了具有变量的功能，还有最主要一个特点就是加上() 就执行，其实他还有一个学名叫第一类对象 迭代器可迭代对象 从字面意思来说：可迭代对象就是一个可以重复取值的实实在在的东西。 从专业角度来说：但凡内部含有iter方法的对象，都是可迭代对象。 可迭代对象可以通过判断该对象是否有’iter’方法来判断。 优缺点 可迭代对象的优点： 可以直观的查看里面的数据。 可迭代对象的缺点： 占用内存。 可迭代对象不能迭代取值（除去索引，key以外 即使抛去索引,key以外，这些我可以通过for循环进行取值呀！对，他们都可以通过for循环进行取值，其实for循环在底层做了一个转化，就是先将可迭代对象转化成迭代器，然后在进行取值的 判断dir()会返回一个列表，这个列表中含有该对象的以字符串的形式所有方法名。这样我们就可以判断python中的一个对象是不是可迭代对象了： 1234s1 = 'alex'i = 100print('__iter__' in dir(i)) # Falseprint('__iter__' in dir(s1)) # True 迭代器 从字面意思来说迭代器，是一个可以迭代取值的工具，器：在这里当做工具比较合适。 从专业角度来说：迭代器是这样的对象：实现了无参数的next方法，返回序列中的下一个元素，如果没有元素了，那么抛出StopIteration异常.python中的迭代器还实现了iter方法，因此迭代器也可以迭代。 出自《流畅的python》 简单来说：在python中，内部含有’Iter‘方法并且含有’next‘方法的对象就是迭代器。 判断1234567891011121314151617181920o1 = 'alex'o2 = [1, 2, 3]o3 = (1, 2, 3)o4 = &#123;'name': '太白','age': 18&#125;o5 = &#123;1, 2, 3&#125;f = open('file',encoding='utf-8', mode='w')print('__iter__' in dir(o1)) # Trueprint('__iter__' in dir(o2)) # Trueprint('__iter__' in dir(o3)) # Trueprint('__iter__' in dir(o4)) # Trueprint('__iter__' in dir(o5)) # Trueprint('__iter__' in dir(f)) # True# hsagnprint('__next__' in dir(o1)) # Falseprint('__next__' in dir(o2)) # Falseprint('__next__' in dir(o3)) # Falseprint('__next__' in dir(o4)) # Falseprint('__next__' in dir(o5)) # Falseprint('__next__' in dir(f)) # Truef.close() 之前我们学过的这些对象，只有文件句柄是迭代器，剩下的那些数据类型都是可迭代对象。 迭代器取值取值之前仅是保存了那些地址 可迭代对象是不可以一直迭代取值的（除去用索引，切片以及Key），但是转化成迭代器就可以了，迭代器是利用next()进行取值： 12345678910111213l1 = [1, 2, 3,]obj = l1.__iter__() # 或者 iter(l1)# print(obj) # &lt;list_iterator object at 0x000002057FE1A3C8&gt;ret = obj.__next__()print(ret)ret = obj.__next__()print(ret)ret = obj.__next__()print(ret)ret = obj.__next__() # StopIterationprint(ret)# 迭代器利用next取值：一个next取对应的一个值，如果迭代器里面的值取完了，还要next，# 那么就报StopIteration的错误。 while模拟forfor循环的内部机制是：将可迭代对象转换成迭代器，然后利用next进行取值，最后利用异常处理处理StopIteration抛出的异常 12345678910l1 = [1, 2, 3, 4, 5, 6]# 1 将可迭代对象转化成迭代器obj = iter(l1)# 2,利用while循环，next进行取值while 1: # 3,利用异常处理终止循环 try: print(next(obj)) except StopIteration: break 优缺点​ 迭代器的优点： ​ 节省内存。​ 迭代器在内存中相当于只占一个数据的空间：因为每次取值都上一条数据会在内存释放，加载当前的此条数据。 ​ 惰性机制。​ next一次，取一个值，绝不过多取值。​ ​ 迭代器的缺点： ​ 不能直观的查看里面的数据。 ​ 取值时不走回头路，只能一直向下取值。 可迭代对象转化成迭代器1234l1 = [1, 2, 3, 4, 5, 6]obj = l1.__iter__() # 或者 iter(l1)# &lt;list_iterator object at 0x000002057FE1A3C8&gt; 迭代器与可迭代对象对比 可迭代对象： 是一个私有的方法比较多，操作灵活（比如列表，字典的增删改查，字符串的常用操作方法等）,比较直观，但是占用内存，而且不能直接通过循环迭代取值的这么一个数据集。 应用：当你侧重于对于数据可以灵活处理，并且内存空间足够，将数据集设置为可迭代对象是明确的选择。 迭代器： 是一个非常节省内存，可以记录取值位置，可以直接通过循环+next方法取值，但是不直观，操作方法比较单一的数据集。 应用：当你的数据量过大，大到足以撑爆你的内存或者你以节省内存为首选因素时，将数据集设置为迭代器是一个不错的选择。（可参考为什么python把文件句柄设置成迭代器）。 生成器什么是生成器？各种文献都有不同的理解，但是核心基本相同。生成器的本质就是迭代器，在python社区中，大多数时候都把迭代器和生成器是做同一个概念。生成器和迭代器也有不同，唯一的不同就是：迭代器都是Python给你提供的已经写好的工具或者通过数据转化得来的，（比如文件句柄，iter([1,2,3])。生成器是需要我们自己用python代码构建的工具。最大的区别也就如此了 构建方式通过生成器函数 通过生成器推导式 python内置函数或者模块提供 （其实1,3两种本质上差不多，只不过1是自己写的生成器函数，3是python提供的生成器函数而已） 生成器函数1234567def func(): print(11) yield 22ret = func()print(ret)# 运行结果:&lt;generator object func at 0x000001A575163888&gt; 由于函数中存在yield,那么这个函数就是一个生成器函数. 我们在执行这个函数的时候.就不再是函数的执行了.而是获取这个生成器对象，那么生成器对象如何取值呢？ 生成器的本质就是迭代器。所以我们可以直接执行next()来执行以下生成器 123456def func(): print("111") yield 222gener = func() # 这个时候函数不会执⾏. ⽽是获取到⽣成器ret = gener.__next__() # 这个时候函数才会执⾏print(ret) # 并且yield会将func生产出来的数据 222 给了 ret 当程序运行完最后一个yield,那么后面继续运行next()程序会报错，一个yield对应一个next，next超过yield数量，就会报错，与迭代器一样。 yield与return的区别​ return一般在函数中只设置一个，他的作用是终止函数，并且给函数的执行者返回值。 ​ yield在生成器函数中可设置多个，他并不会终止函数，next会获取对应yield生成的元素。 举例： 我们来看一下这个需求：老男孩向楼下卖包子的老板订购了10000个包子.包子铺老板非常实在，一下就全部都做出来了 1234567def eat(): lst = [] for i in range(1,10000): lst.append('包子'+str(i)) return lste = eat()print(e) 这样做没有问题，但是我们由于学生没有那么多，只吃了2000个左右，剩下的8000个，就只能占着一定的空间，放在一边了。如果包子铺老板效率够高，我吃一个包子，你做一个包子，那么这就不会占用太多空间存储了，完美。 123456def eat(): for i in range(1,10000): yield '包子'+str(i)e = eat()for i in range(200): next(e) 这两者的区别: 第一种是直接把包子全部做出来，占用内存。 第二种是吃一个生产一个，非常的节省内存，而且还可以保留上次的位置。 123456789def eat(): for i in range(1,10000): yield '包子'+str(i)e = eat()for i in range(200): next(e) for i in range(300): next(e)# 多次next包子的号码是按照顺序记录的。 yield from可以直接把可迭代对象中的每一个数据作为生成器的结果进行返回 12345678910111213141516171819202122232425# 对比yield 与 yield from def func(): lst = ['卫龙','老冰棍','北冰洋','牛羊配'] yield lstg = func()print(g)print(next(g)) # 只是返回一个列表def func(): lst = ['卫龙','老冰棍','北冰洋','牛羊配'] yield from lstg = func()print(g)# 他会将这个可迭代对象(列表)的每个元素当成迭代器的每个结果进行返回。print(next(g))print(next(g))print(next(g))print(next(g))'''yield from ['卫龙','老冰棍','北冰洋','牛羊配'] 等同于： yield '卫龙' yield '老冰棍' yield '北冰洋' yield '牛羊配'''' 两个yield from不会交替输出，而会先打印完第一个，在打印第二个 123456789def func(): lst1 = ['卫龙','老冰棍','北冰洋','牛羊配'] lst2 = ['馒头','花卷','豆包','大饼'] yield from lst1 yield from lst2 g = func()for i in g: print(i) send方法(补充)send和next()区别: ​ 相同点： ​ send 和 next()都可以让生成器对应的yield向下执行一次。 ​ 都可以获取到yield生成的值。 ​ 不同点： ​ 第一次获取yield值只能用next不能用send（可以用send(None)）。 ​ send可以给上一个yield置传递值 1234567891011121314151617181920212223242526272829303132# next只能获取yield生成的值，但是不能传递值。def gen(name): print(f'&#123;name&#125; ready to eat') while 1: food = yield print(f'&#123;name&#125; start to eat &#123;food&#125;')dog = gen('alex')next(dog)next(dog)next(dog)# 而使用send这个方法是可以的。def gen(name): print(f'&#123;name&#125; ready to eat') while 1: food = yield 222 print(f'&#123;name&#125; start to eat &#123;food&#125;')dog = gen('alex')next(dog) # 第一次必须用next让指针停留在第一个yield后面# 与next一样，可以获取到yield的值ret = dog.send('骨头')print(ret)def gen(name): print(f'&#123;name&#125; ready to eat') while 1: food = yield print(f'&#123;name&#125; start to eat &#123;food&#125;')dog = gen('alex')next(dog)# 还可以给上一个yield发送值dog.send('骨头')dog.send('狗粮')dog.send('香肠') 生成器表达式形式上仅是将列表生成式的[]改为() 生成器表达式和列表推导式的区别: 列表推导式比较耗内存,所有数据一次性加载到内存。而.生成器表达式遵循迭代器协议，逐个产生元素。 得到的值不一样,列表推导式得到的是一个列表.生成器表达式获取的是一个生成器 列表推导式一目了然，生成器表达式只是一个内存地址 123gen = (i for i in range(1,100) if i % 3 == 0)for num in gen: print(num) 内置函数思维导图 函数就是以功能为导向，一个函数封装一个功能，那么Python将一些常用的功能（比如len）给我们封装成了一个一个的函数，供我们使用，他们不仅效率高（底层都是用C语言写的），而且是拿来即用，避免重复早轮子，那么这些函数就称为内置函数，到目前为止python给我们提供的内置函数一共是68个 了解all：可迭代对象中，全都是True才是True any：可迭代对象中，有一个True 就是True 1234# all 可迭代对象中，全都是True才是True# any 可迭代对象中，有一个True 就是Trueprint(all([1,2,True,0]))print(any([1,'',0])) bytes：用于不同编码之间的转化。 12345678910s = '你好'bs = s.encode('utf-8')print(bs)s1 = bs.decode('utf-8')print(s1)bs = bytes(s,encoding='utf-8')print(bs)b = '你好'.encode('gbk')b1 = b.decode('gbk')print(b1.encode('utf-8')) ord:输入字符找该字符编码的位置 chr:输入位置数字找出其对应的字符 1234567# ord 输入字符找该字符编码的位置print(ord('a'))print(ord('中'))# chr 输入位置数字找出其对应的字符print(chr(97))print(chr(20013)) repr:返回一个对象的string形式（原形毕露）。 1234567# %r 原封不动的写出来name = 'taibai'print('我叫%r'%name)# repr 原形毕露print(repr('&#123;"name":"alex"&#125;'))print('&#123;"name":"alex"&#125;') eval：执行字符串类型的代码，并返回最终结果。 exec:执行字符串类型的代码。 用于网络上数据处理时易出现安全分险 1234eval('2 + 2') # 4n=81eval("n + 4") # 85eval('print(666)') # 666 12345s = '''for i in [1,2,3]: print(i)'''exec(s) hash：获取一个对象（可哈希对象：int，str，Bool，tuple）的哈希值。 1234567891011121314print(hash(12322))print(hash('123'))print(hash('arg'))print(hash('alex'))print(hash(True))print(hash(False))print(hash((1,2,3)))'''-2996001552409009098-463751598188813973912528502973977326415''' help：函数用于查看函数或模块用途的详细说明。 12print(help(list))print(help(str.split)) callable：函数用于检查一个对象是否是可调用的。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。 12345name = 'alex'def func(): passprint(callable(name)) # Falseprint(callable(func)) # True int：函数用于将一个字符串或数字(取整)转换为整型。 1234print(int()) # 0print(int('12')) # 12print(int(3.6)) # 3print(int('0100',base=2)) # 将2进制的 0100 转化成十进制。结果为 4 float：函数用于将整数和字符串转换成浮点数。 complex：函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。。 12print(float(3)) # 3.0print(complex(1,2)) # (1+2j) bin：将十进制转换成二进制并返回。 oct：将十进制转化成八进制字符串并返回。 hex：将十进制转化成十六进制字符串并返回。 123print(bin(10),type(bin(10))) # 0b1010 &lt;class 'str'&gt;print(oct(10),type(oct(10))) # 0o12 &lt;class 'str'&gt;print(hex(10),type(hex(10))) # 0xa &lt;class 'str'&gt; divmod：计算除数与被除数的结果，返回一个包含商和余数的元组(a // b, a % b)。 round：保留浮点数的小数位数，默认保留整数。 pow：求xy次幂。（三个参数为xy的结果对z取余） 123456print(divmod(7,2)) # (3, 1)print(round(7/3,2)) # 2.33print(round(7/3)) # 2print(round(3.32567,3)) # 3.326print(pow(2,3)) # 两个参数为2**3次幂print(pow(2,3,3)) # 三个参数为2**3次幂，对3取余。 重点print() 屏幕输出。 123456789101112131415161718''' 源码分析def print(self, *args, sep=' ', end='\n', file=None): # known special case of print """ print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False) file: 默认是输出到屏幕，如果设置为文件句柄，输出到文件 sep: 打印多个值之间的分隔符，默认为空格 end: 每一次打印的结尾，默认为换行符 flush: 立即把内容输出到流文件，不作缓存 """'''print(111,222,333,sep='*') # 111*222*333print(111,end='')print(222) #两行的结果 111222f = open('log','w',encoding='utf-8')print('写入文件',fle=f,flush=True) int():pass str():pass bool():pass set(): pass list() 将一个可迭代对象转换成列表 tuple() 将一个可迭代对象转换成元组 dict() 通过相应的方式创建字典。 12345listl1 = list('abcd')print(l1) # ['a', 'b', 'c', 'd']tu1 = tuple('abcd')print(tu1) # ('a', 'b', 'c', 'd') abs() 返回绝对值 12i = -5print(abs(i)) # 5 sum() 求和 12print(sum([1,2,3]))print(sum((1,2,3),100)) min() 求最小值 123456789print(min([1,2,3])) # 返回此序列最小值ret = min([1,2,-5,],key=abs) # 按照绝对值的大小，返回此序列最小值print(ret)# 加key是可以加函数名，min自动会获取传入函数中的参数的每个元素，然后通过你设定的返回值比较大小，# 返回最小的传入的那个参数。print(min(1,2,-5,6,-3,key=lambda x:abs(x))) # 可以设置很多参数比较大小dic = &#123;'a':3,'b':2,'c':1&#125;print(min(dic,key=lambda x:dic[x]))# x为dic的key，lambda的返回值（即dic的值进行比较）返回最小的值对应的键 max() 最大值与最小值用法相同。 reversed() 将一个序列翻转, 返回翻转序列的迭代器 1234l = reversed('你好') # l 获取到的是一个生成器print(list(l))ret = reversed([1, 4, 3, 7, 9])print(list(ret)) # [9, 7, 3, 4, 1] bytes() 把字符串转换成bytes类型 1234567891011121314s = '你好太白'bs = s.encode('utf-8')print(bs)# 结果:b'\xe4\xbd\xa0\xe5\xa5\xbd\xe6\xad\xa6\xe5\xa4\xa7's1 = bs.decode('utf-8')print(s1)# 结果: 你好太白s = '你好'bs = bytes(s,encoding='utf-8')print(bs)# 将字符串转换成字节bs1 = str(bs,encoding='utf-8')print(bs1)# 将字节转换成字符串 zip() 拉链方法。函数用于将可迭代的对象作为参数,将对象中对应的元素打包成一个个元组, 然后返回由这些元祖组成的内容,如果各个迭代器的元素个数不一致,则按照长度最短的返回， 123456789lst1 = [1,2,3]lst2 = ['a','b','c','d']lst3 = (11,12,13,14,15)for i in zip(lst1,lst2,lst3): print(i)结果:(1, 'a', 11)(2, 'b', 12)(3, 'c', 13) sorted排序函数 123456789101112131415161718192021222324252627282930313233343536373839404142# 语法:sorted(iterable,key=None,reverse=False)# iterable : 可迭代对象# key: 排序规则(排序函数),在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数.# 根据函数运算的结果进行排序# reverse :是否是倒叙,True 倒叙 False 正序lst = [1,3,2,5,4]lst2 = sorted(lst)print(lst) #原列表不会改变print(lst2) #返回的新列表是经过排序的 lst3 = sorted(lst,reverse=True)print(lst3) #倒叙 # 结果:[1, 3, 2, 5, 4][1, 2, 3, 4, 5][5, 4, 3, 2, 1]# 字典使用sorted排序dic = &#123;1:'a',3:'c',2:'b'&#125;print(sorted(dic)) # 字典排序返回的就是排序后的key # 结果:[1,2,3]# 和函数组合使用# 定义一个列表,然后根据一元素的长度排序lst = ['天龙八部','西游记','红楼梦','三国演义'] # 计算字符串的长度def func(s): return len(s)print(sorted(lst,key=func)) # 结果:# ['西游记', '红楼梦', '天龙八部', '三国演义']和lambda组合使用lst = ['天龙八部','西游记','红楼梦','三国演义'] print(sorted(lst,key=lambda s:len(s))) 结果:['西游记', '红楼梦', '天龙八部', '三国演义'] lst = [&#123;'id':1,'name':'alex','age':18&#125;, &#123;'id':2,'name':'wusir','age':17&#125;, &#123;'id':3,'name':'taibai','age':16&#125;,] # 按照年龄对学生信息进行排序 print(sorted(lst,key=lambda e:e['age'])) 结果:[&#123;'id': 3, 'name': 'taibai', 'age': 16&#125;, \ &#123;'id': 2, 'name': 'wusir', 'age': 17&#125;, &#123;'id': 1, 'name': 'alex', 'age': 18&#125;] filter筛选过滤 类似于各种推导式 123456789101112# 语法: filter(function,iterable)# function: 用来筛选的函数,在filter中会自动的把iterable中的元素传递给function,# 然后根据function返回的True或者False来判断是否保留此项数据iterable:可迭代对象lst = [&#123;'id':1,'name':'alex','age':18&#125;, &#123;'id':1,'name':'wusir','age':17&#125;, &#123;'id':1,'name':'taibai','age':16&#125;,] ls = filter(lambda e:e['age'] &gt; 16,lst) print(list(ls)) # 结果:[&#123;'id': 1, 'name': 'alex', 'age': 18&#125;, &#123;'id': 1, 'name': 'wusir', 'age': 17&#125;] map 123456789101112131415161718# 映射函数# 语法: map(function,iterable) 可以对可迭代对象中的每一个元素进映射,分别取执行function,返回一个迭代器# 计算列表中每个元素的平方,返回新列表lst = [1,2,3,4,5]def func(s): return s*smp = map(func,lst)print(mp)print(list(mp))# 改写成lambdalst = [1,2,3,4,5]print(list(map(lambda s:s*s,lst)))# 计算两个列表中相同位置的数据的和lst1 = [1, 2, 3, 4, 5]lst2 = [2, 4, 6, 8, 10]print(list(map(lambda x, y: x+y, lst1, lst2)))# 结果:[3, 6, 9, 12, 15] reduce 123456789101112131415161718192021222324from functools import reducedef func(x,y): return x + y# reduce 的使用方式:# reduce(函数名,可迭代对象) # 这两个参数必须都要有,缺一个不行ret = reduce(func,[3,4,5,6,7])print(ret) # 结果 25# reduce的作用是先把列表中的前俩个元素取出计算出一个值然后临时保存着,# 接下来用这个临时保存的值和列表中第三个元素进行计算,求出一个新的值将最开始# 临时保存的值覆盖掉,然后在用这个新的临时值和列表中第四个元素计算.依次类推# 注意:我们放进去的可迭代对象没有更改# 以上这个例子我们使用sum就可以完全的实现了.我现在有[1,2,3,4]想让列表中的数变成1234,就要用到reduce了.# 普通函数版from functools import reducedef func(x,y): return x * 10 + yl = reduce(func,[1,2,3,4])print(l)# 匿名函数版l = reduce(lambda x,y:x*10+y,[1,2,3,4])print(l)# 在Python2.x版本中recude是直接 import就可以的, Python3.x版本中需要从functools这个包中导入# 龟叔本打算将 lambda 和 reduce 都从全局名字空间都移除, 舆论说龟叔不喜欢lambda 和 reduce# 最后lambda没删除是因为和一个人写信写了好多封,进行交流然后把lambda保住了. 匿名函数匿名函数 lambda，顾名思义就是没有名字的函数，也叫一句话函数。 语法 函数名 = lambda 参数:返回值(对参数的简单处理) 1）此函数不是没有名字，他是有名字的，他的名字就是你给其设置的变量，比如func. 2）lambda 是定义匿名函数的关键字，相当于函数的def. 3）lambda 后面直接加形参，形参加多少都可以，只要用逗号隔开就行。 123func = lambda a,b,*args,sex= 'alex',c,**kwargs: kwargsprint(func(3, 4,c=666,name='alex')) # &#123;'name': 'alex'&#125;# 所有类型的形参都可以加，但是一般使用匿名函数只是加位置参数，其他的用不到。 4）返回值在冒号之后设置，返回值和正常的函数一样,可以是任意数据类型。 5）匿名函数不管多复杂.只能写一行.且逻辑结束后直接返回数据 小题写匿名函数：接收一个可切片的数据，返回索引为0与2的对应的元素（元组形式）。 12func = lambda x:(x[0],x[2])print(func(&apos;afafasd&apos;)) 写匿名函数：接收两个int参数，将较大的数据返回。 12func = lambda x,y: x if x &gt; y else yprint(func(3,100)) 闭包1234567891011121314def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averageravg = make_averager()print(avg(100000))print(avg(110000))print(avg(120000)) 大家仔细看一下这个代码，我是在函数中嵌套了一个函数。那么avg 这个变量接收的实际是averager函数名，也就是其对应的内存地址，我执行了三次avg 也就是执行了三次averager这个函数。那么此时你们有什么问题？ 肯定有学生就会问，那么我的make_averager这个函数只是执行了一次，为什么series这个列表没有消失？反而还可以被调用三次呢？这个就是最关键的地方，也是闭包的精华所在。我给大家说一下这个原理，以图为证： 上面被红色方框框起来的区域就是闭包，被蓝色圈起来的那个变量应该是make_averager()函数的局部变量，它应该是随着make_averager()函数的执行结束之后而消失。但是他没有，是因为此区域形成了闭包，series变量就变成了一个叫自由变量的东西，averager函数的作用域会延伸到包含自由变量series的绑定。也就是说，每次我调用avg对应的averager函数 时，都可以引用到这个自用变量series，这个就是闭包。 闭包的定义： 闭包是嵌套在函数中的函数。 闭包必须是内层函数对外层函数的变量（非全局变量）的引用。 判断123456789101112131415161718192021222324252627# 例一：def wrapper(): a = 1 def inner(): print(a) return innerret = wrapper()# 例二：a = 2def wrapper(): def inner(): print(a) return innerret = wrapper()# 例三：def wrapper(a,b): def inner(): print(a) print(b) return innera = 2b = 3ret = wrapper(a,b) 以上三个例子，最难判断的是第三个，其实第三个也是闭包，如果我们每次去研究代码判断其是不是闭包，有一些不科学，或者过于麻烦了，那么有一些函数的属性是可以获取到此函数是否拥有自由变量的，如果此函数拥有自由变量，那么就可以侧面证明其是否是闭包函数了（了解）： 12345678910111213141516171819202122def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averageravg = make_averager()# 函数名.__code__.co_freevars 查看函数的自由变量print(avg.__code__.co_freevars) # ('series',)当然还有一些参数，仅供了解：# 函数名.__code__.co_freevars 查看函数的自由变量print(avg.__code__.co_freevars) # ('series',)# 函数名.__code__.co_varnames 查看函数的局部变量print(avg.__code__.co_varnames) # ('new_value', 'total')# 函数名.__closure__ 获取具体的自由变量对象，也就是cell对象。# (&lt;cell at 0x0000020070CB7618: int object at 0x000000005CA08090&gt;,)# cell_contents 自由变量具体的值print(avg.__closure__[0].cell_contents) # [] 作用保存局部信息不被销毁，保证数据的安全性。 应用 可以保存一些非全局变量但是不易被销毁、改变的数据。 装饰器 装饰器开发封闭原则 1.对扩展是开放的 ​ 我们说，任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。 2.对修改是封闭的 ​ 就像我们刚刚提到的，因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对函数内部进行修改，或者修改了函数的调用方式，很有可能影响其他已经在使用该函数的用户。OK，理解了开封封闭原则之后，我们聊聊装饰器。 所以装饰器最终最完美的定义就是：在不改变原被装饰的函数的源代码以及调用方式下，为其添加额外的功能。]]></content>
      <tags>
        <tag>python</tag>
        <tag>老男孩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requests]]></title>
    <url>%2F2020%2F01%2F31%2Frequests%2F</url>
    <content type="text"></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫踩得坑]]></title>
    <url>%2F2020%2F01%2F31%2F%E7%88%AC%E8%99%AB%E8%B8%A9%E5%BE%97%E5%9D%91%2F</url>
    <content type="text"><![CDATA[百度最近更新，需要过安检默认情况 下先请求一次百度获取这些参数，然后每次请求带上即可 1234567item.Header.Add(&quot;Bdpagetype&quot;, &quot; 3&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Bdqid&quot;, &quot; 0xd30b86920004fb3f&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Cache-Control&quot;, &quot; private&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Ckpacknum&quot;, &quot; 2&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Ckrndstr&quot;, &quot; 20004fb3f&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Strict-Transport-Security&quot;, &quot; max-age=172800&quot;);//设置请求头信息（Header） item.Header.Add(&quot;Traceid&quot;, &quot; 1574759518274850689015207396528370285375&quot;);//设置请求头信息（Header） 抓取简书登录cookie登录发现post需要包含参数 检查页面，发现在这儿，但不知如何取值 authenticity_token应该每个页面动态生成]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门]]></title>
    <url>%2F2020%2F01%2F30%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HTTP 爬虫入门爬虫简介 &lt; urllib.requestpython3内置的包 123456789101112131415161718import urllib.requestdef load_data(): # 用https时拿不到数据 url = "http://www.baidu.com/" response = urllib.request.urlopen(url) # print(response) data = response.read().decode("utf-8") # print(data) with open("baidu.html", "w", encoding="utf-8") as f: f.write(data) # python爬取到的多为str,bytes # str通过对应encode("编码")转为bytes，同理bytes通过decode转为str # 具体编码格式见html页面head头信息中load_data() get传参要注意转成url编码 由于百度更新，以下过不了安检，实际上拿不到数据了 123456789101112131415161718import urllib.requestimport urllib.parseimport stringdef get_param(): url = "http://www.baidu.com/s?wd=" param = "美女" final_url = url + param # python解释器只支持ASCII码，所以必须转码 final_url = urllib.parse.quote(final_url, safe=string.printable) response = urllib.request.urlopen(final_url) data_str = response.read().decode("utf-8") with open("meinv.html", "w", encoding="utf-8") as f: f.write(data_str)get_param() 字典传参时,这样得到字符串参数 123456params = &#123; "wd": "中文", "key": "zhang", "value": "san"&#125;params_str = urllib.parse.urlencode(params) 绑定请求头 12345678url = "https://www.baidu.com/s?wd=%E7%BE%8E%E5%A5%B3"header = &#123; # 浏览器版本 "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36",&#125;# 创建时绑定请求头，也可以requset.add_header()来动态绑定request = urllib.request.Request(url, headers=header)response = urllib.request.urlopen(request) 获取随机的User-Agent(第三方包) 1234567from fake_useragent import UserAgent print(UserAgent().chrome) print(UserAgent().ie) print(UserAgent().firefox) print(UserAgent().opera) print(UserAgent().safari) print(UserAgent().random) Handler对urlopen进行扩展 urlopen源码如下 123456789101112131415161718192021222324252627global _openerif cafile or capath or cadefault: import warnings warnings.warn("cafile, capath and cadefault are deprecated, use a " "custom context instead.", DeprecationWarning, 2) if context is not None: raise ValueError( "You can't pass both context and any of cafile, capath, and " "cadefault" ) # 安全套阶层，第三方CA数字证书 if not _have_ssl: raise ValueError('SSL support not available') context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile=cafile, capath=capath) # 默认用HTTPSHandler，可以用别的Handler来实现功能扩展 https_handler = HTTPSHandler(context=context) opener = build_opener(https_handler)elif context: https_handler = HTTPSHandler(context=context) opener = build_opener(https_handler)elif _opener is None: _opener = opener = build_opener()else: opener = _openerreturn opener.open(url, data, timeout) HTTPHandler演示12345678910url = "https://www.baidu.com/"header = &#123; # 浏览器版本 "User-Agent": UserAgent().random&#125;request = urllib.request.Request(url, headers=header)handler = urllib.request.HTTPHandler()opener = urllib.request.build_opener(handler)response = opener.open(request)data = response.read().decode("utf-8") ProxyHandler123456789101112131415161718192021222324import urllib.requestfrom fake_useragent import UserAgentdef create_proxy_handler(): url = "https://blog.csdn.net/willsnowdev/article/details/90140266" header = &#123; # 浏览器版本 "User-Agent": UserAgent().random &#125; # 可以用多个IP，到时候随机选取 # "http": "163.204.247.20:9999"也可 proxy = &#123; "http": "http://163.204.247.20:9999" &#125; request = urllib.request.Request(url, headers=header) proxy_handler = urllib.request.ProxyHandler(proxy) opener = urllib.request.build_opener(proxy_handler) response = opener.open(request) with open("requset_header.html", "w", encoding="utf-8") as f: f.write(response.read().decode())create_proxy_handler() 多个免费代理 123456proxy_list = [ &#123;"https":"106.75.226.36:808"&#125;, &#123;"https":"61.135.217.7:80"&#125;, &#123;"https":"125.70.13.77:8080"&#125;, &#123;"https":"118.190.95.35:9001"&#125; ] 付费代理 1234567891011121314# 第一种方式proxy = &#123; "http": "username:pwd@163.204.247.20:9999"&#125;# 第二种方式username = "xunzhao"pwd = "173hjgew8"money_proxy1 = "163.204.247.20:9999"# 创建密码管理器password_manger = urllib.request.HTTPPasswordMgr()password_manger.add_password(None, money_proxy1, username, pwd)handle_auth = urllib.request.ProxyBasicAuthHandler(password_manger)opener_auth = urllib.request.build_opener(handle_auth)response = opener_auth.open(url) 用公司内网爬数据 1234567891011121314def auth_nei_wang(): nei_url = "https://www.jianshu.com/p/325bdc0ae92f" header = &#123; "User-Agent": UserAgent().random &#125; username = "admin" pwd = "admin007" password_manger = urllib.request.HTTPPasswordMgrWithDefaultRealm() password_manger.add_password(None, nei_url, username, pwd) # handle不同，其他和付费代理很像 handle_nei = urllib.request.HTTPBasicAuthHandler(password_manger) opener_nei = urllib.request.build_opener(handle_nei) response = opener_nei.open(nei_url) print(response.read().decode("utf-8")) cookie认证手动获取cookie，添加到header中 1234header = &#123; "User-Agent": UserAgent().random, "Cookie": "__yadk_uid=e2gl8vcNK8DLVH2eQd6vHpvH1QvuStkO; web_login_version=MTU4MDA5MDc3OQ%3D%3D--366eb244926d0d504aa444afc85df5e80948cee6; remember_user_token=W1syMTAxNzY3NV0sIiQyYSQxMSRUVGNQenhyZjFtMzdiN3Mxc0xzT25lIiwiMTU4MDQ2MzkzNy42MjQ5NjA0Il0%3D--2fd8938f7291d2405e0c23b0f267c631fad3fd9b; read_mode=day; default_font=font2; locale=zh-CN; _m7e_session_core=ad86ea9fddf5bd5d6969bc414a322298; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%2221017675%22%2C%22%24device_id%22%3A%2216bea6ca2e9365-067bb910973608-e343166-1049088-16bea6ca2ea5c2%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E8%87%AA%E7%84%B6%E6%90%9C%E7%B4%A2%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22https%3A%2F%2Fwww.baidu.com%2Fs%22%2C%22%24latest_search_keyword%22%3A%22%E7%AE%80%E4%B9%A6%22%2C%22%24latest_utm_source%22%3A%22desktop%22%2C%22%24latest_utm_medium%22%3A%22not-signed-in-like-note-btn-in-bottom%22%2C%22%24latest_referrer_host%22%3A%22www.baidu.com%22%7D%2C%22first_id%22%3A%2216bea6ca2e9365-067bb910973608-e343166-1049088-16bea6ca2ea5c2%22%7D; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1580090858,1580277385,1580463938,1580466286; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1580466310"&#125; 自动获取，用cookiejar来保存cookie 123456获取 个人中心的页面1. 代码登录 登录成功 cookie(有效)2. 自动带着cookie 去请求个人中心cookiejar 自动保存这个cookie 1234567891011121314151617181920212223242526header = &#123; "User-Agent": UserAgent().random, &#125; url = 'https://www.yaozh.com/login' # 1.2 登录的参数 login_form_data = &#123; "username": "xiaomaoera12", "pwd": "lina081012", "formhash": "CE3ADF28C5", "backurl": "https%3A%2F%2Fwww.yaozh.com%2F" &#125; login_form_data_str = urllib.parse.urlencode(login_form_data).encode("utf-8") cookie_jar = cookiejar.CookieJar() cookie_handle = urllib.request.HTTPCookieProcessor(cookie_jar) cookie_opener = urllib.request.build_opener(cookie_handle) requset = urllib.request.Request(url, headers=header, data=login_form_data_str) cookie_opener.open(requset) # 2. 代码带着cooke去访问 个人中心 center_url = 'https://www.yaozh.com/member/' center_request = urllib.request.Request(center_url, headers=header) response = cookie_opener.open(center_url) data = response.read().decode("utf-8") with open("jianshu.html", "w", encoding="utf-8") as f: f.write(data) 疑问cookiejar原理和urlencode中safe=string.printable作用 常见报错URLErrorurl不存在 HTTPError4××，5××，可通过catch到error后，error.code来打印状态码 小结]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础]]></title>
    <url>%2F2020%2F01%2F30%2F%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>python爬虫</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法]]></title>
    <url>%2F2019%2F10%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[前提须知用处 写出性能更高的程序 更快更深的掌握一门技术 数据结构+算法=程序 数组 定义 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 链表适合插入、删除，时间复杂度O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为O(1) 警惕数组的访问越界问题 我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第k个位置，为了避免大规模的数据搬移，直接将第k位的数据搬移到数组元素的最后，把新的元素直接放入第k个位置。 容器可否完全替代数组 .Java ArrayList无法存储基本类型，比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。 如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。 .还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList &gt; array。 总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。 数组下标为何从零开始 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要用这个公式： 1a[k]_address = base_address + k * type_size 但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为： 1a[k]_address = base_address + (k-1)*type_size 对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始。 不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非0开始不可。所以我觉得最主要的原因可能是历史原因。链表 常见的缓存淘汰策略有三种：先进先出策略FIFO（First In，First Out）、最少使用策略LFU（Least Frequently Used）、最近最少使用策略LRU（Least Recently Used）。 排序]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F09%2F22%2FJDBC%2F</url>
    <content type="text"><![CDATA[概述JDBC主要是有 java的类和接口组成 在JDBC中核心的三个接口和一个类 DriverManager: 驱动管理类,帮助我们加载各种驱动 Connection: 数据库连接接口,实现类在驱动中 Statement: 执行SQL语句的接口,实现类在驱动中 ResultSet: 结果集接口,实现类在驱动中 驱动：每个厂商提供自己操作数据库的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//操作步骤/* * 使用JDBC操作数据库步骤 * * 1.必须先把对应的数据库驱动 添加到工程的构建路径 * * 代码步骤: * * 1.注册驱动:使用DriverManger来注册 * * 2.获取和数据库的连接对象: 是Connection接口的实现类对象 * * 3.获取SQL语句的执行者对象: 是Statement接口的实现类对象 * * 4.结果集对象:是ResultSet接口的实现类对象 * * 5.处理结果集(打印,保存) * * 6.释放资源 * */public class JDBCDemo &#123; public static void main(String[] args) throws Exception &#123;// * 1.注册驱动:使用DriverManger来注册 发现实现类在静态代码块里会注册，所以用反射直接加载字节码文件更好 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName("com.mysql.jdbc.Driver");// * 2.获取和数据库的连接对象: 是Connection接口的实现类对象 String url = "jdbc:mysql://localhost:3306/day04"; // jdbc:固定语法 数据库厂商名 IP地址 端口号 要连接的数据库 Connection conn = DriverManager.getConnection(url, "root", "123");// * 3.获取SQL语句的执行者对象: 是Statement接口的实现类对象 Statement st = conn.createStatement();// * 4.结果集对象:是ResultSet接口的实现类对象 ResultSet rs = st.executeQuery("select * from category");//执行查询,返回值是结果集 //int rows = st.executeUpdate("insert into category values (6,'饮料')"); //int rows = st.executeUpdate("delete from category"); //执行增,删除,改,返回值是被影响的行数 // * 5.处理结果集(打印,保存),迭代器 hasNext next // System.out.println(rows); while(rs.next())&#123;//判断有没有下一条记录 //取出对应字段的值 // getInt getString getDouble getObject //getObject(1) getObject(列名); Object cid = rs.getObject("cid"); Object cname = rs.getObject("cname"); System.out.println(cid+"\t"+cname); &#125;// * 6.释放资源 rs.close();//只有执行查询,才有结果集对象,如果执行增删改,只有int类型行数 st.close(); conn.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//JDBCUtils 工具类package com.guardwarm.JDBC;import java.sql.*;public class JDBCUtils &#123; public static String driverName = "com.mysql.jdbc.Driver"; public static String url = "jdbc:mysql://localhost:3306/****"; public static String root = "***"; public static String passward = "********"; static &#123; try &#123; Class.forName(driverName); &#125; catch (ClassNotFoundException e) &#123; //抛出运行时异常，及时停止且错误明确 throw new RuntimeException("驱动加载失败，请检查驱动包"); &#125; &#125; public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url,root,passward); return conn; &#125; //可以传空值，也可以写函数重载 public static void close(Connection conn, Statement st, ResultSet rs)&#123; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st!=null)&#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 用Utils是实现增删改查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.guardwarm.JDBC;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class testDemo &#123; public static void main(String[] args) throws SQLException &#123;// query();// insert();// delete();// update();// alter("insert into norvals values ('我欲封天',888)"); &#125; public static void insert()&#123; Connection conn = null; Statement st = null; try &#123; conn = JDBCUtils.getConnection(); st = conn.createStatement(); //将“转义，或者使用单引号 int row = st.executeUpdate("insert into norvals (fname,fprice) values (\"同桌凶猛\",77)"); System.out.println("成功修改"+row+"行"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn,st,null); &#125; &#125; public static void delete()&#123; Connection conn = null; Statement st = null; try &#123; conn = JDBCUtils.getConnection(); st = conn.createStatement(); int row = st.executeUpdate("delete from norvals where fname = '同桌凶猛'"); System.out.println("成功修改"+row+"行"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn,st,null); &#125; &#125; public static void update()&#123; Connection conn = null; Statement st = null; try &#123; conn = JDBCUtils.getConnection(); st = conn.createStatement(); int row = st.executeUpdate("update norvals set fprice = 66 where fname = '终极'"); System.out.println("成功修改"+row+"行"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn,st,null); &#125; &#125; public static void alter(String sql)&#123; Connection conn = null; Statement st = null; try &#123; conn = JDBCUtils.getConnection(); st = conn.createStatement(); int row = st.executeUpdate(sql); System.out.println("成功修改"+row+"行"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn,st,null); &#125; &#125; public static void query() throws SQLException &#123; Connection conn = JDBCUtils.getConnection(); Statement st = conn.createStatement(); ResultSet rs = st.executeQuery("select * from norvals"); while (rs.next())&#123; Object fname = rs.getObject("fname"); Object fprice = rs.getObject("fprice"); System.out.println(fname+"\t"+fprice); &#125; JDBCUtils.close(conn,st,rs); &#125;&#125; SQL注入 通过特殊字符，可以强行加入命令来登录成功 123456789101112131415161718192021222324252627282930313233343536package com.guardwarm.JDBC;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.Scanner;public class SQLDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println("请输入用户名"); String user = scan.nextLine(); System.out.println("请输入密码"); String passwd = scan.nextLine(); Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); st = conn.createStatement(); String sql = "select * from usersInfo where user = '"+user+"' and password = '"+passwd+"'"; rs = st.executeQuery(sql); System.out.println(sql); if (rs.next())&#123; System.out.println("登录成功"); &#125;else &#123; System.out.println("登录失败"); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(conn,st,rs); &#125; &#125;&#125; PrepareedStatementStatement的子类，用于对齐内sql转义，防止SQL注入 12345678910111213141516171819/* * PreparedStatement pst = conn.PrepareStatement(sql语句);//注意 sql语句中不要写具体的参数 * 通过set方法为pst中的sql语句设置具体的值 * pst.setXxxx(第几个?号,具体的值);//?号从1开始 */ Connection conn = null; PreparedStatement pst = null; ResultSet rs = null; try&#123; conn = JDBCUtils.getConnection();// st = conn.createStatement(); String sql = "select * from users where username = ? and password = ?"; pst = conn.prepareStatement(sql); //设置值 pst.setObject(1,username); pst.setObject(2, password); rs = st.executeQuery(); 小结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 1.JDBC: java语言操作各种数据库的技术 * JDBC由一堆接口和类组成 * 类: DriverManger,用于注册驱动 * 接口: * Connection:数据库连接类的根接口 * Statement:数据库语句执行类的根接口 * ResultSet:结果集类的根接口 * 以上接口的实现类,在驱动包中 * 2.JDBC和具体数据库的驱动,他们是接口和实现类的关系 * * 3.[重点]原生JDBC开发的步骤 * 0.向工程中导入具体的数据库驱动包 * 1.注册驱动 * DriverManger.register(new com.mysql.jdbc.Driver());//注册两次 * Class.forName("com.mysql.jdbc.Driver"); * 2.获取连接(四大要素:驱动,连接串,用户名,密码) * 前提:必须有驱动 * Connection conn = DriverManager.getConnection( * "jdbc:mysql://ip地址:3306/数据库名","用户名","密码" * ); * 3.获取sql语句执行对象 * Statement st = conn.createStatement(); * PreparedStatement pst = conn.prepareStatement(String sql); * pst.setObject("占位符序号","具体的参数值"); * * 4.使用执行对象执行sql语句,获取到结果集 * ResultSet rs = st.excuteQuery(sql); * ResultSet rs = pst.excuteQuery(); * * 5.处理结果集 * rs.next();//判断有没有下一条记录 * rs.getObject("字段名");//rs.getObject(字段对应的序号); * * 6.释放资源 * rs.close(),st.close,conn.close() * * 4.[重点] * JDBCUtils.java工具类 * //先定义4个字符串,数据库操作中的四大要素 * //这个工具类,主要为我们获取一个数据库连接 * private static String driverName = "com.mysql.jdbc.Driver"; * private static String url = "jdbc:mysql://localhost:3306/day04"; * private static String username = "root"; * private static String password = "123"; * //在静态代码块中注册驱动 * static&#123; * Class.forName(driverName); * &#125; * * //获取连接 * public static Connection getConnection()&#123; * return DriverManger.getConnection(url,username,password); * &#125; * * //关闭资源 * public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123; * //先判断是否为空 * //如果不为空关闭 * * &#125; * 5.练习:增删改查 * excuteUpdate();//执行增删改 * excuteQuery(); //执行查询 */ DBCP连接池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 所有的连接池必须遵循 javax.sql.DataSource接口 * * 在DBCP连接池中 * 实现 javax.sql.DataSource接口的实现类是: * BasicDataSource * 使用: * 创建BasicDataSource对象,并且给他设置数据库连接的四大要素即可 * private static BasicDataSource ds = new BasicDataSource(); * //设置数据库连接四大要素 后期都是通过配置文件读取 * ds.setDriverClassName(driverName); * ds.setUrl(url); * ds.setUsername(username); * ds.setPassword(password); *///自己用ArrayList实现的一个很low的连接池public class connPoolDemo &#123; private static String driverName = "com.mysql.jdbc.Driver"; private static String url = "jdbc:mysql://localhost:3306/warm"; private static String userName = "root"; private static String passward = "xunzhao"; private static ArrayList&lt;Connection&gt; conns = new ArrayList&lt;Connection&gt;(10); static &#123; try &#123; Class.forName(driverName); for (int i = 0; i &lt; 10; i++) &#123; Connection conn = DriverManager.getConnection(url,userName,passward); conns.add(conn); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; Connection conn = conns.remove(0); return conn; &#125; public static void closeAll(Connection conn, Statement st, ResultSet rs)&#123; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st != null)&#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;//没有用配置文件的DBCPUtilpublic class DBCPUtils &#123; private static String driverName = "com.mysql.jdbc.Driver"; private static String url = "jdbc:mysql://localhost:3306/day04"; private static String username = "root"; private static String password = "123"; private static BasicDataSource ds = new BasicDataSource(); //静态代码块,设置ds的四大要素 static&#123; ds.setDriverClassName(driverName); ds.setUrl(url); ds.setUsername(username); ds.setPassword(password); &#125; public static Connection getConnection() throws SQLException&#123; //返回一个连接对象,不要用DriverManager获取,而是连接池中获取 return ds.getConnection(); &#125; //关闭所有资源的统一代码 public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123; //负责关闭 if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(st != null)&#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;//改用配置文件 private static DataSource ds = null; static &#123; try &#123; Properties ps = new Properties(); //ps.load(new FileInputStream("F:\\javaWorkspace\\project2\\module01\\src\\dbcpconfig.properties")); ps.load(DBCPDemo1.class.getClassLoader().getResourceAsStream("dbcpconfig.properties")); ds = BasicDataSourceFactory.createDataSource(ps); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; C3P0连接池12345678910111213141516171819202122232425262728293031/** * 在C3P0连接池中 遵循了javax.sql.DataSource接口的实现类: * ComboPooledDataSource *最大优势是不用加载配置文件，按规定格式将配置文件置于src下即可 */ //不使用配置文件 private static ComboPooledDataSource ds = new ComboPooledDataSource(); //static代码块设置数据库连接四大要素 static&#123; try &#123; ds.setDriverClass("com.mysql.jdbc.Driver"); ds.setJdbcUrl("jdbc:mysql://localhost:3306/day04"); ds.setUser("root"); ds.setPassword("123"); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;//使用XML配置文件 会自动根据配置文件获取连接 // * 1.文件名和文件中标签名 必须是官方指定的 //* 2.必须放到src根目录下,C3P0的实现类ComboPooledDataSource会自动加载 private static ComboPooledDataSource ds = new ComboPooledDataSource();//后续开启事务获取统一连接和DBUtild会用到 public static ComboPooledDataSource getDataSources()&#123; return ds; &#125; DBUtils框架使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** * DBUtils框架的介绍 * * DBUtils类:主要负责关闭连接,释放资源,开启事务等操作 * * QueryRunner:负责我们对象数据库的CURD操作(核心类) * * ResultSetHandler:结果集处理类,帮我我们处理结果集(帮助我们封装数据的) * * QueryRunner类的使用: * 构造: * public QueryRunner(DataSource ds);//需要一个连接池 * public QueryRunner();//不需要连接,用来进行事务操作，后续调用方法时手动传入连接 * 方法: * int update(String sql, Object... params);//主要执行增删改 * query(String sql, ResultSetHandler&lt;T&gt; rsh, Object... params);//主要执行查询 * ResultSetHandler:结果集处理类 * 我们发现ResultSetHandler是一个接口, * 而框架中给我们定义了一堆实现类 * ArrayHandler: * ArrayListHandler * **BeanHandler * **BeanListHandler * ColumnListHandler * KeyedHandler * MapHandler * MapListHandler * **ScalarHandler * * * @author guardwarm * */public class DBUtilsDemo &#123; public static void main(String[] args) throws SQLException &#123; // TODO Auto-generated method stub// insert();// delete(); update(); &#125; //增 public static void insert() throws SQLException&#123; QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //插入 Object[] obj = &#123;16,"皮鞋类"&#125;; int rows = qr.update("insert into category (cid,cname) values (?,?)", obj); System.out.println(rows); // System.out.println( new QueryRunner(C3P0Utils02.getDataSource()).// update("insert into category (cid,cname) values (?,?)",// new Object[]&#123;17,"成人用品类"&#125;)); &#125; //删 public static void delete() throws SQLException&#123; //1.创建QueryRunner对象,给定连接池 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行 int rows = qr.update("delete from category where cid = ?", new Object[]&#123;17&#125;); System.out.println(rows); &#125; //修改 public static void update() throws SQLException&#123; //1.创建QueryRunner对象,给定连接池 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行 int rows = qr.update("update category set cname = ? where cid = ?", new Object[]&#123;"运动鞋类",16&#125;); System.out.println(rows); &#125; //ArrayHandler处理类的使用 将第一条记录的各字段存储在obj数组中 public static void demo01() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select * from category"; Object[] objs = qr.query(sql, new ArrayHandler()); //3.打印 for (Object obj : objs) &#123; System.out.println(obj); &#125; &#125; //ArrayListHandler处理类的使用 将多条记录存在list中 public static void demo02() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select * from category"; List&lt;Object[]&gt; list = qr.query(sql, new ArrayListHandler()); //3.打印 for (Object[] objects : list) &#123; System.out.println(objects[0]+"\t"+objects[1]); &#125; &#125; //BeanHandler处理类的使用 将一条记录存储在bean中 public static void demo03() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select * from category"; Category c = qr.query(sql, new BeanHandler&lt;Category&gt;(Category.class)); //3 System.out.println(c); &#125; //BeanListHandler处理类的使用 将多条记录存储在list中 public static void demo04() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select * from category"; List&lt;Category&gt; list = qr.query(sql, new BeanListHandler&lt;Category&gt;(Category.class)); //3 for (Category category : list) &#123; System.out.println(category); &#125; &#125; //ColumnListHandler处理类的使用 将一个字段存储在一个list中 public static void demo05() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select * from category"; List&lt;Object&gt; ids = qr.query(sql, new ColumnListHandler&lt;Object&gt;("cname")); //3 System.out.println(ids); &#125; //MapHandler处理类的使用 key为string类型，存的是字段名，value存的是第一条记录 public static void demo06() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select * from category"; Map&lt;String, Object&gt; map = qr.query(sql,new MapHandler()); //3 System.out.println(map); &#125; //MapListHandler处理类的使用 存储多条记录 public static void demo07() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select * from category"; List&lt;Map&lt;String, Object&gt;&gt; maps = qr.query(sql,new MapListHandler()); //3 System.out.println(maps); &#125; //ScalarHandler处理类的使用 存储单个值 public static void demo08() throws SQLException&#123; //1.创建QueryRunner对象 QueryRunner qr = new QueryRunner(C3P0Utils02.getDataSource()); //2.执行查询 String sql = "select count(*) from category"; Object count = qr.query(sql,new ScalarHandler&lt;Object&gt;()); //3 System.out.println(count); &#125;&#125; 事务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 1.事务: 是逻辑上的一组操作(多个sql语句),要么都成功 要么都失败 * * 2.事务的操作: * 开启事务: * java程序代码: 连接对象.setAutoCommit(false); * DOS窗口代码: start transaction; * 提交事务 * java代码:连接对象.commit(); * DOS窗口代码:commit; * 回滚事务 * java代码:连接对象.rollback(); * DOS窗口:rollback; * 3.ThreadLocal:线程本地变量 lang包中内置的一个对象 * ThreadLocal能保证,哪个线程保存的数据 只能由那个线程取出,别的线程取不到数据的 * public class ThreadLocal&#123; * Map&lt;Thread,Object&gt; map = new Map&lt;Thread,Object&gt;(); * public void set(Object obj)&#123; * map.set(Thread.currentThread(),obj); * &#125; * public Object get()&#123; * map.get(Thread.currentThread()); * &#125; * &#125; *///用原生JDBC实现转账 public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; Connection conn = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/warm","root","*****"); Statement st = conn.createStatement(); conn.setAutoCommit(false); int row1 = st.executeUpdate("update account set money = money - 1000 where name = 'mike'"); System.out.println(1/0); int row2 = st.executeUpdate("update account set money = money + 1000 where name = 'alice'"); if(row1 &gt; 0 &amp;&amp; row2 &gt; 0 ) &#123; conn.commit(); System.out.println("转账成功"); &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println("转账失败"); conn.rollback(); &#125; catch (SQLException e) &#123; System.out.println("转账失败"); conn.rollback(); &#125; &#125;&#125; 案例一：转账 案例二：商品查询系统出现的小问题 JavaBean必须变量名和字段名相同 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174/** * JDBC: * 1.JDBC原生API * 步骤: * 1.注册驱动: * Class.forName("com.mysql.jdbc.Driver"); * 2.获取连接: * Connection conn = * DriverManager.getConnection("jdbc:mysql://ip:3306/数据库名","用户名","密码"); * 3.获取sql执行对象 * Statement st = conn.createStatement(); * 4.执行sql语句,并且获取结果集(只有查询有结果集,其他都是int返回值) * int rows = st.excuteUpdate(sql); * ResultSet rs = st.excuteQuery(sql); * 5.处理结果集 * 结果集中的两个方法 * next();//判断有没有下一条记录 * getXxx(int colid),getXxx(String colname); * 其中Xxx可以是int,String,Double,Object * 6.释放资源 * conn.close(),st.close(),rs.close(); * 2.JDBCUtils工具类 * //四个要素 * private static String driverName = "com.mysql.jdbc.Driver"; * private static String url = "jdbc:mysql://localhost:3306/day04"; * private static String username = "root"; * private static String password = "123"; * //static * static&#123; * Class.forName(driverName); * &#125; * //获取连接: * public static Connection getConnection()&#123; * DriverManager.getConnecton(url,username,password); * &#125; * //关闭资源 * public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123;..&#125; * * 3.连接池: 是一个集合,预先获取一些连接对象,保存到集合中以便下次使用 * JDBC中规定:所有的连接池对象,必须实现 DataSource接口 * DBCP连接池: * public class BasicDataSource implements DataSource; * ================================================== * DBCPUtils工具类: 不使用配置文件 * //四个要素 * private static String driverName = "com.mysql.jdbc.Driver"; * private static String url = "jdbc:mysql://localhost:3306/day04"; * private static String username = "root"; * private static String password = "123"; * //连接池 * private static BasicDataSource ds = new BasicDataSource(); * static&#123; * //设置四大要素 * ds.setDriverClassName(driverName); * ds.setUrl(url); * ds.setUsername(username); * ds.setPassword(password); * &#125; * public static Connection getConnection()&#123; * ds.getConnection(); * &#125; * //关闭资源 * public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123;..&#125; * ================================================== * DBCPUtils工具类: 使用配置文件(推荐使用Properties配置文件) * //配置文件中写四个要素 * driverName=com.mysql.jdbc.Driver * url=jdbc:mysql://localhost:3306/day04 * username=root * password=123 * //连接池 * private static DataSource ds; * static&#123; * Properties ps = new Properties(); * ps.load(new FIleInputStream("dbcpconfig.properties")) * //用到一个生产BasicDataSource的工厂类 * ds = BasicDataSourceFactory.createDataSource(ps); * //设置四大要素 * //ds.setDriverClassName(ps.get("driverName")); * //ds.setUrl(ps.get("url")); * //ds.setUsername(ps.get("username")); * //ds.setPassword(ps.get("password")); * &#125; * public static Connection getConnection()&#123; * ds.getConnection(); * &#125; * //关闭资源 * public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123;..&#125; * ============================================= * C3P0连接池:不使用配置文件 * //四个要素 * private static String driverName = "com.mysql.jdbc.Driver"; * private static String url = "jdbc:mysql://localhost:3306/day04"; * private static String username = "root"; * private static String password = "123"; * //连接池对象 * ComboPooledDataSource ds = new ComboPooledDataSource(); * //静态代码块 * static&#123; * ds.setDriverClass(driverName); * ds.setJdbcurl(url); * ds.setUser(username); * ds.setPassword(password); * &#125; * public static Connection getConnection()&#123; * ds.getConnection(); * &#125; * //关闭资源 * public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123;..&#125; * ============================================= * C3P0连接池:使用配置文件 * //四个要素写到XMl文件中 * &lt;default-config&gt;&lt;!-- 默认配置 --&gt; * &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; * &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/day04&lt;/property&gt; * &lt;property name="user"&gt;root&lt;/property&gt; * &lt;property name="password"&gt;123&lt;/property&gt; * &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; * &lt;/default-config&gt; * //连接池对象 * //在创建ComboPooledDataSource对象时,底层会去自动读取并解析XML * //但是这个XML必须Src根目录下,文件名字必须叫做c3p0-config.xml * ComboPooledDataSource ds = new ComboPooledDataSource(); * * public static Connection getConnection()&#123; * ds.getConnection(); * &#125; * //关闭资源 * public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123;..&#125; * 第三方框架: DBUtils工具类 * DBUtils: 主要是关系资源 * public static void closeQuietly(Connection conn,Statement st,ResultSet rs); * * QueryRunner:SQL语句执行对象 * 不支持事务 * 构造:QueryRunner(DataSource ds) * 1.int update(String sql,Object... params) * 2. query(String sql,ResultSetHandler接口 rsh, Object...params) * 支持事务 * 构造:QueryRunner() * 1.int update(Connection conn,String sql,Object... params) * 2. query(Connection conn,String sql,ResultSetHandler接口 rsh, Object...params) * ResultSetHandler接口 的实现类 * Object[] ArrayHandler: * 把结果集中的第一条记录,封装到一个数组中,数组中的每个元素都是字段的值 * List&lt;Object[]&gt; ArrayListHandler: * 把结果集中的每一条记录,分别封装到一个数组中,数组中的每个元素都是字段的值 * 把所有数组再封装到List集合中,并返回这个集合 * JavaBean BeanHandler: * 把结果集中的第一条记录,封装到一个JavaBean对象中,并返回这个对象 * List&lt;JavaBean&gt; BeanListHandler: * 把结果集中的每一条记录,分别封装到一个JavaBean对象中, * 把这些对象保存到集合中,并返回这个集合 * Map&lt;String,Object&gt; MapHandler: * List&lt;Map&lt;String,Object&gt;&gt; MapListHandler * List&lt;Object&gt; ColumnHandler: * Object Scalarhandler: * 事务: * 开始事务: * try&#123; * conn.setAutoCommit(false); * insert(..) * insert(..) * insert(..) * conn.commit(); * &#125;catch(Exception ex)&#123; * conn.rollback(); * &#125; * ThreadLocal:底层是一个Map&lt;Thread,Object&gt; * set(Object 值);==&gt; map.set(当前线程对象,值) * get();===&gt;map.get(当前线程对象) * remove();====&gt;map.remove(当前线程对象) * */]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2019%2F09%2F21%2FXML%2F</url>
    <content type="text"><![CDATA[XML介绍XML:可扩展的标记语言。 可扩展的:扩展性特别强,语法上比较松 标记: 我们用的是1.0的版本 用于存放数据或配置文件 XML的语法:a.文档声明 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 版本一般选1.0，编码默认是utf8 b.注释: 开始：&lt;!– 结束 –&gt; c.元素(Element)/标签(Tag) 必须有开始和结束标签组成 &lt;dan&gt; &lt;/dan&gt; 一般只有一个跟标签，可以相互嵌套 d.属性:attribute 属性名=“属性值” 必须写在开始标签中 必须以字母开头 e.转义字符 12345&lt; --- &amp;lt;&gt; --- &amp;gt;" --- &amp;quot;' --- &amp;apos;&amp; --- &amp;amp f.CDATA区 当内容中出现大量的需要转译的字符 XML提供了CDATA区 12345678910111213141516&lt;abc&gt; &lt;![CDATA[ String s = "abc"; int count = 0; for(int i = 0;i &lt; s.length() ; i++)&#123; char c = s.charAt(i); if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')&#123; count++;]]&gt; &lt;!-- 特例：里面还包含了]]&gt;,需要分开成两个CDATA区 --&gt; ]]&amp;gt; &lt;![CDATA[ &#125; &#125; System.out.println("count = " + count); ]]&gt; &lt;/abc&gt; XML约束 DTD约束 文档开始注释会提示在xml文档前添加&lt;!DOCTYPE beans SYSTEM “bean.dtd”&gt; 第一个值为跟标签名字 根据智能提示编写即可 三种引入方式 内部DTD 外部DTD SYSTEM 本地DTD,后面一般跟个文件名 PUBLIC 公共DTD，后面一般跟个网址 Schema约束 文档开头注释会提示应在xml中1导入的信息 &lt;beans xmlns=”http://www.itcast.cn/bean&quot; xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=”http://www.itcast.cn/bean bean-schema.xsd”&gt; 注意这是一个开始标签，添加一下结束标签即可，其余使用方法和DTD差不多 如果有多个schema约束文件名字冲突时，需使用targetname来指定，但显得很冗长，可以给其起个别名 XML解析用io流来解析太过繁琐，一般使用第三方提供的解析开发包 三种解析方式 常用解析开发包 dom4j1.核心类 SAXReader:加载XML文件 2.Document对象,表示整个XML文件对象 3.元素:Element 获取根元素: document.getRootElement(); 获取属性: element.attributeValue(“属性名”) 获取子元素:List element.elements();//好几个重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//被解析文件&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;bean id="001" className="cn.itcast.demo.User"&gt; &lt;property name="username" value="jack"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="002" className="cn.itcast.demo.Admin"&gt; &lt;property name="username" value="admin"&gt;&lt;/property&gt; &lt;property name="password" value="123321"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;public class Dom4JDemo &#123; public static void main(String[] args) throws DocumentException &#123; // TODO Auto-generated method stub //1.把整个要解析的XML文件加载到内存 SAXReader reader = new SAXReader(); //2.会生产一个Documnet对象 Document document =reader.read(new File("beans.xml")); //3.获取根标签 Element rootEle = document.getRootElement(); //4.获取根标签的子标签 List&lt;Element&gt; beanElements = rootEle.elements(); //5.遍历elements集合 for (Element beanElement : beanElements) &#123; //6.获取子标签bean的属性 String idValue = beanElement.attributeValue("id"); String classNameValue = beanElement.attributeValue("className"); System.out.println(idValue+".."+classNameValue); //获取bean的子标签 List&lt;Element&gt; propertyElements = beanElement.elements(); //遍历property标签 for (Element propertyElement : propertyElements) &#123; //propertyElement Property标签 //获取Property的属性 String nameValue = propertyElement.attributeValue("name"); String valuevalue = propertyElement.attributeValue("value"); System.out.println(nameValue+"==="+valuevalue); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F09%2F20%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySQL软件安装去MySQL官网下社区版，根据网上教程配置属性 还下了SQLyog，可以图形化界面写mysql（注册码百度一下很好找） 数据库（DB）和数据库管理系统（DBMS）数据库：存储数据的仓库，本质是一个文件管理系统 数据库管理系统：是一个软件，用来管理文件 我们常说的数据库，实际上是数据库管理系统，一般习惯称为数据库 一般不直接操作DB，而是通过DBMS来操作DB 表（java中一个类）行：一条记录 类的一个对象 列：一个字段 java中一个属性 常见数据库MySQL：开源免费，小型的数据库，已经被Oracle收购，开始收费（6.x之后） Oracle：收费的大型数据库，收购了SUN,MySQL DB2：IBM的数据库，常用在银行，效率差，安全性高 SQLSever：Microsoft的，常用于c#，.net SyBase：已经淡出历史舞台，提供了一个专业的数据建模工具——PowerDesigner SQLite：嵌入式的小型数据库，用于手机端 MySQL开启和关闭 法一：此电脑-&gt;管理-&gt;服务-&gt;找到MySQL即可 法二：以管理员权限打开command net start mysql net stop mysql mysql -u root -p(直接跟密码或回车然后会提示输入密码) 法三：用SQLyog SQL语句 DDL：数据库定义语言 defination 主要是对数据库数据库表进行创建删除等维护操作 create 创建 drop 删除 alter 修改 show 查看 DCL：数据库操纵/控制语言 control 控制数据库访问权限 DML：数据库操作语言 manager 主要是对表中数据进行增删改 insert 增加 delete 删除 update 修改 DQL：数据库查询语言 query 主要是对表中数据进行查询 select 查询 from 从 where 条件 SQL通用语法 SQL语句可以单行或多行书写，以分号结尾 可使用空格和缩进来增强可读性 语句不区分大小写，关键字建议使用大写 /**/ 块注释 # 单行注释 常用数据类型（还有很多，但不常用） int 整形 double 浮点型 varchar 字符串型 date 日期型 yyyy-mm-dd，没有时分秒 DDL操作数据库​ 增 ​ create database 数据库名 采用默认编码，安装时选的 ​ create database 数据库名 charset utf8 ​ 删 ​ drop database 数据库名 ​ 改 ​ 修改数据库名字很麻烦 ​ use 数据库名 修改正在使用的数据库 ​ 查 ​ select database() 查询正在使用的数据库 ​ show database 查询所有数据库 ​ show create database 数据库名 查询某个数据库详细信息 操作数据库表​ 增 ​ create table 表名（ ​ 字段名1 数据类型1（长度） [约束]， ​ 字段名2 数据类型2（长度） [约束] ​ 字段名2 数据类型2（长度） [约束] ​ ）； ​ 删 ​ drop table 表名 ​ 查 ​ desc 表名 查看一个表的详细信息 description ​ show tables 查看所有的表 ​ 改 ​ rename table 表名 to 新表名 改名字 操作数据库表中的列​ 增 ​ alter table 表名 add 列名 类型（长度） [约束] ​ 删 ​ alter table 表名 drop 列名 ​ 查（同查看表的信息） ​ desc 表名 查看一个表的详细信息 ​ 改 可以修改列的名字，类型，约束等等 ​ alter table 表名 change 旧列名 新列名 类型(长度) 约束 修改列名,实际上类型和约束也可以一起改了 ​ alter table 表名 modify 列名 类型（长度） 约束 修改类型和约束 ​ alter table 表名 character set 字符集 一般不修改 DML增 insert into 表名 (列名1，列名2) values (value1，value2) 插入一条记录 列名可以选择一列或几列，前后必须一一对应 除了int，double，其它数据必须用””或’’引起来，推荐使用单引号 如果要插入的记录所有字段都有，则(列名1，列名2)可省略 删 delete from 表名 删除所有记录 delete from 表名 where 条件 改 update 表名 set 字段名=值 把该字段内所有的值都改了 update 表名 set 字段名=值 where 条件 DQL基本查询select [distinct] *|列名1，列名2 from 表名 查询表中所有行数据 distinct 去重查询 字段名+10 查询结果是表达式 运算查询 字段名+10 as 新名字 别名查询 条件查询 1234567891011121314151617181920212223where price &lt;&gt; 60;where not (price=60);where price &gt;= 400 and price &lt;= 600;where price between 400 and 600;where price in (400,600); 价格是400和600的where price &gt;1000 or price &lt; 300;where pname like &apos;%霸%&apos; 名字中含&apos;霸&apos;的商品where pname like &apos;_霸%&apos; 名字中第二个字为&apos;霸&apos;的商品where pname is null; 没有名字的，不可以用pname=nullwhere price &gt;2000 and category_id in (&apos;c002&apos;,&apos;c003&apos;);where (price &gt;2000 and category_id=&apos;c002&apos;) or(price &gt;2000 and category_id=&apos;c003&apos;); 排序查询对查询结果进行排序，关键字order by 格式：查询语句 order by 字段名 [ASC|DESC] ASC 升序，从小到大，默认 DESC 降序，从大到小 聚合查询以前的查询都是横向记录查询，该查询是纵向个数查询 查询特点：查询到的是单一值 聚合函数：求记录数的聚合函数 格式：聚合函数（字段名） ​ count函数会自动忽略空值 ​ max：求最大值 ​ min：求最小值 ​ avg：求平均值 ​ sum：求和 分组查询把查询到的结果分成几个组，先分组再查询，具体查询到的结果数，取决于分成几个组 若分组后还有条件需要判断，用having关键字 where写在基本查询语句后，且后面不可以写聚合函数 having写在分组查询后，且后面可以写聚合函数 格式：查询语句 group by 字段 select count() from product group by categroy_id having count(\)&gt;1 只显示个数大于1的商品分类，注意条件用having 完整查询过程 分页查询只查询记录的一部分 格式：limit 数值一（开始下标，从0开始计数），数值二（需要查出的记录数） 查询公式：假设每次查n条 第m页 limit (m-1)*n,n 多表查询交叉查询 格式：select * from 表一，表二 总字段=表一字段+表二字段 总记录数=表一记录数*表二记录数 但交叉查询无实际意义，实际上是一个矩阵（坐标）的笛卡尔，是另外两个查询的基础 内连接查询 inner join 隐式内连接查询：不写关键字inner join select * from 表一，表二 where 表一.主键=表二.外键 显式内连接查询：写关键字inner join select * from 表一 inner join 表二 on 表一.主键=表二.外键 外连接查询 outer join 左外连接：left outer join select * from 表一 left outer join 表二 on 表一.主键=表二.外键 左外连接，以左表为主，左表中数据都会有 右外连接：right outer join select * from 表一 right outer join 表二 on 表一.主键=表二.外键 右外连接，以右表为主，右表中数据都会有 子查询一个查询的结果，做另一个查询的一部分 12SELECT * FROM products WHERE category_id IN (SELECT cid FROM category WHERE cname IN('化妆品'，'家电'))； SQL备份和恢复在SQLyog中，右击数据库进行导入和导出 三个知识点两个约束主键约束(primary key):只能有一个，值必须唯一且不能为空 自动增长约束（auto_increment):初始值唯一，若被设置为一个值后，下一个值从这个的基础上增加 删除表所有数据的两种方式 delete from 表名 所有记录被删除，但自增值不会重置 truncate table 表名 删除所有记录，并重置自增值 底层是先摧毁表，再重建 乱码问题 在DOS中查看utf8编码的数据库数据时会出现乱码问题，因为DOS默认的是gbk 解决方法 临时方案：set names gbk 临时的确告诉数据库我们用gbk来查询 永久方案：修改my.ini的配置文件，不建议 数据完整性添加数据完整性==添加表约束 实体完整性：对数据行的约束，比如主键约束，唯一约束 域完整性：对数据列的约束 引用完整性：外键约束（多表关系） 各种约束主键约束：primary key 保证该字段唯一并且不为空 123456789101112131415161718-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE，-- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;//创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid)//删除主键约束ALTER TABLE books DROP PRIMARY KEY; -- 因为只能有一个主键，所以无需加字段名 唯一约束：unique 保证该字段唯一，可以为null 123456789101112131415161718192021-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT UNIQUE, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT unique_bid UNIQUE(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid);-- 删除主键约束ALTER TABLE books DROP UNIQUE(约束名); -- /如果添加唯一约束时没起名字，默认是字段名 自动增长约束：auto_increment 把该字段的值交给数据库去维护，默认每次加一（这个字段必须是建，多为主键） 1234567891011121314151617181920-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY AUTO_INCREMENT, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY bid INT AUTO_CREMENT-- /字段名 类型 约束-- 删除主键约束ALTER TABLE books MODIFY bid INT; 非空约束：not null 被约束字段不可为空值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) NOT NULL, bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 默认约束：default 给字段添加一个默认值，如果添加记录时没赋值的话用默认值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) DEFAULT 'JAVA 入门', bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 多表操作双向看，两边都是一个记录对另一边多个记录，这是多对多，否则为一对多 一对多：两张表即可，多个外键字段关联起来 多对多：需要一张中间表 12345678910111213141516171819-- 多对多建表，一张学生表，一张课程表，一张中间表，至少两个字段-- 创建三张表CREATE TABLE student&#123; sid INT PRIMARY KEY AUTO_INCREMENT, sname VARCHAR(20), sage INT&#125;CREATE TABLE course&#123; cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(20)&#125;CREATE TABLE student_course_item&#123; student_id INT&#125;-- 添加外键约束 核心ALTER TABLE student_course_item ADD CONSTRAINT item_student_fk FOREIGN KEY(student_id) REFENRENCE student (sid);ALTER TABLE student_course_item ADD CONSTRAINT item_course_fk FOREIGN KEY(course_id) REFENRENCE course (cid); 特例：有时候两张表内记录一对一，但字段过多，也会分成两张表 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * 一.SQL语句 * * 1.分类: * DDL:数据库定义语言,主要对数据库,表,列,进行增删改查 * a.创建数据库 * create database 数据名 [charset 字符集名]; * ***b.创建表 * create table 表名( * 字段名 数据类型(长度) [约束], * 字段名 数据类型(长度) [约束] * ); * SQL中的数据类型: * 整数:int * 小数:double * 字符串:varchar(长度),建议 用2的整数倍 * 日期:date 格式: 'YYYY-MM-DD' * SQL中的约束: * a.主键约束:primary key, 唯一且非空 * b.自动增长列约束:auto_increment,必须是数值类型,而且一般我们会给主键加上自增长约束 * c.唯一约束:Unique, 多个记录的该列的值不能相同 * d.非空约束: Not Null,不能为null * e.默认约束: default 默认值,为某一个字段设置默认值 * f.外键约束: foreign key 多表查询 * DCL:数据库控制语言 * 了解(Oracle时说讲述) * **DML:数据库操作语言 : 对数据库中表中的数据进行增删改 * 增: * insert into 表名 (字段1,字段2...) values (值1,值2,值3); * 注意事项: * 1.字段和值要一一对应 * 2.如果是全字段,表名后面可以不写,但是values必须写上全部字段的值 * 3.值的写法: 除了数值类型的值,其他值必须用''或者""括起来 * 删: * delete from 表名 [where条件]; * trancate table 表名: * 以上两种删除表中数据的区别: * delete from 表名:只会删除记录,不会重置自动增长值,下次插入数据时,接着增加自动增长值 * trancate table 表名: 摧毁表,再重建,即会删除所有记录,也会重置自动增长值(重置为1) * 改: * update 表名 set 字段=值,字段=值 [where 条件] * * **DQL:数据库查询语言: 对数据库中表中的数据进行花式查询 * 单表查询: * a.条件查询: * select * from 表名 where 条件: * 条件: * 大小: &gt; &lt; &gt;= &lt;= = != &lt;&gt; * 区间: * between .. and .. 注意:只能判断数值和日期 * 比如: between '1990-05-30' and '2000-10-10' * age in (10,20)===&gt; age=10 or age = 20; * 为空: * is null; * is not null * 模糊查询: * like '表达式', 符号_表示任意一个字符 符号%表示任意个任意字符 * b.排序查询 * select * from 表名 order by 字段 ASC(默认,升序)|DESC(降序); * c.聚合查询: * select count(*)|max(数值字段)|min(数值字段)|sum(数值字段)|avg(数值字段) from 表名 * 注意事项:聚合函数查询出来的只有一个值,会忽略null值 * d.分组查询: * select 分组字段,聚合函数 from 表名 group by 某个字段; * 在分组查询中,要查询的字段必须是分组字段,也可以是聚合函数 * e.分页查询 * select * from 表名 limit 第几条记录,要查询第三条记录 * 比如: 我要查询第m页,每页有n条记录 * 第一页: limit (1-1)*n,n; * 第二页: limit (2-1)*n,n; * 第m页: limit (m-1)*n;n * f.去重复查询 * select distinct 字段 from 表名; * 查询出所有该字段,并且去掉重复值 * 多表: * 1.为什么使用多表? 回顾第二天视频 * 2.表与表之间的关系: * 一对多:商品分类 和 商品信息, 学生和考试成绩,省和市 * 必须两张表,一张主表,一张从表, * 原则:从表必须有一个外键,这个外键 引用 主表的主键 * 如何给从表添加外键约束 * Alter table 从表 add constraint 主表_从表_fk * foreign key (从表外键名) references 主表 (主键名); * 多对多: 学生和课程, 演员和角色 , 老师和学生 * 必须有三张表,两张正常表,一张中间表 * 原则: 中间表,至少有两个字段,分别是外键,引用两张的主键 * Alter table 中间表 add constraint _fk * foreign key (第一个外键名) references 第一张表 (主键名); * Alter table 中间表 add constraint _fk * foreign key (第二个外键名) references 第二张表 (主键名); * 一对一: QQ号码,和QQ详细信息 * 可以用一张表示 * 多表查询语句: * 1.交叉查询: 本身有错误的 ,实际上是一个叫做笛卡尔积的东西 * select * from 表1,表2; * 2.内连接:在交叉连接的基础上 添加条件(一般是主表.主键=从表.外键) * 隐式内连接: 不写inner join 后面的条件用where判断 * select * from 表A,表B where 表A.主键=表B.外键 * 显示内连接: 写上inner join 后面的条件用on判断 * select * from 表A inner join 表B on 表A.主键=表B.外键 * * 3.外链接:关键字 outer join * 左外连接: left outer join,以左表作为,如果右表中没有和左表匹配的那条记录 * 那么也会将这条记录查询出来,没有值的地方填充null; * 右外连接: right outer join * 以右表作为,如果左表中没有和右表匹配的那条记录 * 那么也会将这条记录查询出来,没有值的地方填充null; **内外连接的区别**- 内连接（inner join）：取出两张表中匹配到的数据，匹配不到的不保留- 外连接（outer join）：取出连接表中匹配到的数据，匹配不到的也会保留，其值为NULL * 4.子查询: * 一条select语句的结果,作为另外一条select语句的一部分 * 比如: 商品分类表和 商品详情表为例 * 查询 商品名字为 "霸王" 的商品的分类名 * select cname from 商品分类表 where 分类id = * (select 商品分类id from 商品详情表 where 商品名="霸王"); * */ 异常解决【MySQL】SELECT list is not in GROUP BY clause… 12345678910SELECT a.* FROM tbl_inspection_equipment_record aRIGHT JOIN ( SELECT * FROM tbl_inspection_equipment_record WHERE state = 1 AND build_id = ? ORDER BY end_time DESC) AS tempON a.id = temp.idGROUP BY room_idORDER BY end_time DESC 问题原因 MySQL 5.7.5及以上功能依赖检测功能。如果启用了 ONLY_FULL_GROUP_BY SQL 模式（默认情况下），MySQL 将拒绝选择列表，HAVING 条件或 ORDER BY 列表的查询引用在 GROUP BY 子句中既未命名的非集合列，也不在功能上依赖于它们。（5.7.5之前，MySQL 没有检测到功能依赖关系，默认情况下不启用 ONLY_FULL_GROUP_BY。有关5.7.5之前的行为的说明，请参见“MySQL 5.6参考手册”。） 解决方案方法一(该方式每次mysql服务重新启动恢复原来的模式) S1：select @@global.sql_mode; S2：执行以下sql语句，去除步骤1中 ONLY_FULL_GROUP_BY 1234567set @@global.sql_mode =&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;; 方法二：修改配置文件 远程服务器找到 my.cnf 文件 在文件底部加入 12sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION 重启mysql]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用途正则表达式（regular expression，简称regex）：是一些用来匹配和处理文本的字符串 正则表达式通常被简称为模式，其实是一些由字符构成的字符串 这些字符可以是普通字符（纯文本）或元字符（有特殊含义的特殊字符） 匹配单个字符 . 匹配任何单个的字符 \ 对特殊字符进行转义 匹配一组字符[和] 定义字符集合 [0-9a-zA-Z] - 定义字符区间 0-9 a-z ^ 对字符集合进行取非匹配 [^0-9a-zA-Z] 元字符 空白字符 [\b] 回退（删除）一个字符 \f 换页符 \n 换行符 \r 回车符 \t 制表符（tab） \v 垂直制表符 \s 任何一个空白字符 [\f\n\r\t\v] \S 任何一个非空白字符 匹配数字 \d 任何一个数字 \D 任何一个非数字 匹配字母和数字 \w 任何一个字母，数字和下划线 \W 任何一个非字母，数字和下划线 进制 \x 十六进制 \0 八进制 POSIX字符串 [[:alnum:]] 数字字符 [[:alpha:]] 字母字符 [[:lower:]] 小写字母字符 [[:print:]] 可显示的字符 [[:blank:]] 空格(space)与定位字符 [[:punct:]] 除[[:cntrl:]]和[[:alnum:]]外 [[:cntrl:]] ASCII控制字符(0-31和127) [[:space:]] 空白(whitespace)字符 [[:upper:]] 大写字母字符 [[:digit:]] 数字字符 [[:graph:]] 非空格(nonspace)字符 [[:xdigit:]] 十六进制数字字符 重复匹配+ 给字符或字符集合作为后缀，表示匹配一个或多个字符或字符合集 * 给字符或字符集合作为后缀，表示匹配零个或多个字符或字符合集 {num1，num2} 精确重复次数 {6} {1,4} {3,} ? 给字符或字符集合作为后缀，表示匹配零个或一个字符或字符合集 前三个为贪婪型元字符，为了防止过度匹配，会在其后加个？变为懒惰型元字符 位置匹配\b 用来匹配单词的开始或结束（\w与非\w之间） 只匹配一个位置，而不匹配任何字符 \B 匹配一个前后都不是单词边界 \&lt; 单词开始 \&gt; 单词结束 ^ 字符串开始 $ 字符串结束 (?m) 分行匹配模式，必须写在模式最前面 子表达式(和) 字表达式可以多层嵌套 回溯引用：前后一致匹配\n 匹配前面第n个子表达式 $n 替换时使用匹配上一条查询中的第n个子表达式匹配到的内容 大小写转换（替换时使用） \E 结束\L或\U转换 \I 把下一个字符转换为小写 \L 把后面的字符转换为小写 \u 把下一个字符转换为大写 \U 把后面的字符转换为大写 前后查找都是只匹配但不消费 (?=字符) 正向前查找，匹配到指定字符，停止匹配 (?!字符) 正向前查找，匹配到不是指定字符的，停止匹配 (?&lt;=字符) 正向后查找，匹配到指定字符，停止匹配 (&lt;=字符) 负向后查找，匹配到不是指定字符，停止匹配 嵌入条件(?(n)regex) 如果前一个子表达式匹配到了则执行该正则 (?(前后查找)regex) 如果前后查找成功了则执行该正则]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2019%2F09%2F04%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git版本控制系统 记录版本信息（记录每一次的修改） 方便团队相互之间协作，共同开发 常用版本控制系统 svn/cvs：集中式版本控制系统 共用一个服务器，一旦出问题就全完了，保存差异 git：分布式版本控制系统 保存的是所有文件的快照，每个人本地都相当于一个服务器 Git安装这个网上很常见，自行参考网上教程 使用GitHub目的：托管项目代码工作区 -&gt; 暂存区 -&gt; 历史区 1.Git的全局配置123456789第一次安装完成git后，要在全局环境下配置基本信息：我是谁？$ git config -l 查看配置信息$ git config --global -l 查看全局配置信息配置全局信息，用户名和邮箱$ git config --global user.name 'xxx'$ git config --global user.email 'xxx@xx.xx'初始化ssh$ ssh-Keygon 先是确定保存路径，再是密码，三次回车即可在C:\Users\asus\.ssh用记事本打开id_ssh.pub,复制其中内容 2.创建仓库完成版本控制123456789101112131415161718192021222324252627282930创建本地git仓库$ git init会生成一个隐藏文件夹“.git”（这个文件夹很重要，暂存区和历史区以及一些其他数据都在里面存着）在本地编写完成代码后（在工作区），把一些文件提交到暂存区$ git add xxx 把某一个文件或者文件夹提交到暂存区$ git add . || git add A 把当前仓库中所有最新修改的文件都提交到暂存区$ git status 查看当前文件的状态（红色代表工作区，绿色代表暂存区，看不见东西代表所有东西都已提交到历史区）把暂存区内容提交到历史区$ git commit -m'描述信息'本地版本库回退$ git checkout -- 文件名 回到最近的一次add/commit时的状态$ git reset --hard/mixed/soft HEAD~num --hard 回退全部，包括HEAD，index，working tree --mixed 回退部分，包括HEAD，index --soft 只回退HEAD查看历史版本信息（历史记录）$ git log$ git reflog 包含回滚的信息 可以获得版本号差异比较$ git diff 比较工作区和暂存区$ git diff --cached 比较暂存区和本地库最近一次提交的区别$ git diff HEAD 比较工作区和本地库最近一次提交的区别分支操作$ git branch -d 分支名 删除分支$ git remote push 分支一：分支二 将分支一推给分支二$ git branch 查看现在有哪些分支$ git checkout 分支名 切换到分支$ git checkout -b 分支名 创建并切换到新分支 通过移动head指针来改变版本 一般多分支同时开发，然后由项目组长来分支合并 git小技巧 把一些暂时用不到的修改，暂存起来 GitHub一个网站（开源的代码管理平台），用户注册号，可以在自己账户下创建仓库，用来管理项目的源代码（源代码基于git传到仓库中） 我们所熟知的插件，类库，框架等都在这个平台上有托管，我们可以下载观看和研究源码等 settings用户设置 profile 修改自己的基本信息 account 作用修改用户名 security 可以改自己的密码 emails 私有仓库作为内部团队协作管理的项目 …… new repository -&gt; 填写信息，公私有都免费 -&gt; create repository public 公共开源 private 私有，作为内部团队项目 settings -&gt; 删除仓库 ​ -&gt; collaborators 设置协助开发人员，需对方同意邀请 code可以查看历史版本和分支信息 把本地仓库信息提交到远程仓库 12345678910111213141516171819202122查看本地仓库和哪些远程仓库保持连接$ git remote -v让本地仓库和远程仓库创建一个连接 origin是随便起的一个名字，但一般都用这个$ git remote add origin [仓库地址]$ git remote rename old new 重命名解除关联信息$ git remote rm origin提交之前最好先拉取$ git pull origin master将本地代码提交到远程仓库（第一次需要输入用户名和密码）$ git push origin master将远程仓库代码拉取到本地$ git clone [远程仓库git地址] [别名，默认为仓库名，也可以起一个作为拉取后的文件夹名]/* *真实项目开发流程： * 1.组长或者负责人先创建中央仓库 * 2.小组成员基于$ git clone 把远程仓库及默认的内容克隆到本地（解决了三个事情：初始化一个 本地仓库“git init”，和对应的远程仓库也保持了关联“git remote add”，把远程仓库默认内人拉取到本地 “git pull” * 3.每个组员写自己的程序后，基于“git add/git commit”把自己修改的内容存放到历史区，然后通过 “git pull/git push”把本地信息和远程仓库信息保持同步即可（可能涉及冲突处理） */ NPMnode package manger:NODE模块管理工具，根据NPM我们可快速安装、卸载所需要的资源文件 区NODE官网：下载NODE重启支持版，安装NODE后，NPM也跟着安装了 基于npm是从npmjs.com平台下下载安装 123//在终端中检测安装是否成功，出现版本号即成功了node -vnpm -v 12345678910111213$ npm install xxx 把模块安装在当前项目中（node_modules）$ npm install xxx -g 把模块安装在全局环境中$ npm i xxx@1.0.0 安装指定版本号的模块$ npm view xx version &gt; xxx.version.json 查看某个模块的版本信息（输出到指定json文件中）$ npm init -y 初始化当前项目的配置依赖清单$ npm i xxx -save 把模块保存在清单生产依赖中$ npm i xxx --save-dev 把模块保存在清单开发依赖中$ npm install 跑环境，按照清单安装所需模块$ npm root -g 查看全局安装模块的目录$ npm -uninstall xxx$ npm -uninstall xxx -g 卸载安装过的模块 高级搜索 更多高级搜索]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE]]></title>
    <url>%2F2019%2F08%2F16%2FjavaSE%2F</url>
    <content type="text"><![CDATA[入门及环境搭建下载JDK进入Oracle官网，下载相应版本，最近下载好像都得注册个账号 下完按到所需目录，一般默认，一直下一步即可，完了设置一下环境变量 此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;编辑path，把bin目录路径加入 classpath也可以设置 在cmd中，输入java -version检查是否安装成功 javac 文件路径（编译，生成。class文件） java 文件名，不加后缀，运行 IDE选择 目前比较流行的是eclipse和IDEA，我更喜欢IDEA，熟练了快捷键和各种模板之后会用得很舒服 语言特点通过编译成统一的字节码，不同平台下载对应JVM来实现跨平台 完全面向对象，简单，高性能，分布式，多线程，健壮 JDK（用于开发）-&gt;JRE（运行环境）-&gt;JVM(依次包含) java SE 标准版，定位于个人计算机用户 java EE 企业版，定位于服务器端领域 java ME 微型版，定位于消费电子产品的应用 越高级语言越容易入门，但要精通还需沉下心来 数据类型和运算符注释单行，多行，文档注释 标识符的命名规则虽然不同语言之间会有细微区别，但为了便于编写，感觉大多数语言都推荐采用比较大众的规范 不可以是java关键字，并且大小写敏感 类名 大驼峰命名法 方法和变量 小驼峰命名法 常量 大写 数据类型向上隐士转换，向下需要显示加括号强转 基本数据类型（四类八种）byte(1) boolean(1) short(2) char(2)unicode字符集 int()4 float(4) long(8) double(8) 限制double小数点数 12DecimalFormat df = new DecimalFormat("0.00");df.format(total); string与基本类型转换 包装类的parse和tostring方法 引用数据类型string，数组，集合ArrayList，Scanner，Random，自定义类型 包的声明和访问包的本质就是文件夹，在包名中以.来区分上下级文件关系 作用：分类管理文件 包的声明：package 包名 指示某个类在哪个包下 包的声明必须和类的实际位置保持一致 包的导入：用来告诉编译器我们要用的类在哪个包下 import 包名.类名 不导包时需采用全限定类名：包名.类名（所有用到类名的地方都需这样写） 四种访问权限修饰符 面向对象面向对象是一种编程思想，是相当于面向过程的 面向过程：遇到问题，亲力亲为一步一步解决 核心理念：谁的功能谁负责 面向对象：遇到一个问题，找具有解决这个问题能力的对象，调用它的方法 面向对象三大特性：封装（安全性），继承（拓展性），多态（） 类的格式 1234567public class 类名&#123; //构造方法 //成员类名 //成员方法&#125;//一个标准的类 封装：隐藏细节，对外暴露公共防蚊1方式 构造：无参必须有，全参最好有//类名作为方法参数或返回值时需要传入或返回的应该是该类的对象 继承继承是两个类之间的关系，子类继承父类 this关键字区分局部变量和成员变量同名的情况 this的本质：实际上是个对象 谁调用的方法，this指的就是谁 匿名对象：（可用可不用） 没有名字的对象 只创建对象，但不用变量接收 在一些用来传参后续不调用时使用 特点：匿名对象也是一个对象，具有对象所有功能 ​ 每次调用都是一个新的对象，所一每个对象只能使用一次 123this.xxx //调用该对象属性this.aaa() //调用该对象方法//高级使用：用来调用本类的其他构造 通过输入不同参数来调用不同构造 super关键字区分子类和父类成员同名的情况，但默认优先调用子类 1234super.xxx //调用父类属性super.aaa() //调用父类方法super(); //调用父类构造方法，通过输入不同参数来调用不同构造，默认调用无参构造//无论调用子类那个构造，都会先调用父类构造，符合单一职责原则，一个类只需负责给本类变量初始化 继承12345678910111213public class 子类 extends 父类&#123; &#125;//继承必须合理 人是人他妈生的，妖是妖他妈生的//继承中的成员抽取了子类中的共性内容//子类会自动继承父类中所有成员，但private不可访问//创建子类对象时会先创建其父类对象//继承后成员变量不同时，没有任何问题，相同时优先访问子类//继承后成员方法不同时，没有任何问题，相同时(子类重写了父类方法时)优先访问子类，但可以通过super.方法名访问//只能单继承，但可以多层继承（直接父类唯一，但可以有多个间接父类）//多继承的话调用方法时会产生不确定性，同名父类成员不知道该掉哪个 继承大大提高代码重用性 方法的重载：在同一个类中，方法名相同，但参数列表不同（参数类型，参数顺序，参数个数任一不同） 方法的重写（覆盖，覆写override）：子类中出现了和父类一模一样的方法 重写原因：当子类发现继承过来的方法不适用时需要重写自己的方法 重写要求：该方法子类权限需大于等于父类权限（一般都是相同权限） public protected default private private方法不可重写 方法名，参数列表，返回值类型必须一模一样 多态一个对象的多种状态 java中的前提：必须有字符类关系，必须有方法的重写 抽象类和接口抽象类：以前一个类中包含抽象方法即为抽象类，现在只要由关键字abstract修饰即为抽象类 抽象类不可以实例化，天生就是作为父类的 抽象方法：只有声明而没有实现 向上抽取时会出现一种特殊情况，方法功能声明相同，但方法主体不同，这时只抽取方法声明，所得即为抽象方法 必须用关键字abstract修饰 不能调用，为了强制子类去重写 类名作为返回值或参数时，传递和返回的应是该类对象 抽象类作为返回值或参数时，传递和返回的应是该类的子类的对象 链式编程：当返回值为调用这个方法的对象时，便可以链式的调用下去 小练习 12//案例：武警开坦克打飞机//名词提取：武警 坦克 飞机 再分析每个类对应属性和方法 接口类：一堆具有共同属性和成员方法的对象的集合 接口：方法的集合，只能定义抽象方法 天生作为父接口 12345678910111213//class 类//abstract class 抽象类//interface 接口//enum 枚举public interface 接口名&#123; //不能定义普通成员变量，只能定义抽象方法 //可以定义常量 public static final 变量名 即使不加修饰，编译器也会自动添加&#125;//开发中常用模式：一个类继承一个抽象类，实现多个接口public class A extends AbstractClass B implements 接口A，接口B&#123; &#125; 类与类之间是单继承，一个子类只能有一个直接父类 接口与接口之间支持多继承也支持多层继承 类与接口之间不叫继承（extends）而是实现（implements） 可以多实现 比较抽象类和接口 相同点：都不能实例化，都是作为父类/父接口，子类继承/实现都不行重写抽象方法 不同点：抽象类中不全是抽象方法，可以有普通成员变量，修饰的关键字不同 弥补了java的单继承 思想上的区别：抽象类中必须定义整个体系的共性内容 ​ 接口中定义整个继承体系之外额外的扩展功能（谁想有这些功能就来是实现下这个接口） 优先使用接口 需要定义子类行为又要为子类提供共性功能时才用抽象类 多态父类类型 变量名 = new 子类类型(); 父类类型变量指向了子类对象 注意事项：多态使用变量是，编译和运行都看父类 调用成员方法，编译看父类，运行看子类 多态的弊端：只能调用子父类共有的方法，不能调用子类特有的（因为编译时看父类，特有的编译过不了） 好处：提高灵活性，父类可以接收任何一个子类对象 传哪个子类运行哪个子类的方法 1234//弊端解决方案//向下转型：强制类型转换 double转int，父类转之类 把向下和强转关联记忆吧//向上转型:隐式类型转换 子类转父类（多态） 向下转换会面临不知道该转成哪个子类的困扰，易出现类型转换异常//向下转型弊端解决：instanceof 格式：boolean b = 父类对象名 instanceof 子类对象名 内部类 成员内部类：定义类中方法外 在其他类中创建对象 外部类名.内部类名 对象名 = new 外部类名().new 内部类(); 局部内部类：定义方法中 在其他类中无法使用，只能局部使用 匿名内部类一种特殊的语法，用于快速创建抽象类的对象 12345678910111213141516//创建抽闲类对象//创建子类继承抽象类 重写抽象方法 new子类对象//用匿名内部类可以一步完成new 抽象类名()&#123; //重写方法&#125;;new 抽象类名()&#123; //重写方法&#125;.调用属性/方法;//最常用抽象类名 对象名 = new 抽象类名()&#123; //重写方法&#125;;//只重写抽象方法而不写独有的方法，因为没有名字，即使写了也无法向下强转为子类调用 静态代码块12345678public class 类名&#123; static&#123; //当我们使用到这个类的时候（实例化或使用静态成员等等），JVM会自动执行静态代码块中的内容 //仅在第一次使用到这个类的时候会执行一次，第二次就不会了 //优先级高于main和构造方法 //用于初始化类，比如MySQL加载驱动等 &#125;&#125; 访问修饰符static 静态的用于修饰类中的成员 被static修饰的成员访问时无需实例化再调用，可以直接通过类名访问（推荐） 当一个对象不独属于某个成员，而是所有成员共享事应加static修饰 静态没有多态性，静态属于类，而多态属于对象 多态调用静态成员时没有多态性（访问的是父类而非子类） 静态优先于对象存在 final 最终的可以修饰类，成员变量，成员方法，局部变量（基本类型，引用类型） 通过最终来理解这些性质 final修饰类——最终类：不能被继承，但可以有父类（太监类） final修饰成员变量：该变量必需在被实例化前赋值，且只能赋值一次 final修饰成员方法：该方法不能被子类重写 final修饰的基本类型局部变量只能赋值一次 final修饰的引用类型局部变量只能赋值一次，但其所指向的对象的内容可以随意改变 类中各种成员的初始化的顺序 1.如果类中存在继承关系(像 Son 继承 Father) 则首先会初始化导出类(Son)的基类(Father)，然后再是导出类 2.在基类首先会初始化静态 的东西 静态代码块&gt;静态变量 而且只初始化一次 （因为静态的东西都是跟着类的加载而加载的） 3.随后就是初始化导出类的静态东西 跟基类的静态初始化一样（同上） 4.初始化基类无参构造器（调用有参就初始化有参构造器） 5.初始化导出类无参构造器（注意：导出类的成员变量和代码块都是是比构造函数的初始化要早。。看输出结果可知）可知） object类是类层次的根类，所有类都直接或间接继承 12345//两个重要方法boolean equals(Object obj); //obj中定义的是根据地址计算出的hashcode //string类中重写了，改为比较字符串内容,我们自己定义类也一般会重写String toString(Object obj) //返回该对象的字符串表示 默认包名.类名@hashcode(地址) //system.out 打印对象会默认调用tostring 我们一般会重写这个方法 异常java代码编译或执行过程中出现的一些问题 异常的继承体系 Throwable：可以抛出去的东西 Exception：异常（普通问题） 编译时异常：Exception及其子类（RuntimeException除外） 运行时异常：RuntimeException及其子类 Errow：错误（严重的问题） 异常处理方式异常处理：异常处理指的是一种可能性，只有当出现了异常时才会执行异常处理代码，否则正常执行 异常处理方式 不处理 throw：动词，真正的抛出一个异常 throws：形容词，用来形容一个方法，表示该方法可能抛出的异常 要求调用者去处理它 public void 方法名（参数）throws 可能抛出的异常类型{ } 捕获处理 try(){ ​ 可能出现异常的代码 }catch(对应类型的异常对象){ ​ //catch可以有多个 ​ //处理异常 }finally{ ​ //写上必须要执行的代码，比如释放资源等 } 一次捕获多次处理: 一个try 多个catch (多个catch中 必须是异常子类在前,父类在后) 多次捕获多次处理: 多个try,每个try多应一个catch 一次捕获一次处理(最常用的):一个try一个catch(catch中异常类必须所有可能出现异常的父类) 注意事项：子类异常必须从属于父类异常 技巧: 如何区分一个异常类 到底是编译时还是运行时异常 1.编译时异常 在编译的时候会报错的 (需要我们去处理) 2.运行时异常 在编译的时候不会报错 只要定义一个方法,在方法中抛出一个异常对象,如果编译报错那么就是编译时异常 如果编译成功,那么就是运行时异常 请你说出十个运行时异常: 1.RuntimeException 2.ClassCastException:类型转换异常 (向下转型的时候) 3.ArrayIndexOutOfBoundsException:数组下标越界 4.StringIndexOutOfBoundsException:字符串下标越界 5.NullPointerException:空指针异常 自定义异常类： 1.创建一个类,这个类必须用Exception结尾 2.必须继承 Exception 或者 RumtimeException 3.自定义的异常 至少有两个构造 a.空参数构造 b.带有String类型参数的构造 12345678910package com.itheima.demo09_自定义异常的练习;public class NoSuchAgeException extends Exception&#123; //无参构造 public NoSuchAgeException()&#123;&#125; //带有String的构造 内部调用super(s)，将传入的string交给父类 public NoSuchAgeException(String s)&#123; super(s); &#125;&#125; Date类Date类:日期类 多数方法都过时了，不常用 标准时间1970年1月1日0时0分0秒 构造: public Date();//代表当前系统时间的Date对象 public Date(long time);//代表距离标准时间 time毫秒值的Date对象 成员方法: public String toString();//Date 重写Object类的toString方法 public long getTime();//获取当前Date对象的毫米值 与public Date(long time)互逆 DateFormat:日期格式化类,是一个抽象类 具体的子类:SimpleDateFormat 构造: public SimpleDateFormat(String pattern);//以指定的模式创建格式化对象 123&gt; SimpleDateFormat sdf = new SimpleDateFormat(yyyy年MM月dd日HH时mm分ss秒);&gt; &gt; 成员方法: public String format(Date d);//把date对象按照指定的模式 转成字符串 public Date parse(String s);//把字符串转成Date对象,如果字符串有问题,就会抛出ParseException Calendar:日历类获取Calendar对象 public static Calendar getInstance();//返回的是抽象类Calendar的某一个子类 成员方法: public int get(int field);//获取指定字段的值 public void add(int field,int amount);//给指定的字段增加值 public void set(int field,int value);//修改指定字段的值 public Date getTime();//把Calendar对象转成Date 对象 getTime().getTime() 相当于调用date的方法来获取毫秒值 System:系统类该类无法思力华，被私有化了 public static void exit(0);//结束JVM public static void gc();//通知垃圾回收器过来收垃圾，只是通知，不一定会来 public static getProperty(String key);//根据键 获取值 public static long currentTimeMillis();//获取当前系统的毫秒值 Math:数学类都是些静态方法，直接调用就好 求最大值 max 求最小值 min 求绝对值 abs 求随机数 random 返回一个[0,1)之间的数，通过简单计算得到自己想要的范围 求四舍五入 ceil(向上取整) floor(向下取整) pow(求次幂) 基类数据类型包装类八种基本类对应的包装类型 byte boolean short char int float double long Byte Boolean Short Character Interger Float Double Long 作用 在集合中只允许存储包装类型，不可以存基本类型 实现字符串的转换 public static int parseInt(String s); 将字符串转为int，其它基本类型类比即可 自动拆箱装箱 装箱：基本类型-&gt;包装类型 拆箱：包装类型-&gt;基本类型 哪些数据类型 重写了toString() 1.String类 2.保存数据的引用类型 (Integer,Double…,集合,map) 3.自定义类 可以重写toString 正则表达式所有编程语言都支持，用来匹配字符串的 boolean b = 普通字符串 匹配 正则表达式 public boolean matches(String regex); boolean b = “普通字符串”.matches(“正则表达式”); public String[] split(String regex); 切割字符串,返回切割后的字符串数组 书写技巧：一位一位的匹配 通配符 正则表达式中 “.”代表任意字符 在DOS中 “*”代表任意内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * QQ号码需要满足的规则: * 1.必须是0-9的数字 * 2.开头必须1-9中的一个数字 * 3.位数必须 5-12位 */public static void qq()&#123; String qq = "12355a63564"; boolean b = qq.matches("[1-9][0-9]&#123;4,11&#125;"); System.out.println(b);&#125;/* * 举例：校验手机号码 * 1：要求为11位0-9的数字 * 2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。 */public static void phone()&#123; String phone = "18600363521"; boolean b = phone.matches("1[34578][0-9]&#123;9&#125;"); System.out.println(b);&#125;/* * * 案例:切割电话 */public static void split01()&#123; String phone = "2345--4564----6546-----1345"; //切割phone 把号码切割出来 //+号 在正则表达式中有特殊意义,表示连续的多个相同的字符 String[] phones = phone.split("-+"); for (int i = 0; i &lt; phones.length; i++) &#123; System.out.println(phones[i]); &#125;&#125;/* * 案例:切割ip */public static void split02()&#123; String ip = "192...168....123......110"; //"."号 在正则表达式中 表示 任意字符 //转译字符 //\t //\n String[] ips = ip.split("\\.+");//在正则表达式中 "\\" 代表一个"\" System.out.println(ips.length); for (int i = 0; i &lt; ips.length; i++) &#123; System.out.println(ips[i]); &#125;&#125; String中的方法（4532）判断方法1234boolean equals(String str);boolean equalsIngoreCase(String str);boolean startsWith(String str);boolean endsWith(String str); 获取方法12345int length(String str);char charAt(int index);String substring(int startIndex);String substring(int startIndex,int endIndex); //左闭右开int indexof(String subStr); //少用 转换方法123String toLowerCase()；String toUpperCase()；char[] toCharArray()； 其它方法12String trim(); //去掉两端空格String[] split(String str); //一某一个字符串来分割字符串 集合集合框架: List–&gt; ArrayList,LinkedList,Vector Set –&gt; HashSet,LinkedHashSet,TreeSet Collection接口中的公共方法:子类不是都有下标，所有Collection无下标，故而无法进行改查操作 增: add(E e); 删: remove(Object obj); 改: 无 查: 无 其他: int size();//长度 boolean contains(Object obj); void clear();//清空 Object[] toArray(); //集合转换成数组 在ArrayList中 有一个方法 addAll(Collection c);//把集合c里面的每一个元素添加到ArrayList中 迭代器在Collection根解扣子中定义一种公共的遍历方式:迭代器遍历 Iterator&lt;泛型和集合的一样&gt; it = 集合对象.iterator(); 底层类似链表 迭代器对象 有两个方法: hasNext();//判断有没有下一个 next();//取出下一个 以上两个方法必须配合使用 补充 Concurrent(并发)Modification(修改)Exception java规定,如果一个集合使用迭代器遍历,那么在遍历的过程中 不允许修改集合的长度(增加或者删除) 123456789101112131415//1.创建一个集合对象,使用多态Collection&lt;String&gt; names = new ArrayList&lt;String&gt;();//2.添加names.add("郭德纲");names.add("刘德华");names.add("柳岩");names.add("范伟");names.add("范伟1");//3.获取names集合的迭代器对象Iterator&lt;String&gt; it = names.iterator();//4.标准代码while(it.hasNext())&#123;//反复判断有没有下一个元素 String s = it.next();//如果有取出下一个元素 System.out.println(s);&#125; 增强for循环增强for循环比普通的for循环增强在哪? 增强在语法上更加简单 格式: for(数据类型 变量名:数组/集合){ syso(变量名); } 注意: 当你使用增强for循环遍历集合的时候 底层采用的是迭代器 总结: 当你使用增强for循环遍历集合的时候,不能修改集合的长度 泛型泛泛的类型,不确定的类型，类型参数化 格式: ,&lt;K,V&gt; 好处 避免了强制类型转换 将运行时的ClassCsatException变为了编译错误 泛型通配符 ?:代表任意类型 &lt;? extends Animal&gt; : 表示一种泛型,这种泛型必须是Animal 或者Animal的子类 &lt;? super Animal&gt;:表示一种泛型,这种泛型必须是Animal 或者Animal的父类 泛型可以用在类上，方法上，接口上 泛型用在类上: 泛型类 格式:public class 类名 当你创建该类的对象的时候,就可以确定 泛型用在方法上:泛型方法 格式:public 返回值类型 方法名(T t); 当你调用方法,传递参数的时候确定 泛型用在接口上:泛型接口 格式:public interface 接口名 1.实现类实现接口的时候,直接确定 2.实现类实现接口的时候,不确定泛型,而是直接把泛型继承下来,当这个实现类创建对象的时候确定 堆栈和队列 数组和链表 list接口List接口的特点: a.有下标 b.有序的(有序不是自然顺序,不是123,abc,有序指的是存和取的顺序一致) c.可重复 实现类:ArrayList,LinkedList,Vector ArrayList:底层采用数组结构,查询快,增删慢 LinkedList:底层采用链表结构,查询慢,增删快 Vector:底层采用数组结构,查询快,增删慢（基本不用） List结构中具有的方法: 增: add(E e);add(int index,E e); 删: remove(Object obj);remove(int index); 改: set(int index,E e); 查: get(int index); 其他: size(),clear(),contains(Object obj),toArray() iterator();isEmpty() 实现类的方法: 1.ArrayList:方法基本和List中定义的一模一样 2.LinkedList:除了和List接口中一样的方法之外 LinkedList提供了大量首位操作的方法 第一组: void addFirst(E e); void addLast(E e); 第二组: E removeFirst();//删除首个元素,返回被删除的元素 E removeLast();//删除尾部元素,返回被删除的元素 第三组: E getFirst(); E getLast(); 第四组: E pop();//弹出,删除集合中的某一个元素,和 removeFirst功能是一样的 void push(E e);//推入,把一个元素添加到集合中, 和addFist功能是一样的 set接口Set接口的特点: a.无下标 b.无序的(无序指的是存和取的顺序不一定一致,LinkedHashSet和TreeSet除外) c.不可重复 实现类:HashSet,LinkedHashSet,TreeSet HashSet:底层采用哈希表结构,查询快,增删快,无序的 LinkedHashSet:底层采用 链表+哈希表,查询快,增删快,有序的 Set接口中的特有方法: 没有,和父接口Collection基本一模一样 实现类:HashSet和LinkedHashSet中的方法基本和Set接口一模一样 对象的哈希值: 任何对象,都有一个哈希值,哈希值是对象的一个数字表示 对象的字符串表示,toString方法,默认表示格式:包名.类名@地址值 如果获取对象的哈希值? 每一个对象都有一个方法,hashCode方法,这方法定义在了Object类中,所以每个对象都具有 我们以前说的地址值,实际上根本不是地址值,而是哈希值的16进制 在java中怎么看真正地址值? 看不了 哈希值的由来 是由真正的地址值计算的,通过一种散列算法(哈希算法) 所以 一般来说 地址值 不一样, 哈希值也是不一样的 不可逆算法(MD5,WPA2) 碰撞算法(一个一个试) 暴力破解&amp;字典破解(破解wifi教程) 字符串的哈希值: 由于String类重写了HashCode 那么哈希值不在通过地址值计算 我们观察源码,发现通过字符串的内容计算,所以只要字符串内容相同,哈希值必定相同 思考: 只要字符串内容一样,哈希值 必定一样 两个字符串的内容不一样,哈希值可能一样 比如: abc 和 acD 哈希表结构: 数组结构+链表结构的组合,查询快,增删快 HashSet:采用了哈希表结构 LinkedHashSet:采用了链表+哈希表结构 哈希表结构,判断元素是否重复的原理: 1.先判断 新元素的哈希值 和 所有旧元素的哈希值是否相同 如果都不相同,直接判断不重复,添加 2.再调用 新元素 和 哈希值相同的旧元素的equals方法 如果返回是true 判定重复元素 ,不添加 如果返回是false 判定不重复,添加 总结: 只有哈希值相同,并且equals返回true,才判定重复 判断元素重复不重复的原理: 1 比较哈希值 2 调用equals方法 只有 哈希值相同,并且equals方法true,才是重复元素,才不存储 contains方法,判断是否包含某一个元素 ArrayList的contains方法: names.contains(“abc”);//判断 names集合中是否包含 “abc” 只比较 equals的返回值,如果某一个元素和要判断的元素equals方法true,那么就是包含该元素 HashSet的contains方法: set.contains(“abc”);// 先判断哈希值 再使用equals方法 只有旧元素和判断的元素 的哈希值相同 并且 euqals方法true 才判定包含 使用HashSet存储自定义元素(Dog对象) 结论: 如果我们自定义了类 要使用HashSet存储 如何保证元素的唯一性: 必须重写自定义类的两个方法,hashCode和equals 定义一个标准的类: 1.封装(private+get/set) 2.构造(无参+全参) 3.toString(快速打印对象信息) 4.hashCode和equals(保证元素使用哈希表结构存储时的唯一性) MapMap集合的特点: 1.Map集合 和 Collection集合 没有继承关系,所以不能直接用迭代器 2.Collection集合 每一个元素都是单独存在 Map集合的每一个元素都是成对存在的 3.Collection一个泛型 Map&lt;K,V&gt;两个泛型, K代表键的类型,V代表值的类型 K,V可以相同 也可以不同,必须都是引用类型 4.在Map集合的元素中,键是唯一的,值是可以重复的 5.常用的实现类: HashMap:无序 底层哈希表结构,保证键的唯一性,需要重写键对应类的hashCode和equals方法 LinkedHashMap:有序 底层哈希表结构+链表,哈希表保证键的唯一,链表保证元素的有序 需要重写键对应类的hashCode和equals方法 Map&lt;K,V&gt;集合常用的方法: 增: V put(K key,V value);//向集合中添加键值对 //如果集合中已存在该键,覆盖整个键值对,并返回被覆盖的键值对的值 删: V remove(OBject key);//根据键 从map集合中删除 键值对,返回值表示被删除的键值对的值 改: 隐藏到了put方法 查: V get(K key);//根据键 从map集合中找到唯一对应的值 Map集合第一种遍历方法:以键找值 1.先获取map集合的键的集合,这个集合是一个Set集合 Set keys = map集合.keySet(); 2.遍历keys集合 a.foreach b.迭代器 3.在遍历的过程中,从map集合获取键对应的值 123456789101112//3.获取map的键的集合Set&lt;String&gt; keys = map.keySet();//4.遍历keys这个集合,获取到每一个键//4.1迭代器遍历Iterator&lt;String&gt; it = keys.iterator();while(it.hasNext())&#123; String key = it.next(); //根据key 从map集合中查找 对应值 String value = map.get(key); //打印 System.out.println(key+":"+value);&#125; map集合第二种遍历 ：键值对遍历 1.获取map集合中所有 结婚证对象 Set&lt;Map.Entry&lt;K,V&gt;&gt; set = map集合.entrySet(); 2.遍历这个set集合,获取每一个Map.Entry类型的对象 a.迭代器 b.foreach 3.获取到 Map.Entry类型的对象之后 K key = entry.getKey(); V value = entry.getValue(); 1234567891011//3.获取所有键值对关系对象的集合Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();//4.遍历 这个entry集合, 拿出每一个结婚证对象//使用迭代器遍历Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = entrySet.iterator();while(it.hasNext())&#123; Map.Entry&lt;String, String&gt; entry = it.next(); //获取这个entry中的 键和值 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"="+value); 回顾：内部类和内部接口 内部类: 一个类A,定义在另外一个类B 的内部,这个类A 这个类被称为内部类 OuterClass.InnerClass ic = new OuterClass().new InnerClass(); 内部接口: 一个接口A,定义在另外一个接口B的内部,这个接口A, 这个接口A被称为内部接口 class Class2 implements OuterInter.InnerInter 只重写内部类中的方法即可 使用map存储自定义类型使用map存储:键为学号,值为一个学生的对象, 学生对象有属性（姓名，年龄） 使用map存储:键为学生（姓名，年龄）值为学生自己的家庭住址。 结论: 如果Map中的键是自定义类型,那么要保证键的唯一性,必须重写键对应类的hashCode和equals方法 Properties属性集在开发中Map集合可能用到,但是Properties属性集,1000%会用到 Properties类到底是什么?属性集, class Propeties extends HashTable implements Map 所以:Properties本质上 就是一个Map集合 Properties是一个持久的属性集 所谓持久 就是 它具有自己写数据到文件的方法 Properties是没有泛型,泛型是固定,String 和 String Properties类,具有Map接口的一切方法 还有具有一些自己特有的方法: public String getProperty(String key)用指定的键在此属性列表中搜索属性的值,功能和Map中的get是一样 public Object setProperty(String key, String value);添加键值对,功能和Map的put方法是一样 public Set stringPropertyNames()://和Map中的keySet方法是一样 Properties具有持久化到文件的功能 store();//保存数据到文件,实际上不是保存到文件 而是写入到流中,由流写到文件 load();//从文件中加载数据,实际上不是直接加载文件,而是加载流中的数据,而流的数据是从该文件中读取的 12345678910111213141516171819202122232425262728293031323334353637383940public class PropertiesDemo &#123; public static void main(String[] args) throws IOException &#123; //和Properties持久化有关的方法 Properties ps = new Properties(); //从文件中读取数据 ps.load(new FileReader("phones.properties")); System.out.println(ps); &#125; //Properties持久化数据到文件中 public static void writePs() throws IOException&#123; //1.定义Properties Properties ps = new Properties(); ps.setProperty("iphoneX", "8888"); ps.setProperty("xiaomiMix", "3888"); ps.setProperty("huaweiMate11", "6888"); ps.setProperty("vivoX20", "1888"); //2.把ps的数据持久化到文件中 ps.store(new FileWriter("phones.properties"), ""); &#125; public static void demo01()&#123; // TODO Auto-generated method stub //1.创建一个Properties对象 Properties ps = new Properties(); //2.添加数据 ps.setProperty("张三", "18"); ps.setProperty("李四", "28"); ps.setProperty("王五", "38"); ps.setProperty("前妻", "48"); //3.遍历 //1.stringPropertyNames 就是keySet Set&lt;String&gt; propertyNames = ps.stringPropertyNames(); //4.遍历 for (String propertyName : propertyNames) &#123; //根据属性名 propertyName获取属性值 String propertyValue = ps.getProperty(propertyName); System.out.println(propertyName+"="+propertyValue); &#125; &#125;&#125; 小知识点可变参数说的不是参数类型可变,而是参数的个数可以变化 语法: JDK1.5 出现新特性 public 返回值类型 方法名(数据类型… 参数名){} 注意: 1.可变参数只是参数的个数是任意个,参数的类型不能改变 2.一个方法中 只能有一个可变参数 3.当一个方法中有多个参数,并且有一个是可变参数的时候,要求这个可变参数必须在最后 可变参数的本质: 就是一个数组 Collections中的静态方法: public static void shuffle(List list);//打乱顺序 public static void sort(List list);//把集合元素按照自然顺序(123,abc)排序 Arrays:数组工具类 public static List asList(数组/可变参数);//把一个数组 转成List集合 public static void sort(数组);//排序数组 public static String toString(数组);//把数组转成字符串 递归 递归:是一个通用技术,所有的编程语言,只要有方法概念的编程语言都具有递归 什么叫递归:在一个方法的内部,再调用方法本身 无限递归本身是错误的:因为方法运行需要进栈,而栈空间不是无限大的 使用递归的前提****: 1.必须有一个可以是递归结束的出口 2.递归的次数,不能太多(具体的次数不好确定,与内存,CPU…都有关) 我们建议在开发中 能不用递归 就是不要用 急剧消耗内存(最常见是杀毒软件 扫描硬盘) 递归的其他分类: 直接递归: 在A方法的内部 直接调用A方法 123456789101112131415161718192021222324&gt; //定义一个方法,求1-n的和 先想一下基于n-1步如何解决&gt; public static int getSum(int n)&#123;&gt; //1+2+3...n = (1+2+3..n-1)+n&gt; if(n==1)&#123;&gt; return 1;&gt; &#125;&gt; return getSum(n-1)+n;&gt; &#125;&gt; &gt; //求1-n的和 常用&gt; public static int getSum(int n)&#123;&gt; int sum = 0;&gt; for (int i = 1; i &lt;= n; i++) &#123;&gt; sum+=i;&gt; &#125;&gt; return sum;&gt; &#125;&gt; private static int getSum2(int n) &#123;&gt; if (n == 1) &#123;&gt; return 1;&gt; &#125;&gt; return getSum2(n - 2) + n;&gt; &#125;&gt; 间接递归: 在A方法的内部调用B方法,在B方法的内部调用C方法,在C方法的内部调用A方法 1234567891011121314151617181920212223242526272829&gt; package com.guardwarm.递归;&gt; &gt; import java.util.Scanner;&gt; &gt; //定义方法 求 n个式子的和&gt; //n=5&gt; //1+(1+2)+(1+2+3)+(1+2+3+4)+(1+2+3+4+5)&gt; public class undirectDiGui &#123;&gt; public static void main(String[] args) &#123;&gt; System.out.println("please enter a num");&gt; Scanner scan = new Scanner(System.in);&gt; int n = scan.nextInt();&gt; int sum = getsum(n);&gt; System.out.println(sum);&gt; &#125;&gt; public static int getsum(int n)&#123;&gt; if(n == 1)&gt; return 1;&gt; return getsum(n-1)+zigetsum(n);&gt; &#125;&gt; public static int zigetsum(int n)&#123;&gt; if(n == 1)&gt; return 1;&gt; return zigetsum(n-1)+n;&gt; &#125;&gt; &#125;&gt; &gt; &gt; 斗地主案例案例分析 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.guardwarm.斗地主;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedHashMap;import java.util.Map;/* * 斗地主步骤: * * 1.创建编号和牌对应的map集合 * * 2.准备一副牌(54个数字1-54) * * 3.洗牌 * * 4.发牌 * * 5.排序 * * 6.从map集合查找 * * 7.看牌 */public class doudizhuMapDemo &#123; public static void main(String[] args) &#123; //准备一副牌 Map&lt;Integer,String&gt; allcard = new LinkedHashMap&lt;Integer, String&gt;(); ArrayList&lt;Integer&gt; cards = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; dp = new ArrayList&lt;Integer&gt;(); int id = 1; String[] colors = &#123;"♠","♥","♣","♦"&#125;; String[] nums = &#123;"3","4","5","6","7","8","9","10","J","Q","K","A","2"&#125;; for(String num : nums)&#123; for(String color : colors)&#123; String card = num+ color; allcard.put(id,card); cards.add(id); id++; &#125; &#125; allcard.put(id,"大S"); cards.add(id); id++; allcard.put(id,"小S"); cards.add(id); id++; Collections.shuffle(cards); //测试// System.out.println(cards); for (int i = 0; i &lt; cards.size(); ++i) &#123; Integer cd = cards.get(i); if (i &gt;= 51) &#123; dp.add(cd); &#125; else if (i % 3 == 0) &#123; p1.add(cd); &#125; else if (i % 3 == 1) &#123; p2.add(cd); &#125; else if (i % 3 == 2) &#123; p3.add(cd); &#125; &#125; Collections.sort(p1); Collections.sort(p2); Collections.sort(p3); Collections.sort(dp); /* System.out.println(p1); System.out.println(p2); System.out.println(p3); System.out.println(dp);*/ outputcard(p1,allcard); outputcard(p2,allcard); outputcard(p3,allcard); outputcard(dp,allcard); /* Collections.sort(cards); System.out.println(cards);*/ &#125; private static void outputcard(ArrayList&lt;Integer&gt; ls,Map&lt;Integer,String&gt; map)&#123; for(Integer cardid:ls)&#123; String card = map.get(cardid); System.out.print(card+" "); &#125; System.out.println(); &#125;&#125; IO流_读写文件（输入输出是相对程序而言的） 输出流：数据从java程序到文件中 123456//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)write(int ch); //可以写ascll码值write(char[] ch);write(char[] ch,int startIndex,int len);write(String s);write(String s,int startIndex,int len); 输入流：数据从文件到java程序 123//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)int read(); //读取一个字符int read(char[] chs); //读取一个字符数组，返回值表示读取到的字符个数 File类:描述:文件和 目录路径名的抽象表示 文件:可以直接保存数据 目录路径名:文件夹,分类管理文件 结论:File类可以表示文件 也可以表示文件夹 构造: public File(String filepath); 绝对路径:以盘符开头的路径 相对路径:相对当前项目的根目录 File对象的获取方法: 1.public String getAbsolutePath();//获取绝对路径 2.public String getName()//获取当前File对象的名字 3.public String getPath();//获取创建File对象时 传递的路径 4.public long length();//获取表示文件的File对象的占用的字节数,如果是文件夹的File对象,返回值不确定 File对象的删除和创建方法: 1.创建方法: 创建文件: public boolean createNewFile();//创建一个新的文件(只能是文件,不能是文件夹),返回是否创建成功 创建文件夹 public boolean mkdir();//创建一个新的文件夹,返回是否创建成功 public boolean mkdirs();//可以一次性创建多层文件夹 2.判断方法: 判断是否是文件 public boolean isFile();//返回是否是文件 判断是否是文件夹 public boolean isDirectory();//返回是否是文件夹 判断文件或者文件夹是否存在,是前面两个前提 public boolean exists();//返回该File 对象是否存在 3.删除方法: public boolean delete();//删除文件或者文件夹 可以删除的是单个文件,或者空文件夹 File类的list和listFiles方法 1.public String[] list(); 2.public File[] listFiles(); 注意: 只能列出当前文件夹下的一级子文件或者子文件夹，那个对象必须存在且是文件夹才可以调用 案例：使用递归遍历使用文件夹 1234567891011121314151617181920212223242526272829303132333435/* * 使用递归遍历 一个文件夹aaa下的所有文件(包括一级的也包括n级文件) * * 1.定义方法,遍历一个文件夹下的所有文件 * * 2.在方法中判断 某一个File对象 ,如果是文件 直接打印 * 如果不是文件,递归调用第1步定义的方法 * */public class DiguiDemo &#123; public static void main(String[] args) &#123; //1.创建aaa文件夹的File 对象 File aaa = new File("C:\\Users\\yingpeng\\Desktop\\aaa"); //2.调用方法 列出 aaa下的所有文件 printFiles(aaa); &#125; //定义一个方法:列出一个文件夹下的文件 public static void printFiles(File objFileDir)&#123; //2.列出aaa文件夹下的所有File 对象 File[] files = objFileDir.listFiles(); for (File file : files) &#123; //判断是否是文件 或者 文件夹 if(file.isFile())&#123; //打印 System.out.println(file); &#125;else&#123; //是文件夹.列出该文件夹下的所有东西 printFiles(file); &#125; &#125; &#125;&#125; 文件过滤器:FileFilter 在list和listFiles方法中使用，用来过滤文件，有多少个文件就会执行多少次 1234567891011public class MyFileFilter implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; // TODO Auto-generated method stub System.out.println(".."); //用来看这个方法执行了多少次 if(pathname.getName().endsWith(".PNG"))&#123; return true; &#125; return false; &#125; 案例：map集合嵌套遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.guardwarm.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* * 案例: * 需要定义一个Map集合,保存学生的学号和他对应的名字 * Map&lt;String,String&gt; * JavaEE: * heima001 张三 * heima003 李四 * heima005 王五 * UI: * heima001 小丽 * heima004 小红 * heima005 小美 * PHP: * heima002 小黑 * heima003 小白 * heima006 小猪 * */public class MapQianTao &#123; public static void main(String[] args) &#123; //定义所需map Map&lt;String,String&gt; eeMap = new HashMap&lt;String, String&gt;(); Map&lt;String,String&gt; uiMap = new HashMap&lt;String, String&gt;(); Map&lt;String,String&gt; phpMap = new HashMap&lt;String, String&gt;(); Map&lt;String,Map&lt;String,String&gt;&gt; outMap = new HashMap&lt;String, Map&lt;String, String&gt;&gt;(); eeMap.put("heima001","张三"); eeMap.put("heima003","李四"); eeMap.put("heima005","王五"); uiMap.put("heima001","小丽"); uiMap.put("heima004","小红"); uiMap.put("heima005","小美"); phpMap.put("heima002","小黑"); phpMap.put("heima004","小白"); phpMap.put("heima005","小猪"); outMap.put("javaee",eeMap); outMap.put("ui",uiMap); outMap.put("php",phpMap); //先通过entrySet获取Set，然后再用set获取迭代器开始遍历 Set&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outSet = outMap.entrySet(); Iterator&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outit = outSet.iterator(); while (outit.hasNext())&#123; Map.Entry&lt;String,Map&lt;String,String&gt;&gt; outEntry = outit.next(); String outKey = outEntry.getKey(); //由于值是map，所以内部还得再遍历 Map&lt;String,String&gt; outvalue = outEntry.getValue(); System.out.println(outKey); Set&lt;String&gt; mapKeys = outvalue.keySet(); for(String key:mapKeys)&#123; String mapValue = outvalue.get(key); System.out.println(mapValue); &#125; &#125; &#125;&#125; IO流根据流的流向分类: Input:输入流 Output:输出流 根据流操作的数据来分类 字符流: 操作字符 只能操作普通文本文件, ​ 最常见的文本文件:.txt,.java,.c,.cpp等其他语言的源代码 ​ 只要用文本工具(记事本,notepad++,editplus) 可以打开的 ,而且打开后我们人类能看懂的 都是文本文件 ​ 注意:我们用的.doc,excel,ppt这些不是文本文件 字节流: 操作字节 ​ 能操作一切文件(文本文件,.mp3,视频.avi,.rmvb,mp4,doc,excel,ppt) java中的四大流: 字符输入流:共同父类 Reader 比如:FileReader,BufferedReader 功能:读取一个字符,读取一个字符数组 字符输出流:共同的父类 Writer 比如:FileWriter BufferedWriter 功能:写一个字符,写一个字符数组(一部分),写一个字符串 字节输入流:共同父类 InputStream 比如:FileInputStream,BufferedInputStream 功能:读取一个字节,读取一个字节数组 字节输出流:共同父类 OutputStream 比如:FileOutputStream,BufferedOutputStream 功能:写一个字节,写一个字节数组(一部分) 只要是输入流 此流的方法名 一定叫做 read 只要是输出流 此流的方法名 一定叫做 write java中流的命名是十分规范的: 功能+父类的名字（4种） OutputStream:字节输出流的根类,这是一个抽象类 public void close();//关闭流 public void flush();//刷新流 和写数据有关系的方法; public void write(int b);//写一个字节 public void write(byte[] bs);//写一个字节数组 public void write(byte[] bs,int startIndex,int lenght);//写一个字节数组的一部分 FileOutputStream OutputStream具体子类 追加: 以前用的构造: ​ public FileOutputStream(String filename);//默认就是覆盖 ​ public FileOutputStream(File file);//给定一个File对象,这个File对象代表我们要写入的文件 请用这个构造,实现追加: ​ public FileOutputStream(String filename,boolean flag) ​ public FileOutputStream(File file,boolean flag) 换行（不同操作系统用不同换行）: windows:\r\n Linux:\n Mac:\r InputStream:字节输入流的根类,这是一个抽象类 public int read();//读取一个字节,返回的是码值 public int read(byte[] bs);//读取一个字节数组,返回值表示实际读取到的字节数 我们用InputStream具体子类:FileInputStream 12345678910111213141516171819202122232425262728293031323334353637383940package com.guardwarm.文件;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 复制文件练习: * * 1.源文件: 是读取用的, new FileInputStream("源文件") * * 2.目标文件: 是写入用的, new OutputStream("目标文件") * * 3. 一边读取 源文件 一边写出到目标文件 * * 4.关闭流 */public class CopyFile &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("F:\\书\\史铁生.docx"); FileOutputStream fos = new FileOutputStream("F:\\书\\copy.docx"); long s = System.currentTimeMillis(); int b = 0; while((b=fis.read())!=-1)&#123; fos.write(b); &#125;/* //一次读取一个字节数组 byte[] bs = new byte[1024];//用来保存读取到的字节数据 int len = 0;//保存实际读取到的字节个数 while((len=fis.read(bs))!=-1)&#123; fos.write(bs, 0, len);//写入bs中的从0下标开始len个字节 到文件中 &#125;*/ long e = System.currentTimeMillis(); long time = e-s; System.out.println(time); fos.close(); fis.close(); &#125;&#125; 缓冲流: 相比较没有缓冲区的流,效率更高BufferedOutputStream 缓冲输出流 构造方法 public BufferedOutputStream(OutputStream out) BufferedInputStream 缓冲输入流 构造方法 public BufferedInputStream(InputStream in) 小案例：复制单级文件夹1234567891011121314151617181920212223242526272829303132333435363738package com.guardwarm.文件;import java.io.*;public class CopySingleDirectory &#123; public static void main(String[] args) throws IOException &#123; //创建文件夹 File srcfl = new File("F:\\demo1"); File dstfl = new File("F:\\demo2"); if (!dstfl.exists())&#123; boolean b = dstfl.mkdirs(); if (b)&#123; System.out.println("文件夹不存在，成功创建"); &#125; &#125;else &#123; System.out.println("目标文件夹已存在，直接复制即可"); &#125; //遍历文件 注意创建目标文件 File[] srcfiles = srcfl.listFiles(); for (File src : srcfiles)&#123; File dst = new File(dstfl,src.getName()); copyfile(src,dst); &#125; &#125; public static void copyfile(File srcfl,File dstfl) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcfl)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dstfl)); //固定格式 byte[] bs = new byte[1024]; int len = 0; while ((len = bis.read(bs))!= -1)&#123; bos.write(bs,0,len); &#125; bis.close(); bos.close(); System.out.println("复制文件"+srcfl.getName()+"成功！"); &#125;&#125; 小知识点使用字节流读取中文的乱码问题: 如果是一个一个字节读取, 100%会出现乱码 如果是一个一个字节数组读取,可能也会出现乱码 解决方法 字符流 转换流 字符编码集 ASCII码表 美国 每个字符对应一个字节 保存了字母，数字，以及一些常用符号 a-97 A-65 0-48 GB2313 保存常用汉字，一个中文占两字节，这两个字节全是负数 GBK 保存了基本所有汉字，统统占两个字节第一个字节为负，第二个字节随意 Unicode 统一码表（万国码表）所有文字统统两字符，向下兼容ASCII UTF-8 在Unicode的基础上做了一些优化，能用一个字节的不用两个字节，且在每一个字节头加入了编码信息，一个中文占三个字节 Latin-1（ISO-8859-1） 拉丁码表，Tomact会用到 编码 – &gt;文字到对应码值 解码 – &gt;码值到对应文字 转换流字符流的子类 OutputStreamWriter 查码表，是字符流通向字节流的桥梁，write方法与其他流一致 123456public static void writeCN() throws Exception &#123; //创建可以把字符转成字节的转换流对象，并指定编码 两种构造，指定编码也可不写，默认GBK OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("c:\\cn8.txt"),"utf-8"); //调用转换流，把文字写出去，其实是写到转换流的高效区中 osw.write("你好");//写入高效区。 osw.close(); InputStreamReader 注意选择正确的解码方式 1234567891011121314151617181920public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; //演示字节转字符流的转换流 readCN(); &#125; public static void readCN() throws IOException&#123; //创建读取文件的字节流对象 InputStream in = new FileInputStream("c:\\cn8.txt"); //创建转换流对象 //InputStreamReader isr = new InputStreamReader(in);这样创建对象，会用本地默认码表读取，将会发生错误解码的错误 InputStreamReader isr = new InputStreamReader(in,"utf-8"); //使用转换流去读字节流中的字节 int ch = 0; while((ch = isr.read())!=-1)&#123; System.out.println((char)ch); &#125; //关闭流 isr.close(); &#125;&#125; 转换流和子类区别：转换流可以选择解码/编码方式 java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter ​ FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编 码表时可以不用父类，而直接用子类就完成操作了，简化了代码。 序列化流和反序列化流用于从流中读取对象的操作流 ObjectInputStream 称为 反序列化流 用于向流中写入对象的操作流 ObjectOutputStream 称为 序列化流 构造方法类似转换流，具体看API 常见异常 当一个对象要能被序列化，这个对象所属的类必须实现Serializable接口。否则会发生异常NotSerializableException异常。 同时当反序列化对象时，如果对象所属的class文件在序列化之后进行的修改，那么进行反序列化也会发生异常InvalidClassException。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 版本号默认有java管理，也可以生成版本号自己管理 transient关键字 不需要序列化的属性可以使用关键字transient修饰 同时static修饰的也不会序列化 打印流字节打印流 PrintStream 字符打印流 PrintWriter 两者基本一致，可以打印的目的地略有不同 PrintStream 字符串的文件名，file对象，其他的tOutputStream，其他的Writer PrintWriter 字符串的文件名，file对象，其他的tOutputStream 12345678910111213public class PrintWriterDemo &#123; public static void main(String[] args) throws IOException &#123; //创建流 //PrintWriter out = new PrintWriter(new FileWriter("printFile.txt")); PrintWriter out = new PrintWriter("printFile.txt"); //2，写数据 for (int i=0; i&lt;5; i++) &#123; out.println("helloWorld"); &#125; //3,关闭流 out.close(); &#125;&#125; 第三方小框架：commons-iops.第一方：官方，第二方：我们 jar包：java专用压缩包 从上到下依次为：api文档，框架class文件，生成api文档的源文件，框架源文件，测试class文件，测试源文件，许可，注意事项 添加jar包 eclipse 1.创建lib文件夹 2.将commons-io.jar拷贝到lib文件夹 3.右键点击，→ IDEA file-&gt; project structure 点最右侧那个+，然后OK就好 FileUtils readFileToString(File file)：读取文件内容，并返回一个String； writeStringToFile(File file，String content)：将内容content写入到file中； copyFile(File srcFile, File destFile): 文件复制 copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制 多是一些静态方法，直接用类名就可调用 多线程几个小概念 进程: 正在运行的程序 叫做进程 线程: 进程中的一个小任务 一个进程中通常是由多个线程在执行任务 main方法所在线程 我们称为主线程 创建方法Thread类:就是我们说的线程类 构造: public Thread();//创建一个默认名字的线程对象 public Thread(String name);//创建一个指定名字的线程对象 创建新的线程的方法一: 1.定义子类 继承 Thread 2.在子类中重写run方法(就是执行任务的方法,在run方法中写任务代码即可) 3.创建子类对象(就是创建一个线程对象) 4.开启这个线程 123456//3.创建子类线程对象MyThread mt = new MyThread();//设置守护线程mt.setDaemon(true);//4.开启线程,JVM自动会告诉CPU去执行线程任务代码mt.start(); 开启线程的第二种方式: 1.定义实现类 实现Runnable接口 2.实现类要重写run方法(就是写任务代码的方法) 3.创建实现类对象 4.创建Thread对象,并把刚刚的实现类对象 作为参数传递 5.启动这个Thread对象 12345MyRunnable mr = new MyRunnable();//4.创建Thread对象,并把刚刚的实现类对象 作为参数传递Thread td = new Thread(mr);//5.开启线程td.start(); 内存图 创建两个线程对象 我们发现: a.线程默认是有名字,名字Thread-n,n从0开始 依次递增的 b.我们可以修改线程的名字,但是一般不改 setName(String name); c我们可以获取线程的名字,通过线程对象的getName方法获取 d.获取线程名字的最常用的方法 Thread.currentThread().getName(); 两种创建方式比较 从耦合性分析: 第一种方式:线程和任务是紧紧联系在一起的,耦合性高 第二种方式:线程是线程,任务是任务,他们之间没有必然联系,给一个线程传递哪个任务那么该线程就执行哪个任务 所以说开发中,我们用第二种方式 从代码的扩展性: 第一种方式 由于是继承Thread,那么子线程类就不能继承别的类 第二种方式 由于是实现了接口,同时可以继承别的类 所以说开发中,我们用第二种方式 用匿名内部类创建对象12345678910111213141516171819202122232425262728293031323334/* * 匿名内部类: * 快速创建一个类的子类对象,或者一个接口的实现类对象 * * 格式: * new 父类()&#123; * 重写方法(); * &#125;; * new 接口()&#123; * 实现方法() * &#125;; * 使用匿名内部类 创建线程对象 *///1.第一种方式创建线程对象:继承方式 new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("线程"+getName()+i); &#125; &#125; &#125;.start();//2.第二种方式创建线程对象:实现方式 new Thread(new Runnable()&#123; @Override public void run() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; 10; i++) &#123; System.out.println("线程"+Thread.currentThread().getName()+i); &#125; &#125; &#125;).start(); 案例：卖票123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/* * 案例:电影院卖票 * * 假设 上演"忍者神龟" 100张票 * * 有三个柜台在卖票,同时开卖,并且卖的都是这100张票 * * 三个柜台就是三个线程,他们同时执行同一个买票任务,同时操作一个共享数据100张票 * */public class SaleTicketsDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //1.创建卖票任务对象 TicketsRunnable tr = new TicketsRunnable(); //2.创建 3个线程 去执行买票任务 Thread t1 = new Thread(tr,"窗口1"); Thread t2 = new Thread(tr,"窗口2"); Thread t3 = new Thread(tr,"窗口3"); t1.start(); t2.start(); t3.start(); &#125;&#125;public class TicketsRunnable implements Runnable&#123; private int count = 100; @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; if(count&gt;0)&#123; try &#123;Thread.sleep(120);&#125; catch (InterruptedException e) &#123;&#125; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125; &#125;/* * 解决线程安全问题方式一: * 给代码加上同步锁 * 格式: * synchronized(锁对象)&#123; * 代码 * &#125; * 锁对象可以是任意对象 * 先运行到那块的会拿到锁对象，然后执行几次后会将锁对象放回，让其他线程执行 */ public class TicketsRunnable implements Runnable&#123; private int count = 1000; private Object obj = new Object(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; synchronized(obj)&#123; if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125; &#125; &#125;&#125; /* * 解决线程安全问题方式二: * 同步方法 * 格式: * public synchronized void 方法名()&#123; * 需要运行的代码 * &#125; * 注意:同步代码块和同步方法的原理是一样,都是具有锁对象,哪一个线程进来执行,那么该线程就持有这个锁对象 * 这里同步方法使用的锁对象 叫做this对象 * 如果同步方法是静态方法,那么他的锁对象是 当前类.class */ public class TicketsRunnable implements Runnable&#123; private int count = 1000; private Object obj = new Object(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; sale(); &#125; &#125; public synchronized void sale()&#123; if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125;&#125; /* * 解决线程安全问题方式三: * Lock接口方式 * 我们实际用的是他的一个实现类:ReentrantLock * * 在Lock接口中有两个方法: * lock();//获取锁 * unlock();//释放锁 */ public class TicketsRunnable implements Runnable&#123; private static int count = 1000; //创建一个Lock接口的实现类对象 Lock l = new ReentrantLock(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; l.lock(); if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; l.unlock(); &#125; &#125;&#125; 线程状态图 socket-网络编程计算机网络网络通信协议: 网络:由多台计算机,以及外部设备 连接起来一个系统 我们就称为网络 通信协议: 就像交通规则,规定网络上传输的数据的格式,大小,速度等等 在我们现在的网络中都有哪些通信协议: TCP/IP协议 UDP协议 其他协议 IP地址和端口号的介绍 IP地址: 网络每一台计算的唯一标识 1Byte=8Bit IP地址 每一个段 0-255 端口号: 是每一个计算机中的”门”,一共有0-65535号门 总结:我们向别的计算机发信息的时候 确定 IP地址:为了找到那台计算机 确定 端口号: 为了确定发送到对方计算机中的哪个应用程序 InetAddress:代表IP地址类 public static InetAddress getLocalHost();//获取你的计算机的IP地址对象 public String getHostName();//仅获取主机名 public String getHostAddress();//仅获取IP地址 public static InetAddress getByName(“其他主机的名字或者IP”);//远程主机的IP地址对象 UDP和TCPUDP:用户数据报协议 特点:面向无连接,数据是不安全,不完整 有无接收端均可 优点:效率高 比如:发短信,供屏软件,QQ视频 TCP:传输控制协议 特点:面向有连接,数据是安全,完整性 没有接收端会直接报错 比如:打电话,上网 TCP协议建立连接 有三个步骤 我们称为”三次握手” UDP使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * 使用UDP进行数据通信,需要用到两个类 * * 数据的发送接收器:DatagramSocket * * 数据包类:DatagramPacket *///发送端public class UDPSender &#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); //1.创建DatagramSocket对象 DatagramSocket ds = new DatagramSocket(); while(true)&#123; //2.创建DatagramPacket对象 //存储 发送的数据,对方的IP,端口号 System.out.println("请输入您要发送的数据:"); String sendMsg = sc.nextLine(); byte[] bs = sendMsg.getBytes(); //IP地址:127.0.0.1 代表本机,本地回环地址 DatagramPacket dp = new DatagramPacket(bs,bs.length,InetAddress.getByName("127.0.0.1"),12345); //3.发送 ds.send(dp); System.out.println("发送数据成功!!!");//192.168.146.72 &#125; //4.关闭资源 //ds.close(); &#125;&#125;//接收端public class UDPReceiver &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //1.创建DatagramSocket对象, //强调:接收端必须指定一个端口号 DatagramSocket ds = new DatagramSocket(12345); while(true)&#123; //2.直接创建一个DatagramPacket对象 byte[] bs = new byte[1024]; DatagramPacket dp = new DatagramPacket(bs, bs.length); //3.接收 System.out.println("等待发送端发送数据...."); ds.receive(dp);//这个方法具有等待功能,等待发送端发送过来的数据 System.out.println("接收数据成功!!"); //获取发送端的地址 InetAddress sendAddress = dp.getAddress(); System.out.println("发送端是:"+sendAddress.getHostAddress()); //获取真正的数据 byte[] data = dp.getData(); //获取发送端 发来了多少字节 int len = dp.getLength(); //打印数据 String receiveMsg = new String(data, 0, len); System.out.println("发送端说:"+receiveMsg); &#125; //4.关闭资源 //ds.close(); &#125;&#125; TCP使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485进行简单数据交互/** * TCP客户端: * * 1.创建Socket对象,传入服务器的IP和端口 * * 2.通过Socket对象获取输出流,调用write方法写数据到服务器 * * 3.通过socket对象获取输入流,调用read方法读取服务器反馈的信息 * * 4.关闭(Socket对象) * * * TCP服务端: * * 1.创建ServerSocket对象,传入一个端口,端口必须和客户端的一样 * * 2.先获取哪一个客户端连接的服务器,通过accept()方法获取 * * 3.通过Socket对象获取输入流,调用read方法读取客户端发来的数据 * * 4.通过socket对象获取输出流,调用write方法向客户端反馈数据 * * 5.关闭(ServerSocket,Socket) * * @author yingpeng * */public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致 ServerSocket server = new ServerSocket(12345); //2.获取到 哪一个 客户端连接的我 System.out.println("等待客户端连接..."); Socket client = server.accept();//此方法也具有等待功能,等待某一个客户端连接 //打印一些和客户端有关信息 String ip = client.getInetAddress().getHostAddress(); System.out.println("小样,抓到你了:"+ip); //3.获取输入流,实际上是客户端写数据时的输出流 InputStream in = client.getInputStream(); //4.读取数据 byte[] bs = new byte[1024]; int len = in.read(bs); //打印 System.out.println("客户端说:"+new String(bs,0,len)); //5.要向客户端 回写数据,告诉客户端您的信息我已经收到了 OutputStream out = client.getOutputStream(); out.write("您的消息已经收到...".getBytes()); System.out.println("给客户端反馈的信息发送成功!!!"); //关闭资源 server.close(); client.close(); in.close(); &#125;&#125;public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口) /* * 这个构造方法干了很多事情: * a.自动去连接服务器 * b.自动进行三次握手,建立连接 * c.自动为连接中创建两个流 */ Socket client = new Socket("127.0.0.1", 12345); // 2.从客户端对象中获取 输出流:getOutputStream() //OutputStream out = client.getOutputStream(); // 3.调用输出流的Write方法写数据到服务器即可 //out.write("How are you".getBytes()); client.getOutputStream().write("How are you".getBytes()); System.out.println("给服务器发送数据成功!!"); //4.读取服务器 发送过来的反馈信息 InputStream in = client.getInputStream(); byte[] bs = new byte[1024]; int len = in.read(bs); System.out.println("服务器响应:"+new String(bs,0,len)); // 关闭资源 client.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//上传文件//客户端public class FileUploadClient &#123; public static void main(String[] args)throws IOException &#123; //1.创建Socket对象,连接服务器 Socket client = new Socket("127.0.0.1", 12345); System.out.println("连接服务器成功.."); //2.获取输出流,把数据写向服务器 OutputStream out = client.getOutputStream(); //3.创建文件的输入流,读取本地的文件数据 FileInputStream fis = new FileInputStream("C:\\Users\\yingpeng\\Desktop\\pictures\\3.png"); //4.循环,读取本地文件,写到服务器 byte[] bs = new byte[1024]; int len = 0; while((len=fis.read(bs))!=-1)&#123; out.write(bs, 0, len); &#125; //关闭输出流 client.shutdownOutput(); //5.获取服务器反馈的信息 InputStream in = client.getInputStream(); byte[] bs1 = new byte[1024]; int len1 = in.read(bs1); System.out.println("服务器说:"+new String(bs1,0,len1)); //6关闭 client.close(); out.close(); fis.close(); &#125;&#125;//服务器端 服务器一直开启，通过多次执行客户端来多文件上传public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //1.创建ServerSocket对象,绑定一个端口 ServerSocket server = new ServerSocket(12345); while(true)&#123; //2.获取哪一个客户端连接的服务器 System.out.println("等待客户端连接..."); final Socket client = server.accept(); //开启一个线程,和clinet进行交互 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // TODO Auto-generated method stub System.out.println("小样:"+client.getInetAddress().getHostAddress()); //3.获取输入流,读取客户端发来数据 InputStream in = client.getInputStream(); //4.创建文件的输出流,把数据写到文件中 String picName = "H:\\upload\\"+System.currentTimeMillis()+".png"; FileOutputStream fos = new FileOutputStream(picName); //5.循环 从输入流读取客户端数据, 写入到文件中 byte[] bs = new byte[1024]; int len = 0; while((len=in.read(bs))!=-1)&#123; fos.write(bs, 0, len); &#125;//1小时 System.out.println("客户端的文件已经保存完毕,可以查看了"+picName); //6.告知客户端,文件真的真的真的上传成功 OutputStream out = client.getOutputStream(); out.write("您的文件真的真的真的上传成功".getBytes()); client.close(); in.close(); out.close(); fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; //6.关闭 // server.close(); &#125;&#125; 一个bug 客户端传输完文件需主动调用client.shutdownoutputstream来关闭输出流，不然服务器会不知道是执行完了还是网络延迟 反射定义一个应用程序已写好，后期出现的接口子类无法直接在该应用中new一个对象，该怎么办？ 子类不确定，可以通过提供配置文件形式将不确定的信息存储在配置文件中即可。该程序只要之前写好读取配置文件的信息即可。 如果存储了指定的子类名，就根据具体名称找该类并进行加载和对象的创建，这些动作都是在定义软件时写好的 没有类之前就将创建对象的动作写好了，这就是动态的获取指定的类，并使用类中的功能——反射技术 字节码文件对应的类class Class 描述字节码文件的类 Field field 将字段封装成对象类型 Constructor cons 将构造函数封装成了对象类型 Method method 将类中的成员都封装成了对象 getField() getMethod() getConstrctor() 获取字节码文件对象要想获取字节码文件中的成员，首先要获取字节码文件对象 法一 通过object类中的getClass方法 12Person p1=new Person();Class clszz1=p1.getClass(); 虽然通用，但必须有指定类，并对该类进行实例化才能调用getClass方法 法二 调用任意一个数据类型的一个静态成员class 不用实例化类，但还是需要指定的类 法三 使用class类中的forName方法，通过给定类名来获取相应的字节码文件对象 最常用，只需从配置文件中解析到类名即可 调用newInstanse()方法来实例化 123456789101112131415161718192021222324252627282930String className = "cn.itcast.domain.Person";//一般从配置文件解析获取Class clazz = Class.forName(className);Object obj = clazz.newInstanse();//1.通过给定类名称加载对应字节码文件，并封装成字节码文件对象//2.通过new创建Person对象//3.调用构造方法初始化//通常被反射的类会提供无参构造，若没有会报instantiationException//如果提供了，但是权限不够会报illegalAccessExceptionPerson p = new Person();//1.加载Person类，并将类封装成字节码对象//2.通过new创建Person对象//3.调用构造方法初始化String className = "cn.itcast.domain.Person";Class clazz = Class.forName(className);Constructor cons = clazz.getConstructor(String.class,int.class);//获取指定的构造器Object obj = cons.newInstance("wangwu",23);//有了构造器对象后，通过其来初始化对象//获取字段 需要先获取到class对象Field field = clazz.getField(字段名); //公共字段可以这样获取Field field = clazz.getDeclaredField(字段名); //获取以声明字段 多数方法都有对应的declarefield.set(obj,30) //需要获取到字段和字节码对象，只可修改公共字段field.setAccessible(); //暴力访问，去除该字段访问权限//获取方法，需要先获取到class对象Method method = clazz.getMethod(方法名,null); //第二个表示无参method.invoke(null,null); //第一个为字节码对象，后面表示无参Method method = clazz.getMethod(方法名,String.class,int.class); //第二个表示无参method.invoke(obj,"wangwu",33); java设计思想设计模式前人把解决问题的方案总结出一个套路 代理设计模式静态代理设计模式 设计个接口，限制代理需要做哪些事，用接口来接收不同代理 1234567891011121314151617181920212223242526package com.itheima.demo10_代理设计模式;/* * 代理类:经销商 */public class ProxyPerson implements ComputerInterface&#123; private ComputerInterface lianxiang; public ProxyCompany(ComputerInterface lianxiang) &#123; this.lianxiang = lianxiang; &#125; @Override public String buyComputer() &#123; // TODO Auto-generated method stub return "鼠标,键盘,电脑包,u盘,操作系统,3000$ + "+lianxiang.buyComputer(); &#125; @Override public void repair() &#123; // TODO Auto-generated method stub System.out.println("需要运费1000块"); lianxiang.repair(); System.out.println("再给500块保管费"); System.out.println("再给100块运费"); &#125; 动态代理设计模式 设计原则 向上抽取原则 Java数据结构和算法先看几个经典算法面试题 用最快速度判断str2是否为str1子串 暴力破解（逐字匹配）/kmp算法《部分匹配表》 汉诺塔问题 递归，分治算法 八皇后问题 回溯算法 马踏棋盘 图的深度优化算法（DFS），贪心算法（优化） 算法是程序的灵魂，大厂对算法要求越来越高 数据结构]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaSE]]></title>
    <url>%2F2019%2F08%2F16%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数据类型和运算符基本数据类型（四类八种）byte(1) boolean(1) short(2) char(2)unicode字符集 int()4 float(4) long(8) double(8) 限制double小数点数 12DecimalFormat df = new DecimalFormat("0.00");df.format(total); string与基本类型转换 包装类的parse和tostring方法 引用数据类型string，数组，集合ArrayList，Scanner，Random，自定义类型 包的声明和访问包的本质就是文件夹，在包名中以.来区分上下级文件关系 作用：分类管理文件 包的声明：package 包名 指示某个类在哪个包下 包的声明必须和类的实际位置保持一致 包的导入：用来告诉编译器我们要用的类在哪个包下 import 包名.类名 不导包时需采用全限定类名：包名.类名（所有用到类名的地方都需这样写） 四种访问权限修饰符 面向对象面向对象是一种编程思想，是相当于面向过程的 面向过程：遇到问题，亲力亲为一步一步解决 核心理念：谁的功能谁负责 面向对象：遇到一个问题，找具有解决这个问题能力的对象，调用它的方法 面向对象三大特性：封装（安全性），继承（拓展性），多态（） 类的格式 1234567public class 类名&#123; //构造方法 //成员类名 //成员方法&#125;//一个标准的类 封装：隐藏细节，对外暴露公共防蚊1方式 构造：无参必须有，全参最好有//类名作为方法参数或返回值时需要传入或返回的应该是该类的对象 继承继承是两个类之间的关系，子类继承父类 this关键字区分局部变量和成员变量同名的情况 this的本质：实际上是个对象 谁调用的方法，this指的就是谁 匿名对象：（可用可不用） 没有名字的对象 只创建对象，但不用变量接收 在一些用来传参后续不调用时使用 特点：匿名对象也是一个对象，具有对象所有功能 ​ 每次调用都是一个新的对象，所一每个对象只能使用一次 123this.xxx //调用该对象属性this.aaa() //调用该对象方法//高级使用：用来调用本类的其他构造 通过输入不同参数来调用不同构造 super关键字区分子类和父类成员同名的情况，但默认优先调用子类 1234super.xxx //调用父类属性super.aaa() //调用父类方法super(); //调用父类构造方法，通过输入不同参数来调用不同构造，默认调用无参构造//无论调用子类那个构造，都会先调用父类构造，符合单一职责原则，一个类只需负责给本类变量初始化 继承12345678910111213public class 子类 extends 父类&#123; &#125;//继承必须合理 人是人他妈生的，妖是妖他妈生的//继承中的成员抽取了子类中的共性内容//子类会自动继承父类中所有成员，但private不可访问//创建子类对象时会先创建其父类对象//继承后成员变量不同时，没有任何问题，相同时优先访问子类//继承后成员方法不同时，没有任何问题，相同时(子类重写了父类方法时)优先访问子类，但可以通过super.方法名访问//只能单继承，但可以多层继承（直接父类唯一，但可以有多个间接父类）//多继承的话调用方法时会产生不确定性，同名父类成员不知道该掉哪个 继承大大提高代码重用性 方法的重载：在同一个类中，方法名相同，但参数列表不同（参数类型，参数顺序，参数个数任一不同） 方法的重写（覆盖，覆写override）：子类中出现了和父类一模一样的方法 重写原因：当子类发现继承过来的方法不适用时需要重写自己的方法 重写要求：该方法子类权限需大于等于父类权限（一般都是相同权限） public protected default private private方法不可重写 方法名，参数列表，返回值类型必须一模一样 多态一个对象的多种状态 java中的前提：必须有字符类关系，必须有方法的重写 抽象类和接口抽象类：以前一个类中包含抽象方法即为抽象类，现在只要由关键字abstract修饰即为抽象类 抽象类不可以实例化，天生就是作为父类的 抽象方法：只有声明而没有实现 向上抽取时会出现一种特殊情况，方法功能声明相同，但方法主体不同，这时只抽取方法声明，所得即为抽象方法 必须用关键字abstract修饰 不能调用，为了强制子类去重写 类名作为返回值或参数时，传递和返回的应是该类对象 抽象类作为返回值或参数时，传递和返回的应是该类的子类的对象 链式编程：当返回值为调用这个方法的对象时，便可以链式的调用下去 小练习 12//案例：武警开坦克打飞机//名词提取：武警 坦克 飞机 再分析每个类对应属性和方法 接口类：一堆具有共同属性和成员方法的对象的集合 接口：方法的集合，只能定义抽象方法 天生作为父接口 12345678910111213//class 类//abstract class 抽象类//interface 接口//enum 枚举public interface 接口名&#123; //不能定义普通成员变量，只能定义抽象方法 //可以定义常量 public static final 变量名 即使不加修饰，编译器也会自动添加&#125;//开发中常用模式：一个类继承一个抽象类，实现多个接口public class A extends AbstractClass B implements 接口A，接口B&#123; &#125; 类与类之间是单继承，一个子类只能有一个直接父类 接口与接口之间支持多继承也支持多层继承 类与接口之间不叫继承（extends）而是实现（implements） 可以多实现 比较抽象类和接口 相同点：都不能实例化，都是作为父类/父接口，子类继承/实现都不行重写抽象方法 不同点：抽象类中不全是抽象方法，可以有普通成员变量，修饰的关键字不同 弥补了java的单继承 思想上的区别：抽象类中必须定义整个体系的共性内容 ​ 接口中定义整个继承体系之外额外的扩展功能（谁想有这些功能就来是实现下这个接口） 优先使用接口 需要定义子类行为又要为子类提供共性功能时才用抽象类 多态父类类型 变量名 = new 子类类型(); 父类类型变量指向了子类对象 注意事项：多态使用变量是，编译和运行都看父类 调用成员方法，编译看父类，运行看子类 多态的弊端：只能调用子父类共有的方法，不能调用子类特有的（因为编译时看父类，特有的编译过不了） 好处：提高灵活性，父类可以接收任何一个子类对象 传哪个子类运行哪个子类的方法 1234//弊端解决方案//向下转型：强制类型转换 double转int，父类转之类 把向下和强转关联记忆吧//向上转型:隐式类型转换 子类转父类（多态） 向下转换会面临不知道该转成哪个子类的困扰，易出现类型转换异常//向下转型弊端解决：instanceof 格式：boolean b = 父类对象名 instanceof 子类对象名 内部类 成员内部类：定义类中方法外 在其他类中创建对象 外部类名.内部类名 对象名 = new 外部类名().new 内部类(); 局部内部类：定义方法中 在其他类中无法使用，只能局部使用 匿名内部类一种特殊的语法，用于快速创建抽象类的对象 12345678910111213141516//创建抽闲类对象//创建子类继承抽象类 重写抽象方法 new子类对象//用匿名内部类可以一步完成new 抽象类名()&#123; //重写方法&#125;;new 抽象类名()&#123; //重写方法&#125;.调用属性/方法;//最常用抽象类名 对象名 = new 抽象类名()&#123; //重写方法&#125;;//只重写抽象方法而不写独有的方法，因为没有名字，即使写了也无法向下强转为子类调用 静态代码块12345678public class 类名&#123; static&#123; //当我们使用到这个类的时候（实例化或使用静态成员等等），JVM会自动执行静态代码块中的内容 //仅在第一次使用到这个类的时候会执行一次，第二次就不会了 //优先级高于main和构造方法 //用于初始化类，比如MySQL加载驱动等 &#125;&#125; 访问修饰符static 静态的用于修饰类中的成员 被static修饰的成员访问时无需实例化再调用，可以直接通过类名访问（推荐） 当一个对象不独属于某个成员，而是所有成员共享事应加static修饰 静态没有多态性，静态属于类，而多态属于对象 多态调用静态成员时没有多态性（访问的是父类而非子类） 静态优先于对象存在 final 最终的可以修饰类，成员变量，成员方法，局部变量（基本类型，引用类型） 通过最终来理解这些性质 final修饰类——最终类：不能被继承，但可以有父类（太监类） final修饰成员变量：该变量必需在被实例化前赋值，且只能赋值一次 final修饰成员方法：该方法不能被子类重写 final修饰的基本类型局部变量只能赋值一次 final修饰的引用类型局部变量只能赋值一次，但其所指向的对象的内容可以随意改变 类中各种成员的初始化的顺序 1.如果类中存在继承关系(像 Son 继承 Father) 则首先会初始化导出类(Son)的基类(Father)，然后再是导出类 2.在基类首先会初始化静态 的东西 静态代码块&gt;静态变量 而且只初始化一次 （因为静态的东西都是跟着类的加载而加载的） 3.随后就是初始化导出类的静态东西 跟基类的静态初始化一样（同上） 4.初始化基类无参构造器（调用有参就初始化有参构造器） 5.初始化导出类无参构造器（注意：导出类的成员变量和代码块都是是比构造函数的初始化要早。。看输出结果可知）可知） object类是类层次的根类，所有类都直接或间接继承 12345//两个重要方法boolean equals(Object obj); //obj中定义的是根据地址计算出的hashcode //string类中重写了，改为比较字符串内容,我们自己定义类也一般会重写String toString(Object obj) //返回该对象的字符串表示 默认包名.类名@hashcode(地址) //system.out 打印对象会默认调用tostring 我们一般会重写这个方法 异常java代码编译或执行过程中出现的一些问题 异常的继承体系 Throwable：可以抛出去的东西 Exception：异常（普通问题） 编译时异常：Exception及其子类（RuntimeException除外） 运行时异常：RuntimeException及其子类 Errow：错误（严重的问题） 异常处理方式异常处理：异常处理指的是一种可能性，只有当出现了异常时才会执行异常处理代码，否则正常执行 异常处理方式 不处理 throw：动词，真正的抛出一个异常 throws：形容词，用来形容一个方法，表示该方法可能抛出的异常 要求调用者去处理它 public void 方法名（参数）throws 可能抛出的异常类型{ } 捕获处理 try(){ ​ 可能出现异常的代码 }catch(对应类型的异常对象){ ​ //catch可以有多个 ​ //处理异常 }finally{ ​ //写上必须要执行的代码，比如释放资源等 } 一次捕获多次处理: 一个try 多个catch (多个catch中 必须是异常子类在前,父类在后) 多次捕获多次处理: 多个try,每个try多应一个catch 一次捕获一次处理(最常用的):一个try一个catch(catch中异常类必须所有可能出现异常的父类) 注意事项：子类异常必须从属于父类异常 技巧: 如何区分一个异常类 到底是编译时还是运行时异常 1.编译时异常 在编译的时候会报错的 (需要我们去处理) 2.运行时异常 在编译的时候不会报错 只要定义一个方法,在方法中抛出一个异常对象,如果编译报错那么就是编译时异常 如果编译成功,那么就是运行时异常 请你说出十个运行时异常: 1.RuntimeException 2.ClassCastException:类型转换异常 (向下转型的时候) 3.ArrayIndexOutOfBoundsException:数组下标越界 4.StringIndexOutOfBoundsException:字符串下标越界 5.NullPointerException:空指针异常 自定义异常类： 1.创建一个类,这个类必须用Exception结尾 2.必须继承 Exception 或者 RumtimeException 3.自定义的异常 至少有两个构造 a.空参数构造 b.带有String类型参数的构造 12345678910package com.itheima.demo09_自定义异常的练习;public class NoSuchAgeException extends Exception&#123; //无参构造 public NoSuchAgeException()&#123;&#125; //带有String的构造 内部调用super(s)，将传入的string交给父类 public NoSuchAgeException(String s)&#123; super(s); &#125;&#125; Date类Date类:日期类 多数方法都过时了，不常用 标准时间1970年1月1日0时0分0秒 构造: public Date();//代表当前系统时间的Date对象 public Date(long time);//代表距离标准时间 time毫秒值的Date对象 成员方法: public String toString();//Date 重写Object类的toString方法 public long getTime();//获取当前Date对象的毫米值 与public Date(long time)互逆 DateFormat:日期格式化类,是一个抽象类 具体的子类:SimpleDateFormat 构造: public SimpleDateFormat(String pattern);//以指定的模式创建格式化对象 123&gt; SimpleDateFormat sdf = new SimpleDateFormat(yyyy年MM月dd日HH时mm分ss秒);&gt; &gt; 成员方法: public String format(Date d);//把date对象按照指定的模式 转成字符串 public Date parse(String s);//把字符串转成Date对象,如果字符串有问题,就会抛出ParseException Calendar:日历类获取Calendar对象 public static Calendar getInstance();//返回的是抽象类Calendar的某一个子类 成员方法: public int get(int field);//获取指定字段的值 public void add(int field,int amount);//给指定的字段增加值 public void set(int field,int value);//修改指定字段的值 public Date getTime();//把Calendar对象转成Date 对象 getTime().getTime() 相当于调用date的方法来获取毫秒值 System:系统类该类无法思力华，被私有化了 public static void exit(0);//结束JVM public static void gc();//通知垃圾回收器过来收垃圾，只是通知，不一定会来 public static getProperty(String key);//根据键 获取值 public static long currentTimeMillis();//获取当前系统的毫秒值 Math:数学类都是些静态方法，直接调用就好 求最大值 max 求最小值 min 求绝对值 abs 求随机数 random 返回一个[0,1)之间的数，通过简单计算得到自己想要的范围 求四舍五入 ceil(向上取整) floor(向下取整) pow(求次幂) 基类数据类型包装类八种基本类对应的包装类型 byte boolean short char int float double long Byte Boolean Short Character Interger Float Double Long 作用 在集合中只允许存储包装类型，不可以存基本类型 实现字符串的转换 public static int parseInt(String s); 将字符串转为int，其它基本类型类比即可 自动拆箱装箱 装箱：基本类型-&gt;包装类型 拆箱：包装类型-&gt;基本类型 哪些数据类型 重写了toString() 1.String类 2.保存数据的引用类型 (Integer,Double…,集合,map) 3.自定义类 可以重写toString 正则表达式所有编程语言都支持，用来匹配字符串的 boolean b = 普通字符串 匹配 正则表达式 public boolean matches(String regex); boolean b = “普通字符串”.matches(“正则表达式”); public String[] split(String regex); 切割字符串,返回切割后的字符串数组 书写技巧：一位一位的匹配 通配符 正则表达式中 “.”代表任意字符 在DOS中 “*”代表任意内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * QQ号码需要满足的规则: * 1.必须是0-9的数字 * 2.开头必须1-9中的一个数字 * 3.位数必须 5-12位 */public static void qq()&#123; String qq = "12355a63564"; boolean b = qq.matches("[1-9][0-9]&#123;4,11&#125;"); System.out.println(b);&#125;/* * 举例：校验手机号码 * 1：要求为11位0-9的数字 * 2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。 */public static void phone()&#123; String phone = "18600363521"; boolean b = phone.matches("1[34578][0-9]&#123;9&#125;"); System.out.println(b);&#125;/* * * 案例:切割电话 */public static void split01()&#123; String phone = "2345--4564----6546-----1345"; //切割phone 把号码切割出来 //+号 在正则表达式中有特殊意义,表示连续的多个相同的字符 String[] phones = phone.split("-+"); for (int i = 0; i &lt; phones.length; i++) &#123; System.out.println(phones[i]); &#125;&#125;/* * 案例:切割ip */public static void split02()&#123; String ip = "192...168....123......110"; //"."号 在正则表达式中 表示 任意字符 //转译字符 //\t //\n String[] ips = ip.split("\\.+");//在正则表达式中 "\\" 代表一个"\" System.out.println(ips.length); for (int i = 0; i &lt; ips.length; i++) &#123; System.out.println(ips[i]); &#125;&#125; String中的方法（4532）判断方法1234boolean equals(String str);boolean equalsIngoreCase(String str);boolean startsWith(String str);boolean endsWith(String str); 获取方法12345int length(String str);char charAt(int index);String substring(int startIndex);String substring(int startIndex,int endIndex); //左闭右开int indexof(String subStr); //少用 转换方法123String toLowerCase()；String toUpperCase()；char[] toCharArray()； 其它方法12String trim(); //去掉两端空格String[] split(String str); //一某一个字符串来分割字符串 集合集合框架: List–&gt; ArrayList,LinkedList,Vector Set –&gt; HashSet,LinkedHashSet,TreeSet Collection接口中的公共方法:子类不是都有下标，所有Collection无下标，故而无法进行改查操作 增: add(E e); 删: remove(Object obj); 改: 无 查: 无 其他: int size();//长度 boolean contains(Object obj); void clear();//清空 Object[] toArray(); //集合转换成数组 在ArrayList中 有一个方法 addAll(Collection c);//把集合c里面的每一个元素添加到ArrayList中 迭代器在Collection根解扣子中定义一种公共的遍历方式:迭代器遍历 Iterator&lt;泛型和集合的一样&gt; it = 集合对象.iterator(); 底层类似链表 迭代器对象 有两个方法: hasNext();//判断有没有下一个 next();//取出下一个 以上两个方法必须配合使用 补充 Concurrent(并发)Modification(修改)Exception java规定,如果一个集合使用迭代器遍历,那么在遍历的过程中 不允许修改集合的长度(增加或者删除) 123456789101112131415//1.创建一个集合对象,使用多态Collection&lt;String&gt; names = new ArrayList&lt;String&gt;();//2.添加names.add("郭德纲");names.add("刘德华");names.add("柳岩");names.add("范伟");names.add("范伟1");//3.获取names集合的迭代器对象Iterator&lt;String&gt; it = names.iterator();//4.标准代码while(it.hasNext())&#123;//反复判断有没有下一个元素 String s = it.next();//如果有取出下一个元素 System.out.println(s);&#125; 增强for循环增强for循环比普通的for循环增强在哪? 增强在语法上更加简单 格式: for(数据类型 变量名:数组/集合){ syso(变量名); } 注意: 当你使用增强for循环遍历集合的时候 底层采用的是迭代器 总结: 当你使用增强for循环遍历集合的时候,不能修改集合的长度 泛型泛泛的类型,不确定的类型，类型参数化 格式: ,&lt;K,V&gt; 好处 避免了强制类型转换 将运行时的ClassCsatException变为了编译错误 泛型通配符 ?:代表任意类型 &lt;? extends Animal&gt; : 表示一种泛型,这种泛型必须是Animal 或者Animal的子类 &lt;? super Animal&gt;:表示一种泛型,这种泛型必须是Animal 或者Animal的父类 泛型可以用在类上，方法上，接口上 泛型用在类上: 泛型类 格式:public class 类名 当你创建该类的对象的时候,就可以确定 泛型用在方法上:泛型方法 格式:public 返回值类型 方法名(T t); 当你调用方法,传递参数的时候确定 泛型用在接口上:泛型接口 格式:public interface 接口名 1.实现类实现接口的时候,直接确定 2.实现类实现接口的时候,不确定泛型,而是直接把泛型继承下来,当这个实现类创建对象的时候确定 堆栈和队列 数组和链表 list接口List接口的特点: a.有下标 b.有序的(有序不是自然顺序,不是123,abc,有序指的是存和取的顺序一致) c.可重复 实现类:ArrayList,LinkedList,Vector ArrayList:底层采用数组结构,查询快,增删慢 LinkedList:底层采用链表结构,查询慢,增删快 Vector:底层采用数组结构,查询快,增删慢（基本不用） List结构中具有的方法: 增: add(E e);add(int index,E e); 删: remove(Object obj);remove(int index); 改: set(int index,E e); 查: get(int index); 其他: size(),clear(),contains(Object obj),toArray() iterator();isEmpty() 实现类的方法: 1.ArrayList:方法基本和List中定义的一模一样 2.LinkedList:除了和List接口中一样的方法之外 LinkedList提供了大量首位操作的方法 第一组: void addFirst(E e); void addLast(E e); 第二组: E removeFirst();//删除首个元素,返回被删除的元素 E removeLast();//删除尾部元素,返回被删除的元素 第三组: E getFirst(); E getLast(); 第四组: E pop();//弹出,删除集合中的某一个元素,和 removeFirst功能是一样的 void push(E e);//推入,把一个元素添加到集合中, 和addFist功能是一样的 set接口Set接口的特点: a.无下标 b.无序的(无序指的是存和取的顺序不一定一致,LinkedHashSet和TreeSet除外) c.不可重复 实现类:HashSet,LinkedHashSet,TreeSet HashSet:底层采用哈希表结构,查询快,增删快,无序的 LinkedHashSet:底层采用 链表+哈希表,查询快,增删快,有序的 Set接口中的特有方法: 没有,和父接口Collection基本一模一样 实现类:HashSet和LinkedHashSet中的方法基本和Set接口一模一样 对象的哈希值: 任何对象,都有一个哈希值,哈希值是对象的一个数字表示 对象的字符串表示,toString方法,默认表示格式:包名.类名@地址值 如果获取对象的哈希值? 每一个对象都有一个方法,hashCode方法,这方法定义在了Object类中,所以每个对象都具有 我们以前说的地址值,实际上根本不是地址值,而是哈希值的16进制 在java中怎么看真正地址值? 看不了 哈希值的由来 是由真正的地址值计算的,通过一种散列算法(哈希算法) 所以 一般来说 地址值 不一样, 哈希值也是不一样的 不可逆算法(MD5,WPA2) 碰撞算法(一个一个试) 暴力破解&amp;字典破解(破解wifi教程) 字符串的哈希值: 由于String类重写了HashCode 那么哈希值不在通过地址值计算 我们观察源码,发现通过字符串的内容计算,所以只要字符串内容相同,哈希值必定相同 思考: 只要字符串内容一样,哈希值 必定一样 两个字符串的内容不一样,哈希值可能一样 比如: abc 和 acD 哈希表结构: 数组结构+链表结构的组合,查询快,增删快 HashSet:采用了哈希表结构 LinkedHashSet:采用了链表+哈希表结构 哈希表结构,判断元素是否重复的原理: 1.先判断 新元素的哈希值 和 所有旧元素的哈希值是否相同 如果都不相同,直接判断不重复,添加 2.再调用 新元素 和 哈希值相同的旧元素的equals方法 如果返回是true 判定重复元素 ,不添加 如果返回是false 判定不重复,添加 总结: 只有哈希值相同,并且equals返回true,才判定重复 判断元素重复不重复的原理: 1 比较哈希值 2 调用equals方法 只有 哈希值相同,并且equals方法true,才是重复元素,才不存储 contains方法,判断是否包含某一个元素 ArrayList的contains方法: names.contains(“abc”);//判断 names集合中是否包含 “abc” 只比较 equals的返回值,如果某一个元素和要判断的元素equals方法true,那么就是包含该元素 HashSet的contains方法: set.contains(“abc”);// 先判断哈希值 再使用equals方法 只有旧元素和判断的元素 的哈希值相同 并且 euqals方法true 才判定包含 使用HashSet存储自定义元素(Dog对象) 结论: 如果我们自定义了类 要使用HashSet存储 如何保证元素的唯一性: 必须重写自定义类的两个方法,hashCode和equals 定义一个标准的类: 1.封装(private+get/set) 2.构造(无参+全参) 3.toString(快速打印对象信息) 4.hashCode和equals(保证元素使用哈希表结构存储时的唯一性) MapMap集合的特点: 1.Map集合 和 Collection集合 没有继承关系,所以不能直接用迭代器 2.Collection集合 每一个元素都是单独存在 Map集合的每一个元素都是成对存在的 3.Collection一个泛型 Map&lt;K,V&gt;两个泛型, K代表键的类型,V代表值的类型 K,V可以相同 也可以不同,必须都是引用类型 4.在Map集合的元素中,键是唯一的,值是可以重复的 5.常用的实现类: HashMap:无序 底层哈希表结构,保证键的唯一性,需要重写键对应类的hashCode和equals方法 LinkedHashMap:有序 底层哈希表结构+链表,哈希表保证键的唯一,链表保证元素的有序 需要重写键对应类的hashCode和equals方法 Map&lt;K,V&gt;集合常用的方法: 增: V put(K key,V value);//向集合中添加键值对 //如果集合中已存在该键,覆盖整个键值对,并返回被覆盖的键值对的值 删: V remove(OBject key);//根据键 从map集合中删除 键值对,返回值表示被删除的键值对的值 改: 隐藏到了put方法 查: V get(K key);//根据键 从map集合中找到唯一对应的值 Map集合第一种遍历方法:以键找值 1.先获取map集合的键的集合,这个集合是一个Set集合 Set keys = map集合.keySet(); 2.遍历keys集合 a.foreach b.迭代器 3.在遍历的过程中,从map集合获取键对应的值 123456789101112//3.获取map的键的集合Set&lt;String&gt; keys = map.keySet();//4.遍历keys这个集合,获取到每一个键//4.1迭代器遍历Iterator&lt;String&gt; it = keys.iterator();while(it.hasNext())&#123; String key = it.next(); //根据key 从map集合中查找 对应值 String value = map.get(key); //打印 System.out.println(key+":"+value);&#125; map集合第二种遍历 ：键值对遍历 1.获取map集合中所有 结婚证对象 Set&lt;Map.Entry&lt;K,V&gt;&gt; set = map集合.entrySet(); 2.遍历这个set集合,获取每一个Map.Entry类型的对象 a.迭代器 b.foreach 3.获取到 Map.Entry类型的对象之后 K key = entry.getKey(); V value = entry.getValue(); 1234567891011//3.获取所有键值对关系对象的集合Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();//4.遍历 这个entry集合, 拿出每一个结婚证对象//使用迭代器遍历Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = entrySet.iterator();while(it.hasNext())&#123; Map.Entry&lt;String, String&gt; entry = it.next(); //获取这个entry中的 键和值 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"="+value); 回顾：内部类和内部接口 内部类: 一个类A,定义在另外一个类B 的内部,这个类A 这个类被称为内部类 OuterClass.InnerClass ic = new OuterClass().new InnerClass(); 内部接口: 一个接口A,定义在另外一个接口B的内部,这个接口A, 这个接口A被称为内部接口 class Class2 implements OuterInter.InnerInter 只重写内部类中的方法即可 使用map存储自定义类型使用map存储:键为学号,值为一个学生的对象, 学生对象有属性（姓名，年龄） 使用map存储:键为学生（姓名，年龄）值为学生自己的家庭住址。 结论: 如果Map中的键是自定义类型,那么要保证键的唯一性,必须重写键对应类的hashCode和equals方法 Properties属性集在开发中Map集合可能用到,但是Properties属性集,1000%会用到 Properties类到底是什么?属性集, class Propeties extends HashTable implements Map 所以:Properties本质上 就是一个Map集合 Properties是一个持久的属性集 所谓持久 就是 它具有自己写数据到文件的方法 Properties是没有泛型,泛型是固定,String 和 String Properties类,具有Map接口的一切方法 还有具有一些自己特有的方法: public String getProperty(String key)用指定的键在此属性列表中搜索属性的值,功能和Map中的get是一样 public Object setProperty(String key, String value);添加键值对,功能和Map的put方法是一样 public Set stringPropertyNames()://和Map中的keySet方法是一样 Properties具有持久化到文件的功能 store();//保存数据到文件,实际上不是保存到文件 而是写入到流中,由流写到文件 load();//从文件中加载数据,实际上不是直接加载文件,而是加载流中的数据,而流的数据是从该文件中读取的 12345678910111213141516171819202122232425262728293031323334353637383940public class PropertiesDemo &#123; public static void main(String[] args) throws IOException &#123; //和Properties持久化有关的方法 Properties ps = new Properties(); //从文件中读取数据 ps.load(new FileReader("phones.properties")); System.out.println(ps); &#125; //Properties持久化数据到文件中 public static void writePs() throws IOException&#123; //1.定义Properties Properties ps = new Properties(); ps.setProperty("iphoneX", "8888"); ps.setProperty("xiaomiMix", "3888"); ps.setProperty("huaweiMate11", "6888"); ps.setProperty("vivoX20", "1888"); //2.把ps的数据持久化到文件中 ps.store(new FileWriter("phones.properties"), ""); &#125; public static void demo01()&#123; // TODO Auto-generated method stub //1.创建一个Properties对象 Properties ps = new Properties(); //2.添加数据 ps.setProperty("张三", "18"); ps.setProperty("李四", "28"); ps.setProperty("王五", "38"); ps.setProperty("前妻", "48"); //3.遍历 //1.stringPropertyNames 就是keySet Set&lt;String&gt; propertyNames = ps.stringPropertyNames(); //4.遍历 for (String propertyName : propertyNames) &#123; //根据属性名 propertyName获取属性值 String propertyValue = ps.getProperty(propertyName); System.out.println(propertyName+"="+propertyValue); &#125; &#125;&#125; 小知识点可变参数说的不是参数类型可变,而是参数的个数可以变化 语法: JDK1.5 出现新特性 public 返回值类型 方法名(数据类型… 参数名){} 注意: 1.可变参数只是参数的个数是任意个,参数的类型不能改变 2.一个方法中 只能有一个可变参数 3.当一个方法中有多个参数,并且有一个是可变参数的时候,要求这个可变参数必须在最后 可变参数的本质: 就是一个数组 Collections中的静态方法: public static void shuffle(List list);//打乱顺序 public static void sort(List list);//把集合元素按照自然顺序(123,abc)排序 Arrays:数组工具类 public static List asList(数组/可变参数);//把一个数组 转成List集合 public static void sort(数组);//排序数组 public static String toString(数组);//把数组转成字符串 递归 递归:是一个通用技术,所有的编程语言,只要有方法概念的编程语言都具有递归 什么叫递归:在一个方法的内部,再调用方法本身 无限递归本身是错误的:因为方法运行需要进栈,而栈空间不是无限大的 使用递归的前提****: 1.必须有一个可以是递归结束的出口 2.递归的次数,不能太多(具体的次数不好确定,与内存,CPU…都有关) 我们建议在开发中 能不用递归 就是不要用 急剧消耗内存(最常见是杀毒软件 扫描硬盘) 递归的其他分类: 直接递归: 在A方法的内部 直接调用A方法 123456789101112131415161718192021222324&gt; //定义一个方法,求1-n的和 先想一下基于n-1步如何解决&gt; public static int getSum(int n)&#123;&gt; //1+2+3...n = (1+2+3..n-1)+n&gt; if(n==1)&#123;&gt; return 1;&gt; &#125;&gt; return getSum(n-1)+n;&gt; &#125;&gt; &gt; //求1-n的和 常用&gt; public static int getSum(int n)&#123;&gt; int sum = 0;&gt; for (int i = 1; i &lt;= n; i++) &#123;&gt; sum+=i;&gt; &#125;&gt; return sum;&gt; &#125;&gt; private static int getSum2(int n) &#123;&gt; if (n == 1) &#123;&gt; return 1;&gt; &#125;&gt; return getSum2(n - 2) + n;&gt; &#125;&gt; 间接递归: 在A方法的内部调用B方法,在B方法的内部调用C方法,在C方法的内部调用A方法 1234567891011121314151617181920212223242526272829&gt; package com.guardwarm.递归;&gt; &gt; import java.util.Scanner;&gt; &gt; //定义方法 求 n个式子的和&gt; //n=5&gt; //1+(1+2)+(1+2+3)+(1+2+3+4)+(1+2+3+4+5)&gt; public class undirectDiGui &#123;&gt; public static void main(String[] args) &#123;&gt; System.out.println("please enter a num");&gt; Scanner scan = new Scanner(System.in);&gt; int n = scan.nextInt();&gt; int sum = getsum(n);&gt; System.out.println(sum);&gt; &#125;&gt; public static int getsum(int n)&#123;&gt; if(n == 1)&gt; return 1;&gt; return getsum(n-1)+zigetsum(n);&gt; &#125;&gt; public static int zigetsum(int n)&#123;&gt; if(n == 1)&gt; return 1;&gt; return zigetsum(n-1)+n;&gt; &#125;&gt; &#125;&gt; &gt; &gt; 斗地主案例案例分析 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.guardwarm.斗地主;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedHashMap;import java.util.Map;/* * 斗地主步骤: * * 1.创建编号和牌对应的map集合 * * 2.准备一副牌(54个数字1-54) * * 3.洗牌 * * 4.发牌 * * 5.排序 * * 6.从map集合查找 * * 7.看牌 */public class doudizhuMapDemo &#123; public static void main(String[] args) &#123; //准备一副牌 Map&lt;Integer,String&gt; allcard = new LinkedHashMap&lt;Integer, String&gt;(); ArrayList&lt;Integer&gt; cards = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; dp = new ArrayList&lt;Integer&gt;(); int id = 1; String[] colors = &#123;"♠","♥","♣","♦"&#125;; String[] nums = &#123;"3","4","5","6","7","8","9","10","J","Q","K","A","2"&#125;; for(String num : nums)&#123; for(String color : colors)&#123; String card = num+ color; allcard.put(id,card); cards.add(id); id++; &#125; &#125; allcard.put(id,"大S"); cards.add(id); id++; allcard.put(id,"小S"); cards.add(id); id++; Collections.shuffle(cards); //测试// System.out.println(cards); for (int i = 0; i &lt; cards.size(); ++i) &#123; Integer cd = cards.get(i); if (i &gt;= 51) &#123; dp.add(cd); &#125; else if (i % 3 == 0) &#123; p1.add(cd); &#125; else if (i % 3 == 1) &#123; p2.add(cd); &#125; else if (i % 3 == 2) &#123; p3.add(cd); &#125; &#125; Collections.sort(p1); Collections.sort(p2); Collections.sort(p3); Collections.sort(dp); /* System.out.println(p1); System.out.println(p2); System.out.println(p3); System.out.println(dp);*/ outputcard(p1,allcard); outputcard(p2,allcard); outputcard(p3,allcard); outputcard(dp,allcard); /* Collections.sort(cards); System.out.println(cards);*/ &#125; private static void outputcard(ArrayList&lt;Integer&gt; ls,Map&lt;Integer,String&gt; map)&#123; for(Integer cardid:ls)&#123; String card = map.get(cardid); System.out.print(card+" "); &#125; System.out.println(); &#125;&#125; IO流_读写文件（输入输出是相对程序而言的） 输出流：数据从java程序到文件中 123456//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)write(int ch); //可以写ascll码值write(char[] ch);write(char[] ch,int startIndex,int len);write(String s);write(String s,int startIndex,int len); 输入流：数据从文件到java程序 123//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)int read(); //读取一个字符int read(char[] chs); //读取一个字符数组，返回值表示读取到的字符个数 File类:描述:文件和 目录路径名的抽象表示 文件:可以直接保存数据 目录路径名:文件夹,分类管理文件 结论:File类可以表示文件 也可以表示文件夹 构造: public File(String filepath); 绝对路径:以盘符开头的路径 相对路径:相对当前项目的根目录 File对象的获取方法: 1.public String getAbsolutePath();//获取绝对路径 2.public String getName()//获取当前File对象的名字 3.public String getPath();//获取创建File对象时 传递的路径 4.public long length();//获取表示文件的File对象的占用的字节数,如果是文件夹的File对象,返回值不确定 File对象的删除和创建方法: 1.创建方法: 创建文件: public boolean createNewFile();//创建一个新的文件(只能是文件,不能是文件夹),返回是否创建成功 创建文件夹 public boolean mkdir();//创建一个新的文件夹,返回是否创建成功 public boolean mkdirs();//可以一次性创建多层文件夹 2.判断方法: 判断是否是文件 public boolean isFile();//返回是否是文件 判断是否是文件夹 public boolean isDirectory();//返回是否是文件夹 判断文件或者文件夹是否存在,是前面两个前提 public boolean exists();//返回该File 对象是否存在 3.删除方法: public boolean delete();//删除文件或者文件夹 可以删除的是单个文件,或者空文件夹 File类的list和listFiles方法 1.public String[] list(); 2.public File[] listFiles(); 注意: 只能列出当前文件夹下的一级子文件或者子文件夹，那个对象必须存在且是文件夹才可以调用 案例：使用递归遍历使用文件夹 1234567891011121314151617181920212223242526272829303132333435/* * 使用递归遍历 一个文件夹aaa下的所有文件(包括一级的也包括n级文件) * * 1.定义方法,遍历一个文件夹下的所有文件 * * 2.在方法中判断 某一个File对象 ,如果是文件 直接打印 * 如果不是文件,递归调用第1步定义的方法 * */public class DiguiDemo &#123; public static void main(String[] args) &#123; //1.创建aaa文件夹的File 对象 File aaa = new File("C:\\Users\\yingpeng\\Desktop\\aaa"); //2.调用方法 列出 aaa下的所有文件 printFiles(aaa); &#125; //定义一个方法:列出一个文件夹下的文件 public static void printFiles(File objFileDir)&#123; //2.列出aaa文件夹下的所有File 对象 File[] files = objFileDir.listFiles(); for (File file : files) &#123; //判断是否是文件 或者 文件夹 if(file.isFile())&#123; //打印 System.out.println(file); &#125;else&#123; //是文件夹.列出该文件夹下的所有东西 printFiles(file); &#125; &#125; &#125;&#125; 文件过滤器:FileFilter 在list和listFiles方法中使用，用来过滤文件，有多少个文件就会执行多少次 1234567891011public class MyFileFilter implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; // TODO Auto-generated method stub System.out.println(".."); //用来看这个方法执行了多少次 if(pathname.getName().endsWith(".PNG"))&#123; return true; &#125; return false; &#125; 案例：map集合嵌套遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.guardwarm.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* * 案例: * 需要定义一个Map集合,保存学生的学号和他对应的名字 * Map&lt;String,String&gt; * JavaEE: * heima001 张三 * heima003 李四 * heima005 王五 * UI: * heima001 小丽 * heima004 小红 * heima005 小美 * PHP: * heima002 小黑 * heima003 小白 * heima006 小猪 * */public class MapQianTao &#123; public static void main(String[] args) &#123; //定义所需map Map&lt;String,String&gt; eeMap = new HashMap&lt;String, String&gt;(); Map&lt;String,String&gt; uiMap = new HashMap&lt;String, String&gt;(); Map&lt;String,String&gt; phpMap = new HashMap&lt;String, String&gt;(); Map&lt;String,Map&lt;String,String&gt;&gt; outMap = new HashMap&lt;String, Map&lt;String, String&gt;&gt;(); eeMap.put("heima001","张三"); eeMap.put("heima003","李四"); eeMap.put("heima005","王五"); uiMap.put("heima001","小丽"); uiMap.put("heima004","小红"); uiMap.put("heima005","小美"); phpMap.put("heima002","小黑"); phpMap.put("heima004","小白"); phpMap.put("heima005","小猪"); outMap.put("javaee",eeMap); outMap.put("ui",uiMap); outMap.put("php",phpMap); //先通过entrySet获取Set，然后再用set获取迭代器开始遍历 Set&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outSet = outMap.entrySet(); Iterator&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outit = outSet.iterator(); while (outit.hasNext())&#123; Map.Entry&lt;String,Map&lt;String,String&gt;&gt; outEntry = outit.next(); String outKey = outEntry.getKey(); //由于值是map，所以内部还得再遍历 Map&lt;String,String&gt; outvalue = outEntry.getValue(); System.out.println(outKey); Set&lt;String&gt; mapKeys = outvalue.keySet(); for(String key:mapKeys)&#123; String mapValue = outvalue.get(key); System.out.println(mapValue); &#125; &#125; &#125;&#125; IO流根据流的流向分类: Input:输入流 Output:输出流 根据流操作的数据来分类 字符流: 操作字符 只能操作普通文本文件, ​ 最常见的文本文件:.txt,.java,.c,.cpp等其他语言的源代码 ​ 只要用文本工具(记事本,notepad++,editplus) 可以打开的 ,而且打开后我们人类能看懂的 都是文本文件 ​ 注意:我们用的.doc,excel,ppt这些不是文本文件 字节流: 操作字节 ​ 能操作一切文件(文本文件,.mp3,视频.avi,.rmvb,mp4,doc,excel,ppt) java中的四大流: 字符输入流:共同父类 Reader 比如:FileReader,BufferedReader 功能:读取一个字符,读取一个字符数组 字符输出流:共同的父类 Writer 比如:FileWriter BufferedWriter 功能:写一个字符,写一个字符数组(一部分),写一个字符串 字节输入流:共同父类 InputStream 比如:FileInputStream,BufferedInputStream 功能:读取一个字节,读取一个字节数组 字节输出流:共同父类 OutputStream 比如:FileOutputStream,BufferedOutputStream 功能:写一个字节,写一个字节数组(一部分) 只要是输入流 此流的方法名 一定叫做 read 只要是输出流 此流的方法名 一定叫做 write java中流的命名是十分规范的: 功能+父类的名字（4种） OutputStream:字节输出流的根类,这是一个抽象类 public void close();//关闭流 public void flush();//刷新流 和写数据有关系的方法; public void write(int b);//写一个字节 public void write(byte[] bs);//写一个字节数组 public void write(byte[] bs,int startIndex,int lenght);//写一个字节数组的一部分 FileOutputStream OutputStream具体子类 追加: 以前用的构造: ​ public FileOutputStream(String filename);//默认就是覆盖 ​ public FileOutputStream(File file);//给定一个File对象,这个File对象代表我们要写入的文件 请用这个构造,实现追加: ​ public FileOutputStream(String filename,boolean flag) ​ public FileOutputStream(File file,boolean flag) 换行（不同操作系统用不同换行）: windows:\r\n Linux:\n Mac:\r InputStream:字节输入流的根类,这是一个抽象类 public int read();//读取一个字节,返回的是码值 public int read(byte[] bs);//读取一个字节数组,返回值表示实际读取到的字节数 我们用InputStream具体子类:FileInputStream 12345678910111213141516171819202122232425262728293031323334353637383940package com.guardwarm.文件;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 复制文件练习: * * 1.源文件: 是读取用的, new FileInputStream("源文件") * * 2.目标文件: 是写入用的, new OutputStream("目标文件") * * 3. 一边读取 源文件 一边写出到目标文件 * * 4.关闭流 */public class CopyFile &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("F:\\书\\史铁生.docx"); FileOutputStream fos = new FileOutputStream("F:\\书\\copy.docx"); long s = System.currentTimeMillis(); int b = 0; while((b=fis.read())!=-1)&#123; fos.write(b); &#125;/* //一次读取一个字节数组 byte[] bs = new byte[1024];//用来保存读取到的字节数据 int len = 0;//保存实际读取到的字节个数 while((len=fis.read(bs))!=-1)&#123; fos.write(bs, 0, len);//写入bs中的从0下标开始len个字节 到文件中 &#125;*/ long e = System.currentTimeMillis(); long time = e-s; System.out.println(time); fos.close(); fis.close(); &#125;&#125; 缓冲流: 相比较没有缓冲区的流,效率更高BufferedOutputStream 缓冲输出流 构造方法 public BufferedOutputStream(OutputStream out) BufferedInputStream 缓冲输入流 构造方法 public BufferedInputStream(InputStream in) 小案例：复制单级文件夹1234567891011121314151617181920212223242526272829303132333435363738package com.guardwarm.文件;import java.io.*;public class CopySingleDirectory &#123; public static void main(String[] args) throws IOException &#123; //创建文件夹 File srcfl = new File("F:\\demo1"); File dstfl = new File("F:\\demo2"); if (!dstfl.exists())&#123; boolean b = dstfl.mkdirs(); if (b)&#123; System.out.println("文件夹不存在，成功创建"); &#125; &#125;else &#123; System.out.println("目标文件夹已存在，直接复制即可"); &#125; //遍历文件 注意创建目标文件 File[] srcfiles = srcfl.listFiles(); for (File src : srcfiles)&#123; File dst = new File(dstfl,src.getName()); copyfile(src,dst); &#125; &#125; public static void copyfile(File srcfl,File dstfl) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcfl)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dstfl)); //固定格式 byte[] bs = new byte[1024]; int len = 0; while ((len = bis.read(bs))!= -1)&#123; bos.write(bs,0,len); &#125; bis.close(); bos.close(); System.out.println("复制文件"+srcfl.getName()+"成功！"); &#125;&#125; 小知识点使用字节流读取中文的乱码问题: 如果是一个一个字节读取, 100%会出现乱码 如果是一个一个字节数组读取,可能也会出现乱码 解决方法 字符流 转换流 字符编码集 ASCII码表 美国 每个字符对应一个字节 保存了字母，数字，以及一些常用符号 a-97 A-65 0-48 GB2313 保存常用汉字，一个中文占两字节，这两个字节全是负数 GBK 保存了基本所有汉字，统统占两个字节第一个字节为负，第二个字节随意 Unicode 统一码表（万国码表）所有文字统统两字符，向下兼容ASCII UTF-8 在Unicode的基础上做了一些优化，能用一个字节的不用两个字节，且在每一个字节头加入了编码信息，一个中文占三个字节 Latin-1（ISO-8859-1） 拉丁码表，Tomact会用到 编码 – &gt;文字到对应码值 解码 – &gt;码值到对应文字 转换流字符流的子类 OutputStreamWriter 查码表，是字符流通向字节流的桥梁，write方法与其他流一致 123456public static void writeCN() throws Exception &#123; //创建可以把字符转成字节的转换流对象，并指定编码 两种构造，指定编码也可不写，默认GBK OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("c:\\cn8.txt"),"utf-8"); //调用转换流，把文字写出去，其实是写到转换流的高效区中 osw.write("你好");//写入高效区。 osw.close(); InputStreamReader 注意选择正确的解码方式 1234567891011121314151617181920public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; //演示字节转字符流的转换流 readCN(); &#125; public static void readCN() throws IOException&#123; //创建读取文件的字节流对象 InputStream in = new FileInputStream("c:\\cn8.txt"); //创建转换流对象 //InputStreamReader isr = new InputStreamReader(in);这样创建对象，会用本地默认码表读取，将会发生错误解码的错误 InputStreamReader isr = new InputStreamReader(in,"utf-8"); //使用转换流去读字节流中的字节 int ch = 0; while((ch = isr.read())!=-1)&#123; System.out.println((char)ch); &#125; //关闭流 isr.close(); &#125;&#125; 转换流和子类区别：转换流可以选择解码/编码方式 java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter ​ FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编 码表时可以不用父类，而直接用子类就完成操作了，简化了代码。 序列化流和反序列化流用于从流中读取对象的操作流 ObjectInputStream 称为 反序列化流 用于向流中写入对象的操作流 ObjectOutputStream 称为 序列化流 构造方法类似转换流，具体看API 常见异常 当一个对象要能被序列化，这个对象所属的类必须实现Serializable接口。否则会发生异常NotSerializableException异常。 同时当反序列化对象时，如果对象所属的class文件在序列化之后进行的修改，那么进行反序列化也会发生异常InvalidClassException。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 版本号默认有java管理，也可以生成版本号自己管理 transient关键字 不需要序列化的属性可以使用关键字transient修饰 同时static修饰的也不会序列化 打印流字节打印流 PrintStream 字符打印流 PrintWriter 两者基本一致，可以打印的目的地略有不同 PrintStream 字符串的文件名，file对象，其他的tOutputStream，其他的Writer PrintWriter 字符串的文件名，file对象，其他的tOutputStream 12345678910111213public class PrintWriterDemo &#123; public static void main(String[] args) throws IOException &#123; //创建流 //PrintWriter out = new PrintWriter(new FileWriter("printFile.txt")); PrintWriter out = new PrintWriter("printFile.txt"); //2，写数据 for (int i=0; i&lt;5; i++) &#123; out.println("helloWorld"); &#125; //3,关闭流 out.close(); &#125;&#125; 第三方小框架：commons-iops.第一方：官方，第二方：我们 jar包：java专用压缩包 从上到下依次为：api文档，框架class文件，生成api文档的源文件，框架源文件，测试class文件，测试源文件，许可，注意事项 添加jar包 eclipse 1.创建lib文件夹 2.将commons-io.jar拷贝到lib文件夹 3.右键点击，→ IDEA file-&gt; project structure 点最右侧那个+，然后OK就好 FileUtils readFileToString(File file)：读取文件内容，并返回一个String； writeStringToFile(File file，String content)：将内容content写入到file中； copyFile(File srcFile, File destFile): 文件复制 copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制 多是一些静态方法，直接用类名就可调用 多线程几个小概念 进程: 正在运行的程序 叫做进程 线程: 进程中的一个小任务 一个进程中通常是由多个线程在执行任务 main方法所在线程 我们称为主线程 创建方法Thread类:就是我们说的线程类 构造: public Thread();//创建一个默认名字的线程对象 public Thread(String name);//创建一个指定名字的线程对象 创建新的线程的方法一: 1.定义子类 继承 Thread 2.在子类中重写run方法(就是执行任务的方法,在run方法中写任务代码即可) 3.创建子类对象(就是创建一个线程对象) 4.开启这个线程 123456//3.创建子类线程对象MyThread mt = new MyThread();//设置守护线程mt.setDaemon(true);//4.开启线程,JVM自动会告诉CPU去执行线程任务代码mt.start(); 开启线程的第二种方式: 1.定义实现类 实现Runnable接口 2.实现类要重写run方法(就是写任务代码的方法) 3.创建实现类对象 4.创建Thread对象,并把刚刚的实现类对象 作为参数传递 5.启动这个Thread对象 12345MyRunnable mr = new MyRunnable();//4.创建Thread对象,并把刚刚的实现类对象 作为参数传递Thread td = new Thread(mr);//5.开启线程td.start(); 内存图 创建两个线程对象 我们发现: a.线程默认是有名字,名字Thread-n,n从0开始 依次递增的 b.我们可以修改线程的名字,但是一般不改 setName(String name); c我们可以获取线程的名字,通过线程对象的getName方法获取 d.获取线程名字的最常用的方法 Thread.currentThread().getName(); 两种创建方式比较 从耦合性分析: 第一种方式:线程和任务是紧紧联系在一起的,耦合性高 第二种方式:线程是线程,任务是任务,他们之间没有必然联系,给一个线程传递哪个任务那么该线程就执行哪个任务 所以说开发中,我们用第二种方式 从代码的扩展性: 第一种方式 由于是继承Thread,那么子线程类就不能继承别的类 第二种方式 由于是实现了接口,同时可以继承别的类 所以说开发中,我们用第二种方式 用匿名内部类创建对象12345678910111213141516171819202122232425262728293031323334/* * 匿名内部类: * 快速创建一个类的子类对象,或者一个接口的实现类对象 * * 格式: * new 父类()&#123; * 重写方法(); * &#125;; * new 接口()&#123; * 实现方法() * &#125;; * 使用匿名内部类 创建线程对象 *///1.第一种方式创建线程对象:继承方式 new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("线程"+getName()+i); &#125; &#125; &#125;.start();//2.第二种方式创建线程对象:实现方式 new Thread(new Runnable()&#123; @Override public void run() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; 10; i++) &#123; System.out.println("线程"+Thread.currentThread().getName()+i); &#125; &#125; &#125;).start(); 案例：卖票123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/* * 案例:电影院卖票 * * 假设 上演"忍者神龟" 100张票 * * 有三个柜台在卖票,同时开卖,并且卖的都是这100张票 * * 三个柜台就是三个线程,他们同时执行同一个买票任务,同时操作一个共享数据100张票 * */public class SaleTicketsDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //1.创建卖票任务对象 TicketsRunnable tr = new TicketsRunnable(); //2.创建 3个线程 去执行买票任务 Thread t1 = new Thread(tr,"窗口1"); Thread t2 = new Thread(tr,"窗口2"); Thread t3 = new Thread(tr,"窗口3"); t1.start(); t2.start(); t3.start(); &#125;&#125;public class TicketsRunnable implements Runnable&#123; private int count = 100; @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; if(count&gt;0)&#123; try &#123;Thread.sleep(120);&#125; catch (InterruptedException e) &#123;&#125; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125; &#125;/* * 解决线程安全问题方式一: * 给代码加上同步锁 * 格式: * synchronized(锁对象)&#123; * 代码 * &#125; * 锁对象可以是任意对象 * 先运行到那块的会拿到锁对象，然后执行几次后会将锁对象放回，让其他线程执行 */ public class TicketsRunnable implements Runnable&#123; private int count = 1000; private Object obj = new Object(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; synchronized(obj)&#123; if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125; &#125; &#125;&#125; /* * 解决线程安全问题方式二: * 同步方法 * 格式: * public synchronized void 方法名()&#123; * 需要运行的代码 * &#125; * 注意:同步代码块和同步方法的原理是一样,都是具有锁对象,哪一个线程进来执行,那么该线程就持有这个锁对象 * 这里同步方法使用的锁对象 叫做this对象 * 如果同步方法是静态方法,那么他的锁对象是 当前类.class */ public class TicketsRunnable implements Runnable&#123; private int count = 1000; private Object obj = new Object(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; sale(); &#125; &#125; public synchronized void sale()&#123; if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125;&#125; /* * 解决线程安全问题方式三: * Lock接口方式 * 我们实际用的是他的一个实现类:ReentrantLock * * 在Lock接口中有两个方法: * lock();//获取锁 * unlock();//释放锁 */ public class TicketsRunnable implements Runnable&#123; private static int count = 1000; //创建一个Lock接口的实现类对象 Lock l = new ReentrantLock(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; l.lock(); if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; l.unlock(); &#125; &#125;&#125; 线程状态图 socket-网络编程计算机网络网络通信协议: 网络:由多台计算机,以及外部设备 连接起来一个系统 我们就称为网络 通信协议: 就像交通规则,规定网络上传输的数据的格式,大小,速度等等 在我们现在的网络中都有哪些通信协议: TCP/IP协议 UDP协议 其他协议 IP地址和端口号的介绍 IP地址: 网络每一台计算的唯一标识 1Byte=8Bit IP地址 每一个段 0-255 端口号: 是每一个计算机中的”门”,一共有0-65535号门 总结:我们向别的计算机发信息的时候 确定 IP地址:为了找到那台计算机 确定 端口号: 为了确定发送到对方计算机中的哪个应用程序 InetAddress:代表IP地址类 public static InetAddress getLocalHost();//获取你的计算机的IP地址对象 public String getHostName();//仅获取主机名 public String getHostAddress();//仅获取IP地址 public static InetAddress getByName(“其他主机的名字或者IP”);//远程主机的IP地址对象 UDP和TCPUDP:用户数据报协议 特点:面向无连接,数据是不安全,不完整 有无接收端均可 优点:效率高 比如:发短信,供屏软件,QQ视频 TCP:传输控制协议 特点:面向有连接,数据是安全,完整性 没有接收端会直接报错 比如:打电话,上网 TCP协议建立连接 有三个步骤 我们称为”三次握手” UDP使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * 使用UDP进行数据通信,需要用到两个类 * * 数据的发送接收器:DatagramSocket * * 数据包类:DatagramPacket *///发送端public class UDPSender &#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); //1.创建DatagramSocket对象 DatagramSocket ds = new DatagramSocket(); while(true)&#123; //2.创建DatagramPacket对象 //存储 发送的数据,对方的IP,端口号 System.out.println("请输入您要发送的数据:"); String sendMsg = sc.nextLine(); byte[] bs = sendMsg.getBytes(); //IP地址:127.0.0.1 代表本机,本地回环地址 DatagramPacket dp = new DatagramPacket(bs,bs.length,InetAddress.getByName("127.0.0.1"),12345); //3.发送 ds.send(dp); System.out.println("发送数据成功!!!");//192.168.146.72 &#125; //4.关闭资源 //ds.close(); &#125;&#125;//接收端public class UDPReceiver &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //1.创建DatagramSocket对象, //强调:接收端必须指定一个端口号 DatagramSocket ds = new DatagramSocket(12345); while(true)&#123; //2.直接创建一个DatagramPacket对象 byte[] bs = new byte[1024]; DatagramPacket dp = new DatagramPacket(bs, bs.length); //3.接收 System.out.println("等待发送端发送数据...."); ds.receive(dp);//这个方法具有等待功能,等待发送端发送过来的数据 System.out.println("接收数据成功!!"); //获取发送端的地址 InetAddress sendAddress = dp.getAddress(); System.out.println("发送端是:"+sendAddress.getHostAddress()); //获取真正的数据 byte[] data = dp.getData(); //获取发送端 发来了多少字节 int len = dp.getLength(); //打印数据 String receiveMsg = new String(data, 0, len); System.out.println("发送端说:"+receiveMsg); &#125; //4.关闭资源 //ds.close(); &#125;&#125; TCP使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485进行简单数据交互/** * TCP客户端: * * 1.创建Socket对象,传入服务器的IP和端口 * * 2.通过Socket对象获取输出流,调用write方法写数据到服务器 * * 3.通过socket对象获取输入流,调用read方法读取服务器反馈的信息 * * 4.关闭(Socket对象) * * * TCP服务端: * * 1.创建ServerSocket对象,传入一个端口,端口必须和客户端的一样 * * 2.先获取哪一个客户端连接的服务器,通过accept()方法获取 * * 3.通过Socket对象获取输入流,调用read方法读取客户端发来的数据 * * 4.通过socket对象获取输出流,调用write方法向客户端反馈数据 * * 5.关闭(ServerSocket,Socket) * * @author yingpeng * */public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致 ServerSocket server = new ServerSocket(12345); //2.获取到 哪一个 客户端连接的我 System.out.println("等待客户端连接..."); Socket client = server.accept();//此方法也具有等待功能,等待某一个客户端连接 //打印一些和客户端有关信息 String ip = client.getInetAddress().getHostAddress(); System.out.println("小样,抓到你了:"+ip); //3.获取输入流,实际上是客户端写数据时的输出流 InputStream in = client.getInputStream(); //4.读取数据 byte[] bs = new byte[1024]; int len = in.read(bs); //打印 System.out.println("客户端说:"+new String(bs,0,len)); //5.要向客户端 回写数据,告诉客户端您的信息我已经收到了 OutputStream out = client.getOutputStream(); out.write("您的消息已经收到...".getBytes()); System.out.println("给客户端反馈的信息发送成功!!!"); //关闭资源 server.close(); client.close(); in.close(); &#125;&#125;public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口) /* * 这个构造方法干了很多事情: * a.自动去连接服务器 * b.自动进行三次握手,建立连接 * c.自动为连接中创建两个流 */ Socket client = new Socket("127.0.0.1", 12345); // 2.从客户端对象中获取 输出流:getOutputStream() //OutputStream out = client.getOutputStream(); // 3.调用输出流的Write方法写数据到服务器即可 //out.write("How are you".getBytes()); client.getOutputStream().write("How are you".getBytes()); System.out.println("给服务器发送数据成功!!"); //4.读取服务器 发送过来的反馈信息 InputStream in = client.getInputStream(); byte[] bs = new byte[1024]; int len = in.read(bs); System.out.println("服务器响应:"+new String(bs,0,len)); // 关闭资源 client.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//上传文件//客户端public class FileUploadClient &#123; public static void main(String[] args)throws IOException &#123; //1.创建Socket对象,连接服务器 Socket client = new Socket("127.0.0.1", 12345); System.out.println("连接服务器成功.."); //2.获取输出流,把数据写向服务器 OutputStream out = client.getOutputStream(); //3.创建文件的输入流,读取本地的文件数据 FileInputStream fis = new FileInputStream("C:\\Users\\yingpeng\\Desktop\\pictures\\3.png"); //4.循环,读取本地文件,写到服务器 byte[] bs = new byte[1024]; int len = 0; while((len=fis.read(bs))!=-1)&#123; out.write(bs, 0, len); &#125; //关闭输出流 client.shutdownOutput(); //5.获取服务器反馈的信息 InputStream in = client.getInputStream(); byte[] bs1 = new byte[1024]; int len1 = in.read(bs1); System.out.println("服务器说:"+new String(bs1,0,len1)); //6关闭 client.close(); out.close(); fis.close(); &#125;&#125;//服务器端 服务器一直开启，通过多次执行客户端来多文件上传public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //1.创建ServerSocket对象,绑定一个端口 ServerSocket server = new ServerSocket(12345); while(true)&#123; //2.获取哪一个客户端连接的服务器 System.out.println("等待客户端连接..."); final Socket client = server.accept(); //开启一个线程,和clinet进行交互 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // TODO Auto-generated method stub System.out.println("小样:"+client.getInetAddress().getHostAddress()); //3.获取输入流,读取客户端发来数据 InputStream in = client.getInputStream(); //4.创建文件的输出流,把数据写到文件中 String picName = "H:\\upload\\"+System.currentTimeMillis()+".png"; FileOutputStream fos = new FileOutputStream(picName); //5.循环 从输入流读取客户端数据, 写入到文件中 byte[] bs = new byte[1024]; int len = 0; while((len=in.read(bs))!=-1)&#123; fos.write(bs, 0, len); &#125;//1小时 System.out.println("客户端的文件已经保存完毕,可以查看了"+picName); //6.告知客户端,文件真的真的真的上传成功 OutputStream out = client.getOutputStream(); out.write("您的文件真的真的真的上传成功".getBytes()); client.close(); in.close(); out.close(); fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; //6.关闭 // server.close(); &#125;&#125; 一个bug 客户端传输完文件需主动调用client.shutdownoutputstream来关闭输出流，不然服务器会不知道是执行完了还是网络延迟 反射定义一个应用程序已写好，后期出现的接口子类无法直接在该应用中new一个对象，该怎么办？ 子类不确定，可以通过提供配置文件形式将不确定的信息存储在配置文件中即可。该程序只要之前写好读取配置文件的信息即可。 如果存储了指定的子类名，就根据具体名称找该类并进行加载和对象的创建，这些动作都是在定义软件时写好的 没有类之前就将创建对象的动作写好了，这就是动态的获取指定的类，并使用类中的功能——反射技术 字节码文件对应的类class Class 描述字节码文件的类 Field field 将字段封装成对象类型 Constructor cons 将构造函数封装成了对象类型 Method method 将类中的成员都封装成了对象 getField() getMethod() getConstrctor() 获取字节码文件对象要想获取字节码文件中的成员，首先要获取字节码文件对象 法一 通过object类中的getClass方法 12Person p1=new Person();Class clszz1=p1.getClass(); 虽然通用，但必须有指定类，并对该类进行实例化才能调用getClass方法 法二 调用任意一个数据类型的一个静态成员class 不用实例化类，但还是需要指定的类 法三 使用class类中的forName方法，通过给定类名来获取相应的字节码文件对象 最常用，只需从配置文件中解析到类名即可 调用newInstanse()方法来实例化 123456789101112131415161718192021222324252627282930String className = "cn.itcast.domain.Person";//一般从配置文件解析获取Class clazz = Class.forName(className);Object obj = clazz.newInstanse();//1.通过给定类名称加载对应字节码文件，并封装成字节码文件对象//2.通过new创建Person对象//3.调用构造方法初始化//通常被反射的类会提供无参构造，若没有会报instantiationException//如果提供了，但是权限不够会报illegalAccessExceptionPerson p = new Person();//1.加载Person类，并将类封装成字节码对象//2.通过new创建Person对象//3.调用构造方法初始化String className = "cn.itcast.domain.Person";Class clazz = Class.forName(className);Constructor cons = clazz.getConstructor(String.class,int.class);//获取指定的构造器Object obj = cons.newInstance("wangwu",23);//有了构造器对象后，通过其来初始化对象//获取字段 需要先获取到class对象Field field = clazz.getField(字段名); //公共字段可以这样获取Field field = clazz.getDeclaredField(字段名); //获取以声明字段 多数方法都有对应的declarefield.set(obj,30) //需要获取到字段和字节码对象，只可修改公共字段field.setAccessible(); //暴力访问，去除该字段访问权限//获取方法，需要先获取到class对象Method method = clazz.getMethod(方法名,null); //第二个表示无参method.invoke(null,null); //第一个为字节码对象，后面表示无参Method method = clazz.getMethod(方法名,String.class,int.class); //第二个表示无参method.invoke(obj,"wangwu",33); java设计思想设计模式前人把解决问题的方案总结出一个套路 代理设计模式静态代理设计模式 设计个接口，限制代理需要做哪些事，用接口来接收不同代理 1234567891011121314151617181920212223242526package com.itheima.demo10_代理设计模式;/* * 代理类:经销商 */public class ProxyPerson implements ComputerInterface&#123; private ComputerInterface lianxiang; public ProxyCompany(ComputerInterface lianxiang) &#123; this.lianxiang = lianxiang; &#125; @Override public String buyComputer() &#123; // TODO Auto-generated method stub return "鼠标,键盘,电脑包,u盘,操作系统,3000$ + "+lianxiang.buyComputer(); &#125; @Override public void repair() &#123; // TODO Auto-generated method stub System.out.println("需要运费1000块"); lianxiang.repair(); System.out.println("再给500块保管费"); System.out.println("再给100块运费"); &#125; 动态代理设计模式 设计原则 向上抽取原则 Java数据结构和算法先看几个经典算法面试题 用最快速度判断str2是否为str1子串 暴力破解（逐字匹配）/kmp算法《部分匹配表》 汉诺塔问题 递归，分治算法 八皇后问题 回溯算法 马踏棋盘 图的深度优化算法（DFS），贪心算法（优化） 算法是程序的灵魂，大厂对算法要求越来越高 数据结构]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xmind使用]]></title>
    <url>%2F2019%2F08%2F13%2Fxmind%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[软件下载使用的较简单的免费版，本意只是为了简单的做一些总结之所以选择xmind:zen而不是xmind 8是因为感觉xmind:zen相对来说更小，启动速度更快，并且感觉更加代表了未来的发展方向，xmind 8有些笨重了官网 使用技巧编辑主题文字：选中主题“双击鼠标”或者按【空格键】 添加同级主题：快捷键【enter/return】 添加子主题：可快捷键【tab】 删除：选中主题按【delete/backspace】 添加外框：选中要框选的主题按工具栏的【外框】进行添加 添加概要：选中主题按工具栏的【概要】进行添加 添加笔记： ctrl+shift+n(note) 撤销: Ctrl+z 恢复: Ctrl+y emmm,帮助-&gt;快捷键助手，基本列出了常用快捷键，还可以自定义快捷键 自己直接上手也很easy，就不一一总结了 小结整体使用还是比较符合我的预期的，启动快，简约，操作方便，虽然免费版导出格式受限，并且还有水印，但这个对我基本没什么影响]]></content>
      <tags>
        <tag>思维导图</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看过的一些编程书及评价]]></title>
    <url>%2F2019%2F07%2F28%2F%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8F%8A%E8%AF%84%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[汇编 汇编语言基础教程 James T.Streib整体讲解不够深入，用了很多高级汇编指令，与最初想了解底层如何实现的初衷相违背，并且很多话说的不清楚，很绕。整体学到了一些东西，算是入门了，但整体感觉不好，不推荐。 运维 跟阿铭学linux（第三版）学linux最初的各种命令是看的网课。那几个明明运用及理解都不难的命令，反反复复讲了好长时间，白白浪费了不少时间。我感觉看书来学习linux的各种命令更高效，这本书整体节奏不错，难度感觉略高一点，但认着看，感觉看的很舒服，收货很多。勉强算适合小白吧，我感觉还是有一些对新手不怎么友好的点。 （这本书学习笔记参见）]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出现过的小问题]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[与git相关​ fatal: Not a git repository (or any of the parent directories): .git ​ git init ​ 生成子项目 ​ git submodule add 项目路径 文件路径 与hexo相关常用命令 ​ 清楚缓存 hexo clean ​ 本地检测 hexo s (-p 4001 指定端口，默认4000) （–debug检测） ​ 生成静态文件 hexo g（-w 监视文件变动） ​ 部署 hexo d ​ (hexo clean &amp;&amp; hexo g -d) 与Markdown相关 感觉没有光标移动很不舒服，暂时没找到解决办法 默认开启了拼写检查，很多编程的英文下面都是红线，很难受 文件 -&gt; 偏好设置，下拉就可以找到钱拼写检查 ) 不喜欢默认主题的可以在偏好设置中获取主题 选择自己喜欢的点击download，会给出css源码（有时也会直接给一个压缩文件），自己ctrl A,ctrl C存为一个css文件，导入主题文件夹即可 （从偏好设置中打开主题文件夹，导入即可） 与intellij IDEA相关]]></content>
      <tags>
        <tag>编程</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编基础]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础知识 直接在硬件工作，与机器语言一一对应 机器语言 01010000 本质：电平脉冲（早期通过穿孔卡片是实现） push ax 难以阅读且易错 汇编语言主体是汇编指令，相当于机器指令的助记符 程序–&gt; 汇编指令 –&gt; 编译器–&gt; 机器码 –&gt; 计算机 汇编语言包括 汇编指令（机器码的助记符）核心 伪指令（由编译器执行） 其他符号（由编译器执行） CPU：控制计算机运作并进行运算 核心部件 内存：存储数据，不常用的置于磁盘中 寄存器]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
