<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2019%2F09%2F22%2FJDBC%2F</url>
    <content type="text"><![CDATA[概述JDBC主要是有 java的类和接口组成 在JDBC中核心的三个接口和一个类 DriverManager: 驱动管理类,帮助我们加载各种驱动 Connection: 数据库连接接口,实现类在驱动中 Statement: 执行SQL语句的接口,实现类在驱动中 ResultSet: 结果集接口,实现类在驱动中 驱动：每个厂商提供自己操作数据库的实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//操作步骤/* * 使用JDBC操作数据库步骤 * * 1.必须先把对应的数据库驱动 添加到工程的构建路径 * * 代码步骤: * * 1.注册驱动:使用DriverManger来注册 * * 2.获取和数据库的连接对象: 是Connection接口的实现类对象 * * 3.获取SQL语句的执行者对象: 是Statement接口的实现类对象 * * 4.结果集对象:是ResultSet接口的实现类对象 * * 5.处理结果集(打印,保存) * * 6.释放资源 * */public class JDBCDemo &#123; public static void main(String[] args) throws Exception &#123;// * 1.注册驱动:使用DriverManger来注册 发现实现类在静态代码块里会注册，所以用反射直接加载字节码文件更好 //DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName("com.mysql.jdbc.Driver");// * 2.获取和数据库的连接对象: 是Connection接口的实现类对象 String url = "jdbc:mysql://localhost:3306/day04"; // jdbc:固定语法 数据库厂商名 IP地址 端口号 要连接的数据库 Connection conn = DriverManager.getConnection(url, "root", "123");// * 3.获取SQL语句的执行者对象: 是Statement接口的实现类对象 Statement st = conn.createStatement();// * 4.结果集对象:是ResultSet接口的实现类对象 ResultSet rs = st.executeQuery("select * from category");//执行查询,返回值是结果集 //int rows = st.executeUpdate("insert into category values (6,'饮料')"); //int rows = st.executeUpdate("delete from category"); //执行增,删除,改,返回值是被影响的行数 // * 5.处理结果集(打印,保存),迭代器 hasNext next // System.out.println(rows); while(rs.next())&#123;//判断有没有下一条记录 //取出对应字段的值 // getInt getString getDouble getObject //getObject(1) getObject(列名); Object cid = rs.getObject("cid"); Object cname = rs.getObject("cname"); System.out.println(cid+"\t"+cname); &#125;// * 6.释放资源 rs.close();//只有执行查询,才有结果集对象,如果执行增删改,只有int类型行数 st.close(); conn.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//JDBCUtils 工具类package com.guardwarm.JDBC;import java.sql.*;public class JDBCUtils &#123; public static String driverName = "com.mysql.jdbc.Driver"; public static String url = "jdbc:mysql://localhost:3306/****"; public static String root = "***"; public static String passward = "********"; static &#123; try &#123; Class.forName(driverName); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException("驱动加载失败，请检查驱动包"); &#125; &#125; public static Connection getConnection() throws SQLException &#123; Connection conn = DriverManager.getConnection(url,root,passward); return conn; &#125; public static void close(Connection conn, Statement st, ResultSet rs)&#123; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (st!=null)&#123; try &#123; st.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端三件套]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%2F</url>
    <content type="text"><![CDATA[HTMLHTML:（HyperText Markup Language）超级文本标记语言 超级文本: 普通文本只能显示文字,超级文本,除了显示基本文字之外,显示图片,视频,音频,文件特殊效果等 标记: 是HTML的组成元素,&lt;a&gt;&lt;/a&gt; 语言: 一门编程语言 HTML语言能干啥? 写网页结构 HTML语言的特点 HTML文件不需要编译，直接使用浏览器阅读即可 HTML文件的扩展名是*.html (推荐)或 *.htm HTML的标签特点: 1.标签是预定义好的,我们只要了解其功能,直接拿过来使用即可 2.标签的名字是不区分大小写的 3.通常情况下标签由开始标签和结束标签组成 4.如果没有内容,那么可以写成 &lt;a/&gt; 自闭合标签 12345678910&lt;html&gt; // 只要是HTML网页,要求 必须有一个根标签HTML &lt;head&gt; //head标签,叫头标签,保存网页中的最最最重要的信息 //而且这些信息打开网页是开不见 //头标签中有多个子标签 &lt;meta&gt; 标签 保存了页面重要信息,编码,关键字等等 &lt;title&gt; 这是网页的标题,显示在打开网页的最上端 &lt;/head&gt; &lt;body&gt; body标签是网页的身体,就是我们写内容的地方 &lt;/body&gt;&lt;/html&gt; 常用标签标题标签&lt;h1&gt;-&lt;h6&gt; h1最大,6h最小 特点:自动换行,并且上下留白 水平线标签&lt;hr /&gt; 属性size:水平线的高度 属性noshade:设置纯色效果 属性width:设置宽度 字体标签&lt;font&gt; 已过时，被CSS取代 属性size:字体大小 有值1-7, 其中7最大 属性color:字体颜色,颜色有两种表示 a.英文单词 b.#RGB #ff0000 属性face:设置字体,比如微软雅黑,宋体 格式化标签 加粗:&lt;b&gt; &lt;strong&gt; 倾斜:&lt;i&gt; &lt;em&gt; 段落和换行 段落:&lt;p&gt;,特点:自动换行,上下留白 换行:&lt;br /&gt; 图片标签 属性src: 图片路径 路径有两种 1.绝对路径: http://www.baidu.com/logo.png 相对路径: 相对本文件所在的文件夹 有两种路径格式: ./表示本文件夹 ../上一层文件夹 属性width:图片宽度,可以使用像素,也可以百分比 属性height:图片高度,可以使用像素,也可以百分比 不要同时设置宽度和高度都使用百分比,因为图片会等比例放大或者缩小 属性atl:图片显示有问题时的代替文本 属性title:鼠标移动到图片上面时显示的文字 列表标签 &lt;ul&gt; &lt;ol&gt; &lt;ul&gt;:无序列表&lt;ol&gt;:有序列表列表标签想要显示必须有列表项标签需要修改列表的序号或者图案 属性type: ol中type的取值: 1(默认的) a A i I ul中type的取值: circle(空心圆点) disc(小黑点,默认的) square(小方点) 超链接标签&lt;a&gt; 属性href: 表示点击后跳转的页面 属性target:表示点击后网页在哪一个位置显示 值:_self 本页面 _blank 新页面 framename:其他框架 表格标签 子标签: 表示表头，默认加粗居中 ​ 子标签: 表示行标签​ 子标签:表示行中的单元格table标签的属性:​ border:边框的高度 单位 px​ align:水平对齐方式,有 左对齐left 右对齐right 中间对齐center​ width:​ weight:​ bgcolor:设置整个表格的背景色,tr和td也有bgcolor​ align属性用在table上表示整个表格的对齐方式​ 用在tr上表示行中所有单元格内容的对齐方式​ 用在td上表示某一个单元格内容的对齐方式​ &lt;td&gt;:合并单元格的属性​ rowspan: 跨行合并,属性具体的值表示跨几行​ colspan:跨列合并,属性具体的值表示跨几列 &lt;frameset&gt; h5不支持 JavaScript1.JavaScript:是一门嵌入式编程语言,主要是嵌入到html中 而且这个语言不需要编译,直接用浏览器就可以运行 常量/变量 数据类型 if,switch 循环for,while 函数 事件 事件和函数绑定 js中的分类: ECMAScript：js的核心语法 BOM:浏览器对象 DOM:Document Object Model.操作文档中的元素和内容. 2.js必须嵌入到HTML中才能运行 a.内嵌式: 必须在一个标签&lt;script&gt;的开始和结束标签之间写 格式:在HTML写一个标签 b.外联式: 写在另外一个文件,但是文件的后缀必须.js 在HTML中通过 标签引入刚刚写的js文件 格式: 假设我们已经写了一个 aa.js的外部js文件 123&lt;script type="text/javascript" src="外部js的路径" charset="utf-8"&gt; //不能再次写代码&lt;/script&gt; JS的基本语法: 变量的命名:和java基本类似 变量的声明: 在java中: 数据类型 变量名; int a; 在JS中: var 变量; //注意: 在js中变量如果没有赋值 默认值 undefined 赋值: a.定义变量同时赋值 var a = 10; b.先定义后赋值: var a; a=10;a=&quot;abc&quot;; 数据类型: 基本类型: a.Undefined 只有一个值 undefined,当定义变量并且不赋值的时候,默认值就是undefined b.Null 只有一个值 null,空值,但是在ECMAScript中把他们定义成了相等 c.Boolean，有两个值 true 和 false d.Number，表示任意数字 1 10000000000 3.13 3.13456732345678 e.string,表示字符串,在js中字符串必须用&quot;&quot;或者&apos;&apos;引起来 引用类型: 也是一种叫做类(class),但是我们一般不会自己创建对象,而是直接使用 js已经给我们准备好的对象, 所以说JS是基于对象 ,而不是面向对象 运算符: 算术运算符和java一模一样 比较运算符: &quot;\==&quot;:称为值等,只比较两个数据的值,不考虑类型 比如 var a = &quot;10&quot; a=\=10,这是true,因为值一样 &quot;\=\=\=&quot;:称为全等,即比较类型 也比较数值, 比如 var a = &quot;10&quot; a===10 这是false,因为类型不一样 逻辑运算符: 与 && 或 || 非 ! 5.boolean类型的转换 其他数据类型转成boolean类型 undifined和null 转成了false +0,-0和NaN 转成了false,其他数值转成了true "" 空字符串转成了false "abc" 有内容字符串 转成了true boolean类型如果参与运算,那么true转成1 false 转成0 6.js中的一些等式运算(见讲义的表)]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML]]></title>
    <url>%2F2019%2F09%2F21%2FXML%2F</url>
    <content type="text"><![CDATA[XML介绍XML:可扩展的标记语言。 可扩展的:扩展性特别强,语法上比较松 标记: 我们用的是1.0的版本 用于存放数据或配置文件 XML的语法:a.文档声明 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 版本一般选1.0，编码默认是utf8 b.注释: 开始：&lt;!– 结束 –&gt; c.元素(Element)/标签(Tag) 必须有开始和结束标签组成 &lt;dan&gt; &lt;/dan&gt; 一般只有一个跟标签，可以相互嵌套 d.属性:attribute 属性名=“属性值” 必须写在开始标签中 必须以字母开头 e.转义字符 12345&lt; --- &amp;lt;&gt; --- &amp;gt;" --- &amp;quot;' --- &amp;apos;&amp; --- &amp;amp f.CDATA区 当内容中出现大量的需要转译的字符 XML提供了CDATA区 12345678910111213141516&lt;abc&gt; &lt;![CDATA[ String s = "abc"; int count = 0; for(int i = 0;i &lt; s.length() ; i++)&#123; char c = s.charAt(i); if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')&#123; count++;]]&gt; &lt;!-- 特例：里面还包含了]]&gt;,需要分开成两个CDATA区 --&gt; ]]&amp;gt; &lt;![CDATA[ &#125; &#125; System.out.println("count = " + count); ]]&gt; &lt;/abc&gt; XML约束 DTD约束 文档开始注释会提示在xml文档前添加&lt;!DOCTYPE beans SYSTEM “bean.dtd”&gt; 第一个值为跟标签名字 根据智能提示编写即可 三种引入方式 内部DTD 外部DTD SYSTEM 本地DTD,后面一般跟个文件名 PUBLIC 公共DTD，后面一般跟个网址 Schema约束 文档开头注释会提示应在xml中1导入的信息 &lt;beans xmlns=”http://www.itcast.cn/bean&quot; xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=”http://www.itcast.cn/bean bean-schema.xsd”&gt; 注意这是一个开始标签，添加一下结束标签即可，其余使用方法和DTD差不多 如果有多个schema约束文件名字冲突时，需使用targetname来指定，但显得很冗长，可以给其起个别名 XML解析用io流来解析太过繁琐，一般使用第三方提供的解析开发包 三种解析方式 常用解析开发包 dom4j1.核心类 SAXReader:加载XML文件 2.Document对象,表示整个XML文件对象 3.元素:Element 获取根元素: document.getRootElement(); 获取属性: element.attributeValue(“属性名”) 获取子元素:List element.elements();//好几个重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//被解析文件&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;bean id="001" className="cn.itcast.demo.User"&gt; &lt;property name="username" value="jack"&gt;&lt;/property&gt; &lt;property name="password" value="123"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="002" className="cn.itcast.demo.Admin"&gt; &lt;property name="username" value="admin"&gt;&lt;/property&gt; &lt;property name="password" value="123321"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;public class Dom4JDemo &#123; public static void main(String[] args) throws DocumentException &#123; // TODO Auto-generated method stub //1.把整个要解析的XML文件加载到内存 SAXReader reader = new SAXReader(); //2.会生产一个Documnet对象 Document document =reader.read(new File("beans.xml")); //3.获取根标签 Element rootEle = document.getRootElement(); //4.获取根标签的子标签 List&lt;Element&gt; beanElements = rootEle.elements(); //5.遍历elements集合 for (Element beanElement : beanElements) &#123; //6.获取子标签bean的属性 String idValue = beanElement.attributeValue("id"); String classNameValue = beanElement.attributeValue("className"); System.out.println(idValue+".."+classNameValue); //获取bean的子标签 List&lt;Element&gt; propertyElements = beanElement.elements(); //遍历property标签 for (Element propertyElement : propertyElements) &#123; //propertyElement Property标签 //获取Property的属性 String nameValue = propertyElement.attributeValue("name"); String valuevalue = propertyElement.attributeValue("value"); System.out.println(nameValue+"==="+valuevalue); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2019%2F09%2F20%2FMySQL%2F</url>
    <content type="text"><![CDATA[MySQL软件安装去MySQL官网下社区版，根据网上教程配置属性 还下了SQLyog，可以图形化界面写mysql（注册码百度一下很好找） 数据库（DB）和数据库管理系统（DBMS）数据库：存储数据的仓库，本质是一个文件管理系统 数据库管理系统：是一个软件，用来管理文件 我们常说的数据库，实际上是数据库管理系统，一般习惯称为数据库 一般不直接操作DB，而是通过DBMS来操作DB 表（java中一个类）行：一条记录 类的一个对象 列：一个字段 java中一个属性 常见数据库MySQL：开源免费，小型的数据库，已经被Oracle收购，开始收费（6.x之后） Oracle：收费的大型数据库，收购了SUN,MySQL DB2：IBM的数据库，常用在银行，效率差，安全性高 SQLSever：Microsoft的，常用于c#，.net SyBase：已经淡出历史舞台，提供了一个专业的数据建模工具——PowerDesigner SQLite：嵌入式的小型数据库，用于手机端 MySQL开启和关闭 法一：此电脑-&gt;管理-&gt;服务-&gt;找到MySQL即可 法二：以管理员权限打开command net start mysql net stop mysql mysql -u root -p(直接跟密码或回车然后会提示输入密码) 法三：用SQLyog SQL语句 DDL：数据库定义语言 defination 主要是对数据库数据库表进行创建删除等维护操作 create 创建 drop 删除 alter 修改 show 查看 DCL：数据库操纵/控制语言 control 控制数据库访问权限 DML：数据库操作语言 manager 主要是对表中数据进行增删改 insert 增加 delete 删除 update 修改 DQL：数据库查询语言 query 主要是对表中数据进行查询 select 查询 from 从 where 条件 SQL通用语法 SQL语句可以单行或多行书写，以分号结尾 可使用空格和缩进来增强可读性 语句不区分大小写，关键字建议使用大写 /**/ 块注释 # 单行注释 常用数据类型（还有很多，但不常用） int 整形 double 浮点型 varchar 字符串型 date 日期型 yyyy-mm-dd，没有时分秒 DDL操作数据库​ 增 ​ create database 数据库名 采用默认编码，安装时选的 ​ create database 数据库名 charset utf8 ​ 删 ​ drop database 数据库名 ​ 改 ​ 修改数据库名字很麻烦 ​ use 数据库名 修改正在使用的数据库 ​ 查 ​ select database() 查询正在使用的数据库 ​ show database 查询所有数据库 ​ show create database 数据库名 查询某个数据库详细信息 操作数据库表​ 增 ​ create table 表名（ ​ 字段名1 数据类型1（长度） [约束]， ​ 字段名2 数据类型2（长度） [约束] ​ 字段名2 数据类型2（长度） [约束] ​ ）； ​ 删 ​ drop table 表名 ​ 查 ​ desc 表名 查看一个表的详细信息 description ​ show tables 查看所有的表 ​ 改 ​ rename table 表名 to 新表名 改名字 操作数据库表中的列​ 增 ​ alter table 表名 add 列名 类型（长度） [约束] ​ 删 ​ alter table 表名 drop 列名 ​ 查（同查看表的信息） ​ desc 表名 查看一个表的详细信息 ​ 改 可以修改列的名字，类型，约束等等 ​ alter table 表名 change 旧列名 新列名 类型(长度) 约束 修改列名,实际上类型和约束也可以一起改了 ​ alter table 表名 modify 列名 类型（长度） 约束 修改类型和约束 ​ alter table 表名 character set 字符集 一般不修改 DML增 insert into 表名 (列名1，列名2) values (value1，value2) 插入一条记录 列名可以选择一列或几列，前后必须一一对应 除了int，double，其它数据必须用””或’’引起来，推荐使用单引号 如果要插入的记录所有字段都有，则(列名1，列名2)可省略 删 delete from 表名 删除所有记录 delete from 表名 where 条件 改 update 表名 set 字段名=值 把该字段内所有的值都改了 update 表名 set 字段名=值 where 条件 DQL基本查询select [distinct] *|列名1，列名2 from 表名 查询表中所有行数据 distinct 去重查询 字段名+10 查询结果是表达式 运算查询 字段名+10 as 新名字 别名查询 条件查询 1234567891011121314151617181920212223where price &lt;&gt; 60;where not (price=60);where price &gt;= 400 and price &lt;= 600;where price between 400 and 600;where price in (400,600); 价格是400和600的where price &gt;1000 or price &lt; 300;where pname like &apos;%霸%&apos; 名字中含&apos;霸&apos;的商品where pname like &apos;_霸%&apos; 名字中第二个字为&apos;霸&apos;的商品where pname is null; 没有名字的，不可以用pname=nullwhere price &gt;2000 and category_id in (&apos;c002&apos;,&apos;c003&apos;);where (price &gt;2000 and category_id=&apos;c002&apos;) or(price &gt;2000 and category_id=&apos;c003&apos;); 排序查询对查询结果进行排序，关键字order by 格式：查询语句 order by 字段名 [ASC|DESC] ASC 升序，从小到大，默认 DESC 降序，从大到小 聚合查询以前的查询都是横向记录查询，该查询是纵向个数查询 查询特点：查询到的是单一值 聚合函数：求记录数的聚合函数 格式：聚合函数（字段名） ​ count函数会自动忽略空值 ​ max：求最大值 ​ min：求最小值 ​ avg：求平均值 ​ sum：求和 分组查询把查询到的结果分成几个组，先分组再查询，具体查询到的结果数，取决于分成几个组 若分组后还有条件需要判断，用having关键字 where写在基本查询语句后，且后面不可以写聚合函数 having写在分组查询后，且后面可以写聚合函数 格式：查询语句 group by 字段 select count() from product group by categroy_id having count(\)&gt;1 只显示个数大于1的商品分类，注意条件用having 完整查询过程 分页查询只查询记录的一部分 格式：limit 数值一（开始下标，从0开始计数），数值二（需要查出的记录数） 查询公式：假设每次查n条 第m页 limit (m-1)*n,n 多表查询交叉查询 格式：select * from 表一，表二 总字段=表一字段+表二字段 总记录数=表一记录数*表二记录数 但交叉查询无实际意义，实际上是一个矩阵（坐标）的笛卡尔，是另外两个查询的基础 内连接查询 inner join 隐式内连接查询：不写关键字inner join select * from 表一，表二 where 表一.主键=表二.外键 显式内连接查询：写关键字inner join select * from 表一 inner join 表二 on 表一.主键=表二.外键 外连接查询 outer join 左外连接：left outer join select * from 表一 left outer join 表二 on 表一.主键=表二.外键 左外连接，以左表为主，左表中数据都会有 右外连接：right outer join select * from 表一 right outer join 表二 on 表一.主键=表二.外键 右外连接，以右表为主，右表中数据都会有 子查询一个查询的结果，做另一个查询的一部分 12SELECT * FROM products WHERE category_id IN (SELECT cid FROM category WHERE cname IN('化妆品'，'家电'))； SQL备份和恢复在SQLyog中，右击数据库进行导入和导出 三个知识点两个约束主键约束(primary key):只能有一个，值必须唯一且不能为空 自动增长约束（auto_increment):初始值唯一，若被设置为一个值后，下一个值从这个的基础上增加 删除表所有数据的两种方式 delete from 表名 所有记录被删除，但自增值不会重置 truncate table 表名 删除所有记录，并重置自增值 底层是先摧毁表，再重建 乱码问题 在DOS中查看utf8编码的数据库数据时会出现乱码问题，因为DOS默认的是gbk 解决方法 临时方案：set names gbk 临时的确告诉数据库我们用gbk来查询 永久方案：修改my.ini的配置文件，不建议 数据完整性添加数据完整性==添加表约束 实体完整性：对数据行的约束，比如主键约束，唯一约束 域完整性：对数据列的约束 引用完整性：外键约束（多表关系） 各种约束主键约束：primary key 保证该字段唯一并且不为空 123456789101112131415161718-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE，-- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;//创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid)//删除主键约束ALTER TABLE books DROP PRIMARY KEY; -- 因为只能有一个主键，所以无需加字段名 唯一约束：unique 保证该字段唯一，可以为null 123456789101112131415161718192021-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT UNIQUE, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT unique_bid UNIQUE(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid);-- 删除主键约束ALTER TABLE books DROP UNIQUE(约束名); -- /如果添加唯一约束时没起名字，默认是字段名 自动增长约束：auto_increment 把该字段的值交给数据库去维护，默认每次加一（这个字段必须是建，多为主键） 1234567891011121314151617181920-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY AUTO_INCREMENT, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY bid INT AUTO_CREMENT-- /字段名 类型 约束-- 删除主键约束ALTER TABLE books MODIFY bid INT; 非空约束：not null 被约束字段不可为空值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) NOT NULL, bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 默认约束：default 给字段添加一个默认值，如果添加记录时没赋值的话用默认值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) DEFAULT 'JAVA 入门', bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 多表操作双向看，两边都是一个记录对另一边多个记录，这是多对多，否则为一对多 一对多：两张表即可 多对多：需要一张中间表 12345678910111213141516171819-- 多对多建表，一张学生表，一张课程表，一张中间表，至少两个字段-- 创建三张表CREATE TABLE student&#123; sid INT PRIMARY KEY AUTO_INCREMENT, sname VARCHAR(20), sage INT&#125;CREATE TABLE course&#123; cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(20)&#125;CREATE TABLE student_course_item&#123; student_id INT&#125;-- 添加外键约束 核心ALTER TABLE student_course_item ADD CONSTRAINT item_student_fk FOREIGN KEY(student_id) REFENRENCE student (sid);ALTER TABLE student_course_item ADD CONSTRAINT item_course_fk FOREIGN KEY(course_id) REFENRENCE course (cid); 特例：有时候两张表内记录一对一，但字段过多，也会分成两张表]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用途正则表达式（regular expression，简称regex）：是一些用来匹配和处理文本的字符串 正则表达式通常被简称为模式，其实是一些由字符构成的字符串 这些字符可以是普通字符（纯文本）或元字符（有特殊含义的特殊字符） 匹配单个字符 . 匹配任何单个的字符 \ 对特殊字符进行转义 匹配一组字符[和] 定义字符集合 [0-9a-zA-Z] - 定义字符区间 0-9 a-z ^ 对字符集合进行取非匹配 [^0-9a-zA-Z] 元字符 空白字符 [\b] 回退（删除）一个字符 \f 换页符 \n 换行符 \r 回车符 \t 制表符（tab） \v 垂直制表符 \s 任何一个空白字符 [\f\n\r\t\v] \S 任何一个非空白字符 匹配数字 \d 任何一个数字 \D 任何一个非数字 匹配字母和数字 \w 任何一个字母，数字和下划线 \W 任何一个非字母，数字和下划线 进制 \x 十六进制 \0 八进制 POSIX字符串 [[:alnum:]] 数字字符 [[:alpha:]] 字母字符 [[:lower:]] 小写字母字符 [[:print:]] 可显示的字符 [[:blank:]] 空格(space)与定位字符 [[:punct:]] 除[[:cntrl:]]和[[:alnum:]]外 [[:cntrl:]] ASCII控制字符(0-31和127) [[:space:]] 空白(whitespace)字符 [[:upper:]] 大写字母字符 [[:digit:]] 数字字符 [[:graph:]] 非空格(nonspace)字符 [[:xdigit:]] 十六进制数字字符 重复匹配+ 给字符或字符集合作为后缀，表示匹配一个或多个字符或字符合集 * 给字符或字符集合作为后缀，表示匹配零个或多个字符或字符合集 {num1，num2} 精确重复次数 {6} {1,4} {3,} ? 给字符或字符集合作为后缀，表示匹配零个或一个字符或字符合集 前三个为贪婪型元字符，为了防止过度匹配，会在其后加个？变为懒惰型元字符 位置匹配\b 用来匹配单词的开始或结束（\w与非\w之间） 只匹配一个位置，而不匹配任何字符 \B 匹配一个前后都不是单词边界 \&lt; 单词开始 \&gt; 单词结束 ^ 字符串开始 $ 字符串结束 (?m) 分行匹配模式，必须写在模式最前面 子表达式(和) 字表达式可以多层嵌套 回溯引用：前后一致匹配\n 匹配前面第n个子表达式 $n 替换时使用匹配上一条查询中的第n个子表达式匹配到的内容 大小写转换（替换时使用） \E 结束\L或\U转换 \I 把下一个字符转换为小写 \L 把后面的字符转换为小写 \u 把下一个字符转换为大写 \U 把后面的字符转换为大写 前后查找都是只匹配但不消费 (?=字符) 正向前查找，匹配到指定字符，停止匹配 (?!字符) 正向前查找，匹配到不是指定字符的，停止匹配 (?&lt;=字符) 正向后查找，匹配到指定字符，停止匹配 (&lt;=字符) 负向后查找，匹配到不是指定字符，停止匹配 嵌入条件(?(n)regex) 如果前一个子表达式匹配到了则执行该正则 (?(前后查找)regex) 如果前后查找成功了则执行该正则]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2019%2F09%2F04%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git版本控制系统 记录版本信息（记录每一次的修改） 方便团队相互之间协作，共同开发 常用版本控制系统 svn/cvs：集中式版本控制系统 共用一个服务器，一旦出问题就全完了，保存差异 git：分布式版本控制系统 保存的是所有文件的快照，每个人本地都相当于一个服务器 Git安装这个网上很常见，自行参考网上教程 使用GitHub目的：托管项目代码工作区 -&gt; 暂存区 -&gt; 历史区 1.Git的全局配置123456789第一次安装完成git后，要在全局环境下配置基本信息：我是谁？$ git config -l 查看配置信息$ git config --global -l 查看全局配置信息配置全局信息，用户名和邮箱$ git config --global user.name 'xxx'$ git config --global user.email 'xxx@xx.xx'初始化ssh$ ssh-Keygon 先是确定保存路径，再是密码，三次回车即可在C:\Users\asus\.ssh用记事本打开id_ssh.pub,复制其中内容 2.创建仓库完成版本控制123456789101112131415161718192021222324252627282930创建本地git仓库$ git init会生成一个隐藏文件夹“.git”（这个文件夹很重要，暂存区和历史区以及一些其他数据都在里面存着）在本地编写完成代码后（在工作区），把一些文件提交到暂存区$ git add xxx 把某一个文件或者文件夹提交到暂存区$ git add . || git add A 把当前仓库中所有最新修改的文件都提交到暂存区$ git status 查看当前文件的状态（红色代表工作区，绿色代表暂存区，看不见东西代表所有东西都已提交到历史区）把暂存区内容提交到历史区$ git commit -m'描述信息'本地版本库回退$ git checkout -- 文件名 回到最近的一次add/commit时的状态$ git reset --hard/mixed/soft HEAD~num --hard 回退全部，包括HEAD，index，working tree --mixed 回退部分，包括HEAD，index --soft 只回退HEAD查看历史版本信息（历史记录）$ git log$ git reflog 包含回滚的信息 可以获得版本号差异比较$ git diff 比较工作区和暂存区$ git diff --cached 比较暂存区和本地库最近一次提交的区别$ git diff HEAD 比较工作区和本地库最近一次提交的区别分支操作$ git branch -d 分支名 删除分支$ git remote push 分支一：分支二 将分支一推给分支二$ git branch 查看现在有哪些分支$ git checkout 分支名 切换到分支$ git checkout -b 分支名 创建并切换到新分支 通过移动head指针来改变版本 一般多分支同时开发，然后由项目组长来分支合并 git小技巧 把一些暂时用不到的修改，暂存起来 GitHub一个网站（开源的代码管理平台），用户注册号，可以在自己账户下创建仓库，用来管理项目的源代码（源代码基于git传到仓库中） 我们所熟知的插件，类库，框架等都在这个平台上有托管，我们可以下载观看和研究源码等 settings用户设置 profile 修改自己的基本信息 account 作用修改用户名 security 可以改自己的密码 emails 私有仓库作为内部团队协作管理的项目 …… new repository -&gt; 填写信息，公私有都免费 -&gt; create repository public 公共开源 private 私有，作为内部团队项目 settings -&gt; 删除仓库 ​ -&gt; collaborators 设置协助开发人员，需对方同意邀请 code可以查看历史版本和分支信息 3.把本地仓库信息提交到远程仓库12345678910111213141516171819202122查看本地仓库和哪些远程仓库保持连接$ git remote -v让本地仓库和远程仓库创建一个连接 origin是随便起的一个名字，但一般都用这个$ git remote add origin [仓库地址]$ git remote rename old new 重命名解除关联信息$ git remote rm origin提交之前最好先拉取$ git pull origin master将本地代码提交到远程仓库（第一次需要输入用户名和密码）$ git push origin master将远程仓库代码拉取到本地$ git clone [远程仓库git地址] [别名，默认为仓库名，也可以起一个作为拉取后的文件夹名]/* *真实项目开发流程： * 1.组长或者负责人先创建中央仓库 * 2.小组成员基于$ git clone 把远程仓库及默认的内容克隆到本地（解决了三个事情：初始化一个 本地仓库“git init”，和对应的远程仓库也保持了关联“git remote add”，把远程仓库默认内人拉取到本地 “git pull” * 3.每个组员写自己的程序后，基于“git add/git commit”把自己修改的内容存放到历史区，然后通过 “git pull/git push”把本地信息和远程仓库信息保持同步即可（可能涉及冲突处理） */ NPMnode package manger:NODE模块管理工具，根据NPM我们可快速安装、卸载所需要的资源文件 区NODE官网：下载NODE重启支持版，安装NODE后，NPM也跟着安装了 基于npm是从npmjs.com平台下下载安装 123//在终端中检测安装是否成功，出现版本号即成功了node -vnpm -v 12345678910111213$ npm install xxx 把模块安装在当前项目中（node_modules）$ npm install xxx -g 把模块安装在全局环境中$ npm i xxx@1.0.0 安装指定版本号的模块$ npm view xx version &gt; xxx.version.json 查看某个模块的版本信息（输出到指定json文件中）$ npm init -y 初始化当前项目的配置依赖清单$ npm i xxx -save 把模块保存在清单生产依赖中$ npm i xxx --save-dev 把模块保存在清单开发依赖中$ npm install 跑环境，按照清单安装所需模块$ npm root -g 查看全局安装模块的目录$ npm -uninstall xxx$ npm -uninstall xxx -g 卸载安装过的模块]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F08%2F16%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[[TOC] ### 入门及环境搭建下载JDK进入Oracle官网，下载相应版本，最近下载好像都得注册个账号 下完按到所需目录，一般默认，一直下一步即可，完了设置一下环境变量 此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;编辑path，把bin目录路径加入 classpath也可以设置 在cmd中，输入java -version检查是否安装成功 javac 文件路径（编译，生成。class文件） java 文件名，不加后缀，运行 IDE选择 目前比较流行的是eclipse和IDEA，我更喜欢IDEA，熟练了快捷键和各种模板之后会用得很舒服 语言特点通过编译成统一的字节码，不同平台下载对应JVM来实现跨平台 完全面向对象，简单，高性能，分布式，多线程，健壮 JDK（用于开发）-&gt;JRE（运行环境）-&gt;JVM(依次包含) java SE 标准版，定位于个人计算机用户 java EE 企业版，定位于服务器端领域 java ME 微型版，定位于消费电子产品的应用 越高级语言越容易入门，但要精通还需沉下心来 数据类型和运算符注释单行，多行，文档注释 标识符的命名规则虽然不同语言之间会有细微区别，但为了便于编写，感觉大多数语言都推荐采用比较大众的规范 不可以是java关键字，并且大小写敏感 类名 大驼峰命名法 方法和变量 小驼峰命名法 常量 大写 数据类型向上隐士转换，向下需要显示加括号强转 基本数据类型（四类八种）byte(1) boolean(1) short(2) char(2)unicode字符集 int()4 float(4) long(8) double(8) 限制double小数点数 12DecimalFormat df = new DecimalFormat("0.00");df.format(total); string与基本类型转换 包装类的parse和tostring方法 引用数据类型string，数组，集合ArrayList，Scanner，Random，自定义类型 包的声明和访问包的本质就是文件夹，在包名中以.来区分上下级文件关系 作用：分类管理文件 包的声明：package 包名 指示某个类在哪个包下 包的声明必须和类的实际位置保持一致 包的导入：用来告诉编译器我们要用的类在哪个包下 import 包名.类名 不导包时需采用全限定类名：包名.类名（所有用到类名的地方都需这样写） 四种访问权限修饰符 面向对象面向对象是一种编程思想，是相当于面向过程的 面向过程：遇到问题，亲力亲为一步一步解决 核心理念：谁的功能谁负责 面向对象：遇到一个问题，找具有解决这个问题能力的对象，调用它的方法 面向对象三大特性：封装（安全性），继承（拓展性），多态（） 类的格式 1234567public class 类名&#123; //构造方法 //成员类名 //成员方法&#125;//一个标准的类 封装：隐藏细节，对外暴露公共防蚊1方式 构造：无参必须有，全参最好有//类名作为方法参数或返回值时需要传入或返回的应该是该类的对象 继承继承是两个类之间的关系，子类继承父类 this关键字区分局部变量和成员变量同名的情况 this的本质：实际上是个对象 谁调用的方法，this指的就是谁 匿名对象：（可用可不用） 没有名字的对象 只创建对象，但不用变量接收 在一些用来传参后续不调用时使用 特点：匿名对象也是一个对象，具有对象所有功能 ​ 每次调用都是一个新的对象，所一每个对象只能使用一次 123this.xxx //调用该对象属性this.aaa() //调用该对象方法//高级使用：用来调用本类的其他构造 通过输入不同参数来调用不同构造 super关键字区分子类和父类成员同名的情况，但默认优先调用子类 1234super.xxx //调用父类属性super.aaa() //调用父类方法super(); //调用父类构造方法，通过输入不同参数来调用不同构造，默认调用无参构造//无论调用子类那个构造，都会先调用父类构造，符合单一职责原则，一个类只需负责给本类变量初始化 继承12345678910111213public class 子类 extends 父类&#123; &#125;//继承必须合理 人是人他妈生的，妖是妖他妈生的//继承中的成员抽取了子类中的共性内容//子类会自动继承父类中所有成员，但private不可访问//创建子类对象时会先创建其父类对象//继承后成员变量不同时，没有任何问题，相同时优先访问子类//继承后成员方法不同时，没有任何问题，相同时(子类重写了父类方法时)优先访问子类，但可以通过super.方法名访问//只能单继承，但可以多层继承（直接父类唯一，但可以有多个间接父类）//多继承的话调用方法时会产生不确定性，同名父类成员不知道该掉哪个 继承大大提高代码重用性 方法的重载：在同一个类中，方法名相同，但参数列表不同（参数类型，参数顺序，参数个数任一不同） 方法的重写（覆盖，覆写override）：子类中出现了和父类一模一样的方法 重写原因：当子类发现继承过来的方法不适用时需要重写自己的方法 重写要求：该方法子类权限需大于等于父类权限（一般都是相同权限） public protected default private private方法不可重写 方法名，参数列表，返回值类型必须一模一样 多态一个对象的多种状态 java中的前提：必须有字符类关系，必须有方法的重写 抽象类和接口抽象类：以前一个类中包含抽象方法即为抽象类，现在只要由关键字abstract修饰即为抽象类 抽象类不可以实例化，天生就是作为父类的 抽象方法：只有声明而没有实现 向上抽取时会出现一种特殊情况，方法功能声明相同，但方法主体不同，这时只抽取方法声明，所得即为抽象方法 必须用关键字abstract修饰 不能调用，为了强制子类去重写 类名作为返回值或参数时，传递和返回的应是该类对象 抽象类作为返回值或参数时，传递和返回的应是该类的子类的对象 链式编程：当返回值为调用这个方法的对象时，便可以链式的调用下去 小练习 12//案例：武警开坦克打飞机//名词提取：武警 坦克 飞机 再分析每个类对应属性和方法 接口类：一堆具有共同属性和成员方法的对象的集合 接口：方法的集合，只能定义抽象方法 天生作为父接口 12345678910111213//class 类//abstract class 抽象类//interface 接口//enum 枚举public interface 接口名&#123; //不能定义普通成员变量，只能定义抽象方法 //可以定义常量 public static final 变量名 即使不加修饰，编译器也会自动添加&#125;//开发中常用模式：一个类继承一个抽象类，实现多个接口public class A extends AbstractClass B implements 接口A，接口B&#123; &#125; 类与类之间是单继承，一个子类只能有一个直接父类 接口与接口之间支持多继承也支持多层继承 类与接口之间不叫继承（extends）而是实现（implements） 可以多实现 比较抽象类和接口 相同点：都不能实例化，都是作为父类/父接口，子类继承/实现都不行重写抽象方法 不同点：抽象类中不全是抽象方法，可以有普通成员变量，修饰的关键字不同 弥补了java的单继承 思想上的区别：抽象类中必须定义整个体系的共性内容 ​ 接口中定义整个继承体系之外额外的扩展功能（谁想有这些功能就来是实现下这个接口） 优先使用接口 需要定义子类行为又要为子类提供共性功能时才用抽象类 多态父类类型 变量名 = new 子类类型(); 父类类型变量指向了子类对象 注意事项：多态使用变量是，编译和运行都看父类 调用成员方法，编译看父类，运行看子类 多态的弊端：只能调用子父类共有的方法，不能调用子类特有的（因为编译时看父类，特有的编译过不了） 好处：提高灵活性，父类可以接收任何一个子类对象 传哪个子类运行哪个子类的方法 1234//弊端解决方案//向下转型：强制类型转换 double转int，父类转之类 把向下和强转关联记忆吧//向上转型:隐式类型转换 子类转父类（多态） 向下转换会面临不知道该转成哪个子类的困扰，易出现类型转换异常//向下转型弊端解决：instanceof 格式：boolean b = 父类对象名 instanceof 子类对象名 内部类 成员内部类：定义类中方法外 在其他类中创建对象 外部类名.内部类名 对象名 = new 外部类名().new 内部类(); 局部内部类：定义方法中 在其他类中无法使用，只能局部使用 匿名内部类一种特殊的语法，用于快速创建抽象类的对象 12345678910111213141516//创建抽闲类对象//创建子类继承抽象类 重写抽象方法 new子类对象//用匿名内部类可以一步完成new 抽象类名()&#123; //重写方法&#125;;new 抽象类名()&#123; //重写方法&#125;.调用属性/方法;//最常用抽象类名 对象名 = new 抽象类名()&#123; //重写方法&#125;;//只重写抽象方法而不写独有的方法，因为没有名字，即使写了也无法向下强转为子类调用 静态代码块12345678public class 类名&#123; static&#123; //当我们使用到这个类的时候（实例化或使用静态成员等等），JVM会自动执行静态代码块中的内容 //仅在第一次使用到这个类的时候会执行一次，第二次就不会了 //优先级高于main和构造方法 //用于初始化类，比如MySQL加载驱动等 &#125;&#125; 访问修饰符static 静态的用于修饰类中的成员 被static修饰的成员访问时无需实例化再调用，可以直接通过类名访问（推荐） 当一个对象不独属于某个成员，而是所有成员共享事应加static修饰 静态没有多态性，静态属于类，而多态属于对象 多态调用静态成员时没有多态性（访问的是父类而非子类） 静态优先于对象存在 final 最终的可以修饰类，成员变量，成员方法，局部变量（基本类型，引用类型） 通过最终来理解这些性质 final修饰类——最终类：不能被继承，但可以有父类（太监类） final修饰成员变量：该变量必需在被实例化前赋值，且只能赋值一次 final修饰成员方法：该方法不能被子类重写 final修饰的基本类型局部变量只能赋值一次 final修饰的引用类型局部变量只能赋值一次，但其所指向的对象的内容可以随意改变 类中各种成员的初始化的顺序 1.如果类中存在继承关系(像 Son 继承 Father) 则首先会初始化导出类(Son)的基类(Father)，然后再是导出类 2.在基类首先会初始化静态 的东西 静态代码块&gt;静态变量 而且只初始化一次 （因为静态的东西都是跟着类的加载而加载的） 3.随后就是初始化导出类的静态东西 跟基类的静态初始化一样（同上） 4.初始化基类无参构造器（调用有参就初始化有参构造器） 5.初始化导出类无参构造器（注意：导出类的成员变量和代码块都是是比构造函数的初始化要早。。看输出结果可知）可知） object类是类层次的根类，所有类都直接或间接继承 12345//两个重要方法boolean equals(Object obj); //obj中定义的是根据地址计算出的hashcode //string类中重写了，改为比较字符串内容,我们自己定义类也一般会重写String toString(Object obj) //返回该对象的字符串表示 默认包名.类名@hashcode(地址) //system.out 打印对象会默认调用tostring 我们一般会重写这个方法 异常java代码编译或执行过程中出现的一些问题 异常的继承体系 Throwable：可以抛出去的东西 Exception：异常（普通问题） 编译时异常：Exception及其子类（RuntimeException除外） 运行时异常：RuntimeException及其子类 Errow：错误（严重的问题） 异常处理方式异常处理：异常处理指的是一种可能性，只有当出现了异常时才会执行异常处理代码，否则正常执行 异常处理方式 不处理 throw：动词，真正的抛出一个异常 throws：形容词，用来形容一个方法，表示该方法可能抛出的异常 要求调用者去处理它 public void 方法名（参数）throws 可能抛出的异常类型{ } 捕获处理 try(){ ​ 可能出现异常的代码 }catch(对应类型的异常对象){ ​ //catch可以有多个 ​ //处理异常 }finally{ ​ //写上必须要执行的代码，比如释放资源等 } 一次捕获多次处理: 一个try 多个catch (多个catch中 必须是异常子类在前,父类在后) 多次捕获多次处理: 多个try,每个try多应一个catch 一次捕获一次处理(最常用的):一个try一个catch(catch中异常类必须所有可能出现异常的父类) 注意事项：子类异常必须从属于父类异常 技巧: 如何区分一个异常类 到底是编译时还是运行时异常 1.编译时异常 在编译的时候会报错的 (需要我们去处理) 2.运行时异常 在编译的时候不会报错 只要定义一个方法,在方法中抛出一个异常对象,如果编译报错那么就是编译时异常 如果编译成功,那么就是运行时异常 请你说出十个运行时异常: 1.RuntimeException 2.ClassCastException:类型转换异常 (向下转型的时候) 3.ArrayIndexOutOfBoundsException:数组下标越界 4.StringIndexOutOfBoundsException:字符串下标越界 5.NullPointerException:空指针异常 自定义异常类： 1.创建一个类,这个类必须用Exception结尾 2.必须继承 Exception 或者 RumtimeException 3.自定义的异常 至少有两个构造 a.空参数构造 b.带有String类型参数的构造 12345678910package com.itheima.demo09_自定义异常的练习;public class NoSuchAgeException extends Exception&#123; //无参构造 public NoSuchAgeException()&#123;&#125; //带有String的构造 内部调用super(s)，将传入的string交给父类 public NoSuchAgeException(String s)&#123; super(s); &#125;&#125; Date类Date类:日期类 多数方法都过时了，不常用 标准时间1970年1月1日0时0分0秒 构造: public Date();//代表当前系统时间的Date对象 public Date(long time);//代表距离标准时间 time毫秒值的Date对象 成员方法: public String toString();//Date 重写Object类的toString方法 public long getTime();//获取当前Date对象的毫米值 与public Date(long time)互逆 DateFormat:日期格式化类,是一个抽象类 具体的子类:SimpleDateFormat 构造: public SimpleDateFormat(String pattern);//以指定的模式创建格式化对象 123&gt; SimpleDateFormat sdf = new SimpleDateFormat(yyyy年MM月dd日HH时mm分ss秒);&gt; &gt; 成员方法: public String format(Date d);//把date对象按照指定的模式 转成字符串 public Date parse(String s);//把字符串转成Date对象,如果字符串有问题,就会抛出ParseException Calendar:日历类获取Calendar对象 public static Calendar getInstance();//返回的是抽象类Calendar的某一个子类 成员方法: public int get(int field);//获取指定字段的值 public void add(int field,int amount);//给指定的字段增加值 public void set(int field,int value);//修改指定字段的值 public Date getTime();//把Calendar对象转成Date 对象 getTime().getTime() 相当于调用date的方法来获取毫秒值 System:系统类该类无法思力华，被私有化了 public static void exit(0);//结束JVM public static void gc();//通知垃圾回收器过来收垃圾，只是通知，不一定会来 public static getProperty(String key);//根据键 获取值 public static long currentTimeMillis();//获取当前系统的毫秒值 Math:数学类都是些静态方法，直接调用就好 求最大值 max 求最小值 min 求绝对值 abs 求随机数 random 返回一个[0,1)之间的数，通过简单计算得到自己想要的范围 求四舍五入 ceil(向上取整) floor(向下取整) pow(求次幂) 基类数据类型包装类八种基本类对应的包装类型 byte boolean short char int float double long Byte Boolean Short Character Interger Float Double Long 作用 在集合中只允许存储包装类型，不可以存基本类型 实现字符串的转换 public static int parseInt(String s); 将字符串转为int，其它基本类型类比即可 自动拆箱装箱 装箱：基本类型-&gt;包装类型 拆箱：包装类型-&gt;基本类型 哪些数据类型 重写了toString() 1.String类 2.保存数据的引用类型 (Integer,Double…,集合,map) 3.自定义类 可以重写toString 正则表达式所有编程语言都支持，用来匹配字符串的 boolean b = 普通字符串 匹配 正则表达式 public boolean matches(String regex); boolean b = “普通字符串”.matches(“正则表达式”); public String[] split(String regex); 切割字符串,返回切割后的字符串数组 书写技巧：一位一位的匹配 通配符 正则表达式中 “.”代表任意字符 在DOS中 “*”代表任意内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * QQ号码需要满足的规则: * 1.必须是0-9的数字 * 2.开头必须1-9中的一个数字 * 3.位数必须 5-12位 */public static void qq()&#123; String qq = "12355a63564"; boolean b = qq.matches("[1-9][0-9]&#123;4,11&#125;"); System.out.println(b);&#125;/* * 举例：校验手机号码 * 1：要求为11位0-9的数字 * 2：第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。 */public static void phone()&#123; String phone = "18600363521"; boolean b = phone.matches("1[34578][0-9]&#123;9&#125;"); System.out.println(b);&#125;/* * * 案例:切割电话 */public static void split01()&#123; String phone = "2345--4564----6546-----1345"; //切割phone 把号码切割出来 //+号 在正则表达式中有特殊意义,表示连续的多个相同的字符 String[] phones = phone.split("-+"); for (int i = 0; i &lt; phones.length; i++) &#123; System.out.println(phones[i]); &#125;&#125;/* * 案例:切割ip */public static void split02()&#123; String ip = "192...168....123......110"; //"."号 在正则表达式中 表示 任意字符 //转译字符 //\t //\n String[] ips = ip.split("\\.+");//在正则表达式中 "\\" 代表一个"\" System.out.println(ips.length); for (int i = 0; i &lt; ips.length; i++) &#123; System.out.println(ips[i]); &#125;&#125; String中的方法（4532）判断方法1234boolean equals(String str);boolean equalsIngoreCase(String str);boolean startsWith(String str);boolean endsWith(String str); 获取方法12345int length(String str);char charAt(int index);String substring(int startIndex);String substring(int startIndex,int endIndex); //左闭右开int indexof(String subStr); //少用 转换方法123String toLowerCase()；String toUpperCase()；char[] toCharArray()； 其它方法12String trim(); //去掉两端空格String[] split(String str); //一某一个字符串来分割字符串 集合集合框架: List–&gt; ArrayList,LinkedList,Vector Set –&gt; HashSet,LinkedHashSet,TreeSet Collection接口中的公共方法:子类不是都有下标，所有Collection无下标，故而无法进行改查操作 增: add(E e); 删: remove(Object obj); 改: 无 查: 无 其他: int size();//长度 boolean contains(Object obj); void clear();//清空 Object[] toArray(); //集合转换成数组 在ArrayList中 有一个方法 addAll(Collection c);//把集合c里面的每一个元素添加到ArrayList中 迭代器在Collection根解扣子中定义一种公共的遍历方式:迭代器遍历 Iterator&lt;泛型和集合的一样&gt; it = 集合对象.iterator(); 底层类似链表 迭代器对象 有两个方法: hasNext();//判断有没有下一个 next();//取出下一个 以上两个方法必须配合使用 补充 Concurrent(并发)Modification(修改)Exception java规定,如果一个集合使用迭代器遍历,那么在遍历的过程中 不允许修改集合的长度(增加或者删除) 123456789101112131415//1.创建一个集合对象,使用多态Collection&lt;String&gt; names = new ArrayList&lt;String&gt;();//2.添加names.add("郭德纲");names.add("刘德华");names.add("柳岩");names.add("范伟");names.add("范伟1");//3.获取names集合的迭代器对象Iterator&lt;String&gt; it = names.iterator();//4.标准代码while(it.hasNext())&#123;//反复判断有没有下一个元素 String s = it.next();//如果有取出下一个元素 System.out.println(s);&#125; 增强for循环增强for循环比普通的for循环增强在哪? 增强在语法上更加简单 格式: for(数据类型 变量名:数组/集合){ syso(变量名); } 注意: 当你使用增强for循环遍历集合的时候 底层采用的是迭代器 总结: 当你使用增强for循环遍历集合的时候,不能修改集合的长度 泛型泛泛的类型,不确定的类型，类型参数化 格式: ,&lt;K,V&gt; 好处 避免了强制类型转换 将运行时的ClassCsatException变为了编译错误 泛型通配符 ?:代表任意类型 &lt;? extends Animal&gt; : 表示一种泛型,这种泛型必须是Animal 或者Animal的子类 &lt;? super Animal&gt;:表示一种泛型,这种泛型必须是Animal 或者Animal的父类 泛型可以用在类上，方法上，接口上 泛型用在类上: 泛型类 格式:public class 类名 当你创建该类的对象的时候,就可以确定 泛型用在方法上:泛型方法 格式:public 返回值类型 方法名(T t); 当你调用方法,传递参数的时候确定 泛型用在接口上:泛型接口 格式:public interface 接口名 1.实现类实现接口的时候,直接确定 2.实现类实现接口的时候,不确定泛型,而是直接把泛型继承下来,当这个实现类创建对象的时候确定 堆栈和队列 数组和链表 list接口List接口的特点: a.有下标 b.有序的(有序不是自然顺序,不是123,abc,有序指的是存和取的顺序一致) c.可重复 实现类:ArrayList,LinkedList,Vector ArrayList:底层采用数组结构,查询快,增删慢 LinkedList:底层采用链表结构,查询慢,增删快 Vector:底层采用数组结构,查询快,增删慢（基本不用） List结构中具有的方法: 增: add(E e);add(int index,E e); 删: remove(Object obj);remove(int index); 改: set(int index,E e); 查: get(int index); 其他: size(),clear(),contains(Object obj),toArray() iterator();isEmpty() 实现类的方法: 1.ArrayList:方法基本和List中定义的一模一样 2.LinkedList:除了和List接口中一样的方法之外 LinkedList提供了大量首位操作的方法 第一组: void addFirst(E e); void addLast(E e); 第二组: E removeFirst();//删除首个元素,返回被删除的元素 E removeLast();//删除尾部元素,返回被删除的元素 第三组: E getFirst(); E getLast(); 第四组: E pop();//弹出,删除集合中的某一个元素,和 removeFirst功能是一样的 void push(E e);//推入,把一个元素添加到集合中, 和addFist功能是一样的 set接口Set接口的特点: a.无下标 b.无序的(无序指的是存和取的顺序不一定一致,LinkedHashSet和TreeSet除外) c.不可重复 实现类:HashSet,LinkedHashSet,TreeSet HashSet:底层采用哈希表结构,查询快,增删快,无序的 LinkedHashSet:底层采用 链表+哈希表,查询快,增删快,有序的 Set接口中的特有方法: 没有,和父接口Collection基本一模一样 实现类:HashSet和LinkedHashSet中的方法基本和Set接口一模一样 对象的哈希值: 任何对象,都有一个哈希值,哈希值是对象的一个数字表示 对象的字符串表示,toString方法,默认表示格式:包名.类名@地址值 如果获取对象的哈希值? 每一个对象都有一个方法,hashCode方法,这方法定义在了Object类中,所以每个对象都具有 我们以前说的地址值,实际上根本不是地址值,而是哈希值的16进制 在java中怎么看真正地址值? 看不了 哈希值的由来 是由真正的地址值计算的,通过一种散列算法(哈希算法) 所以 一般来说 地址值 不一样, 哈希值也是不一样的 不可逆算法(MD5,WPA2) 碰撞算法(一个一个试) 暴力破解&amp;字典破解(破解wifi教程) 字符串的哈希值: 由于String类重写了HashCode 那么哈希值不在通过地址值计算 我们观察源码,发现通过字符串的内容计算,所以只要字符串内容相同,哈希值必定相同 思考: 只要字符串内容一样,哈希值 必定一样 两个字符串的内容不一样,哈希值可能一样 比如: abc 和 acD 哈希表结构: 数组结构+链表结构的组合,查询快,增删快 HashSet:采用了哈希表结构 LinkedHashSet:采用了链表+哈希表结构 哈希表结构,判断元素是否重复的原理: 1.先判断 新元素的哈希值 和 所有旧元素的哈希值是否相同 如果都不相同,直接判断不重复,添加 2.再调用 新元素 和 哈希值相同的旧元素的equals方法 如果返回是true 判定重复元素 ,不添加 如果返回是false 判定不重复,添加 总结: 只有哈希值相同,并且equals返回true,才判定重复 判断元素重复不重复的原理: 1 比较哈希值 2 调用equals方法 只有 哈希值相同,并且equals方法true,才是重复元素,才不存储 contains方法,判断是否包含某一个元素 ArrayList的contains方法: names.contains(“abc”);//判断 names集合中是否包含 “abc” 只比较 equals的返回值,如果某一个元素和要判断的元素equals方法true,那么就是包含该元素 HashSet的contains方法: set.contains(“abc”);// 先判断哈希值 再使用equals方法 只有旧元素和判断的元素 的哈希值相同 并且 euqals方法true 才判定包含 使用HashSet存储自定义元素(Dog对象) 结论: 如果我们自定义了类 要使用HashSet存储 如何保证元素的唯一性: 必须重写自定义类的两个方法,hashCode和equals 定义一个标准的类: 1.封装(private+get/set) 2.构造(无参+全参) 3.toString(快速打印对象信息) 4.hashCode和equals(保证元素使用哈希表结构存储时的唯一性) MapMap集合的特点: 1.Map集合 和 Collection集合 没有继承关系,所以不能直接用迭代器 2.Collection集合 每一个元素都是单独存在 Map集合的每一个元素都是成对存在的 3.Collection一个泛型 Map&lt;K,V&gt;两个泛型, K代表键的类型,V代表值的类型 K,V可以相同 也可以不同,必须都是引用类型 4.在Map集合的元素中,键是唯一的,值是可以重复的 5.常用的实现类: HashMap:无序 底层哈希表结构,保证键的唯一性,需要重写键对应类的hashCode和equals方法 LinkedHashMap:有序 底层哈希表结构+链表,哈希表保证键的唯一,链表保证元素的有序 需要重写键对应类的hashCode和equals方法 Map&lt;K,V&gt;集合常用的方法: 增: V put(K key,V value);//向集合中添加键值对 //如果集合中已存在该键,覆盖整个键值对,并返回被覆盖的键值对的值 删: V remove(OBject key);//根据键 从map集合中删除 键值对,返回值表示被删除的键值对的值 改: 隐藏到了put方法 查: V get(K key);//根据键 从map集合中找到唯一对应的值 Map集合第一种遍历方法:以键找值 1.先获取map集合的键的集合,这个集合是一个Set集合 Set keys = map集合.keySet(); 2.遍历keys集合 a.foreach b.迭代器 3.在遍历的过程中,从map集合获取键对应的值 123456789101112//3.获取map的键的集合Set&lt;String&gt; keys = map.keySet();//4.遍历keys这个集合,获取到每一个键//4.1迭代器遍历Iterator&lt;String&gt; it = keys.iterator();while(it.hasNext())&#123; String key = it.next(); //根据key 从map集合中查找 对应值 String value = map.get(key); //打印 System.out.println(key+":"+value);&#125; map集合第二种遍历 ：键值对遍历 1.获取map集合中所有 结婚证对象 Set&lt;Map.Entry&lt;K,V&gt;&gt; set = map集合.entrySet(); 2.遍历这个set集合,获取每一个Map.Entry类型的对象 a.迭代器 b.foreach 3.获取到 Map.Entry类型的对象之后 K key = entry.getKey(); V value = entry.getValue(); 1234567891011//3.获取所有键值对关系对象的集合Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();//4.遍历 这个entry集合, 拿出每一个结婚证对象//使用迭代器遍历Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = entrySet.iterator();while(it.hasNext())&#123; Map.Entry&lt;String, String&gt; entry = it.next(); //获取这个entry中的 键和值 String key = entry.getKey(); String value = entry.getValue(); System.out.println(key+"="+value); 回顾：内部类和内部接口 内部类: 一个类A,定义在另外一个类B 的内部,这个类A 这个类被称为内部类 OuterClass.InnerClass ic = new OuterClass().new InnerClass(); 内部接口: 一个接口A,定义在另外一个接口B的内部,这个接口A, 这个接口A被称为内部接口 class Class2 implements OuterInter.InnerInter 只重写内部类中的方法即可 使用map存储自定义类型使用map存储:键为学号,值为一个学生的对象, 学生对象有属性（姓名，年龄） 使用map存储:键为学生（姓名，年龄）值为学生自己的家庭住址。 结论: 如果Map中的键是自定义类型,那么要保证键的唯一性,必须重写键对应类的hashCode和equals方法 Properties属性集在开发中Map集合可能用到,但是Properties属性集,1000%会用到 Properties类到底是什么?属性集, class Propeties extends HashTable implements Map 所以:Properties本质上 就是一个Map集合 Properties是一个持久的属性集 所谓持久 就是 它具有自己写数据到文件的方法 Properties是没有泛型,泛型是固定,String 和 String Properties类,具有Map接口的一切方法 还有具有一些自己特有的方法: public String getProperty(String key)用指定的键在此属性列表中搜索属性的值,功能和Map中的get是一样 public Object setProperty(String key, String value);添加键值对,功能和Map的put方法是一样 public Set stringPropertyNames()://和Map中的keySet方法是一样 Properties具有持久化到文件的功能 store();//保存数据到文件,实际上不是保存到文件 而是写入到流中,由流写到文件 load();//从文件中加载数据,实际上不是直接加载文件,而是加载流中的数据,而流的数据是从该文件中读取的 12345678910111213141516171819202122232425262728293031323334353637383940public class PropertiesDemo &#123; public static void main(String[] args) throws IOException &#123; //和Properties持久化有关的方法 Properties ps = new Properties(); //从文件中读取数据 ps.load(new FileReader("phones.properties")); System.out.println(ps); &#125; //Properties持久化数据到文件中 public static void writePs() throws IOException&#123; //1.定义Properties Properties ps = new Properties(); ps.setProperty("iphoneX", "8888"); ps.setProperty("xiaomiMix", "3888"); ps.setProperty("huaweiMate11", "6888"); ps.setProperty("vivoX20", "1888"); //2.把ps的数据持久化到文件中 ps.store(new FileWriter("phones.properties"), ""); &#125; public static void demo01()&#123; // TODO Auto-generated method stub //1.创建一个Properties对象 Properties ps = new Properties(); //2.添加数据 ps.setProperty("张三", "18"); ps.setProperty("李四", "28"); ps.setProperty("王五", "38"); ps.setProperty("前妻", "48"); //3.遍历 //1.stringPropertyNames 就是keySet Set&lt;String&gt; propertyNames = ps.stringPropertyNames(); //4.遍历 for (String propertyName : propertyNames) &#123; //根据属性名 propertyName获取属性值 String propertyValue = ps.getProperty(propertyName); System.out.println(propertyName+"="+propertyValue); &#125; &#125;&#125; 小知识点可变参数说的不是参数类型可变,而是参数的个数可以变化 语法: JDK1.5 出现新特性 public 返回值类型 方法名(数据类型… 参数名){} 注意: 1.可变参数只是参数的个数是任意个,参数的类型不能改变 2.一个方法中 只能有一个可变参数 3.当一个方法中有多个参数,并且有一个是可变参数的时候,要求这个可变参数必须在最后 可变参数的本质: 就是一个数组 Collections中的静态方法: public static void shuffle(List list);//打乱顺序 public static void sort(List list);//把集合元素按照自然顺序(123,abc)排序 Arrays:数组工具类 public static List asList(数组/可变参数);//把一个数组 转成List集合 public static void sort(数组);//排序数组 public static String toString(数组);//把数组转成字符串 递归 递归:是一个通用技术,所有的编程语言,只要有方法概念的编程语言都具有递归 什么叫递归:在一个方法的内部,再调用方法本身 无限递归本身是错误的:因为方法运行需要进栈,而栈空间不是无限大的 使用递归的前提****: 1.必须有一个可以是递归结束的出口 2.递归的次数,不能太多(具体的次数不好确定,与内存,CPU…都有关) 我们建议在开发中 能不用递归 就是不要用 急剧消耗内存(最常见是杀毒软件 扫描硬盘) 递归的其他分类: 直接递归: 在A方法的内部 直接调用A方法 123456789101112131415161718192021222324&gt; //定义一个方法,求1-n的和 先想一下基于n-1步如何解决&gt; public static int getSum(int n)&#123;&gt; //1+2+3...n = (1+2+3..n-1)+n&gt; if(n==1)&#123;&gt; return 1;&gt; &#125;&gt; return getSum(n-1)+n;&gt; &#125;&gt; &gt; //求1-n的和 常用&gt; public static int getSum(int n)&#123;&gt; int sum = 0;&gt; for (int i = 1; i &lt;= n; i++) &#123;&gt; sum+=i;&gt; &#125;&gt; return sum;&gt; &#125;&gt; private static int getSum2(int n) &#123;&gt; if (n == 1) &#123;&gt; return 1;&gt; &#125;&gt; return getSum2(n - 2) + n;&gt; &#125;&gt; 间接递归: 在A方法的内部调用B方法,在B方法的内部调用C方法,在C方法的内部调用A方法 1234567891011121314151617181920212223242526272829&gt; package com.guardwarm.递归;&gt; &gt; import java.util.Scanner;&gt; &gt; //定义方法 求 n个式子的和&gt; //n=5&gt; //1+(1+2)+(1+2+3)+(1+2+3+4)+(1+2+3+4+5)&gt; public class undirectDiGui &#123;&gt; public static void main(String[] args) &#123;&gt; System.out.println("please enter a num");&gt; Scanner scan = new Scanner(System.in);&gt; int n = scan.nextInt();&gt; int sum = getsum(n);&gt; System.out.println(sum);&gt; &#125;&gt; public static int getsum(int n)&#123;&gt; if(n == 1)&gt; return 1;&gt; return getsum(n-1)+zigetsum(n);&gt; &#125;&gt; public static int zigetsum(int n)&#123;&gt; if(n == 1)&gt; return 1;&gt; return zigetsum(n-1)+n;&gt; &#125;&gt; &#125;&gt; &gt; &gt; 斗地主案例案例分析 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.guardwarm.斗地主;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedHashMap;import java.util.Map;/* * 斗地主步骤: * * 1.创建编号和牌对应的map集合 * * 2.准备一副牌(54个数字1-54) * * 3.洗牌 * * 4.发牌 * * 5.排序 * * 6.从map集合查找 * * 7.看牌 */public class doudizhuMapDemo &#123; public static void main(String[] args) &#123; //准备一副牌 Map&lt;Integer,String&gt; allcard = new LinkedHashMap&lt;Integer, String&gt;(); ArrayList&lt;Integer&gt; cards = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p2 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; p3 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; dp = new ArrayList&lt;Integer&gt;(); int id = 1; String[] colors = &#123;"♠","♥","♣","♦"&#125;; String[] nums = &#123;"3","4","5","6","7","8","9","10","J","Q","K","A","2"&#125;; for(String num : nums)&#123; for(String color : colors)&#123; String card = num+ color; allcard.put(id,card); cards.add(id); id++; &#125; &#125; allcard.put(id,"大S"); cards.add(id); id++; allcard.put(id,"小S"); cards.add(id); id++; Collections.shuffle(cards); //测试// System.out.println(cards); for (int i = 0; i &lt; cards.size(); ++i) &#123; Integer cd = cards.get(i); if (i &gt;= 51) &#123; dp.add(cd); &#125; else if (i % 3 == 0) &#123; p1.add(cd); &#125; else if (i % 3 == 1) &#123; p2.add(cd); &#125; else if (i % 3 == 2) &#123; p3.add(cd); &#125; &#125; Collections.sort(p1); Collections.sort(p2); Collections.sort(p3); Collections.sort(dp); /* System.out.println(p1); System.out.println(p2); System.out.println(p3); System.out.println(dp);*/ outputcard(p1,allcard); outputcard(p2,allcard); outputcard(p3,allcard); outputcard(dp,allcard); /* Collections.sort(cards); System.out.println(cards);*/ &#125; private static void outputcard(ArrayList&lt;Integer&gt; ls,Map&lt;Integer,String&gt; map)&#123; for(Integer cardid:ls)&#123; String card = map.get(cardid); System.out.print(card+" "); &#125; System.out.println(); &#125;&#125; IO流_读写文件（输入输出是相对程序而言的） 输出流：数据从java程序到文件中 123456//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)write(int ch); //可以写ascll码值write(char[] ch);write(char[] ch,int startIndex,int len);write(String s);write(String s,int startIndex,int len); 输入流：数据从文件到java程序 123//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)int read(); //读取一个字符int read(char[] chs); //读取一个字符数组，返回值表示读取到的字符个数 File类:描述:文件和 目录路径名的抽象表示 文件:可以直接保存数据 目录路径名:文件夹,分类管理文件 结论:File类可以表示文件 也可以表示文件夹 构造: public File(String filepath); 绝对路径:以盘符开头的路径 相对路径:相对当前项目的根目录 File对象的获取方法: 1.public String getAbsolutePath();//获取绝对路径 2.public String getName()//获取当前File对象的名字 3.public String getPath();//获取创建File对象时 传递的路径 4.public long length();//获取表示文件的File对象的占用的字节数,如果是文件夹的File对象,返回值不确定 File对象的删除和创建方法: 1.创建方法: 创建文件: public boolean createNewFile();//创建一个新的文件(只能是文件,不能是文件夹),返回是否创建成功 创建文件夹 public boolean mkdir();//创建一个新的文件夹,返回是否创建成功 public boolean mkdirs();//可以一次性创建多层文件夹 2.判断方法: 判断是否是文件 public boolean isFile();//返回是否是文件 判断是否是文件夹 public boolean isDirectory();//返回是否是文件夹 判断文件或者文件夹是否存在,是前面两个前提 public boolean exists();//返回该File 对象是否存在 3.删除方法: public boolean delete();//删除文件或者文件夹 可以删除的是单个文件,或者空文件夹 File类的list和listFiles方法 1.public String[] list(); 2.public File[] listFiles(); 注意: 只能列出当前文件夹下的一级子文件或者子文件夹，那个对象必须存在且是文件夹才可以调用 案例：使用递归遍历使用文件夹 1234567891011121314151617181920212223242526272829303132333435/* * 使用递归遍历 一个文件夹aaa下的所有文件(包括一级的也包括n级文件) * * 1.定义方法,遍历一个文件夹下的所有文件 * * 2.在方法中判断 某一个File对象 ,如果是文件 直接打印 * 如果不是文件,递归调用第1步定义的方法 * */public class DiguiDemo &#123; public static void main(String[] args) &#123; //1.创建aaa文件夹的File 对象 File aaa = new File("C:\\Users\\yingpeng\\Desktop\\aaa"); //2.调用方法 列出 aaa下的所有文件 printFiles(aaa); &#125; //定义一个方法:列出一个文件夹下的文件 public static void printFiles(File objFileDir)&#123; //2.列出aaa文件夹下的所有File 对象 File[] files = objFileDir.listFiles(); for (File file : files) &#123; //判断是否是文件 或者 文件夹 if(file.isFile())&#123; //打印 System.out.println(file); &#125;else&#123; //是文件夹.列出该文件夹下的所有东西 printFiles(file); &#125; &#125; &#125;&#125; 文件过滤器:FileFilter 在list和listFiles方法中使用，用来过滤文件，有多少个文件就会执行多少次 1234567891011public class MyFileFilter implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; // TODO Auto-generated method stub System.out.println(".."); //用来看这个方法执行了多少次 if(pathname.getName().endsWith(".PNG"))&#123; return true; &#125; return false; &#125; 案例：map集合嵌套遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.guardwarm.map;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/* * 案例: * 需要定义一个Map集合,保存学生的学号和他对应的名字 * Map&lt;String,String&gt; * JavaEE: * heima001 张三 * heima003 李四 * heima005 王五 * UI: * heima001 小丽 * heima004 小红 * heima005 小美 * PHP: * heima002 小黑 * heima003 小白 * heima006 小猪 * */public class MapQianTao &#123; public static void main(String[] args) &#123; //定义所需map Map&lt;String,String&gt; eeMap = new HashMap&lt;String, String&gt;(); Map&lt;String,String&gt; uiMap = new HashMap&lt;String, String&gt;(); Map&lt;String,String&gt; phpMap = new HashMap&lt;String, String&gt;(); Map&lt;String,Map&lt;String,String&gt;&gt; outMap = new HashMap&lt;String, Map&lt;String, String&gt;&gt;(); eeMap.put("heima001","张三"); eeMap.put("heima003","李四"); eeMap.put("heima005","王五"); uiMap.put("heima001","小丽"); uiMap.put("heima004","小红"); uiMap.put("heima005","小美"); phpMap.put("heima002","小黑"); phpMap.put("heima004","小白"); phpMap.put("heima005","小猪"); outMap.put("javaee",eeMap); outMap.put("ui",uiMap); outMap.put("php",phpMap); //先通过entrySet获取Set，然后再用set获取迭代器开始遍历 Set&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outSet = outMap.entrySet(); Iterator&lt;Map.Entry&lt;String,Map&lt;String,String&gt;&gt;&gt; outit = outSet.iterator(); while (outit.hasNext())&#123; Map.Entry&lt;String,Map&lt;String,String&gt;&gt; outEntry = outit.next(); String outKey = outEntry.getKey(); //由于值是map，所以内部还得再遍历 Map&lt;String,String&gt; outvalue = outEntry.getValue(); System.out.println(outKey); Set&lt;String&gt; mapKeys = outvalue.keySet(); for(String key:mapKeys)&#123; String mapValue = outvalue.get(key); System.out.println(mapValue); &#125; &#125; &#125;&#125; IO流根据流的流向分类: Input:输入流 Output:输出流 根据流操作的数据来分类 字符流: 操作字符 只能操作普通文本文件, ​ 最常见的文本文件:.txt,.java,.c,.cpp等其他语言的源代码 ​ 只要用文本工具(记事本,notepad++,editplus) 可以打开的 ,而且打开后我们人类能看懂的 都是文本文件 ​ 注意:我们用的.doc,excel,ppt这些不是文本文件 字节流: 操作字节 ​ 能操作一切文件(文本文件,.mp3,视频.avi,.rmvb,mp4,doc,excel,ppt) java中的四大流: 字符输入流:共同父类 Reader 比如:FileReader,BufferedReader 功能:读取一个字符,读取一个字符数组 字符输出流:共同的父类 Writer 比如:FileWriter BufferedWriter 功能:写一个字符,写一个字符数组(一部分),写一个字符串 字节输入流:共同父类 InputStream 比如:FileInputStream,BufferedInputStream 功能:读取一个字节,读取一个字节数组 字节输出流:共同父类 OutputStream 比如:FileOutputStream,BufferedOutputStream 功能:写一个字节,写一个字节数组(一部分) 只要是输入流 此流的方法名 一定叫做 read 只要是输出流 此流的方法名 一定叫做 write java中流的命名是十分规范的: 功能+父类的名字（4种） OutputStream:字节输出流的根类,这是一个抽象类 public void close();//关闭流 public void flush();//刷新流 和写数据有关系的方法; public void write(int b);//写一个字节 public void write(byte[] bs);//写一个字节数组 public void write(byte[] bs,int startIndex,int lenght);//写一个字节数组的一部分 FileOutputStream OutputStream具体子类 追加: 以前用的构造: ​ public FileOutputStream(String filename);//默认就是覆盖 ​ public FileOutputStream(File file);//给定一个File对象,这个File对象代表我们要写入的文件 请用这个构造,实现追加: ​ public FileOutputStream(String filename,boolean flag) ​ public FileOutputStream(File file,boolean flag) 换行（不同操作系统用不同换行）: windows:\r\n Linux:\n Mac:\r InputStream:字节输入流的根类,这是一个抽象类 public int read();//读取一个字节,返回的是码值 public int read(byte[] bs);//读取一个字节数组,返回值表示实际读取到的字节数 我们用InputStream具体子类:FileInputStream 12345678910111213141516171819202122232425262728293031323334353637383940package com.guardwarm.文件;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/* * 复制文件练习: * * 1.源文件: 是读取用的, new FileInputStream("源文件") * * 2.目标文件: 是写入用的, new OutputStream("目标文件") * * 3. 一边读取 源文件 一边写出到目标文件 * * 4.关闭流 */public class CopyFile &#123; public static void main(String[] args) throws IOException &#123; FileInputStream fis = new FileInputStream("F:\\书\\史铁生.docx"); FileOutputStream fos = new FileOutputStream("F:\\书\\copy.docx"); long s = System.currentTimeMillis(); int b = 0; while((b=fis.read())!=-1)&#123; fos.write(b); &#125;/* //一次读取一个字节数组 byte[] bs = new byte[1024];//用来保存读取到的字节数据 int len = 0;//保存实际读取到的字节个数 while((len=fis.read(bs))!=-1)&#123; fos.write(bs, 0, len);//写入bs中的从0下标开始len个字节 到文件中 &#125;*/ long e = System.currentTimeMillis(); long time = e-s; System.out.println(time); fos.close(); fis.close(); &#125;&#125; 缓冲流: 相比较没有缓冲区的流,效率更高BufferedOutputStream 缓冲输出流 构造方法 public BufferedOutputStream(OutputStream out) BufferedInputStream 缓冲输入流 构造方法 public BufferedInputStream(InputStream in) 小案例：复制单级文件夹1234567891011121314151617181920212223242526272829303132333435363738package com.guardwarm.文件;import java.io.*;public class CopySingleDirectory &#123; public static void main(String[] args) throws IOException &#123; //创建文件夹 File srcfl = new File("F:\\demo1"); File dstfl = new File("F:\\demo2"); if (!dstfl.exists())&#123; boolean b = dstfl.mkdirs(); if (b)&#123; System.out.println("文件夹不存在，成功创建"); &#125; &#125;else &#123; System.out.println("目标文件夹已存在，直接复制即可"); &#125; //遍历文件 注意创建目标文件 File[] srcfiles = srcfl.listFiles(); for (File src : srcfiles)&#123; File dst = new File(dstfl,src.getName()); copyfile(src,dst); &#125; &#125; public static void copyfile(File srcfl,File dstfl) throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcfl)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dstfl)); //固定格式 byte[] bs = new byte[1024]; int len = 0; while ((len = bis.read(bs))!= -1)&#123; bos.write(bs,0,len); &#125; bis.close(); bos.close(); System.out.println("复制文件"+srcfl.getName()+"成功！"); &#125;&#125; 小知识点使用字节流读取中文的乱码问题: 如果是一个一个字节读取, 100%会出现乱码 如果是一个一个字节数组读取,可能也会出现乱码 解决方法 字符流 转换流 字符编码集 ASCII码表 美国 每个字符对应一个字节 保存了字母，数字，以及一些常用符号 a-97 A-65 0-48 GB2313 保存常用汉字，一个中文占两字节，这两个字节全是负数 GBK 保存了基本所有汉字，统统占两个字节第一个字节为负，第二个字节随意 Unicode 统一码表（万国码表）所有文字统统两字符，向下兼容ASCII UTF-8 在Unicode的基础上做了一些优化，能用一个字节的不用两个字节，且在每一个字节头加入了编码信息，一个中文占三个字节 Latin-1（ISO-8859-1） 拉丁码表，Tomact会用到 编码 – &gt;文字到对应码值 解码 – &gt;码值到对应文字 转换流字符流的子类 OutputStreamWriter 查码表，是字符流通向字节流的桥梁，write方法与其他流一致 123456public static void writeCN() throws Exception &#123; //创建可以把字符转成字节的转换流对象，并指定编码 两种构造，指定编码也可不写，默认GBK OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("c:\\cn8.txt"),"utf-8"); //调用转换流，把文字写出去，其实是写到转换流的高效区中 osw.write("你好");//写入高效区。 osw.close(); InputStreamReader 注意选择正确的解码方式 1234567891011121314151617181920public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; //演示字节转字符流的转换流 readCN(); &#125; public static void readCN() throws IOException&#123; //创建读取文件的字节流对象 InputStream in = new FileInputStream("c:\\cn8.txt"); //创建转换流对象 //InputStreamReader isr = new InputStreamReader(in);这样创建对象，会用本地默认码表读取，将会发生错误解码的错误 InputStreamReader isr = new InputStreamReader(in,"utf-8"); //使用转换流去读字节流中的字节 int ch = 0; while((ch = isr.read())!=-1)&#123; System.out.println((char)ch); &#125; //关闭流 isr.close(); &#125;&#125; 转换流和子类区别：转换流可以选择解码/编码方式 java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter ​ FileWriter和FileReader：作为子类，仅作为操作字符文件的便捷类存在。当操作的字符文件，使用的是默认编 码表时可以不用父类，而直接用子类就完成操作了，简化了代码。 序列化流和反序列化流用于从流中读取对象的操作流 ObjectInputStream 称为 反序列化流 用于向流中写入对象的操作流 ObjectOutputStream 称为 序列化流 构造方法类似转换流，具体看API 常见异常 当一个对象要能被序列化，这个对象所属的类必须实现Serializable接口。否则会发生异常NotSerializableException异常。 同时当反序列化对象时，如果对象所属的class文件在序列化之后进行的修改，那么进行反序列化也会发生异常InvalidClassException。发生这个异常的原因如下： 该类的序列版本号与从流中读取的类描述符的版本号不匹配 该类包含未知数据类型 该类没有可访问的无参数构造方法 版本号默认有java管理，也可以生成版本号自己管理 transient关键字 不需要序列化的属性可以使用关键字transient修饰 同时static修饰的也不会序列化 打印流字节打印流 PrintStream 字符打印流 PrintWriter 两者基本一致，可以打印的目的地略有不同 PrintStream 字符串的文件名，file对象，其他的tOutputStream，其他的Writer PrintWriter 字符串的文件名，file对象，其他的tOutputStream 12345678910111213public class PrintWriterDemo &#123; public static void main(String[] args) throws IOException &#123; //创建流 //PrintWriter out = new PrintWriter(new FileWriter("printFile.txt")); PrintWriter out = new PrintWriter("printFile.txt"); //2，写数据 for (int i=0; i&lt;5; i++) &#123; out.println("helloWorld"); &#125; //3,关闭流 out.close(); &#125;&#125; 第三方小框架：commons-iops.第一方：官方，第二方：我们 jar包：java专用压缩包 从上到下依次为：api文档，框架class文件，生成api文档的源文件，框架源文件，测试class文件，测试源文件，许可，注意事项 添加jar包 eclipse 1.创建lib文件夹 2.将commons-io.jar拷贝到lib文件夹 3.右键点击，→ IDEA file-&gt; project structure 点最右侧那个+，然后OK就好 FileUtils readFileToString(File file)：读取文件内容，并返回一个String； writeStringToFile(File file，String content)：将内容content写入到file中； copyFile(File srcFile, File destFile): 文件复制 copyDirectoryToDirectory(File srcDir,File destDir);文件夹复制 多是一些静态方法，直接用类名就可调用 多线程几个小概念 进程: 正在运行的程序 叫做进程 线程: 进程中的一个小任务 一个进程中通常是由多个线程在执行任务 main方法所在线程 我们称为主线程 创建方法Thread类:就是我们说的线程类 构造: public Thread();//创建一个默认名字的线程对象 public Thread(String name);//创建一个指定名字的线程对象 创建新的线程的方法一: 1.定义子类 继承 Thread 2.在子类中重写run方法(就是执行任务的方法,在run方法中写任务代码即可) 3.创建子类对象(就是创建一个线程对象) 4.开启这个线程 123456//3.创建子类线程对象MyThread mt = new MyThread();//设置守护线程mt.setDaemon(true);//4.开启线程,JVM自动会告诉CPU去执行线程任务代码mt.start(); 开启线程的第二种方式: 1.定义实现类 实现Runnable接口 2.实现类要重写run方法(就是写任务代码的方法) 3.创建实现类对象 4.创建Thread对象,并把刚刚的实现类对象 作为参数传递 5.启动这个Thread对象 12345MyRunnable mr = new MyRunnable();//4.创建Thread对象,并把刚刚的实现类对象 作为参数传递Thread td = new Thread(mr);//5.开启线程td.start(); 内存图 创建两个线程对象 我们发现: a.线程默认是有名字,名字Thread-n,n从0开始 依次递增的 b.我们可以修改线程的名字,但是一般不改 setName(String name); c我们可以获取线程的名字,通过线程对象的getName方法获取 d.获取线程名字的最常用的方法 Thread.currentThread().getName(); 两种创建方式比较 从耦合性分析: 第一种方式:线程和任务是紧紧联系在一起的,耦合性高 第二种方式:线程是线程,任务是任务,他们之间没有必然联系,给一个线程传递哪个任务那么该线程就执行哪个任务 所以说开发中,我们用第二种方式 从代码的扩展性: 第一种方式 由于是继承Thread,那么子线程类就不能继承别的类 第二种方式 由于是实现了接口,同时可以继承别的类 所以说开发中,我们用第二种方式 用匿名内部类创建对象12345678910111213141516171819202122232425262728293031323334/* * 匿名内部类: * 快速创建一个类的子类对象,或者一个接口的实现类对象 * * 格式: * new 父类()&#123; * 重写方法(); * &#125;; * new 接口()&#123; * 实现方法() * &#125;; * 使用匿名内部类 创建线程对象 *///1.第一种方式创建线程对象:继承方式 new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("线程"+getName()+i); &#125; &#125; &#125;.start();//2.第二种方式创建线程对象:实现方式 new Thread(new Runnable()&#123; @Override public void run() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; 10; i++) &#123; System.out.println("线程"+Thread.currentThread().getName()+i); &#125; &#125; &#125;).start(); 案例：卖票123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/* * 案例:电影院卖票 * * 假设 上演"忍者神龟" 100张票 * * 有三个柜台在卖票,同时开卖,并且卖的都是这100张票 * * 三个柜台就是三个线程,他们同时执行同一个买票任务,同时操作一个共享数据100张票 * */public class SaleTicketsDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //1.创建卖票任务对象 TicketsRunnable tr = new TicketsRunnable(); //2.创建 3个线程 去执行买票任务 Thread t1 = new Thread(tr,"窗口1"); Thread t2 = new Thread(tr,"窗口2"); Thread t3 = new Thread(tr,"窗口3"); t1.start(); t2.start(); t3.start(); &#125;&#125;public class TicketsRunnable implements Runnable&#123; private int count = 100; @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; if(count&gt;0)&#123; try &#123;Thread.sleep(120);&#125; catch (InterruptedException e) &#123;&#125; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125; &#125;/* * 解决线程安全问题方式一: * 给代码加上同步锁 * 格式: * synchronized(锁对象)&#123; * 代码 * &#125; * 锁对象可以是任意对象 * 先运行到那块的会拿到锁对象，然后执行几次后会将锁对象放回，让其他线程执行 */ public class TicketsRunnable implements Runnable&#123; private int count = 1000; private Object obj = new Object(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; synchronized(obj)&#123; if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125; &#125; &#125;&#125; /* * 解决线程安全问题方式二: * 同步方法 * 格式: * public synchronized void 方法名()&#123; * 需要运行的代码 * &#125; * 注意:同步代码块和同步方法的原理是一样,都是具有锁对象,哪一个线程进来执行,那么该线程就持有这个锁对象 * 这里同步方法使用的锁对象 叫做this对象 * 如果同步方法是静态方法,那么他的锁对象是 当前类.class */ public class TicketsRunnable implements Runnable&#123; private int count = 1000; private Object obj = new Object(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; sale(); &#125; &#125; public synchronized void sale()&#123; if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; &#125;&#125; /* * 解决线程安全问题方式三: * Lock接口方式 * 我们实际用的是他的一个实现类:ReentrantLock * * 在Lock接口中有两个方法: * lock();//获取锁 * unlock();//释放锁 */ public class TicketsRunnable implements Runnable&#123; private static int count = 1000; //创建一个Lock接口的实现类对象 Lock l = new ReentrantLock(); @Override public void run() &#123; // TODO Auto-generated method stub //任务代码 就是卖票 100张 while(true)&#123; l.lock(); if(count&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"第"+count); count--; &#125; l.unlock(); &#125; &#125;&#125; 线程状态图 socket-网络编程计算机网络网络通信协议: 网络:由多台计算机,以及外部设备 连接起来一个系统 我们就称为网络 通信协议: 就像交通规则,规定网络上传输的数据的格式,大小,速度等等 在我们现在的网络中都有哪些通信协议: TCP/IP协议 UDP协议 其他协议 IP地址和端口号的介绍 IP地址: 网络每一台计算的唯一标识 1Byte=8Bit IP地址 每一个段 0-255 端口号: 是每一个计算机中的”门”,一共有0-65535号门 总结:我们向别的计算机发信息的时候 确定 IP地址:为了找到那台计算机 确定 端口号: 为了确定发送到对方计算机中的哪个应用程序 InetAddress:代表IP地址类 public static InetAddress getLocalHost();//获取你的计算机的IP地址对象 public String getHostName();//仅获取主机名 public String getHostAddress();//仅获取IP地址 public static InetAddress getByName(“其他主机的名字或者IP”);//远程主机的IP地址对象 UDP和TCPUDP:用户数据报协议 特点:面向无连接,数据是不安全,不完整 有无接收端均可 优点:效率高 比如:发短信,供屏软件,QQ视频 TCP:传输控制协议 特点:面向有连接,数据是安全,完整性 没有接收端会直接报错 比如:打电话,上网 TCP协议建立连接 有三个步骤 我们称为”三次握手” UDP使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * 使用UDP进行数据通信,需要用到两个类 * * 数据的发送接收器:DatagramSocket * * 数据包类:DatagramPacket *///发送端public class UDPSender &#123; public static void main(String[] args) throws Exception &#123; Scanner sc = new Scanner(System.in); //1.创建DatagramSocket对象 DatagramSocket ds = new DatagramSocket(); while(true)&#123; //2.创建DatagramPacket对象 //存储 发送的数据,对方的IP,端口号 System.out.println("请输入您要发送的数据:"); String sendMsg = sc.nextLine(); byte[] bs = sendMsg.getBytes(); //IP地址:127.0.0.1 代表本机,本地回环地址 DatagramPacket dp = new DatagramPacket(bs,bs.length,InetAddress.getByName("127.0.0.1"),12345); //3.发送 ds.send(dp); System.out.println("发送数据成功!!!");//192.168.146.72 &#125; //4.关闭资源 //ds.close(); &#125;&#125;//接收端public class UDPReceiver &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //1.创建DatagramSocket对象, //强调:接收端必须指定一个端口号 DatagramSocket ds = new DatagramSocket(12345); while(true)&#123; //2.直接创建一个DatagramPacket对象 byte[] bs = new byte[1024]; DatagramPacket dp = new DatagramPacket(bs, bs.length); //3.接收 System.out.println("等待发送端发送数据...."); ds.receive(dp);//这个方法具有等待功能,等待发送端发送过来的数据 System.out.println("接收数据成功!!"); //获取发送端的地址 InetAddress sendAddress = dp.getAddress(); System.out.println("发送端是:"+sendAddress.getHostAddress()); //获取真正的数据 byte[] data = dp.getData(); //获取发送端 发来了多少字节 int len = dp.getLength(); //打印数据 String receiveMsg = new String(data, 0, len); System.out.println("发送端说:"+receiveMsg); &#125; //4.关闭资源 //ds.close(); &#125;&#125; TCP使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485进行简单数据交互/** * TCP客户端: * * 1.创建Socket对象,传入服务器的IP和端口 * * 2.通过Socket对象获取输出流,调用write方法写数据到服务器 * * 3.通过socket对象获取输入流,调用read方法读取服务器反馈的信息 * * 4.关闭(Socket对象) * * * TCP服务端: * * 1.创建ServerSocket对象,传入一个端口,端口必须和客户端的一样 * * 2.先获取哪一个客户端连接的服务器,通过accept()方法获取 * * 3.通过Socket对象获取输入流,调用read方法读取客户端发来的数据 * * 4.通过socket对象获取输出流,调用write方法向客户端反馈数据 * * 5.关闭(ServerSocket,Socket) * * @author yingpeng * */public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; //1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致 ServerSocket server = new ServerSocket(12345); //2.获取到 哪一个 客户端连接的我 System.out.println("等待客户端连接..."); Socket client = server.accept();//此方法也具有等待功能,等待某一个客户端连接 //打印一些和客户端有关信息 String ip = client.getInetAddress().getHostAddress(); System.out.println("小样,抓到你了:"+ip); //3.获取输入流,实际上是客户端写数据时的输出流 InputStream in = client.getInputStream(); //4.读取数据 byte[] bs = new byte[1024]; int len = in.read(bs); //打印 System.out.println("客户端说:"+new String(bs,0,len)); //5.要向客户端 回写数据,告诉客户端您的信息我已经收到了 OutputStream out = client.getOutputStream(); out.write("您的消息已经收到...".getBytes()); System.out.println("给客户端反馈的信息发送成功!!!"); //关闭资源 server.close(); client.close(); in.close(); &#125;&#125;public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口) /* * 这个构造方法干了很多事情: * a.自动去连接服务器 * b.自动进行三次握手,建立连接 * c.自动为连接中创建两个流 */ Socket client = new Socket("127.0.0.1", 12345); // 2.从客户端对象中获取 输出流:getOutputStream() //OutputStream out = client.getOutputStream(); // 3.调用输出流的Write方法写数据到服务器即可 //out.write("How are you".getBytes()); client.getOutputStream().write("How are you".getBytes()); System.out.println("给服务器发送数据成功!!"); //4.读取服务器 发送过来的反馈信息 InputStream in = client.getInputStream(); byte[] bs = new byte[1024]; int len = in.read(bs); System.out.println("服务器响应:"+new String(bs,0,len)); // 关闭资源 client.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//上传文件//客户端public class FileUploadClient &#123; public static void main(String[] args)throws IOException &#123; //1.创建Socket对象,连接服务器 Socket client = new Socket("127.0.0.1", 12345); System.out.println("连接服务器成功.."); //2.获取输出流,把数据写向服务器 OutputStream out = client.getOutputStream(); //3.创建文件的输入流,读取本地的文件数据 FileInputStream fis = new FileInputStream("C:\\Users\\yingpeng\\Desktop\\pictures\\3.png"); //4.循环,读取本地文件,写到服务器 byte[] bs = new byte[1024]; int len = 0; while((len=fis.read(bs))!=-1)&#123; out.write(bs, 0, len); &#125; //关闭输出流 client.shutdownOutput(); //5.获取服务器反馈的信息 InputStream in = client.getInputStream(); byte[] bs1 = new byte[1024]; int len1 = in.read(bs1); System.out.println("服务器说:"+new String(bs1,0,len1)); //6关闭 client.close(); out.close(); fis.close(); &#125;&#125;//服务器端 服务器一直开启，通过多次执行客户端来多文件上传public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub //1.创建ServerSocket对象,绑定一个端口 ServerSocket server = new ServerSocket(12345); while(true)&#123; //2.获取哪一个客户端连接的服务器 System.out.println("等待客户端连接..."); final Socket client = server.accept(); //开启一个线程,和clinet进行交互 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // TODO Auto-generated method stub System.out.println("小样:"+client.getInetAddress().getHostAddress()); //3.获取输入流,读取客户端发来数据 InputStream in = client.getInputStream(); //4.创建文件的输出流,把数据写到文件中 String picName = "H:\\upload\\"+System.currentTimeMillis()+".png"; FileOutputStream fos = new FileOutputStream(picName); //5.循环 从输入流读取客户端数据, 写入到文件中 byte[] bs = new byte[1024]; int len = 0; while((len=in.read(bs))!=-1)&#123; fos.write(bs, 0, len); &#125;//1小时 System.out.println("客户端的文件已经保存完毕,可以查看了"+picName); //6.告知客户端,文件真的真的真的上传成功 OutputStream out = client.getOutputStream(); out.write("您的文件真的真的真的上传成功".getBytes()); client.close(); in.close(); out.close(); fos.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; //6.关闭 // server.close(); &#125;&#125; 一个bug 客户端传输完文件需主动调用client.shutdownoutputstream来关闭输出流，不然服务器会不知道是执行完了还是网络延迟 反射定义一个应用程序已写好，后期出现的接口子类无法直接在该应用中new一个对象，该怎么办？ 子类不确定，可以通过提供配置文件形式将不确定的信息存储在配置文件中即可。该程序只要之前写好读取配置文件的信息即可。 如果存储了指定的子类名，就根据具体名称找该类并进行加载和对象的创建，这些动作都是在定义软件时写好的 没有类之前就将创建对象的动作写好了，这就是动态的获取指定的类，并使用类中的功能——反射技术 字节码文件对应的类class Class 描述字节码文件的类 Field field 将字段封装成对象类型 Constructor cons 将构造函数封装成了对象类型 Method method 将类中的成员都封装成了对象 getField() getMethod() getConstrctor() 获取字节码文件对象要想获取字节码文件中的成员，首先要获取字节码文件对象 法一 通过object类中的getClass方法 12Person p1=new Person();Class clszz1=p1.getClass(); 虽然通用，但必须有指定类，并对该类进行实例化才能调用getClass方法 法二 调用任意一个数据类型的一个静态成员class 不用实例化类，但还是需要指定的类 法三 使用class类中的forName方法，通过给定类名来获取相应的字节码文件对象 最常用，只需从配置文件中解析到类名即可 调用newInstanse()方法来实例化 123456789101112131415161718192021222324252627282930String className = "cn.itcast.domain.Person";//一般从配置文件解析获取Class clazz = Class.forName(className);Object obj = clazz.newInstanse();//1.通过给定类名称加载对应字节码文件，并封装成字节码文件对象//2.通过new创建Person对象//3.调用构造方法初始化//通常被反射的类会提供无参构造，若没有会报instantiationException//如果提供了，但是权限不够会报illegalAccessExceptionPerson p = new Person();//1.加载Person类，并将类封装成字节码对象//2.通过new创建Person对象//3.调用构造方法初始化String className = "cn.itcast.domain.Person";Class clazz = Class.forName(className);Constructor cons = clazz.getConstructor(String.class,int.class);//获取指定的构造器Object obj = cons.newInstance("wangwu",23);//有了构造器对象后，通过其来初始化对象//获取字段 需要先获取到class对象Field field = clazz.getField(字段名); //公共字段可以这样获取Field field = clazz.getDeclaredField(字段名); //获取以声明字段 多数方法都有对应的declarefield.set(obj,30) //需要获取到字段和字节码对象，只可修改公共字段field.setAccessible(); //暴力访问，去除该字段访问权限//获取方法，需要先获取到class对象Method method = clazz.getMethod(方法名,null); //第二个表示无参method.invoke(null,null); //第一个为字节码对象，后面表示无参Method method = clazz.getMethod(方法名,String.class,int.class); //第二个表示无参method.invoke(obj,"wangwu",33); java设计思想设计模式前人把解决问题的方案总结出一个套路 代理设计模式静态代理设计模式 设计个接口，限制代理需要做哪些事，用接口来接收不同代理 1234567891011121314151617181920212223242526package com.itheima.demo10_代理设计模式;/* * 代理类:经销商 */public class ProxyPerson implements ComputerInterface&#123; private ComputerInterface lianxiang; public ProxyCompany(ComputerInterface lianxiang) &#123; this.lianxiang = lianxiang; &#125; @Override public String buyComputer() &#123; // TODO Auto-generated method stub return "鼠标,键盘,电脑包,u盘,操作系统,3000$ + "+lianxiang.buyComputer(); &#125; @Override public void repair() &#123; // TODO Auto-generated method stub System.out.println("需要运费1000块"); lianxiang.repair(); System.out.println("再给500块保管费"); System.out.println("再给100块运费"); &#125; 动态代理设计模式 设计原则 向上抽取原则 Java数据结构和算法先看几个经典算法面试题 用最快速度判断str2是否为str1子串 暴力破解（逐字匹配）/kmp算法《部分匹配表》 汉诺塔问题 递归，分治算法 八皇后问题 回溯算法 马踏棋盘 图的深度优化算法（DFS），贪心算法（优化） 算法是程序的灵魂，大厂对算法要求越来越高 数据结构]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xmind使用]]></title>
    <url>%2F2019%2F08%2F13%2Fxmind%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 软件下载使用的较简单的免费版，本意只是为了简单的做一些总结之所以选择xmind:zen而不是xmind 8是因为感觉xmind:zen相对来说更小，启动速度更快，并且感觉更加代表了未来的发展方向，xmind 8有些笨重了官网 使用技巧编辑主题文字：选中主题“双击鼠标”或者按【空格键】 添加同级主题：快捷键【enter/return】 添加子主题：可快捷键【tab】 删除：选中主题按【delete/backspace】 添加外框：选中要框选的主题按工具栏的【外框】进行添加 添加概要：选中主题按工具栏的【概要】进行添加 添加笔记： ctrl+shift+n(note) 撤销: Ctrl+z 恢复: Ctrl+y emmm,帮助-&gt;快捷键助手，基本列出了常用快捷键，还可以自定义快捷键 自己直接上手也很easy，就不一一总结了 小结整体使用还是比较符合我的预期的，启动快，简约，操作方便，虽然免费版导出格式受限，并且还有水印，但这个对我基本没什么影响]]></content>
      <tags>
        <tag>思维导图</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java开发工具之intelliJ IDEA]]></title>
    <url>%2F2019%2F07%2F30%2Fjava%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BintelliJ-IDEA%2F</url>
    <content type="text"><![CDATA[[TOC] 简介Java开发主流工具是Eclipse（IBM开发）和intellij IDEA（jetbrains）。目前intellij IDEA明显使用人数增加。 主要优势强大的整合能力，比如git，Maven，Spring等 提示功能的快速，便捷，范围广 好用的快捷键和代码模板 精确搜索 下载下载地址 安装目录 第一个目录存的是配置信息，比如字体，快捷键设置，插件 第二个存的是索引，缓存等（刚启动时会自动生成索引，这段时间最好安静等待，不然可能会报一些莫名其妙的错） 如果出了什么问题，可以把第二个目录干掉，一般重启一下就好了 程序主体安装在自己安装时选择的目录下 创建项目 自己导入一下SDK，其余看需求勾选，只是java的话下一步就好 起个名字，选个存储路径就结束了 创建一个moudle-&gt;package-&gt;再在内部创建java类 删除Module：右击，F4，减掉，再右击，就可以找到delete 右上角文件夹图标，点击可以查看项目属性 调试行号旁边单击可以添加断点，右击断点可以改为条件断点 单步，跳出之类的与大多数IDE一致 取消自动更新 安装插件可以直接在设置中查找插件 Plugins 生成javadoctool -&gt; generate javadoc 选择要生成的文件，位置 locate zh_CN other command line arguments: -encoding UTF-8 -charset UTF-8 切换主题具体自行百度 常用设置setting -&gt; editor -&gt; General -&gt;Ctrl+鼠标滚轮改变字体大小/显示快速文档提示，可更改悬停时间/auto import自动导包（展开General）/显示方法间分隔符（apperance）/忽略大小写（code completion）/取消单行显示标签（editor tabs） font修改字体大小及样式 editor内可以单独修改编辑器和控制台样式 language default -&gt; comments 修改注释颜色 editor -&gt; code style -&gt; file and code template -&gt; include -&gt; file header(编写头部信息) editor -&gt; encoding -&gt; 可以将编码格式都改为utf-8（右下角显示了当前文件编码格式） （reload 改变当前文件显示方式 convert 彻底转变） build -&gt; compiler(设置自动编译) file -&gt; power save module(省电模式，关闭代码提示等功能) 右击别的文件标签可以设置显示方式，同时打开多个文件 快捷键setting -&gt;keymap -&gt; 在搜索框中输入功能，会提示对应快捷键/点击搜索图标，可以输入快捷键，提示对应功能 run Ctrl+f5、shift+f10 提示补全 Ctrl+Alt+空格 单行注释 Ctrl+/ 多行注释 Ctrl+shift+/ 向下复制一行 Ctrl+d 删除选中行 Ctrl+y 向上移动一行 Ctrl+shift+向上箭头 向下移动一行 Ctrl+shift+向下箭头 向下开始新的一行 Ctrl+enter 向上开始新的一行 Ctrl+shift+enter 查看源码 按住Ctrl，点击要查看的/还有一种暂时没找见快捷键 查看继承关系 光标位于想查看元素上，ctrl+h 万能解错/生成返回值 alt+enter 返回到前一个编辑的页面 alt+right 进入到下一个编辑的页面 alt+left 格式化代码 Ctrl+alt+l 提示方法参数类型 Ctrl+p 复制，剪切，粘贴，全选与Windows一致 撤销 Ctrl+z 反撤销 ctrl+shift+z 选中数行，整体后移 tab 选中数行，整体前移 shift+tab 查看类的结构 ctrl+o 重构：修改变量名和方法名 shift+f6 大小写转化 Ctrl+shift+u 生成构造函数 alt+fn+insert 查看文档说明 Ctrl+q 收起所有方法 Ctrl+shift+减号 打开所有方法 Ctrl+shift+等号 打开代码所在硬盘文件夹 Ctrl+shift+x（我在设置中自己设置的） 生成try—catch等 alt+ctrl 查看方法在那些地方被调用过 Ctrl+h]]></content>
      <tags>
        <tag>开发工具</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看过的一些编程书及评价]]></title>
    <url>%2F2019%2F07%2F28%2F%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8F%8A%E8%AF%84%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[汇编 汇编语言基础教程 James T.Streib整体讲解不够深入，用了很多高级汇编指令，与最初想了解底层如何实现的初衷相违背，并且很多话说的不清楚，很绕。整体学到了一些东西，算是入门了，但整体感觉不好，不推荐。 运维 跟阿铭学linux（第三版）学linux最初的各种命令是看的网课。那几个明明运用及理解都不难的命令，反反复复讲了好长时间，白白浪费了不少时间。我感觉看书来学习linux的各种命令更高效，这本书整体节奏不错，难度感觉略高一点，但认着看，感觉看的很舒服，收货很多。勉强算适合小白吧，我感觉还是有一些对新手不怎么友好的点。 （这本书学习笔记参见）]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux之centos学习笔记]]></title>
    <url>%2F2019%2F07%2F28%2Flinux%E4%B9%8Bcentos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 常用命令 文件和目录管理绝对路径与相对路径：区别在于是否从根目录开始，本地绝对路径更稳定，服务器端用相对路径 cd cd 路径 . 当前目录 .. 上级目录 什么都不加默认跳转到当前用户根目录下只能跳转到目录，不可以跳转到文件，会报错 mkdir -m 指定文件权限，不常用-p 创建一串级联目录，已存在时不报错 ls -l 详细信息-d 查看指定目录属性-h 人性化显示大小 ll=ls -l rmdir 不常用，仅用于删除目录 -p 级联删除，如果目录非空时报错 rm -r 删除目录时必须加-f 强制删除，不再询问是否删除 PATH变量 一串用：分隔的路径，执行命令时会默认从PATH中找修改: PATH=$PATH:新路径 cp 【选项】 【源文件】 【目标文件】 -r 复制目录时加-i 安全选项，覆盖时会询问，默认alise cp=“cp -i” mv 【选项】 【源文件或目录】 【目标文件或目录】 目标文件是目录，若存在，则将源文件或目录移动到目标目录下；若不存在，则将原目录重命名为给定文件名目标文件是文件，若存在，则询问是否覆盖，若不存在，则将源文件重命名为给定的目标文件 cat -n 显示行号-A 显示所有内容，包括特殊字符 tac 与命令tac一样，倒叙查看 more 文件内容较多时使用 Ctrl+D 向上翻屏Ctrl+F 向下翻屏，同空格空格 向下翻屏q 退出/字符串 从当前行向下查找字符串，按n定位下一个？字符串 从当前行向上查找字符串，按n定位下一个（可以使用通配符） less 作用同more，但命令更多 j 向上移动一行k 向上移动 head 默认显示文件前十行 -n 1/-n1/-1 显示指定行数，三种方式皆可 tail 同head，倒叙查看 文件属性 第一列第一位 d 目录 - 普通文件 l 链接文件 b 块设备 c 串行端口设备文件 s 套接字文件，socket 后九位 每三位为一组，分别为user，group，others权限 最后一位 使用了SElinux context为点 设置了acl属性为+号 第二列 该文件占用的节点（inode），有几种访问方式 第三列 所有者 第四列 所属组 第五列 该文件大小 第六七八列 分别为月日及时间 第九列 文件名 chgrp 不常用更改文件所属组chgrp 【组名】 【文件名】-R 级联更改子目录名或文件名 chown更改文件所有者chown 【-R】 账户名：组名 文件名-R 仅用于目录，作用是级联更改 chmod更改用户权限，目录默认为755，文件默认为644chmod 750 文件或目录名chmod u=rwx，og=rw 文件或目录名 u，g，o，a（all）chmod a-x 文件或目录名 umask修改文件默认权限umask xxx xxx=默认值-所需默认值（文件默认为666，目录默认为777）特例：666-333=444（333代表去了可写和可执行权限，但本来就没有可执行） chattr修改文件特殊属性chattr 【+-=】【Asaci】 【文件或目录名】 分别是增加，减少和设定存疑：=还不清楚-A 文件或目录的atime将不可修改-s 将数据同步写入磁盘-a 只能追加不能删除，非root不可设定该属性（常用）-c 自动压缩文件，读取时自动解压-i 文件不能删除，重命名，设定链接，以及写入数据（常用） lsattr 文件或目录名该命令用于读取文件或者目录的特殊权限-a 列出所有文件，包括隐藏文件-R 连同子目录数据列出 set uid，set gid，sticky bit权限其实共四位，第一位由这三个决定，分别为4,2,1，具体表现在第三位，若为小写则原本有x，大写则无，例如rwsrwsrwt为7777set uid 针对二进制可执行文件，使文件在执行阶段拥有该文件所有者权限 passwd命令set gid 作用在二进制文件上时，同上，作用在目录上时，任何用户在此目录下创建的文件都具有和该目录所属组相同的组sticky bit 设置该权限后，就算用户拥有写权限，也只可以添加而不可删除文件 /tmp/ 在linux下搜索文件which查找可执行文件绝对路径which vi whereis通过预先生成的文件列表库查找whereis 【-bms】 【文件名称】-b 只查找二级制文件-m 只查找帮助文件-s 只查找源代码文件 locate 不常用类似于whereis，包含所搜索关键词的目录和文件都会列出，所以不适合精确搜索 find 重要find 【路径】 【参数】-atime +n/-n 访问或执行时间大于或小于n天-ctime +n/-n 写入、更改inode属性的时间大于或小于n天-mtime +n/-n 写入时间大于或小于n天 用得最多]]></content>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出现过的小问题]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[[TOC] 与git相关​ fatal: Not a git repository (or any of the parent directories): .git ​ git init ​ 生成子项目 ​ git submodule add 项目路径 文件路径 与hexo相关常用命令 ​ 清楚缓存 hexo clean ​ 本地检测 hexo s (-p 4001 指定端口，默认4000) （–debug检测） ​ 生成静态文件 hexo g（-w 监视文件变动） ​ 部署 hexo d ​ (hexo clean &amp;&amp; hexo g -d) 与Markdown相关 感觉没有光标移动很不舒服，暂时没找到解决办法 默认开启了拼写检查，很多编程的英文下面都是红线，很难受 文件 -&gt; 偏好设置，下拉就可以找到钱拼写检查 不喜欢默认主题的可以在偏好设置中获取主题 选择自己喜欢的点击download，会给出css源码（有时也会直接给一个压缩文件），自己ctrl A,ctrl C存为一个css文件，导入主题文件夹即可 （从偏好设置中打开主题文件夹，导入即可） 与intellij IDEA相关]]></content>
      <tags>
        <tag>编程</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学英语路上的点点滴滴.md]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AD%A6%E8%8B%B1%E8%AF%AD%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[短句scissors,paper,stone 剪刀石头布 iron my clothes 熨衣服 I started off for a interview 我动身去参加面试 She needs to move out,find her first job,meet the love of her life,maybe even get married]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编基础]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[[TOC] 基础知识 直接在硬件工作，与机器语言一一对应 机器语言 01010000 本质：电平脉冲（早期通过穿孔卡片是实现） push ax 难以阅读且易错 汇编语言主体是汇编指令，相当于机器指令的助记符 程序–&gt; 汇编指令 –&gt; 编译器–&gt; 机器码 –&gt; 计算机 汇编语言包括 汇编指令（机器码的助记符）核心 伪指令（由编译器执行） 其他符号（由编译器执行） CPU：控制计算机运作并进行运算 核心部件 内存：存储数据，不常用的置于磁盘中 寄存器参考资料 小甲鱼零基础汇编 汇编语言基础教程]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
