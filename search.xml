<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2019%2F09%2F04%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git版本控制系统 记录版本信息（记录每一次的修改） 方便团队相互之间协作，共同开发 常用版本控制系统 svn/cvs：集中式版本控制系统 git：分布式版本控制系统 Git安装这个网上很常见，自行参考网上教程 使用GitHub目的：托管项目代码工作区 -&gt; 暂存区 -&gt; 历史区 1.Git的全局配置123456第一次安装完成git后，要在全局环境下配置基本信息：我是谁？$ git config -l 查看配置信息$ git config --global -l 查看全局配置信息配置全局信息，用户名和邮箱$ git config --global user.name 'xxx'$ git config --global user.email 'xxx@xx.xx' 2.创建仓库完成版本控制1234567891011121314创建本地git仓库$ git init会生成一个隐藏文件夹“.git”（这个文件夹很重要，暂存区和历史区以及一些其他数据都在里面存着）在本地编写完成代码后（在工作区），把一些文件提交到暂存区$ git add xxx 把某一个文件或者文件夹提交到暂存区$ git add . || git add A 把当前仓库中所有最新修改的文件都提交到暂存区$ git status 查看当前文件的状态（红色代表工作区，绿色代表暂存区，看不见东西代表所有东西都已提交到历史区）把暂存区内容提交到历史区$ git commit -m'描述信息'查看历史版本信息（历史记录）$ git log$ git reflog 包含回滚的信息 GitHub一个网站（开源的代码管理平台），用户注册号，可以在自己账户下创建仓库，用来管理项目的源代码（源代码基于git传到仓库中） 我们所熟知的插件，类库，框架等都在这个平台上有托管，我们可以下载观看和研究源码等 settings用户设置 profile 修改自己的基本信息 account 作用修改用户名 security 可以改自己的密码 emails 私有仓库作为内部团队协作管理的项目 …… new repository -&gt; 填写信息，公私有都免费 -&gt; create repository public 公共开源 private 私有，作为内部团队项目 settings -&gt; 删除仓库 ​ -&gt; collaborators 设置协助开发人员，需对方同意邀请 code可以查看历史版本和分支信息 3.把本地仓库信息提交到远程仓库123456789101112131415161718192021查看本地仓库和哪些远程仓库保持连接$ git remote -v让本地仓库和远程仓库创建一个连接 origin是随便起的一个名字，但一般都用这个$ git remote add origin [仓库地址]解除关联信息$ git remote rm origin提交之前最好先拉取$ git pull origin master将本地代码提交到远程仓库（第一次需要输入用户名和密码）$ git push origin master将远程仓库代码拉取到本地$ git clone [远程仓库git地址] [别名，默认为仓库名，也可以起一个作为拉取后的文件夹名]/* *真实项目开发流程： * 1.组长或者负责人先创建中央仓库 * 2.小组成员基于$ git clone 把远程仓库及默认的内容克隆到本地（解决了三个事情：初始化一个 本地仓库“git init”，和对应的远程仓库也保持了关联“git remote add”，把远程仓库默认内人拉取到本地 “git pull” * 3.每个组员写自己的程序后，基于“git add/git commit”把自己修改的内容存放到历史区，然后通过 “git pull/git push”把本地信息和远程仓库信息保持同步即可（可能涉及冲突处理） */ NPMnode package manger:NODE模块管理工具，根据NPM我们可快速安装、卸载所需要的资源文件 区NODE官网：下载NODE重启支持版，安装NODE后，NPM也跟着安装了 基于npm是从npmjs.com平台下下载安装 123//在终端中检测安装是否成功，出现版本号即成功了node -vnpm -v 12345678910111213$ npm install xxx 把模块安装在当前项目中（node_modules）$ npm install xxx -g 把模块安装在全局环境中$ npm i xxx@1.0.0 安装指定版本号的模块$ npm view xx version &gt; xxx.version.json 查看某个模块的版本信息（输出到指定json文件中）$ npm init -y 初始化当前项目的配置依赖清单$ npm i xxx -save 把模块保存在清单生产依赖中$ npm i xxx --save-dev 把模块保存在清单开发依赖中$ npm install 跑环境，按照清单安装所需模块$ npm root -g 查看全局安装模块的目录$ npm -uninstall xxx$ npm -uninstall xxx -g 卸载安装过的模块]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑马java教程]]></title>
    <url>%2F2019%2F08%2F16%2F%E9%BB%91%E9%A9%ACjava%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[TOC] java基础入门及环境搭建下载JDK进入Oracle官网，下载相应版本，最近下载好像都得注册个账号 下完按到所需目录，一般默认，一直下一步即可，完了设置一下环境变量 此电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;编辑path，把bin目录路径加入 classpath也可以设置 在cmd中，输入java -version检查是否安装成功 javac 文件路径（编译，生成。class文件） java 文件名，不加后缀，运行 IDE选择 目前比较流行的是eclipse和IDEA，我更喜欢IDEA，熟练了快捷键和各种模板之后会用得很舒服 语言特点通过编译成统一的字节码，不同平台下载对应JVM来实现跨平台 完全面向对象，简单，高性能，分布式，多线程，健壮 JDK（用于开发）-&gt;JRE（运行环境）-&gt;JVM(依次包含) java SE 标准版，定位于个人计算机用户 java EE 企业版，定位于服务器端领域 java ME 微型版，定位于消费电子产品的应用 越高级语言越容易入门，但要精通还需沉下心来 数据类型和运算符注释单行，多行，文档注释 标识符的命名规则虽然不同语言之间会有细微区别，但为了便于编写，感觉大多数语言都推荐采用比较大众的规范 不可以是java关键字，并且大小写敏感 类名 大驼峰命名法 方法和变量 小驼峰命名法 常量 大写 数据类型向上隐士转换，向下需要显示加括号强转 基本数据类型（四类八种）byte(1) boolean(1) short(2) char(2)unicode字符集 int()4 float(4) long(8) double(8) 引用数据类型string，数组，集合ArrayList，Scanner，Random，自定义类型 面向对象面向对象是一种编程思想，是相当于面向过程的 面向过程：遇到问题，亲力亲为一步一步解决 面向对象：遇到一个问题，找具有解决这个问题能力的对象，调用它的方法 类的格式 1234567public class 类名&#123; //构造方法 //成员类名 //成员方法&#125;//一个标准的类 封装：隐藏细节，对外暴露公共防蚊1方式 构造：无参必须有，全参最好有//类名作为方法参数或返回值时需要传入或返回的应该是该类的对象 this关键字区分局部变量和成员变量同名的情况 this的本质：实际上是个对象 谁调用的方法，this指的就是谁 匿名对象：（可用可不用） 没有名字的对象 只创建对象，但不用变量接收 在一些用来传参后续不调用时使用 特点：匿名对象也是一个对象，具有对象所有功能 ​ 每次调用都是一个新的对象，所一每个对象只能使用一次 super关键字区分子类和父类成员同名的情况，但默认优先调用子类 继承继承是两个类之间的关系，子类继承父类 123456789101112public class 子类 extends 父类&#123; &#125;//继承必须合理 人是人他妈生的，妖是妖他妈生的//继承中的成员抽取了子类中的共性内容//子类会自动继承父类中所有成员，但private不可访问//继承后成员变量不同时，没有任何问题，相同时优先访问子类//继承后成员方法不同时，没有任何问题，相同时(子类重写了父类方法时)优先访问子类，但可以通过super.方法名访问//只能单继承，但可以多层继承（直接父类唯一，但可以有多个间接父类）//多继承的话调用方法时会产生不确定性，同名父类成员不知道该掉哪个 继承大大提高代码重用性 String中的方法（4532）判断方法1234boolean equals(String str);boolean equalsIngoreCase(String str);boolean startsWith(String str);boolean endsWith(String str); 获取方法12345int length(String str);char charAt(int index);String substring(int startIndex);String substring(int startIndex,int endIndex); //左闭右开int indexof(String subStr); //少用 转换方法123String toLowerCase()；String toUpperCase()；char[] toCharArray()； 其它方法12String trim(); //去掉两端空格String[] split(String str); //一某一个字符串来分割字符串 流_读写文件（输入输出是相对程序而言的） 文件路径 绝对路径：以盘符开头 相对路径：相对当前目录而言 输出流：数据从java程序到文件中 123456//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)write(int ch); //可以写ascll码值write(char[] ch);write(char[] ch,int startIndex,int len);write(String s);write(String s,int startIndex,int len); 输入流：数据从文件到java程序 123//FileWriter:文件的字符输出流，写数据(一个字符，一个字符串，一个字符数组)int read(); //读取一个字符int read(char[] chs); //读取一个字符数组，返回值表示读取到的字符个数 反射定义一个应用程序已写好，后期出现的接口子类无法直接在该应用中new一个对象，该怎么办？ 子类不确定，可以通过提供配置文件形式将不确定的信息存储在配置文件中即可。该程序只要之前写好读取配置文件的信息即可。 如果存储了指定的子类名，就根据具体名称找该类并进行加载和对象的创建，这些动作都是在定义软件时写好的 没有类之前就将创建对象的动作写好了，这就是动态的获取指定的类，并使用类中的功能——反射技术 字节码文件对应的类class Class 描述字节码文件的类 Field field 将字段封装成对象类型 Constructor cons 将构造函数封装成了对象类型 Method method 将类中的成员都封装成了对象 getField() getMethod() getConstrctor() 获取字节码文件对象要想获取字节码文件中的成员，首先要获取字节码文件对象 法一 通过object类中的getClass方法 12Person p1=new Person();Class clszz1=p1.getClass(); 虽然通用，但必须有指定类，并对该类进行实例化才能调用getClass方法 法二 调用任意一个数据类型的一个静态成员class 不用实例化类，但还是需要指定的类 法三 使用class类中的forName方法，通过给定类名来获取相应的字节码文件对象 最常用，只需从配置文件中解析到类名即可 调用newInstanse()方法来实例化 123456789101112131415161718192021222324252627282930String className = "cn.itcast.domain.Person";//一般从配置文件解析获取Class clazz = Class.forName(className);Object obj = clazz.newInstanse();//1.通过给定类名称加载对应字节码文件，并封装成字节码文件对象//2.通过new创建Person对象//3.调用构造方法初始化//通常被反射的类会提供无参构造，若没有会报instantiationException//如果提供了，但是权限不够会报illegalAccessExceptionPerson p = new Person();//1.加载Person类，并将类封装成字节码对象//2.通过new创建Person对象//3.调用构造方法初始化String className = "cn.itcast.domain.Person";Class clazz = Class.forName(className);Constructor cons = clazz.getConstructor(String.class,int.class);//获取指定的构造器Object obj = cons.newInstance("wangwu",23);//有了构造器对象后，通过其来初始化对象//获取字段 需要先获取到class对象Field field = clazz.getField(字段名); //公共字段可以这样获取Field field = clazz.getDeclaredField(字段名); //获取以声明字段 多数方法都有对应的declarefield.set(obj,30) //需要获取到字段和字节码对象，只可修改公共字段field.setAccessible(); //暴力访问，去除该字段访问权限//获取方法，需要先获取到class对象Method method = clazz.getMethod(方法名,null); //第二个表示无参method.invoke(null,null); //第一个为字节码对象，后面表示无参Method method = clazz.getMethod(方法名,String.class,int.class); //第二个表示无参method.invoke(obj,"wangwu",33); java设计思想算法设计模式设计原则 向上抽取原则 MySQL软件安装去MySQL官网下社区版，根据网上教程配置属性 还下了SQLyog，可以图形化界面写mysql（注册码百度一下很好找） 数据库（DB）和数据库管理系统（DBMS）数据库：存储数据的仓库，本质是一个文件管理系统 数据库管理系统：是一个软件，用来管理文件 我们常说的数据库，实际上是数据库管理系统，一般习惯称为数据库 一般不直接操作DB，而是通过DBMS来操作DB 表（java中一个类）行：一条记录 类的一个对象 列：一个字段 java中一个属性 常见数据库MySQL：开源免费，小型的数据库，已经被Oracle收购，开始收费（6.x之后） Oracle：收费的大型数据库，收购了SUN,MySQL DB2：IBM的数据库，常用在银行，效率差，安全性高 SQLSever：Microsoft的，常用于c#，.net SyBase：已经淡出历史舞台，提供了一个专业的数据建模工具——PowerDesigner SQLite：嵌入式的小型数据库，用于手机端 MySQL开启和关闭 法一：此电脑-&gt;管理-&gt;服务-&gt;找到MySQL即可 法二：以管理员权限打开command net start mysql net stop mysql mysql -u root -p(直接跟密码或回车然后会提示输入密码) 法三：用SQLyog SQL语句 DDL：数据库定义语言 defination 主要是对数据库数据库表进行创建删除等维护操作 create 创建 drop 删除 alter 修改 show 查看 DCL：数据库操纵/控制语言 control 控制数据库访问权限 DML：数据库操作语言 manager 主要是对表中数据进行增删改 insert 增加 delete 删除 update 修改 DQL：数据库查询语言 query 主要是对表中数据进行查询 select 查询 from 从 where 条件 SQL通用语法 SQL语句可以单行或多行书写，以分号结尾 可使用空格和缩进来增强可读性 语句不区分大小写，关键字建议使用大写 /**/ 块注释 # 单行注释 常用数据类型（还有很多，但不常用） int 整形 double 浮点型 varchar 字符串型 date 日期型 yyyy-mm-dd，没有时分秒 DDL操作数据库​ 增 ​ create database 数据库名 采用默认编码，安装时选的 ​ create database 数据库名 charset utf8 ​ 删 ​ drop database 数据库名 ​ 改 ​ 修改数据库名字很麻烦 ​ use 数据库名 修改正在使用的数据库 ​ 查 ​ select database() 查询正在使用的数据库 ​ show database 查询所有数据库 ​ show create database 数据库名 查询某个数据库详细信息 操作数据库表​ 增 ​ create table 表名（ ​ 字段名1 数据类型1（长度） [约束]， ​ 字段名2 数据类型2（长度） [约束] ​ 字段名2 数据类型2（长度） [约束] ​ ）； ​ 删 ​ drop table 表名 ​ 查 ​ desc 表名 查看一个表的详细信息 description ​ show tables 查看所有的表 ​ 改 ​ rename table 表名 to 新表名 改名字 操作数据库表中的列​ 增 ​ alter table 表名 add 列名 类型（长度） [约束] ​ 删 ​ alter table 表名 drop 列名 ​ 查（同查看表的信息） ​ desc 表名 查看一个表的详细信息 ​ 改 可以修改列的名字，类型，约束等等 ​ alter table 表名 change 旧列名 新列名 类型(长度) 约束 修改列名,实际上类型和约束也可以一起改了 ​ alter table 表名 modify 列名 类型（长度） 约束 修改类型和约束 ​ alter table 表名 character set 字符集 一般不修改 DML增 insert into 表名 (列名1，列名2) values (value1，value2) 插入一条记录 列名可以选择一列或几列，前后必须一一对应 除了int，double，其它数据必须用””或’’引起来，推荐使用单引号 如果要插入的记录所有字段都有，则(列名1，列名2)可省略 删 delete from 表名 删除所有记录 delete from 表名 where 条件 改 update 表名 set 字段名=值 把该字段内所有的值都改了 update 表名 set 字段名=值 where 条件 DQL基本查询select [distinct] *|列名1，列名2 from 表名 查询表中所有行数据 distinct 去重查询 字段名+10 查询结果是表达式 运算查询 字段名+10 as 新名字 别名查询 条件查询 1234567891011121314151617181920212223where price &lt;&gt; 60;where not (price=60);where price &gt;= 400 and price &lt;= 600;where price between 400 and 600;where price in (400,600); 价格是400和600的where price &gt;1000 or price &lt; 300;where pname like &apos;%霸%&apos; 名字中含&apos;霸&apos;的商品where pname like &apos;_霸%&apos; 名字中第二个字为&apos;霸&apos;的商品where pname is null; 没有名字的，不可以用pname=nullwhere price &gt;2000 and category_id in (&apos;c002&apos;,&apos;c003&apos;);where (price &gt;2000 and category_id=&apos;c002&apos;) or(price &gt;2000 and category_id=&apos;c003&apos;); 排序查询对查询结果进行排序，关键字order by 格式：查询语句 order by 字段名 [ASC|DESC] ASC 升序，从小到大，默认 DESC 降序，从大到小 聚合查询以前的查询都是横向记录查询，该查询是纵向个数查询 查询特点：查询到的是单一值 聚合函数：求记录数的聚合函数 格式：聚合函数（字段名） ​ count函数会自动忽略空值 ​ max：求最大值 ​ min：求最小值 ​ avg：求平均值 ​ sum：求和 分组查询把查询到的结果分成几个组，先分组再查询，具体查询到的结果数，取决于分成几个组 若分组后还有条件需要判断，用having关键字 where写在基本查询语句后，且后面不可以写聚合函数 having写在分组查询后，且后面可以写聚合函数 格式：查询语句 group by 字段 select count() from product group by categroy_id having count(\)&gt;1 只显示个数大于1的商品分类，注意条件用having 完整查询过程 分页查询只查询记录的一部分 格式：limit 数值一（开始下标，从0开始计数），数值二（需要查出的记录数） 查询公式：假设每次查n条 第m页 limit (m-1)*n,n 多表查询交叉查询 格式：select * from 表一，表二 总字段=表一字段+表二字段 总记录数=表一记录数*表二记录数 但交叉查询无实际意义，实际上是一个矩阵（坐标）的笛卡尔，是另外两个查询的基础 内连接查询 inner join 隐式内连接查询：不写关键字inner join select * from 表一，表二 where 表一.主键=表二.外键 显式内连接查询：写关键字inner join select * from 表一 inner join 表二 on 表一.主键=表二.外键 外连接查询 outer join 左外连接：left outer join select * from 表一 left outer join 表二 on 表一.主键=表二.外键 左外连接，以左表为主，左表中数据都会有 右外连接：right outer join select * from 表一 right outer join 表二 on 表一.主键=表二.外键 右外连接，以右表为主，右表中数据都会有 子查询一个查询的结果，做另一个查询的一部分 12SELECT * FROM products WHERE category_id IN (SELECT cid FROM category WHERE cname IN('化妆品'，'家电'))； SQL备份和恢复在SQLyog中，右击数据库进行导入和导出 三个知识点两个约束主键约束(primary key):只能有一个，值必须唯一且不能为空 自动增长约束（auto_increment):初始值唯一，若被设置为一个值后，下一个值从这个的基础上增加 删除表所有数据的两种方式 delete from 表名 所有记录被删除，但自增值不会重置 truncate table 表名 删除所有记录，并重置自增值 底层是先摧毁表，再重建 乱码问题 在DOS中查看utf8编码的数据库数据时会出现乱码问题，因为DOS默认的是gbk 解决方法 临时方案：set names gbk 临时的确告诉数据库我们用gbk来查询 永久方案：修改my.ini的配置文件，不建议 数据完整性添加数据完整性==添加表约束 实体完整性：对数据行的约束，比如主键约束，唯一约束 域完整性：对数据列的约束 引用完整性：外键约束（多表关系） 各种约束主键约束：primary key 保证该字段唯一并且不为空 123456789101112131415161718-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE，-- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;//创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid)//删除主键约束ALTER TABLE books DROP PRIMARY KEY; -- 因为只能有一个主键，所以无需加字段名 唯一约束：unique 保证该字段唯一，可以为null 123456789101112131415161718192021-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT UNIQUE, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT unique_bid UNIQUE(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books ADD CONSTRAINT pk_bid PRIMARY KEY(bid);-- 删除主键约束ALTER TABLE books DROP UNIQUE(约束名); -- /如果添加唯一约束时没起名字，默认是字段名 自动增长约束：auto_increment 把该字段的值交给数据库去维护，默认每次加一（这个字段必须是建，多为主键） 1234567891011121314151617181920-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT PRIMARY KEY AUTO_INCREMENT, bname VARCHAR(30), bprice DOUBLE&#125;;-- 在创建表的时候，不直接在字段后添加，而是在表的约束区域添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30), bprice DOUBLE， -- 此处为约束区域 CONSTRAINT pk_bid PRIMARY KEY(bid)&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY bid INT AUTO_CREMENT-- /字段名 类型 约束-- 删除主键约束ALTER TABLE books MODIFY bid INT; 非空约束：not null 被约束字段不可为空值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) NOT NULL, bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 默认约束：default 给字段添加一个默认值，如果添加记录时没赋值的话用默认值 123456789101112-- 在创建表的时候直接在字段后面添加CREATE TABLE books &#123; bid INT, bname VARCHAR(30) DEFAULT 'JAVA 入门', bprice DOUBLE&#125;;-- 创建表后，通过修改表的结构，给某个字段添加主键ALTER TABLE books MODIFY 字段 属性, -- 类似auto_increment-- 删除主键约束ALTER TABLE books MODIFY 字段 属性; 多表操作双向看，两边都是一个记录对另一边多个记录，这是多对多，否则为一对多 一对多：两张表即可 多对多：需要一张中间表 12345678910111213141516171819-- 多对多建表，一张学生表，一张课程表，一张中间表，至少两个字段-- 创建三张表CREATE TABLE student&#123; sid INT PRIMARY KEY AUTO_INCREMENT, sname VARCHAR(20), sage INT&#125;CREATE TABLE course&#123; cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(20)&#125;CREATE TABLE student_course_item&#123; student_id INT&#125;-- 添加外键约束 核心ALTER TABLE student_course_item ADD CONSTRAINT item_student_fk FOREIGN KEY(student_id) REFENRENCE student (sid);ALTER TABLE student_course_item ADD CONSTRAINT item_course_fk FOREIGN KEY(course_id) REFENRENCE course (cid); 特例：有时候两张表内记录一对一，但字段过多，也会分成两张表]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xmind使用]]></title>
    <url>%2F2019%2F08%2F13%2Fxmind%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC] 软件下载使用的较简单的免费版，本意只是为了简单的做一些总结之所以选择xmind:zen而不是xmind 8是因为感觉xmind:zen相对来说更小，启动速度更快，并且感觉更加代表了未来的发展方向，xmind 8有些笨重了官网 使用技巧编辑主题文字：选中主题“双击鼠标”或者按【空格键】 添加同级主题：快捷键【enter/return】 添加子主题：可快捷键【tab】 删除：选中主题按【delete/backspace】 添加外框：选中要框选的主题按工具栏的【外框】进行添加 添加概要：选中主题按工具栏的【概要】进行添加 添加笔记： ctrl+shift+n(note) 撤销: Ctrl+z 恢复: Ctrl+y emmm,帮助-&gt;快捷键助手，基本列出了常用快捷键，还可以自定义快捷键 自己直接上手也很easy，就不一一总结了 小结整体使用还是比较符合我的预期的，启动快，简约，操作方便，虽然免费版导出格式受限，并且还有水印，但这个对我基本没什么影响]]></content>
      <tags>
        <tag>思维导图</tag>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习]]></title>
    <url>%2F2019%2F08%2F03%2Fjava%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[[TOC] java基础入门及环境搭建下载JDK进入Oracle官网，下载相应版本，最近下载好像都得注册个账号 下完按到所需目录，一般默认，一直下一步即可，完了设置一下环境变量 在cmd中，输入java -version检查是否安装成功 javac 文件路径（编译，生成。class文件） java 文件名，不加后缀，运行 IDE选择 目前比较流行的是eclipse和IDEA，我更喜欢IDEA，熟练了快捷键和各种模板之后会用得很舒服 IDEA教程 语言特点通过编译成统一的字节码，不同平台下载对应JVM来实现跨平台 完全面向对象，简单，高性能，分布式，多线程，健壮 JDK（用于开发）-&gt;JRE（运行环境）-&gt;JVM(依次包含) java SE 标准版，定位于个人计算机用户 java EE 企业版，定位于服务器端领域 java ME 微型版，定位于消费电子产品的应用 越高级语言越容易入门，但要精通还需沉下心来 数据类型和运算符注释单行，多行，文档注释 标识符的命名规则虽然不同语言之间会有细微区别，但为了便于编写，感觉大多数语言都推荐采用比较大众的规范 不可以是java关键字，并且大小写敏感 类名 大驼峰命名法 方法和变量 小驼峰命名法 常亮 大写 数据类型 基本数据类型 整形：byte short int long 浮点型：float double 字符型：char 布尔型：boolean（大小为一位，不可用数字赋值） 引用数据类型 数据类型向上隐士转换，向下需要显示加括号强转]]></content>
      <tags>
        <tag>java</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java开发工具之intelliJ IDEA]]></title>
    <url>%2F2019%2F07%2F30%2Fjava%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E4%B9%8BintelliJ-IDEA%2F</url>
    <content type="text"><![CDATA[[TOC] 简介Java开发主流工具是Eclipse（IBM开发）和intellij IDEA（jetbrains）。目前intellij IDEA明显使用人数增加。 主要优势强大的整合能力，比如git，Maven，Spring等 提示功能的快速，便捷，范围广 好用的快捷键和代码模板 精确搜索 下载下载地址 安装目录 第一个目录存的是配置信息，比如字体，快捷键设置，插件 第二个存的是索引，缓存等（刚启动时会自动生成索引，这段时间最好安静等待，不然可能会报一些莫名其妙的错） 如果出了什么问题，可以把第二个目录干掉，一般重启一下就好了 程序主体安装在自己安装时选择的目录下 创建项目 自己导入一下SDK，其余看需求勾选，只是java的话下一步就好 起个名字，选个存储路径就结束了 创建一个moudle-&gt;package-&gt;再在内部创建java类 删除Module：右击，F4，减掉，再右击，就可以找到delete 右上角文件夹图标，点击可以查看项目属性 调试行号旁边单击可以添加断点，右击断点可以改为条件断点 单步，跳出之类的与大多数IDE一致 取消自动更新 安装插件可以直接在设置中查找插件 Plugins 生成javadoctool -&gt; generate javadoc 选择要生成的文件，位置 locate zh_CN other command line arguments: -encoding UTF-8 -charset UTF-8 切换主题具体自行百度 常用设置setting -&gt; editor -&gt; General -&gt;Ctrl+鼠标滚轮改变字体大小/显示快速文档提示，可更改悬停时间/auto import自动导包（展开General）/显示方法间分隔符（apperance）/忽略大小写（code completion）/取消单行显示标签（editor tabs） font修改字体大小及样式 editor内可以单独修改编辑器和控制台样式 language default -&gt; comments 修改注释颜色 editor -&gt; code style -&gt; file and code template -&gt; include -&gt; file header(编写头部信息) editor -&gt; encoding -&gt; 可以将编码格式都改为utf-8（右下角显示了当前文件编码格式） （reload 改变当前文件显示方式 convert 彻底转变） build -&gt; compiler(设置自动编译) file -&gt; power save module(省电模式，关闭代码提示等功能) 右击别的文件标签可以设置显示方式，同时打开多个文件 快捷键setting -&gt;keymap -&gt; 在搜索框中输入功能，会提示对应快捷键/点击搜索图标，可以输入快捷键，提示对应功能 run Ctrl+f5、shift+f10 提示补全 Ctrl+Alt+空格 单行注释 Ctrl+/ 多行注释 Ctrl+shift+/ 向下复制一行 Ctrl+d 删除选中行 Ctrl+y 向上移动一行 Ctrl+shift+向上箭头 向下移动一行 Ctrl+shift+向下箭头 向下开始新的一行 Ctrl+enter 向上开始新的一行 Ctrl+shift+enter 查看源码 按住Ctrl，点击要查看的/还有一种暂时没找见快捷键 查看继承关系 光标位于想查看元素上，ctrl+h 万能解错/生成返回值 alt+enter 返回到前一个编辑的页面 alt+right 进入到下一个编辑的页面 alt+left 格式化代码 Ctrl+alt+l 提示方法参数类型 Ctrl+p 复制，剪切，粘贴，全选与Windows一致 撤销 Ctrl+z 反撤销 ctrl+shift+z 选中数行，整体后移 tab 选中数行，整体前移 shift+tab 查看类的结构 ctrl+o 重构：修改变量名和方法名 shift+f6 大小写转化 Ctrl+shift+u 生成构造函数 alt+fn+insert 查看文档说明 Ctrl+q 收起所有方法 Ctrl+shift+减号 打开所有方法 Ctrl+shift+等号 打开代码所在硬盘文件夹 Ctrl+shift+x（我在设置中自己设置的） 生成try—catch等 alt+ctrl 查看方法在那些地方被调用过 Ctrl+h]]></content>
      <tags>
        <tag>java</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看过的一些编程书及评价]]></title>
    <url>%2F2019%2F07%2F28%2F%E7%9C%8B%E8%BF%87%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8F%8A%E8%AF%84%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[汇编 汇编语言基础教程 James T.Streib整体讲解不够深入，用了很多高级汇编指令，与最初想了解底层如何实现的初衷相违背，并且很多话说的不清楚，很绕。整体学到了一些东西，算是入门了，但整体感觉不好，不推荐。 运维 跟阿铭学linux（第三版）学linux最初的各种命令是看的网课。那几个明明运用及理解都不难的命令，反反复复讲了好长时间，白白浪费了不少时间。我感觉看书来学习linux的各种命令更高效，这本书整体节奏不错，难度感觉略高一点，但认着看，感觉看的很舒服，收货很多。勉强算适合小白吧，我感觉还是有一些对新手不怎么友好的点。 （这本书学习笔记参见）]]></content>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux之centos学习笔记]]></title>
    <url>%2F2019%2F07%2F28%2Flinux%E4%B9%8Bcentos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 常用命令 文件和目录管理绝对路径与相对路径：区别在于是否从根目录开始，本地绝对路径更稳定，服务器端用相对路径 cd cd 路径 . 当前目录 .. 上级目录 什么都不加默认跳转到当前用户根目录下只能跳转到目录，不可以跳转到文件，会报错 mkdir -m 指定文件权限，不常用-p 创建一串级联目录，已存在时不报错 ls -l 详细信息-d 查看指定目录属性-h 人性化显示大小 ll=ls -l rmdir 不常用，仅用于删除目录 -p 级联删除，如果目录非空时报错 rm -r 删除目录时必须加-f 强制删除，不再询问是否删除 PATH变量 一串用：分隔的路径，执行命令时会默认从PATH中找修改: PATH=$PATH:新路径 cp 【选项】 【源文件】 【目标文件】 -r 复制目录时加-i 安全选项，覆盖时会询问，默认alise cp=“cp -i” mv 【选项】 【源文件或目录】 【目标文件或目录】 目标文件是目录，若存在，则将源文件或目录移动到目标目录下；若不存在，则将原目录重命名为给定文件名目标文件是文件，若存在，则询问是否覆盖，若不存在，则将源文件重命名为给定的目标文件 cat -n 显示行号-A 显示所有内容，包括特殊字符 tac 与命令tac一样，倒叙查看 more 文件内容较多时使用 Ctrl+D 向上翻屏Ctrl+F 向下翻屏，同空格空格 向下翻屏q 退出/字符串 从当前行向下查找字符串，按n定位下一个？字符串 从当前行向上查找字符串，按n定位下一个（可以使用通配符） less 作用同more，但命令更多 j 向上移动一行k 向上移动 head 默认显示文件前十行 -n 1/-n1/-1 显示指定行数，三种方式皆可 tail 同head，倒叙查看 文件属性 第一列第一位 d 目录 - 普通文件 l 链接文件 b 块设备 c 串行端口设备文件 s 套接字文件，socket 后九位 每三位为一组，分别为user，group，others权限 最后一位 使用了SElinux context为点 设置了acl属性为+号 第二列 该文件占用的节点（inode），有几种访问方式 第三列 所有者 第四列 所属组 第五列 该文件大小 第六七八列 分别为月日及时间 第九列 文件名 chgrp 不常用更改文件所属组chgrp 【组名】 【文件名】-R 级联更改子目录名或文件名 chown更改文件所有者chown 【-R】 账户名：组名 文件名-R 仅用于目录，作用是级联更改 chmod更改用户权限，目录默认为755，文件默认为644chmod 750 文件或目录名chmod u=rwx，og=rw 文件或目录名 u，g，o，a（all）chmod a-x 文件或目录名 umask修改文件默认权限umask xxx xxx=默认值-所需默认值（文件默认为666，目录默认为777）特例：666-333=444（333代表去了可写和可执行权限，但本来就没有可执行） chattr修改文件特殊属性chattr 【+-=】【Asaci】 【文件或目录名】 分别是增加，减少和设定存疑：=还不清楚-A 文件或目录的atime将不可修改-s 将数据同步写入磁盘-a 只能追加不能删除，非root不可设定该属性（常用）-c 自动压缩文件，读取时自动解压-i 文件不能删除，重命名，设定链接，以及写入数据（常用） lsattr 文件或目录名该命令用于读取文件或者目录的特殊权限-a 列出所有文件，包括隐藏文件-R 连同子目录数据列出 set uid，set gid，sticky bit权限其实共四位，第一位由这三个决定，分别为4,2,1，具体表现在第三位，若为小写则原本有x，大写则无，例如rwsrwsrwt为7777set uid 针对二进制可执行文件，使文件在执行阶段拥有该文件所有者权限 passwd命令set gid 作用在二进制文件上时，同上，作用在目录上时，任何用户在此目录下创建的文件都具有和该目录所属组相同的组sticky bit 设置该权限后，就算用户拥有写权限，也只可以添加而不可删除文件 /tmp/ 在linux下搜索文件which查找可执行文件绝对路径which vi whereis通过预先生成的文件列表库查找whereis 【-bms】 【文件名称】-b 只查找二级制文件-m 只查找帮助文件-s 只查找源代码文件 locate 不常用类似于whereis，包含所搜索关键词的目录和文件都会列出，所以不适合精确搜索 find 重要find 【路径】 【参数】-atime +n/-n 访问或执行时间大于或小于n天-ctime +n/-n 写入、更改inode属性的时间大于或小于n天-mtime +n/-n 写入时间大于或小于n天 用得最多]]></content>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[出现过的小问题]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[[TOC] 与git相关​ fatal: Not a git repository (or any of the parent directories): .git ​ git init ​ 生成子项目 ​ git submodule add 项目路径 文件路径 与hexo相关常用命令 ​ 清楚缓存 hexo clean ​ 本地检测 hexo s (-p 4001 指定端口，默认4000) （–debug检测） ​ 生成静态文件 hexo g（-w 监视文件变动） ​ 部署 hexo d ​ (hexo clean &amp;&amp; hexo g -d) 与Markdown相关 感觉没有光标移动很不舒服，暂时没找到解决办法 默认开启了拼写检查，很多编程的英文下面都是红线，很难受 文件 -&gt; 偏好设置，下拉就可以找到钱拼写检查 不喜欢默认主题的可以在偏好设置中获取主题 选择自己喜欢的点击download，会给出css源码（有时也会直接给一个压缩文件），自己ctrl A,ctrl C存为一个css文件，导入主题文件夹即可 （从偏好设置中打开主题文件夹，导入即可） 与intellij IDEA相关]]></content>
      <tags>
        <tag>编程</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学英语路上的点点滴滴.md]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%AD%A6%E8%8B%B1%E8%AF%AD%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4%2F</url>
    <content type="text"><![CDATA[短句scissors,paper,stone 剪刀石头布 iron my clothes 熨衣服 I started off for a interview 我动身去参加面试 She needs to move out,find her first job,meet the love of her life,maybe even get married]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编基础]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[[TOC] 基础知识 直接在硬件工作，与机器语言一一对应 机器语言 01010000 本质：电平脉冲（早期通过穿孔卡片是实现） push ax 难以阅读且易错 汇编语言主体是汇编指令，相当于机器指令的助记符 程序–&gt; 汇编指令 –&gt; 编译器–&gt; 机器码 –&gt; 计算机 汇编语言包括 汇编指令（机器码的助记符）核心 伪指令（由编译器执行） 其他符号（由编译器执行） CPU：控制计算机运作并进行运算 核心部件 内存：存储数据，不常用的置于磁盘中 寄存器参考资料 小甲鱼零基础汇编 汇编语言基础教程]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
